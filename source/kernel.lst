
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -q -D encode=0 -c -o kernel_nocode.prg -L kernel.lst -l kernel.lbl kernel.asm
; Fri Jan 17 08:05:31 2020

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=0					encode=0

;******  Processing input file: kernel.asm

=$1000					RplBuild = $1000 							; code starts here.
=$9eff					LastMemoryByte = $9EFF 						; program ends here

;******  Processing file: code/data.asm

.0000					NextCode:
>0000							.fill 	5
=3					IP = NextCode+3 							; the IP which points to the current instruction
.0005					rsp:
>0005							.byte 	?
.0006					tos:
>0006							.word 	?
.0008					srcPtr:
>0008							.word 	?
.000a					bufPtr:
>000a							.word 	?
.000c					matchPtr:
>000c							.word 	?
.000e					nextFreeMem:
>000e							.word 	?
.0010					temp1:
>0010							.word 	?
.0012					temp2:
>0012							.word 	?
.0014					temp3:
>0014							.word 	?
.0016					temp4:
>0016							.word 	?
.0018					listPtr:
>0018							.word 	?
.001a					SignCount:
>001a							.byte 	?
.001b					RandomSeed:
>001b							.word 	?
.001d					ListCount:
>001d							.byte 	?
.001e					ListLowest:
>001e							.word 	?
=$102					stack2Low = $102							; access other stack members following tsx
=$101					stack2High = $101							; (which requires saving X, not on the stack !)
=$104					stack3Low = $104
=$103					stack3High = $103
=$600					azVariables = $600 							; 26 x 2 variables occupying 52 bytes * PAGE BOUNDARY *
=16					hashTableSize = 16 							; hash tables for variables.
=$640					hashTable = $640 							; hash tables start here * ALL ON ONE PAGE *
=$810					textBuffer = $810 							; buffer for text.
=$700					returnStack = $700							; return stack (1 page)
=$700					returnStackLow = returnStack
=1856					returnStackHigh = returnStack+$40
=1920					returnStackX = returnStack+$80
=$80					NumberStackBase = $80 						; number stack down from here.
=$910					encodeBuffer = $910 						; buffer for encoded program
=0					COL_BLACK = 0
=1					COL_RED = 1
=2					COL_GREEN = 2
=3					COL_YELLOW = 3
=4					COL_BLUE = 4
=5					COL_MAGENTA = 5
=6					COL_CYAN = 6
=7					COL_WHITE = 7
=8					COL_RVS = 8
=2					CTH_LineNo = COL_Green
=6					CTH_Keyword = COL_Cyan
=11					CTH_Comment = COL_Yellow+COL_Rvs
=7					CTH_Definition = COL_White
=5					CTH_String = COL_Magenta
=3					CTH_Call = COL_Yellow
=7					CTH_Variable = COL_White

;******  Return to file: kernel.asm

.1000	4c bc 23	jmp $23bc			jmp 	ColdStart

;******  Processing file: files.asm


;******  Processing file: code/core.src

.1003					InitialiseCoreCode:
.1003	a9 e8		lda #$e8			lda 	#$E8 					; Copy INX INX 			4 cycles when run
.1005	85 00		sta $00				sta 	NextCode
.1007	85 01		sta $01				sta 	NextCode+1
.1009	a9 7c		lda #$7c			lda 	#$7C 					; Copy JMP ($aaaa,x) 	6 cycles when run
.100b	85 02		sta $02				sta 	NextCode+2
.100d	86 03		stx $03				stx 	NextCode+3 				; set the indirect address (IP)
.100f	84 04		sty $04				sty 	NextCode+4
.1011	a2 01		ldx #$01			ldx 	#1 						; set up to run from provided word.
.1013	60		rts				rts								; (2 INX skip offset and line#)
.1014					HexLiteral2Byte:
.1014	ea		nop				nop 							; must have different address for decoding.
.1015					Literal2Byte:
.1015	a5 06		lda $06				lda 	TOS
.1017	48		pha				pha
.1018	a5 07		lda $07				lda 	TOS+1
.101a	48		pha				pha
.101b	e8		inx				inx  							; point X to the word
.101c	e8		inx				inx
.101d	8a		txa				txa 							; copy into Y
.101e	a8		tay				tay
.101f	b1 03		lda ($03),y			lda 	(IP),y 					; read it. the LSB
.1021	85 06		sta $06				sta 	TOS
.1023	c8		iny				iny 							; read and push the MSB
.1024	b1 03		lda ($03),y			lda 	(IP),y
.1026	85 07		sta $07				sta 	TOS+1
.1028	4c 00 00	jmp $0000			jmp 	NextCode
.102b					HexLiteral2ByteDecode:
.102b	a9 06		lda #$06			lda 	#CTH_Keyword
.102d	20 43 19	jsr $1943			jsr 	DecodeWriteBuffer
.1030	a9 24		lda #$24			lda 	#"$"
.1032	20 43 19	jsr $1943			jsr 	DecodeWriteBuffer
.1035	b1 08		lda ($08),y			lda 	(srcPtr),y
.1037	48		pha				pha
.1038	c8		iny				iny
.1039	b1 08		lda ($08),y			lda 	(srcPtr),y
.103b	c8		iny				iny
.103c	20 44 10	jsr $1044			jsr 	HL2BDWrite
.103f	68		pla				pla
.1040	20 44 10	jsr $1044			jsr 	HL2BDWrite
.1043	60		rts				rts
.1044					HL2BDWrite:
.1044	48		pha				pha
.1045	4a		lsr a				lsr 	a
.1046	4a		lsr a				lsr 	a
.1047	4a		lsr a				lsr 	a
.1048	4a		lsr a				lsr 	a
.1049	20 4d 10	jsr $104d			jsr 	_HLNibble
.104c	68		pla				pla
.104d					_HLNibble:
.104d	29 0f		and #$0f			and 	#$0F
.104f	c9 0a		cmp #$0a			cmp 	#$0A
.1051	90 03		bcc $1056			bcc 	_HLNoAdjust
.1053	18		clc				clc
.1054	69 07		adc #$07			adc 	#7
.1056					_HLNoAdjust:
.1056	18		clc				clc
.1057	69 30		adc #$30			adc 	#48
.1059	20 43 19	jsr $1943			jsr 	DecodeWriteBuffer
.105c	60		rts				rts
.105d					Literal2ByteDecode:
.105d	a9 06		lda #$06			lda 	#CTH_Keyword
.105f	20 43 19	jsr $1943			jsr 	DecodeWriteBuffer
.1062	b1 08		lda ($08),y			lda 	(srcPtr),y
.1064	aa		tax				tax
.1065	c8		iny				iny
.1066	b1 08		lda ($08),y			lda 	(srcPtr),y
.1068	a8		tay				tay
.1069	8a		txa				txa
.106a	38		sec				sec 							; output signed
.106b	20 65 19	jsr $1965			jsr 	DecodeYAToBuffer
.106e	60		rts				rts
.106f					LiteralString:
.106f	a5 06		lda $06				lda 	TOS
.1071	48		pha				pha
.1072	a5 07		lda $07				lda 	TOS+1
.1074	48		pha				pha
.1075	e8		inx				inx
.1076	e8		inx				inx 							; skip over current word
.1077	8a		txa				txa 							; add to IP + 1 to give string address
.1078	a8		tay				tay 							; put in Y
.1079	38		sec				sec 							; make that TOS
.107a	65 03		adc $03				adc 	IP
.107c	85 06		sta $06				sta 	TOS
.107e	a5 04		lda $04				lda 	IP+1
.1080	69 00		adc #$00			adc 	#0
.1082	85 07		sta $07				sta 	TOS+1
.1084	8a		txa				txa 							; add data length to X
.1085	18		clc				clc
.1086	71 03		adc ($03),y			adc 	(IP),y
.1088	aa		tax				tax
.1089	ca		dex				dex
.108a	ca		dex				dex
.108b	4c 00 00	jmp $0000			jmp 	NextCode
.108e					LiteralStringDecoder:
.108e	a9 05		lda #$05			lda 	#CTH_String
.1090	20 43 19	jsr $1943			jsr 	DecodeWriteBuffer
.1093	a9 22		lda #$22			lda 	#'"'
.1095	20 43 19	jsr $1943			jsr 	DecodeWriteBuffer
.1098	20 4c 19	jsr $194c			jsr 	DecodeOutputData
.109b	20 43 19	jsr $1943			jsr 	DecodeWriteBuffer
.109e	60		rts				rts

;******  Return to file: files.asm


;******  Processing file: words/arithmetic/binary.src

.109f					Add:
.109f	7a		ply				ply
.10a0	68		pla				pla
.10a1	18		clc				clc
.10a2	65 06		adc $06				adc 	TOS
.10a4	85 06		sta $06				sta 	TOS
.10a6	98		tya				tya
.10a7	65 07		adc $07				adc 	TOS+1
.10a9	85 07		sta $07				sta 	TOS+1
.10ab	4c 00 00	jmp $0000			jmp 	NextCode
.10ae					Subtract:
.10ae	7a		ply				ply
.10af	68		pla				pla
.10b0	38		sec				sec
.10b1	e5 06		sbc $06				sbc 	TOS
.10b3	85 06		sta $06				sta 	TOS
.10b5	98		tya				tya
.10b6	e5 07		sbc $07				sbc 	TOS+1
.10b8	85 07		sta $07				sta 	TOS+1
.10ba	4c 00 00	jmp $0000			jmp 	NextCode
.10bd					And:
.10bd	68		pla				pla
.10be	25 07		and $07				and 	TOS+1
.10c0	85 07		sta $07				sta 	TOS+1
.10c2	68		pla				pla
.10c3	25 06		and $06				and 	TOS
.10c5	85 06		sta $06				sta 	TOS
.10c7	4c 00 00	jmp $0000			jmp 	NextCode
.10ca					Xor:
.10ca	68		pla				pla
.10cb	45 07		eor $07				eor 	TOS+1
.10cd	85 07		sta $07				sta 	TOS+1
.10cf	68		pla				pla
.10d0	45 06		eor $06				eor 	TOS
.10d2	85 06		sta $06				sta 	TOS
.10d4	4c 00 00	jmp $0000			jmp 	NextCode
.10d7					LogOr:
.10d7	68		pla				pla
.10d8	05 07		ora $07				ora 	TOS+1
.10da	85 07		sta $07				sta 	TOS+1
.10dc	68		pla				pla
.10dd	05 06		ora $06				ora 	TOS
.10df	85 06		sta $06				sta 	TOS
.10e1	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: files.asm


;******  Processing file: words/arithmetic/compare.src

.10e4					CheckNotEqual:
.10e4	38		sec				sec
.10e5	80 01		bra $10e8			bra 	CECode
.10e7					CheckEqual:
.10e7	18		clc				clc
.10e8					CECode:
.10e8	86 10		stx $10				stx 	temp1
.10ea	ba		tsx				tsx
.10eb	08		php				php
.10ec	a5 06		lda $06				lda 	TOS
.10ee	5d 02 01	eor $0102,x			eor 	Stack2Low,x
.10f1	d0 17		bne $110a			bne	 	CompareFalse
.10f3	a5 07		lda $07				lda 	TOS+1
.10f5	5d 01 01	eor $0101,x			eor 	Stack2High,x
.10f8	d0 10		bne $110a			bne 	CompareFalse
.10fa					CompareTrue:
.10fa	a6 10		ldx $10				ldx 	temp1
.10fc	28		plp				plp
.10fd	b0 10		bcs $110f			bcs		CompareFalse2
.10ff					CompareTrue2:
.10ff	68		pla				pla
.1100	68		pla				pla
.1101	a9 ff		lda #$ff			lda 	#$FF
.1103	85 06		sta $06				sta 	TOS
.1105	85 07		sta $07				sta 	TOS+1
.1107	4c 00 00	jmp $0000			jmp 	NextCode
.110a					CompareFalse:
.110a	a6 10		ldx $10				ldx 	temp1
.110c	28		plp				plp
.110d	b0 f0		bcs $10ff			bcs		CompareTrue2
.110f					CompareFalse2:
.110f	68		pla				pla
.1110	68		pla				pla
.1111	64 06		stz $06				stz 	TOS
.1113	64 07		stz $07				stz 	TOS+1
.1115	4c 00 00	jmp $0000			jmp 	NextCode
.1118					CheckGreaterEq:
.1118	38		sec				sec
.1119	80 01		bra $111c			bra		CLCode
.111b					CheckLess:
.111b	18		clc				clc
.111c	86 10		stx $10		CLCode:	stx 	temp1
.111e	ba		tsx				tsx
.111f	08		php				php
.1120	18		clc				clc
.1121	a5 06		lda $06				lda 	TOS
.1123	fd 02 01	sbc $0102,x			sbc 	Stack2Low,x
.1126	a5 07		lda $07				lda 	TOS+1
.1128	fd 01 01	sbc $0101,x			sbc 	Stack2High,x
.112b	50 02		bvc $112f			bvc 	_CLNoFlip
.112d	49 80		eor #$80			eor 	#$80
.112f					_CLNoFlip:
.112f	0a		asl a				asl 	a
.1130	b0 d8		bcs $110a			bcs 	CompareFalse
.1132	80 c6		bra $10fa			bra 	CompareTrue
.1134					CheckLessEq:
.1134	38		sec				sec
.1135	80 01		bra $1138			bra		CGCode
.1137					CheckGreater:
.1137	18		clc				clc
.1138					CGCode:
.1138	86 10		stx $10				stx 	temp1
.113a	ba		tsx				tsx
.113b	08		php				php
.113c	18		clc				clc
.113d	bd 02 01	lda $0102,x			lda 	Stack2Low,x
.1140	e5 06		sbc $06				sbc 	TOS
.1142	bd 01 01	lda $0101,x			lda 	Stack2High,x
.1145	e5 07		sbc $07				sbc 	TOS+1
.1147	50 02		bvc $114b			bvc 	_CGNoFlip
.1149	49 80		eor #$80			eor 	#$80
.114b					_CGNoFlip:
.114b	0a		asl a				asl 	a
.114c	b0 bc		bcs $110a			bcs 	CompareFalse
.114e	80 aa		bra $10fa			bra 	CompareTrue
.1150					Minimum:
.1150	a9 00		lda #$00			lda 	#0
.1152	80 02		bra $1156			bra 	MinMaxCode
.1154					Maximum:
.1154	a9 80		lda #$80			lda 	#$80
.1156					MinMaxCode:
.1156	85 11		sta $11				sta 	temp1+1
.1158	86 10		stx $10				stx 	temp1
.115a	ba		tsx				tsx
.115b	38		sec				sec
.115c	a5 06		lda $06				lda 	TOS
.115e	fd 02 01	sbc $0102,x			sbc 	Stack2Low,x
.1161	a5 07		lda $07				lda 	TOS+1
.1163	fd 01 01	sbc $0101,x			sbc 	Stack2High,x
.1166	50 02		bvc $116a			bvc 	_MMNoFlip
.1168	49 80		eor #$80			eor 	#$80
.116a					_MMNoFlip:
.116a	45 11		eor $11				eor 	temp1+1
.116c	30 0a		bmi $1178			bmi 	_MMNoCopy
.116e	bd 02 01	lda $0102,x			lda 	Stack2Low,x
.1171	85 06		sta $06				sta 	TOS
.1173	bd 01 01	lda $0101,x			lda 	Stack2High,x
.1176	85 07		sta $07				sta 	TOS+1
.1178					_MMNoCopy:
.1178	a6 10		ldx $10				ldx 	temp1
.117a	68		pla				pla
.117b	68		pla				pla
.117c	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: files.asm


;******  Processing file: words/arithmetic/divide.src

.117f					Divide16x16:
.117f	86 12		stx $12				stx 	temp2
.1181	ba		tsx				tsx
.1182	20 a5 11	jsr $11a5			jsr 	IntegerDivide
.1185	68		pla				pla
.1186	85 07		sta $07				sta 	TOS+1
.1188	68		pla				pla
.1189	85 06		sta $06				sta 	TOS
.118b	a6 12		ldx $12				ldx 	temp2
.118d	4c 00 00	jmp $0000			jmp 	NextCode
.1190					Modulus16x16:
.1190	86 12		stx $12				stx 	temp2
.1192	ba		tsx				tsx
.1193	20 a5 11	jsr $11a5			jsr 	IntegerDivide
.1196	a6 12		ldx $12				ldx 	temp2
.1198	68		pla				pla
.1199	68		pla				pla
.119a	a5 10		lda $10				lda 	temp1
.119c	85 06		sta $06				sta 	TOS
.119e	a5 11		lda $11				lda 	temp1+1
.11a0	85 07		sta $07				sta 	TOS+1
.11a2	4c 00 00	jmp $0000			jmp 	NextCode
.11a5					IntegerDivide:
.11a5	a5 06		lda $06				lda 	TOS 				; check for division by zero.
.11a7	05 07		ora $07				ora 	TOS+1
.11a9	d0 14		bne $11bf			bne 	_BFDOkay
.11ab	20 4f 24	jsr $244f			jsr 	ErrorHandler
>11ae	44 49 56 49 53 49 4f 4e				.text 	"DIVISION BY ZERO",0
>11b6	20 42 59 20 5a 45 52 4f 00
.11bf					_BFDOkay:
.11bf	64 10		stz $10				stz 	temp1 						; Q/Dividend/Left in +0
.11c1	64 11		stz $11				stz 	temp1+1 					; M/Divisor/Right in +2
.11c3	64 1a		stz $1a				stz 	SignCount 					; Count of signs.
.11c5	20 00 12	jsr $1200			jsr 	CheckIntegerNegate 			; negate 2nd (and bump sign count)
.11c8	20 1a 12	jsr $121a			jsr 	CheckTOSNegate 				; negate TOS (and bump sign count)
.11cb	5a		phy				phy 								; Y is the counter
.11cc	a0 10		ldy #$10			ldy 	#16 						; 16 iterations of the loop.
.11ce					_BFDLoop:
.11ce	1e 02 01	asl $0102,x			asl 	Stack2Low,x 				; shift AQ left.
.11d1	3e 01 01	rol $0101,x			rol 	Stack2High,x
.11d4	26 10		rol $10				rol 	temp1
.11d6	26 11		rol $11				rol 	temp1+1
.11d8	38		sec				sec
.11d9	a5 10		lda $10				lda 	temp1+0 					; Calculate A-M on stack.
.11db	e5 06		sbc $06				sbc 	TOS
.11dd	48		pha				pha
.11de	a5 11		lda $11				lda 	temp1+1
.11e0	e5 07		sbc $07				sbc 	TOS+1
.11e2	90 0f		bcc $11f3			bcc 	_BFDNoAdd
.11e4	85 11		sta $11				sta 	temp1+1
.11e6	68		pla				pla
.11e7	85 10		sta $10				sta 	temp1+0
.11e9	bd 02 01	lda $0102,x			lda 	Stack2Low,x 				; set Q bit 1.
.11ec	09 01		ora #$01			ora 	#1
.11ee	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.11f1	80 01		bra $11f4			bra 	_BFDNext
.11f3					_BFDNoAdd:
.11f3	68		pla				pla 								; Throw away the intermediate calculations
.11f4					_BFDNext:
.11f4	88		dey				dey
.11f5	d0 d7		bne $11ce			bne 	_BFDLoop
.11f7	7a		ply				ply 								; restore Y
.11f8	46 1a		lsr $1a				lsr 	SignCount 					; if sign count odd,
.11fa	90 03		bcc $11ff			bcc 	_BFDUnsigned 				; then the result is signed
.11fc	20 06 12	jsr $1206			jsr		IntegerNegateAlways 		; negate the result
.11ff					_BFDUnsigned:
.11ff	60		rts				rts
.1200					CheckIntegerNegate:
.1200	bd 01 01	lda $0101,x			lda 	Stack2High,x 				; is it -ve = MSB set ?
.1203	30 01		bmi $1206			bmi 	IntegerNegateAlways 		; if so negate it
.1205	60		rts				rts
.1206					IntegerNegateAlways:
.1206	e6 1a		inc $1a				inc 	SignCount 					; bump the count of signs
.1208	38		sec				sec 								; negate
.1209	a9 00		lda #$00			lda 	#0
.120b	fd 02 01	sbc $0102,x			sbc 	Stack2Low,x
.120e	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.1211	a9 00		lda #$00			lda 	#0
.1213	fd 01 01	sbc $0101,x			sbc 	Stack2High,x
.1216	9d 01 01	sta $0101,x			sta 	Stack2High,x
.1219	60		rts				rts
.121a					CheckTOSNegate:
.121a	a5 07		lda $07				lda 	TOS+1
.121c	10 0f		bpl $122d			bpl		CTNNoChange
.121e	e6 1a		inc $1a				inc 	SignCount
.1220					TOSNegateAlways:
.1220	38		sec				sec
.1221	a9 00		lda #$00			lda 	#0
.1223	e5 06		sbc $06				sbc 	TOS
.1225	85 06		sta $06				sta 	TOS
.1227	a9 00		lda #$00			lda 	#0
.1229	e5 07		sbc $07				sbc 	TOS+1
.122b	85 07		sta $07				sta 	TOS+1
.122d					CTNNoChange:
.122d	60		rts				rts

;******  Return to file: files.asm


;******  Processing file: words/arithmetic/multiply.src

.122e					Multiply16x16:
.122e	86 10		stx $10				stx 	temp1
.1230	ba		tsx				tsx
.1231	bd 02 01	lda $0102,x			lda 	Stack2Low,x 				; 2nd value on stack to temp1
.1234	85 12		sta $12				sta 	temp2
.1236	bd 01 01	lda $0101,x			lda		Stack2High,x
.1239	85 13		sta $13				sta 	temp2+1
.123b	9e 02 01	stz $0102,x			stz 	Stack2Low,x 				; zero 2nd value on stack
.123e	9e 01 01	stz $0101,x			stz 	Stack2High,x
.1241					_MultLoop:
.1241	46 13		lsr $13				lsr 	temp2+1 					; ror temp2 into C
.1243	66 12		ror $12				ror 	temp2
.1245	90 11		bcc $1258			bcc 	_MultNoAdd
.1247	18		clc				clc 								; add 1st to 2nd
.1248	a5 06		lda $06				lda 	TOS
.124a	7d 02 01	adc $0102,x			adc 	Stack2Low,x
.124d	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.1250	a5 07		lda $07				lda 	TOS+1
.1252	7d 01 01	adc $0101,x			adc 	Stack2High,x
.1255	9d 01 01	sta $0101,x			sta 	Stack2High,x
.1258					_MultNoAdd:
.1258	06 06		asl $06				asl 	TOS 						; shift 1st left
.125a	26 07		rol $07				rol 	TOS+1
.125c	a5 12		lda $12				lda 	temp2	 					; until zero
.125e	05 13		ora $13				ora 	temp2+1
.1260	d0 df		bne $1241			bne 	_MultLoop
.1262	a6 10		ldx $10				ldx 	temp1 						; restore X load result
.1264	68		pla				pla
.1265	85 07		sta $07				sta 	TOS+1
.1267	68		pla				pla
.1268	85 06		sta $06				sta 	TOS
.126a	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: files.asm


;******  Processing file: words/arithmetic/unary.src

.126d					Unary1Plus:
.126d	e6 06		inc $06				inc 	TOS
.126f	d0 02		bne $1273			bne 	_U1PSkip
.1271	e6 07		inc $07				inc 	TOS+1
.1273					_U1PSkip:
.1273	4c 00 00	jmp $0000			jmp 	NextCode
.1276					Unary2Plus:
.1276	18		clc				clc
.1277	a5 06		lda $06				lda 	TOS
.1279	69 02		adc #$02			adc 	#2
.127b	85 06		sta $06				sta 	TOS
.127d	90 02		bcc $1281			bcc 	_U1PSkip
.127f	e6 07		inc $07				inc 	TOS+1
.1281					_U1PSkip:
.1281	4c 00 00	jmp $0000			jmp 	NextCode
.1284					Unary1Minus:
.1284	a5 06		lda $06				lda 	TOS
.1286	d0 02		bne $128a			bne 	_U1MSkip
.1288	c6 07		dec $07				dec 	TOS+1
.128a					_U1MSkip:
.128a	c6 06		dec $06				dec 	TOS
.128c	4c 00 00	jmp $0000			jmp 	NextCode
.128f					Unary2Minus:
.128f	38		sec				sec
.1290	a5 06		lda $06				lda 	TOS
.1292	e9 02		sbc #$02			sbc 	#2
.1294	85 06		sta $06				sta 	TOS
.1296	b0 02		bcs $129a			bcs 	_U1PSkip
.1298	c6 07		dec $07				dec 	TOS+1
.129a					_U1PSkip:
.129a	4c 00 00	jmp $0000			jmp 	NextCode
.129d					Absolute:
.129d	a5 07		lda $07				lda 	TOS+1
.129f	30 03		bmi $12a4			bmi 	Negate
.12a1	4c 00 00	jmp $0000			jmp 	NextCode
.12a4					Negate:
.12a4	38		sec				sec
.12a5	a9 00		lda #$00			lda 	#0
.12a7	e5 06		sbc $06				sbc 	TOS
.12a9	85 06		sta $06				sta 	TOS
.12ab	a9 00		lda #$00			lda 	#0
.12ad	e5 07		sbc $07				sbc 	TOS+1
.12af	85 07		sta $07				sta 	TOS+1
.12b1	4c 00 00	jmp $0000			jmp 	NextCode
.12b4					OneComplement:
.12b4	a5 06		lda $06				lda 	TOS
.12b6	49 ff		eor #$ff			eor 	#$FF
.12b8	85 06		sta $06				sta 	TOS
.12ba	a5 07		lda $07				lda 	TOS+1
.12bc	49 ff		eor #$ff			eor 	#$FF
.12be	85 07		sta $07				sta 	TOS+1
.12c0	4c 00 00	jmp $0000			jmp 	NextCode
.12c3					CheckMinus:
.12c3	a5 07		lda $07				lda 	TOS+1
.12c5	30 07		bmi $12ce			bmi 	UnaryTrue
.12c7					UnaryFalse:
.12c7	64 06		stz $06				stz 	TOS
.12c9	64 07		stz $07				stz 	TOS+1
.12cb	4c 00 00	jmp $0000			jmp 	NextCode
.12ce					UnaryTrue:
.12ce	a9 ff		lda #$ff			lda 	#$FF
.12d0	85 06		sta $06				sta 	TOS
.12d2	85 07		sta $07				sta 	TOS+1
.12d4	4c 00 00	jmp $0000			jmp 	NextCode
.12d7					CheckZero:
.12d7	a5 06		lda $06				lda 	TOS
.12d9	05 07		ora $07				ora 	TOS+1
.12db	d0 ea		bne $12c7			bne 	UnaryFalse
.12dd	80 ef		bra $12ce			bra 	UnaryTrue
.12df					SignTOS:
.12df	a5 07		lda $07				lda 	TOS+1
.12e1	30 eb		bmi $12ce			bmi		UnaryTrue
.12e3	05 06		ora $06				ora 	TOS
.12e5	f0 e0		beq $12c7			beq 	UnaryFalse
.12e7	a9 01		lda #$01			lda 	#1
.12e9	85 06		sta $06				sta 	TOS
.12eb	64 07		stz $07				stz		TOS+1
.12ed	4c 00 00	jmp $0000			jmp 	NextCode
.12f0					ByteSwap:
.12f0	a5 06		lda $06				lda 	TOS
.12f2	a4 07		ldy $07				ldy 	TOS+1
.12f4	85 07		sta $07				sta 	TOS+1
.12f6	84 06		sty $06				sty 	TOS
.12f8	4c 00 00	jmp $0000			jmp 	NextCode
.12fb					Times16:
.12fb	06 06		asl $06				asl 	TOS
.12fd	26 07		rol $07				rol 	TOS+1
.12ff					Times8:
.12ff	06 06		asl $06				asl 	TOS
.1301	26 07		rol $07				rol 	TOS+1
.1303					Times4:
.1303	06 06		asl $06				asl 	TOS
.1305	26 07		rol $07				rol 	TOS+1
.1307					Times2:
.1307	06 06		asl $06				asl 	TOS
.1309	26 07		rol $07				rol 	TOS+1
.130b	4c 00 00	jmp $0000			jmp 	NextCode
.130e					Divide16:
.130e	46 07		lsr $07				lsr 	TOS+1
.1310	66 06		ror $06				ror 	TOS
.1312					Divide8:
.1312	46 07		lsr $07				lsr 	TOS+1
.1314	66 06		ror $06				ror 	TOS
.1316					Divide4:
.1316	46 07		lsr $07				lsr 	TOS+1
.1318	66 06		ror $06				ror 	TOS
.131a					Divide2:
.131a	46 07		lsr $07				lsr 	TOS+1
.131c	66 06		ror $06				ror 	TOS
.131e	4c 00 00	jmp $0000			jmp 	NextCode
.1321					Times256:
.1321	a5 06		lda $06				lda 	TOS
.1323	85 07		sta $07				sta 	TOS+1
.1325	64 06		stz $06				stz 	TOS
.1327	4c 00 00	jmp $0000			jmp 	NextCode
.132a					Divide256:
.132a	a5 07		lda $07				lda 	TOS+1
.132c	85 06		sta $06				sta 	TOS
.132e	64 07		stz $07				stz 	TOS+1
.1330	4c 00 00	jmp $0000			jmp 	NextCode
.1333					RandomNumber:
.1333	a5 06		lda $06				lda 	TOS
.1335	48		pha				pha
.1336	a5 07		lda $07				lda 	TOS+1
.1338	48		pha				pha
.1339	a5 1b		lda $1b				lda 	randomSeed
.133b	05 1c		ora $1c				ora 	randomSeed+1
.133d	d0 08		bne $1347			bne 	_RH_NoInit
.133f	a9 7c		lda #$7c			lda 	#$7C
.1341	85 1b		sta $1b				sta 	randomSeed
.1343	a9 a1		lda #$a1			lda 	#$A1
.1345	85 1c		sta $1c				sta 	randomSeed+1
.1347					_RH_NoInit:
.1347	a5 1b		lda $1b				lda 	randomSeed
.1349	4a		lsr a		        lsr		a
.134a	26 1c		rol $1c		        rol 	randomSeed+1
.134c	90 02		bcc $1350	        bcc 	_RH_NoEor
.134e	49 b4		eor #$b4	        eor 	#$B4
.1350					_RH_NoEor:
.1350	85 1b		sta $1b		        sta 	randomSeed
.1352	45 1c		eor $1c		        eor 	randomSeed+1
.1354	85 07		sta $07		        sta 	TOS+1
.1356	a5 1b		lda $1b		        lda 	randomSeed
.1358	85 06		sta $06		        sta 	TOS
.135a	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: files.asm


;******  Processing file: words/data/literals.src

.135d					Constant0:
.135d	a5 06		lda $06				lda 	TOS
.135f	48		pha				pha
.1360	a5 07		lda $07				lda 	TOS+1
.1362	48		pha				pha
.1363	64 06		stz $06				stz 	TOS
.1365	64 07		stz $07				stz 	TOS+1
.1367	4c 00 00	jmp $0000			jmp 	NextCode
.136a					ConstantMinus1:
.136a	a5 06		lda $06				lda 	TOS
.136c	48		pha				pha
.136d	a5 07		lda $07				lda 	TOS+1
.136f	48		pha				pha
.1370	a9 ff		lda #$ff			lda 	#$FF
.1372	85 06		sta $06				sta 	TOS
.1374	85 07		sta $07				sta 	TOS+1
.1376	4c 00 00	jmp $0000			jmp 	NextCode
.1379					C1:
.1379	a0 01		ldy #$01			ldy 	#1
.137b	80 24		bra $13a1			bra 	Const1Byte
.137d					C2:
.137d	a0 02		ldy #$02			ldy 	#2
.137f	80 20		bra $13a1			bra 	Const1Byte
.1381					C3:
.1381	a0 03		ldy #$03			ldy 	#3
.1383	80 1c		bra $13a1			bra 	Const1Byte
.1385					C4:
.1385	a0 04		ldy #$04			ldy 	#4
.1387	80 18		bra $13a1			bra 	Const1Byte
.1389					C5:
.1389	a0 05		ldy #$05			ldy 	#5
.138b	80 14		bra $13a1			bra 	Const1Byte
.138d					C8:
.138d	a0 08		ldy #$08			ldy 	#8
.138f	80 10		bra $13a1			bra 	Const1Byte
.1391					C10:
.1391	a0 0a		ldy #$0a			ldy 	#10
.1393	80 0c		bra $13a1			bra 	Const1Byte
.1395					C15:
.1395	a0 0f		ldy #$0f			ldy 	#15
.1397	80 08		bra $13a1			bra 	Const1Byte
.1399					C16:
.1399	a0 10		ldy #$10			ldy 	#16
.139b	80 04		bra $13a1			bra 	Const1Byte
.139d					C24:
.139d	a0 18		ldy #$18			ldy 	#24
.139f	80 00		bra $13a1			bra 	Const1Byte
.13a1					Const1Byte:
.13a1	a5 06		lda $06				lda 	TOS
.13a3	48		pha				pha
.13a4	a5 07		lda $07				lda 	TOS+1
.13a6	48		pha				pha
.13a7	84 06		sty $06				sty 	TOS
.13a9	64 07		stz $07				stz 	TOS+1
.13ab	4c 00 00	jmp $0000			jmp 	NextCode
.13ae					C32:
.13ae	a0 20		ldy #$20			ldy 	#32
.13b0	80 ef		bra $13a1			bra 	Const1Byte
.13b2					C63:
.13b2	a0 3f		ldy #$3f			ldy 	#63
.13b4	80 eb		bra $13a1			bra 	Const1Byte
.13b6					C64:
.13b6	a0 40		ldy #$40			ldy 	#64
.13b8	80 e7		bra $13a1			bra 	Const1Byte
.13ba					C100:
.13ba	a0 64		ldy #$64			ldy 	#100
.13bc	80 e3		bra $13a1			bra 	Const1Byte
.13be					C127:
.13be	a0 7f		ldy #$7f			ldy 	#127
.13c0	80 df		bra $13a1			bra 	Const1Byte
.13c2					C128:
.13c2	a0 80		ldy #$80			ldy 	#128
.13c4	80 db		bra $13a1			bra 	Const1Byte
.13c6					C255:
.13c6	a0 ff		ldy #$ff			ldy 	#255
.13c8	80 d7		bra $13a1			bra 	Const1Byte
.13ca					Const2Byte:
.13ca	85 06		sta $06				sta 	TOS
.13cc	84 07		sty $07				sty 	TOS+1
.13ce	4c 00 00	jmp $0000			jmp 	NextCode
.13d1					C256:
.13d1	a5 06		lda $06				lda 	TOS
.13d3	48		pha				pha
.13d4	a5 07		lda $07				lda 	TOS+1
.13d6	48		pha				pha
.13d7	a9 00		lda #$00			lda 	#(256) & $FF
.13d9	a0 01		ldy #$01			ldy 	#(256) >> 8
.13db	80 ed		bra $13ca			bra 	Const2Byte
.13dd					C512:
.13dd	a5 06		lda $06				lda 	TOS
.13df	48		pha				pha
.13e0	a5 07		lda $07				lda 	TOS+1
.13e2	48		pha				pha
.13e3	a9 00		lda #$00			lda 	#(512) & $FF
.13e5	a0 02		ldy #$02			ldy 	#(512) >> 8
.13e7	80 e1		bra $13ca			bra 	Const2Byte
.13e9					C1024:
.13e9	a5 06		lda $06				lda 	TOS
.13eb	48		pha				pha
.13ec	a5 07		lda $07				lda 	TOS+1
.13ee	48		pha				pha
.13ef	a9 00		lda #$00			lda 	#(1024) & $FF
.13f1	a0 04		ldy #$04			ldy 	#(1024) >> 8
.13f3	80 d5		bra $13ca			bra 	Const2Byte
.13f5					C4096:
.13f5	a5 06		lda $06				lda 	TOS
.13f7	48		pha				pha
.13f8	a5 07		lda $07				lda 	TOS+1
.13fa	48		pha				pha
.13fb	a9 00		lda #$00			lda 	#(4096) & $FF
.13fd	a0 10		ldy #$10			ldy 	#(4096) >> 8
.13ff	80 c9		bra $13ca			bra 	Const2Byte
.1401					C32767:
.1401	a5 06		lda $06				lda 	TOS
.1403	48		pha				pha
.1404	a5 07		lda $07				lda 	TOS+1
.1406	48		pha				pha
.1407	a9 ff		lda #$ff			lda 	#(32767) & $FF
.1409	a0 7f		ldy #$7f			ldy 	#(32767) >> 8
.140b	80 bd		bra $13ca			bra 	Const2Byte
.140d					C32768:
.140d	a5 06		lda $06				lda 	TOS
.140f	48		pha				pha
.1410	a5 07		lda $07				lda 	TOS+1
.1412	48		pha				pha
.1413	a9 00		lda #$00			lda 	#(32768) & $FF
.1415	a0 80		ldy #$80			ldy 	#(32768) >> 8
.1417	80 b1		bra $13ca			bra 	Const2Byte

;******  Return to file: files.asm


;******  Processing file: words/data/stack.src

.1419					Drop:
.1419	68		pla				pla
.141a	85 07		sta $07				sta 	TOS+1
.141c	68		pla				pla
.141d	85 06		sta $06				sta 	TOS
.141f	4c 00 00	jmp $0000			jmp 	NextCode
.1422					TestDup:
.1422	a5 06		lda $06				lda 	TOS
.1424	05 07		ora $07				ora 	TOS+1
.1426	d0 03		bne $142b			bne 	Dup
.1428	4c 00 00	jmp $0000			jmp 	NextCode
.142b					Dup:
.142b	a5 06		lda $06				lda 	TOS
.142d	48		pha				pha
.142e	a5 07		lda $07				lda 	TOS+1
.1430	48		pha				pha
.1431	4c 00 00	jmp $0000			jmp 	NextCode
.1434					Swap:
.1434	86 10		stx $10				stx 	temp1
.1436	7a		ply				ply
.1437	fa		plx				plx
.1438	a5 06		lda $06				lda 	TOS
.143a	48		pha				pha
.143b	a5 07		lda $07				lda 	TOS+1
.143d	48		pha				pha
.143e	86 06		stx $06				stx 	TOS
.1440	84 07		sty $07				sty 	TOS+1
.1442	a6 10		ldx $10				ldx 	temp1
.1444	4c 00 00	jmp $0000			jmp 	NextCode
.1447					Over:
.1447	a5 06		lda $06				lda 	TOS
.1449	48		pha				pha
.144a	a5 07		lda $07				lda 	TOS+1
.144c	48		pha				pha
.144d	86 10		stx $10				stx 	temp1
.144f	ba		tsx				tsx
.1450	bd 04 01	lda $0104,x			lda 	stack3low,x
.1453	85 06		sta $06				sta 	TOS
.1455	bd 03 01	lda $0103,x			lda 	stack3High,x
.1458	85 07		sta $07				sta 	TOS+1
.145a	a6 10		ldx $10				ldx 	temp1
.145c	4c 00 00	jmp $0000			jmp 	NextCode
.145f					Nip:
.145f	68		pla				pla
.1460	68		pla				pla
.1461	4c 00 00	jmp $0000			jmp 	NextCode
.1464					Rot:
.1464	86 10		stx $10				stx 	temp1
.1466	ba		tsx				tsx
.1467	bd 04 01	lda $0104,x			lda 	Stack3Low,x
.146a	a8		tay				tay
.146b	bd 02 01	lda $0102,x			lda 	Stack2Low,x
.146e	9d 04 01	sta $0104,x			sta 	Stack3Low,x
.1471	a5 06		lda $06				lda 	TOS
.1473	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.1476	84 06		sty $06				sty 	TOS
.1478	bd 03 01	lda $0103,x			lda 	Stack3High,x
.147b	a8		tay				tay
.147c	bd 01 01	lda $0101,x			lda 	Stack2High,x
.147f	9d 03 01	sta $0103,x			sta 	Stack3High,x
.1482	a5 07		lda $07				lda 	TOS+1
.1484	9d 01 01	sta $0101,x			sta 	Stack2High,x
.1487	84 07		sty $07				sty 	TOS+1
.1489	a6 10		ldx $10				ldx 	temp1
.148b	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: files.asm


;******  Processing file: words/data/memory.src

.148e					ByteRead:
.148e	b2 06		lda ($06)			lda 	(TOS)
.1490	85 06		sta $06				sta 	TOS
.1492	64 07		stz $07				stz 	TOS+1
.1494	4c 00 00	jmp $0000			jmp 	NextCode
.1497					WordRead:
.1497	a0 01		ldy #$01			ldy 	#1
.1499	b1 06		lda ($06),y			lda 	(TOS),y
.149b	a8		tay				tay
.149c	b2 06		lda ($06)			lda 	(TOS)
.149e	85 06		sta $06				sta 	TOS
.14a0	84 07		sty $07				sty 	TOS+1
.14a2	4c 00 00	jmp $0000			jmp 	NextCode
.14a5					ByteWrite:
.14a5	68		pla				pla
.14a6	68		pla				pla
.14a7	92 06		sta ($06)			sta 	(TOS)
.14a9	68		pla				pla
.14aa	85 07		sta $07				sta 	TOS+1
.14ac	68		pla				pla
.14ad	85 06		sta $06				sta 	TOS
.14af	4c 00 00	jmp $0000			jmp 	NextCode
.14b2					WordWrite:
.14b2	68		pla				pla
.14b3	a0 01		ldy #$01			ldy 	#1
.14b5	91 06		sta ($06),y			sta 	(TOS),y
.14b7	68		pla				pla
.14b8	92 06		sta ($06)			sta 	(TOS)
.14ba	68		pla				pla
.14bb	85 07		sta $07				sta 	TOS+1
.14bd	68		pla				pla
.14be	85 06		sta $06				sta 	TOS
.14c0	4c 00 00	jmp $0000			jmp 	NextCode
.14c3					WordAdd:
.14c3	7a		ply				ply
.14c4	68		pla				pla
.14c5	18		clc				clc
.14c6	72 06		adc ($06)			adc 	(TOS)
.14c8	92 06		sta ($06)			sta 	(TOS)
.14ca	98		tya				tya
.14cb	a0 01		ldy #$01			ldy 	#1
.14cd	71 06		adc ($06),y			adc 	(TOS),y
.14cf	91 06		sta ($06),y			sta 	(TOS),y
.14d1	68		pla				pla
.14d2	85 07		sta $07				sta 	TOS+1
.14d4	68		pla				pla
.14d5	85 06		sta $06				sta 	TOS
.14d7	4c 00 00	jmp $0000			jmp 	NextCode
.14da					AllocateMemory:
.14da	a5 06		lda $06				lda 	TOS 						; save memory required on stack.
.14dc	48		pha				pha
.14dd	a5 07		lda $07				lda 	TOS+1
.14df	48		pha				pha
.14e0	a5 0e		lda $0e				lda 	nextFreeMem 				; copy free mem address to TOS
.14e2	85 06		sta $06				sta 	TOS
.14e4	a5 0f		lda $0f				lda 	nextFreeMem+1
.14e6	85 07		sta $07				sta 	TOS+1
.14e8	7a		ply				ply 								; advance the free ram pointer
.14e9	68		pla				pla
.14ea	20 22 18	jsr $1822			jsr 	AdvanceFreeMem
.14ed	20 2f 18	jsr $182f			jsr 	CheckMemory 				; low on memory ?
.14f0	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: files.asm


;******  Processing file: words/structures/fornext.src

.14f3					ForHandler:
.14f3	e6 05		inc $05				inc 	rsp 						; bump the RSP
.14f5	a4 05		ldy $05				ldy 	rsp 						; get return stack and push TOS/$FF on it.
.14f7	c0 40		cpy #$40			cpy 	#$40 						; overflow
.14f9	f0 18		beq $1513			beq 	_FHOverflow
.14fb	a5 07		lda $07				lda 	TOS+1
.14fd	99 40 07	sta $0740,y			sta 	returnStackHigh,y
.1500	a5 06		lda $06				lda 	TOS
.1502	99 00 07	sta $0700,y			sta 	returnStackLow,y
.1505	a9 ff		lda #$ff			lda 	#$FF
.1507	99 80 07	sta $0780,y			sta 	returnStackX,y
.150a	68		pla				pla
.150b	85 07		sta $07				sta 	TOS+1
.150d	68		pla				pla
.150e	85 06		sta $06				sta 	TOS
.1510	4c 00 00	jmp $0000			jmp 	NextCode
.1513					_FHOverflow:
.1513	20 4f 24	jsr $244f			jsr 	ErrorHandler
>1516	53 54 52 55 43 54 55 52				.text 	"STRUCTURE OVERFLOW",0
>151e	45 20 4f 56 45 52 46 4c 4f 57 00
.1529					ForEncoder:
.1529	a9 f3		lda #$f3			lda 	#ForHandler & $FF 			; for handler
.152b	a0 14		ldy #$14			ldy 	#ForHandler >> 8
.152d	20 ec 21	jsr $21ec			jsr 	EncodeWriteWord
.1530	a9 46		lda #$46			lda 	#"F" 						; for marker
.1532	20 82 22	jsr $2282			jsr 	EncodePushPosMarkerOnStack
.1535	60		rts				rts
.1536					NextHandler:
.1536	da		phx				phx
.1537	a6 05		ldx $05				ldx 	rsp 						; get current stack ptr
.1539	bd 80 07	lda $0780,x			lda 	returnStackX,x 				; check it's a FOR Loop
.153c	c9 ff		cmp #$ff			cmp 	#$FF
.153e	d0 21		bne $1561			bne 	NHNoFor
.1540	bd 00 07	lda $0700,x			lda 	returnStackLow,x 			; decrement the count
.1543	d0 03		bne $1548			bne 	_NHNoBorrow
.1545	de 40 07	dec $0740,x			dec 	returnStackHigh,x
.1548					_NHNoBorrow:
.1548	de 00 07	dec $0700,x			dec 	returnStackLow,x
.154b	bd 00 07	lda $0700,x			lda 	returnStackLow,x 			; have we reached the end ?
.154e	1d 40 07	ora $0740,x			ora 	returnStackHigh,x
.1551	fa		plx				plx 								; restore X and re-test
.1552	09 00		ora #$00			ora 	#0
.1554	f0 05		beq $155b			beq 	_NHComplete 				; if so then complete, else loop.
.1556	e8		inx				inx 								; advance to branch
.1557	e8		inx				inx
.1558	4c 7d 16	jmp $167d			jmp 	BranchAlways
.155b					_NHComplete:
.155b	e8		inx				inx 								; skip over the branch quantity
.155c	c6 05		dec $05				dec 	rsp 						; drop the indx
.155e	4c 00 00	jmp $0000			jmp 	NextCode
.1561					NHNoFor:
.1561	20 4f 24	jsr $244f			jsr 	ErrorHandler
>1564	4f 55 54 20 4f 46 20 46				.text 	"OUT OF FOR SCOPE",0
>156c	4f 52 20 53 43 4f 50 45 00
.1575					NextEncoder:
.1575	a9 36		lda #$36			lda 	#NextHandler & $FF 			; next code
.1577	a0 15		ldy #$15			ldy 	#NextHandler >> 8
.1579	20 ec 21	jsr $21ec			jsr 	EncodeWriteWord
.157c	a6 05		ldx $05				ldx 	rsp 						; get stack offset and pop
.157e	c6 05		dec $05				dec 	rsp
.1580	bd 40 07	lda $0740,x			lda 	returnStackHigh,x 			; check it is a for
.1583	c9 46		cmp #$46			cmp 	#"F"
.1585	d0 07		bne $158e			bne 	_NENoFor
.1587	bd 80 07	lda $0780,x			lda 	returnStackX,x 				; write the branch
.158a	20 f6 21	jsr $21f6			jsr 	EncodeWriteByte
.158d	60		rts				rts
.158e					_NENoFor:
.158e	20 4f 24	jsr $244f			jsr 	ErrorHandler
>1591	4d 49 53 53 49 4e 47 20				.text 	"MISSING FOR",0
>1599	46 4f 52 00
.159d					GetIndex:
.159d	a4 05		ldy $05				ldy 	rsp 						; get current stack ptr
.159f	b9 80 07	lda $0780,y			lda 	returnStackX,y 				; check it's a FOR Loop
.15a2	c9 ff		cmp #$ff			cmp 	#$FF
.15a4	d0 bb		bne $1561			bne 	NHNoFor
.15a6	a5 06		lda $06				lda 	TOS
.15a8	48		pha				pha
.15a9	a5 07		lda $07				lda 	TOS+1
.15ab	48		pha				pha
.15ac	b9 00 07	lda $0700,y			lda 	returnStackLow,y 			; put counter-1 out
.15af	38		sec				sec
.15b0	e9 01		sbc #$01			sbc 	#1
.15b2	85 06		sta $06				sta 	TOS
.15b4	b9 40 07	lda $0740,y			lda 	returnStackHigh,y
.15b7	e9 00		sbc #$00			sbc 	#0
.15b9	85 07		sta $07				sta 	TOS+1
.15bb	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: files.asm


;******  Processing file: words/structures/ifelseendif.src

.15be					IfHandler:
.15be	4c 65 16	jmp $1665			jmp 	BranchIfZero
.15c1					IfEncoder:
.15c1	a9 be		lda #$be			lda 	#IfHandler & $FF 			; if handler
.15c3	a0 15		ldy #$15			ldy 	#IfHandler >> 8
.15c5	20 ec 21	jsr $21ec			jsr 	EncodeWriteWord
.15c8	a9 49		lda #$49			lda 	#"I" 						; if marker
.15ca	20 82 22	jsr $2282			jsr 	EncodePushPosMarkerOnStack
.15cd	a9 00		lda #$00			lda 	#0
.15cf	20 f6 21	jsr $21f6			jsr 	EncodeWriteByte 			; dummy write.
.15d2	60		rts				rts
.15d3					ElseHandler:
.15d3	4c 7b 16	jmp $167b			jmp 	BranchTestSucceedsNoPop
.15d6					ElseEncoder:
.15d6	a9 d3		lda #$d3			lda 	#ElseHandler & $FF 			; else handler
.15d8	a0 15		ldy #$15			ldy 	#ElseHandler >> 8
.15da	20 ec 21	jsr $21ec			jsr 	EncodeWriteWord
.15dd	ad 10 09	lda $0910			lda 	encodeBuffer 				; push current position
.15e0	48		pha				pha
.15e1	a9 00		lda #$00			lda 	#0 							; zero branch
.15e3	20 f6 21	jsr $21f6			jsr 	EncodeWriteByte
.15e6	20 03 16	jsr $1603			jsr 	IfPatch 					; fix up the branch.
.15e9	a9 49		lda #$49			lda 	#"I" 						; recreate if marker
.15eb	20 82 22	jsr $2282			jsr 	EncodePushPosMarkerOnStack
.15ee	68		pla				pla 								; address to patch
.15ef	a6 05		ldx $05				ldx 	rsp
.15f1	9d 80 07	sta $0780,x			sta 	returnStackX,x 				; and overwrite the target address
.15f4	60		rts				rts
.15f5					EndIfHandler:
.15f5	4c 00 00	jmp $0000			jmp 	NextCode
.15f8					EndIfEncoder:
.15f8	a9 f5		lda #$f5			lda 	#EndIfHandler & $FF 		; endif handler
.15fa	a0 15		ldy #$15			ldy 	#EndIfHandler >> 8
.15fc	20 ec 21	jsr $21ec			jsr 	EncodeWriteWord
.15ff	20 03 16	jsr $1603			jsr 	IfPatch
.1602	60		rts				rts
.1603					IfPatch:
.1603	a6 05		ldx $05				ldx 	rsp 						; get stack offset and pop
.1605	c6 05		dec $05				dec 	rsp
.1607	bd 40 07	lda $0740,x			lda 	returnStackHigh,x 			; check it is an if.
.160a	c9 49		cmp #$49			cmp 	#"I"
.160c	d0 0b		bne $1619			bne 	_NENoIf
.160e	bd 80 07	lda $0780,x			lda 	returnStackX,x 				; this is what you patch.
.1611	aa		tax				tax
.1612	ad 10 09	lda $0910			lda 	encodeBuffer 				; with the current position.
.1615	9d 10 09	sta $0910,x			sta 	encodeBuffer,x
.1618	60		rts				rts
.1619					_NENoIf:
.1619	20 4f 24	jsr $244f			jsr 	ErrorHandler
>161c	4d 49 53 53 49 4e 47 20				.text 	"MISSING IF",0
>1624	49 46 00

;******  Return to file: files.asm


;******  Processing file: words/structures/repeatuntil.src

.1627					RepeatHandler:
.1627	4c 00 00	jmp $0000			jmp 	NextCode
.162a					RepeatEncoder:
.162a	a9 27		lda #$27			lda 	#RepeatHandler & $FF 		; repeat marker
.162c	a0 16		ldy #$16			ldy 	#RepeatHandler >> 8
.162e	20 ec 21	jsr $21ec			jsr 	EncodeWriteWord
.1631	a9 52		lda #$52			lda 	#"R" 						; repeat marker
.1633	20 82 22	jsr $2282			jsr 	EncodePushPosMarkerOnStack
.1636	60		rts				rts
.1637					UntilHandler:
.1637	4c 65 16	jmp $1665			jmp 	BranchIfZero
.163a					UntilEncoder:
.163a	a9 37		lda #$37			lda 	#UntilHandler & $FF 		; until code
.163c	a0 16		ldy #$16			ldy 	#UntilHandler >> 8
.163e	20 ec 21	jsr $21ec			jsr 	EncodeWriteWord
.1641	a6 05		ldx $05				ldx 	rsp 						; get stack offset and pop
.1643	c6 05		dec $05				dec 	rsp
.1645	bd 40 07	lda $0740,x			lda 	returnStackHigh,x 			; check it is a repeat
.1648	c9 52		cmp #$52			cmp 	#"R"
.164a	d0 07		bne $1653			bne 	_UENoRepeat
.164c	bd 80 07	lda $0780,x			lda 	returnStackX,x 				; write the branch
.164f	20 f6 21	jsr $21f6			jsr 	EncodeWriteByte
.1652	60		rts				rts
.1653					_UENoRepeat:
.1653	20 4f 24	jsr $244f			jsr 	ErrorHandler
>1656	4d 49 53 53 49 4e 47 20				.text 	"MISSING REPEAT",0
>165e	52 45 50 45 41 54 00

;******  Return to file: files.asm


;******  Processing file: words/system/branch.src

.1665					BranchIfZero:
.1665	a5 06		lda $06				lda 	TOS 						; check TOS = 0
.1667	05 07		ora $07				ora 	TOS+1
.1669	f0 0a		beq $1675			beq 	BranchTestSucceeds
.166b					BranchTestFails:
.166b	68		pla				pla
.166c	85 07		sta $07				sta 	TOS+1
.166e	68		pla				pla
.166f	85 06		sta $06				sta 	TOS
.1671	e8		inx				inx 								; skip over the relative branch.
.1672	4c 00 00	jmp $0000			jmp 	NextCode
.1675					BranchTestSucceeds:
.1675	68		pla				pla
.1676	85 07		sta $07				sta 	TOS+1
.1678	68		pla				pla
.1679	85 06		sta $06				sta 	TOS
.167b					BranchTestSucceedsNoPop:
.167b	e8		inx				inx 								; advance by two, to the offset
.167c	e8		inx				inx
.167d					BranchAlways:
.167d	8a		txa				txa 								; A = Y = position
.167e	a8		tay				tay 								; (IP),Y now points to the branch target
.167f	b1 03		lda ($03),y			lda 	(IP),y 						; adjust the position
.1681	aa		tax				tax 								; position back in this line.
.1682	ca		dex				dex
.1683	ca		dex				dex
.1684	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: files.asm


;******  Processing file: words/system/callhandler.src

.1687					CallHandler:
.1687	e8		inx				inx									; bump X to the call address.
.1688	e8		inx				inx
.1689	e6 05		inc $05				inc 	rsp 						; bump the RSP (first time to zero)
.168b	a4 05		ldy $05				ldy 	rsp 						; get return stack and push IP/X on it.
.168d	c0 40		cpy #$40			cpy 	#$40 						; overflow
.168f	f0 54		beq $16e5			beq 	_CHOverflow
.1691	a5 04		lda $04				lda 	IP+1
.1693	99 40 07	sta $0740,y			sta 	returnStackHigh,y
.1696	a5 03		lda $03				lda 	IP
.1698	99 00 07	sta $0700,y			sta 	returnStackLow,y
.169b	8a		txa				txa
.169c	99 80 07	sta $0780,y			sta 	returnStackX,y
.169f	8a		txa				txa 								; get the line number into temp1.
.16a0	a8		tay				tay
.16a1	b1 03		lda ($03),y			lda 	(IP),y
.16a3	85 10		sta $10				sta 	temp1
.16a5	c8		iny				iny
.16a6	b1 03		lda ($03),y			lda 	(IP),y
.16a8	85 11		sta $11				sta 	temp1+1
.16aa	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.16ac	85 03		sta $03				sta 	0+(IP)
.16ae	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.16b0	85 04		sta $04				sta 	1+(IP)
.16b2	b2 03		lda ($03)			lda 	(IP)						; no program code ?
.16b4	f0 17		beq $16cd			beq 	_CHFail
.16b6	a0 01		ldy #$01			ldy 	#1 							; Y = 1 throughout.
.16b8					_CHSearch:
.16b8	b1 03		lda ($03),y			lda 	(IP),y 						; check LSB of line number
.16ba	c5 10		cmp $10				cmp 	temp1
.16bc	f0 3e		beq $16fc			beq 	_CHFoundLSB
.16be					_CHSearchNext:
.16be	18		clc				clc
.16bf	a5 03		lda $03				lda 	IP
.16c1	72 03		adc ($03)			adc 	(IP)
.16c3	85 03		sta $03				sta 	IP
.16c5	90 02		bcc $16c9			bcc 	_NoCarryAdv
.16c7	e6 04		inc $04				inc 	IP+1
.16c9					_NoCarryAdv:
.16c9	b2 03		lda ($03)			lda 	(IP)						; check reached the end.
.16cb	d0 eb		bne $16b8			bne 	_CHSearch
.16cd					_CHFail:
.16cd	20 4f 24	jsr $244f			jsr 	ErrorHandler
>16d0	43 41 4e 54 20 46 49 4e				.text 	"CANT FIND DEFINITION",0
>16d8	44 20 44 45 46 49 4e 49 54 49 4f 4e 00
.16e5					_CHOverflow:
.16e5	20 4f 24	jsr $244f			jsr 	ErrorHandler
>16e8	43 41 4c 4c 20 53 54 41				.text 	"CALL STACK OVERFLOW",0
>16f0	43 4b 20 4f 56 45 52 46 4c 4f 57 00
.16fc					_CHFoundLSB:
.16fc	c8		iny				iny 								; get MSB
.16fd	b1 03		lda ($03),y			lda 	(IP),y
.16ff	88		dey				dey
.1700	c5 11		cmp $11				cmp 	temp1+1 					; matches, if not contineu
.1702	d0 ba		bne $16be			bne 	_CHSearchNext
.1704	a0 03		ldy #$03			ldy 	#3	 						; check it begins with $$define
.1706	b1 03		lda ($03),y			lda 	(IP),y
.1708	c9 cc		cmp #$cc			cmp 	#DefineCode & $FF
.170a	d0 c1		bne $16cd			bne 	_CHFail
.170c	c8		iny				iny
.170d	b1 03		lda ($03),y			lda 	(IP),y
.170f	c9 1c		cmp #$1c			cmp 	#DefineCode >> 8
.1711	d0 ba		bne $16cd			bne 	_CHFail
.1713	c8		iny				iny
.1714	b1 03		lda ($03),y			lda 	(IP),y 						; this is the length of the define name
.1716	18		clc				clc
.1717	69 03		adc #$03			adc 	#5-2 						; $$define token, line number, offset - 2 for Next
.1719	aa		tax				tax
.171a	4c 00 00	jmp $0000			jmp 	NextCode
.171d					ReturnHandler:
.171d	a4 05		ldy $05				ldy 	rsp 						; get rsp
.171f	f0 15		beq $1736			beq 	_RHUnderflow 				; if -ve underflowed
.1721	c6 05		dec $05				dec 	rsp 						; decrement rsp
.1723	b9 40 07	lda $0740,y			lda 	returnStackHigh,y 			; restore IP/X
.1726	85 04		sta $04				sta 	IP+1
.1728	b9 00 07	lda $0700,y			lda 	returnStackLow,y
.172b	85 03		sta $03				sta 	IP
.172d	b9 80 07	lda $0780,y			lda 	returnStackX,y
.1730	aa		tax				tax
.1731	f0 15		beq $1748			beq 	_RHInLoop 					; this means you have done :something for ; next
.1733	4c 00 00	jmp $0000			jmp 	NextCode
.1736					_RHUnderflow:
.1736	20 4f 24	jsr $244f			jsr 	ErrorHandler
>1739	4d 49 53 53 49 4e 47 20				.text 	"MISSING RETURN",0
>1741	52 45 54 55 52 4e 00
.1748					_RHInLoop:
.1748	20 4f 24	jsr $244f			jsr 	ErrorHandler
>174b	52 45 54 55 52 4e 20 49				.text 	"RETURN IN LOOP ERROR",0
>1753	4e 20 4c 4f 4f 50 20 45 52 52 4f 52 00
.1760					CallHandlerDecode:
.1760	a9 03		lda #$03			lda 	#CTH_Call					; space
.1762	20 43 19	jsr $1943			jsr 	DecodeWriteBuffer
.1765	b1 08		lda ($08),y			lda 	(srcPtr),y 					; get line number into YA
.1767	aa		tax				tax
.1768	c8		iny				iny
.1769	b1 08		lda ($08),y			lda 	(srcPtr),y
.176b	a8		tay				tay
.176c	8a		txa				txa
.176d	20 aa 17	jsr $17aa			jsr 	FindLine 					; try to locate that line.
.1770	b0 11		bcs $1783			bcs 	_CHDFound 					; if found .....
.1772					_CHDLineOnly:
.1772	48		pha				pha
.1773	a9 3c		lda #$3c			lda 	#"<"
.1775	20 43 19	jsr $1943			jsr 	DecodeWriteBuffer
.1778	68		pla				pla
.1779	18		clc				clc 								; output unsigned
.177a	20 65 19	jsr $1965			jsr 	DecodeYAToBuffer
.177d	a9 3e		lda #$3e			lda 	#">"
.177f	20 43 19	jsr $1943			jsr 	DecodeWriteBuffer
.1782	60		rts				rts
.1783					_CHDFound:
.1783	48		pha				pha 								; save YA
.1784	5a		phy				phy
.1785	a0 03		ldy #$03			ldy 	#3 							; check first is $$define
.1787	b1 10		lda ($10),y			lda 	(temp1),y
.1789	c9 cc		cmp #$cc			cmp 	#DefineCode & 255
.178b	d0 07		bne $1794			bne 	_CHDNoDefine
.178d	c8		iny				iny
.178e	b1 10		lda ($10),y			lda 	(temp1),y
.1790	c9 1c		cmp #$1c			cmp 	#DefineCode >> 8
.1792	f0 04		beq $1798			beq 	_CHDFoundDefine
.1794					_CHDNoDefine:
.1794	7a		ply				ply									; restore the line number and print it in <>
.1795	68		pla				pla
.1796	80 da		bra $1772			bra 	_CHDLineOnly
.1798					_CHDFoundDefine:
.1798	68		pla				pla 								; throw saved line number.
.1799	68		pla				pla
.179a	a0 05		ldy #$05			ldy 	#5 							; 3,4 $$define 5 length, name has bit 7 set at end
.179c					_CHDOutName:
.179c	c8		iny				iny 								; next
.179d	b1 10		lda ($10),y			lda 	(temp1),y 					; print char no bit 7
.179f	48		pha				pha
.17a0	29 7f		and #$7f			and 	#$7F
.17a2	20 43 19	jsr $1943			jsr 	DecodeWriteBuffer
.17a5	68		pla				pla
.17a6	0a		asl a				asl 	a 							; bit 7 to carry
.17a7	90 f3		bcc $179c			bcc 	_CHDOutName
.17a9	60		rts				rts
.17aa					FindLine:
.17aa	48		pha				pha 								; save registers
.17ab	da		phx				phx
.17ac	5a		phy				phy
.17ad	85 12		sta $12				sta 	temp2 						; temp2 = target line#
.17af	84 13		sty $13				sty 	temp2+1
.17b1	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.17b3	85 10		sta $10				sta 	0+(temp1)
.17b5	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.17b7	85 11		sta $11				sta 	1+(temp1)
.17b9					_FLLoop:
.17b9	b2 10		lda ($10)			lda 	(temp1) 					; found end ?
.17bb	18		clc				clc									; if so exit with CC.
.17bc	f0 1d		beq $17db			beq 	_FLExit
.17be	a0 01		ldy #$01			ldy 	#1 							; check line # match
.17c0	b1 10		lda ($10),y			lda 	(temp1),y
.17c2	c5 12		cmp $12				cmp 	temp2
.17c4	d0 08		bne $17ce			bne 	_FLNext
.17c6	c8		iny				iny
.17c7	b1 10		lda ($10),y			lda 	(temp1),y
.17c9	c5 13		cmp $13				cmp 	temp2+1
.17cb	38		sec				sec 								; if so exit with CS
.17cc	f0 0d		beq $17db			beq 	_FLExit
.17ce					_FLNext:
.17ce	18		clc				clc
.17cf	a5 10		lda $10				lda 	temp1
.17d1	72 10		adc ($10)			adc 	(temp1)
.17d3	85 10		sta $10				sta 	temp1
.17d5	90 02		bcc $17d9			bcc 	_NoCarryAdv
.17d7	e6 11		inc $11				inc 	temp1+1
.17d9					_NoCarryAdv:
.17d9	80 de		bra $17b9			bra 	_FLLoop 					; keep looking.
.17db					_FLExit:
.17db	7a		ply				ply
.17dc	fa		plx				plx
.17dd	68		pla				pla
.17de	60		rts				rts
.17df	18		clc				clc
.17e0	60		rts				rts

;******  Return to file: files.asm


;******  Processing file: words/system/clrnew.src

.17e1					NewHandler:
.17e1	9c 00 40	stz $4000			stz 	ProgramMemory 				; Make the first offset zero.
.17e4	20 f7 17	jsr $17f7			jsr 	ClearVariableSpace 			; clear variables, reset pointers
.17e7	4c c9 23	jmp $23c9			jmp 	WarmStartBlankStack
.17ea					ClrHandler:
.17ea	86 10		stx $10				stx 	temp1
.17ec	a2 80		ldx #$80			ldx 	#NumberStackBase
.17ee	9a		txs				txs
.17ef	a6 10		ldx $10				ldx 	temp1
.17f1	20 f7 17	jsr $17f7			jsr 	ClearVariableSpace 			; clear variables, reset pointers
.17f4	4c 00 00	jmp $0000			jmp 	NextCode
.17f7					ClearVariableSpace:
.17f7	64 05		stz $05				stz 	rsp
.17f9	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.17fb	85 0e		sta $0e				sta 	0+(nextFreeMem)
.17fd	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.17ff	85 0f		sta $0f				sta 	1+(nextFreeMem)
.1801	a0 1f		ldy #$1f			ldy 	#hashTableSize*2-1 			; erase the hash table (used for variables)
.1803					_CVSHashClear:
.1803	a9 00		lda #$00			lda 	#0 							; all the first record pointers are $00
.1805	99 40 06	sta $0640,y			sta 	hashTable,y
.1808	88		dey				dey
.1809	10 f8		bpl $1803			bpl 	_CVSHashClear
.180b					_CVSFindEnd:
.180b	18		clc				clc
.180c	a5 0e		lda $0e				lda 	nextFreeMem
.180e	72 0e		adc ($0e)			adc 	(nextFreeMem)
.1810	85 0e		sta $0e				sta 	nextFreeMem
.1812	90 02		bcc $1816			bcc 	_NoCarryAdv
.1814	e6 0f		inc $0f				inc 	nextFreeMem+1
.1816					_NoCarryAdv:
.1816	b2 0e		lda ($0e)			lda 	(nextFreeMem)
.1818	d0 f1		bne $180b			bne 	_CVSFindEnd
.181a	a9 08		lda #$08			lda 	#8 							; this puts a gap in, more for clarity than anything.
.181c	a0 00		ldy #$00			ldy 	#0
.181e	20 22 18	jsr $1822			jsr 	AdvanceFreeMem				; we need +1 because the previous code leaves the
.1821	60		rts				rts 								; free mem pointer pointing to the last zero offset
.1822					AdvanceFreeMem:
.1822	18		clc				clc
.1823	65 0e		adc $0e				adc 	nextFreeMem
.1825	85 0e		sta $0e				sta 	nextFreeMem
.1827	98		tya				tya
.1828	65 0f		adc $0f				adc 	nextFreeMem+1
.182a	85 0f		sta $0f				sta 	nextFreeMem+1
.182c	b0 08		bcs $1836			bcs 	MemoryOverflow
.182e	60		rts				rts
.182f					CheckMemory:
.182f	a5 0f		lda $0f				lda 	nextFreeMem+1
.1831	c9 9d		cmp #$9d			cmp 	#(lastMemoryByte >> 8)-1
.1833	b0 01		bcs $1836			bcs 	MemoryOverflow
.1835	60		rts				rts
.1836					MemoryOverflow:
.1836	20 4f 24	jsr $244f			jsr 	ErrorHandler
>1839	4f 55 54 20 4f 46 20 4d				.text 	"OUT OF MEMORY",0
>1841	45 4d 4f 52 59 00

;******  Return to file: files.asm


;******  Processing file: words/system/debug.src

.1847					ExitDump:
.1847	ba		tsx				tsx 								; save Data Stack in temp1
.1848	86 10		stx $10				stx 	temp1
.184a	4c ff ff	jmp $ffff			jmp 	$FFFF 						; makes the X16-Emulator dump-exit.
.184d					BreakCmd:
>184d	ff						.byte 	$FF
.184e	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: files.asm


;******  Processing file: words/system/decode.src

.1851					DecodeLineIntoBufPtr:
.1851	48		pha				pha
.1852	da		phx				phx
.1853	5a		phy				phy
.1854	85 08		sta $08				sta 	srcPtr 						; save the source line.
.1856	84 09		sty $09				sty 	srcPtr+1
.1858	90 1b		bcc $1875			bcc 	_DecodeNoLineNumber
.185a	a0 01		ldy #$01			ldy 	#1 							; get line # to YA
.185c	b1 08		lda ($08),y			lda 	(srcPtr),y
.185e	aa		tax				tax
.185f	c8		iny				iny
.1860	b1 08		lda ($08),y			lda 	(srcPtr),y
.1862	a8		tay				tay
.1863	8a		txa				txa
.1864	18		clc				clc
.1865	20 65 19	jsr $1965			jsr 	DecodeYAToBuffer 			; convert to string in buffer
.1868	aa		tax				tax 								; count in X
.1869					_DecodeLineSpace:
.1869	e0 05		cpx #$05			cpx 	#5
.186b	f0 08		beq $1875			beq 	_DecodeNoLineNumber
.186d	a9 20		lda #$20			lda 	#" " 						; pad to 5 spaces
.186f	20 43 19	jsr $1943			jsr 	DecodeWriteBuffer
.1872	e8		inx				inx
.1873	80 f4		bra $1869			bra 	_DecodeLineSpace
.1875					_DecodeNoLineNumber:
.1875	a0 03		ldy #$03			ldy 	#3 							; initial position.
.1877					_DecodeLoop:
.1877	b1 08		lda ($08),y			lda 	(srcPtr),y 					; copy the current character to temp1
.1879	85 10		sta $10				sta 	temp1 						; must be an execution address.
.187b	c8		iny				iny
.187c	b1 08		lda ($08),y			lda 	(srcPtr),y
.187e	85 11		sta $11				sta 	temp1+1
.1880	c8		iny				iny 								; y points to the byte after it.
.1881	a5 10		lda $10				lda 	temp1
.1883	c9 8a		cmp #$8a			cmp 	#NextLine & $FF
.1885	d0 06		bne $188d			bne 	_DecodeNotEOL
.1887	a5 11		lda $11				lda 	temp1+1
.1889	c9 1c		cmp #$1c			cmp 	#NextLine >> 8
.188b	f0 0b		beq $1898			beq 	_DecodeEOL
.188d					_DecodeNotEOL:
.188d	20 a0 18	jsr $18a0			jsr 	IdentifyCodeWord
.1890	20 ee 18	jsr $18ee			jsr 	DecodeFoundWord
.1893	20 d8 18	jsr $18d8			jsr 	AdvanceToNext 				; advance to next entry in the line.
.1896	80 df		bra $1877			bra 	_DecodeLoop 				; and go round again
.1898					_DecodeEOL:
.1898	a9 00		lda #$00			lda 	#0
.189a	92 0a		sta ($0a)			sta 	(bufPtr)
.189c	7a		ply				ply 								; restore registers and exit
.189d	fa		plx				plx
.189e	68		pla				pla
.189f	60		rts				rts
.18a0					IdentifyCodeWord:
.18a0	5a		phy				phy 								; save current position on the stack.
.18a1	a9 8d		lda #$8d			lda 	#(Dictionary) & $FF
.18a3	85 0c		sta $0c				sta 	0+(matchPtr)
.18a5	a9 25		lda #$25			lda 	#(Dictionary) >> 8
.18a7	85 0d		sta $0d				sta 	1+(matchPtr)
.18a9					_DecodeIdentify:
.18a9	a0 02		ldy #$02			ldy 	#2 							; have we found a match ?
.18ab	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.18ad	c5 10		cmp $10				cmp 	temp1
.18af	d0 07		bne $18b8			bne 	_DecodeIdNext
.18b1	c8		iny				iny
.18b2	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.18b4	c5 11		cmp $11				cmp 	temp1+1
.18b6	f0 1e		beq $18d6			beq 	_DecodeIdFound
.18b8					_DecodeIdNext:
.18b8	18		clc				clc
.18b9	b2 0c		lda ($0c)			lda 	(matchPtr)
.18bb	f0 0a		beq $18c7			beq 	_DecodeIdIssue
.18bd	65 0c		adc $0c				adc 	matchPtr
.18bf	85 0c		sta $0c				sta 	matchPtr
.18c1	90 e6		bcc $18a9			bcc 	_DecodeIdentify
.18c3	e6 0d		inc $0d				inc 	matchPtr+1
.18c5	80 e2		bra $18a9			bra 	_DecodeIdentify
.18c7					_DecodeIdIssue:
.18c7	20 4f 24	jsr $244f			jsr 	ErrorHandler
>18ca	42 41 44 20 50 52 4f 47				.text 	"BAD PROGRAM",0
>18d2	52 41 4d 00
.18d6					_DecodeIdFound:
.18d6	7a		ply				ply 								; restore position.
.18d7	60		rts				rts
.18d8					AdvanceToNext:
.18d8	5a		phy				phy 								; get the parameter count from bits 0-1 of the type byte
.18d9	a0 01		ldy #$01			ldy 	#1
.18db	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.18dd	29 03		and #$03			and 	#3 							; bits 0-1.
.18df	7a		ply				ply
.18e0	c9 03		cmp #$03			cmp 	#3 							; is it n-bytes e.g. specified by the next byte
.18e2	d0 02		bne $18e6			bne 	_ATN012
.18e4	b1 08		lda ($08),y			lda 	(srcPtr),y 					; if so, use that byte as the overall length.
.18e6					_ATN012:
.18e6	85 12		sta $12				sta 	temp2 						; now add that to Y
.18e8	98		tya				tya
.18e9	18		clc				clc
.18ea	65 12		adc $12				adc 	temp2
.18ec	a8		tay				tay
.18ed	60		rts				rts
.18ee					DecodeFoundWord:
.18ee	5a		phy				phy 								; save current position
.18ef	84 12		sty $12				sty		temp2 						; put it in temp2 as well.
.18f1	a0 01		ldy #$01			ldy 	#1 							; get the type byte
.18f3	b1 0c		lda ($0c),y			lda 	(matchPtr),y 				; is there a special decoder check (bit 4 set) ?
.18f5	29 10		and #$10			and 	#$10
.18f7	d0 0e		bne $1907			bne 	_DFWSpecialDecoder
.18f9	b1 0c		lda ($0c),y			lda 	(matchPtr),y 				; reget it.
.18fb	30 08		bmi $1905			bmi 	_DFWExit 					; if hidden word (bit 7 set)
.18fd	a9 06		lda #$06			lda 	#CTH_Keyword				; output a space to the buffer
.18ff	20 43 19	jsr $1943			jsr 	DecodeWriteBuffer
.1902	20 20 19	jsr $1920			jsr 	DecodeCurrentWord 			; expand that.
.1905					_DFWExit:
.1905	7a		ply				ply 								; restore current position
.1906	60		rts				rts
.1907					_DFWSpecialDecoder:
.1907	a0 04		ldy #$04			ldy 	#4 							; the decode word address is at offset 4,5
.1909	b1 0c		lda ($0c),y			lda 	(matchPtr),y 				; copy this into temp2
.190b	85 12		sta $12				sta 	temp2
.190d	c8		iny				iny
.190e	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.1910	85 13		sta $13				sta 	temp2+1
.1912	7a		ply				ply 	 							; restore current position into Y
.1913	48		pha				pha 								; save registers
.1914	da		phx				phx
.1915	5a		phy				phy
.1916	20 1d 19	jsr $191d			jsr 	_DFWCallDecoder				; call the decoder routine
.1919	7a		ply				ply 								; restore registers and exit
.191a	fa		plx				plx
.191b	68		pla				pla
.191c	60		rts				rts
.191d					_DFWCallDecoder:
.191d	6c 12 00	jmp ($0012)			jmp 	(temp2)
.1920					DecodeCurrentWord:
.1920	5a		phy				phy
.1921	a0 01		ldy #$01			ldy 	#1 							; read type byte
.1923	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.1925	a0 04		ldy #$04			ldy 	#4 							; original offset
.1927	4a		lsr a				lsr 	a 							; encoder/decoder bits in 0-1
.1928	4a		lsr a				lsr 	a 							; add 2 to Y for each encoder/decoder
.1929	4a		lsr a				lsr 	a 							; bit set.
.192a	4a		lsr a				lsr 	a
.192b	4a		lsr a				lsr 	a 							; decoder bit
.192c	90 02		bcc $1930			bcc 	_DWBNoDec
.192e	c8		iny				iny
.192f	c8		iny				iny
.1930					_DWBNoDec:
.1930	4a		lsr a				lsr 	a
.1931	90 02		bcc $1935			bcc 	_DWBNoEnc
.1933	c8		iny				iny
.1934	c8		iny				iny
.1935					_DWBNoEnc:
.1935					_DWBWordOut:
.1935	b1 0c		lda ($0c),y			lda 	(matchPtr),y 				; output until bit 7 set.
.1937	48		pha				pha
.1938	29 7f		and #$7f			and 	#$7F
.193a	20 43 19	jsr $1943			jsr		DecodeWriteBuffer
.193d	c8		iny				iny
.193e	68		pla				pla
.193f	10 f4		bpl $1935			bpl 	_DWBWordOut
.1941	7a		ply				ply 								; restore Y and exit
.1942	60		rts				rts
.1943					DecodeWriteBuffer:
.1943	92 0a		sta ($0a)			sta 	(bufPtr)
.1945	e6 0a		inc $0a				inc 	bufPtr
.1947	d0 02		bne $194b			bne 	_DWBNoCarry
.1949	e6 0b		inc $0b				inc 	bufPtr+1
.194b					_DWBNoCarry:
.194b	60		rts				rts
.194c					DecodeOutputData:
.194c	48		pha				pha
.194d	da		phx				phx
.194e	5a		phy				phy
.194f	b1 08		lda ($08),y			lda 	(srcPtr),y 					; length + 1
.1951	aa		tax				tax
.1952					_DODLoop:
.1952	ca		dex				dex 								; done it all ?
.1953	f0 0c		beq $1961			beq		_DODExit
.1955	c8		iny				iny 								; output next character
.1956	b1 08		lda ($08),y			lda 	(srcPtr),y
.1958	29 7f		and #$7f			and 	#$7F
.195a	f0 f6		beq $1952			beq 	_DODLoop 					; don't print NULL
.195c	20 43 19	jsr $1943			jsr 	DecodeWriteBuffer
.195f	80 f1		bra $1952			bra 	_DODLoop
.1961					_DODExit:
.1961	7a		ply				ply
.1962	fa		plx				plx
.1963	68		pla				pla
.1964	60		rts				rts
.1965					DecodeYAToBuffer:
.1965	da		phx				phx
.1966	5a		phy				phy
.1967	48		pha				pha
.1968	a5 0a		lda $0a				lda 	bufPtr 						; copy bufPtr to temp2
.196a	85 12		sta $12				sta 	temp2
.196c	a5 0b		lda $0b				lda 	bufPtr+1
.196e	85 13		sta $13				sta 	temp2+1
.1970	68		pla				pla
.1971	20 c3 1d	jsr $1dc3			jsr 	ConvertToStringMain 		; convert YA to string there
.1974	aa		tax				tax 								; chars output to X
.1975	18		clc				clc
.1976	65 0a		adc $0a				adc 	bufPtr 						; add to buffer pointer
.1978	85 0a		sta $0a				sta 	bufPtr
.197a	90 02		bcc $197e			bcc 	_DYABNoCarry
.197c	e6 0b		inc $0b				inc 	bufPtr+1
.197e					_DYABNoCarry:
.197e	8a		txa				txa 								; count in A
.197f	7a		ply				ply									; restore and exit.
.1980	fa		plx				plx
.1981	60		rts				rts

;******  Return to file: files.asm


;******  Processing file: words/system/edit.src

.1982					EditProgram:
.1982	20 02 1a	jsr $1a02			jsr 	EDFindLine					; find line address -> temp1
.1985	90 0f		bcc $1996			bcc 	_EPNotFound 				; if missing don't delete it.
.1987	a5 10		lda $10				lda 	temp1 						; save line address
.1989	48		pha				pha
.198a	a5 11		lda $11				lda 	temp1+1
.198c	48		pha				pha
.198d	20 a7 19	jsr $19a7			jsr 	EDDeleteLine 				; delete the line
.1990	68		pla				pla 								; restore line address
.1991	85 11		sta $11				sta 	temp1+1
.1993	68		pla				pla
.1994	85 10		sta $10				sta 	temp1
.1996					_EPNotFound:
.1996	ad 10 09	lda $0910			lda 	encodeBuffer 				; is there anything in the line.
.1999	c9 05		cmp #$05			cmp 	#5 							; <offset> <line#> <next line>
.199b	f0 06		beq $19a3			beq 	_EPNoInsert
.199d	20 ca 19	jsr $19ca			jsr 	EDInsertLine 				; insert line back in.
.19a0	20 2f 18	jsr $182f			jsr 	CheckMemory 				; low on memory ?
.19a3					_EPNoInsert:
.19a3	20 f7 17	jsr $17f7			jsr 	ClearVariableSpace
.19a6	60		rts				rts
.19a7					EDDeleteLine:
.19a7	20 f7 17	jsr $17f7			jsr 	ClearVariableSpace
.19aa	a0 00		ldy #$00			ldy 	#0 							; this is the offset to copy down.
.19ac	a2 00		ldx #$00			ldx 	#0
.19ae	b1 10		lda ($10),y			lda 	(temp1),y
.19b0	a8		tay				tay 								; put in Y
.19b1					_EDDelLoop:
.19b1	b1 10		lda ($10),y			lda 	(temp1),y 					; get it
.19b3	81 10		sta ($10,x)			sta 	(temp1,x) 					; write it.
.19b5	a5 10		lda $10				lda 	temp1 						; check if pointer has reached the end of
.19b7	c5 0e		cmp $0e				cmp		nextFreeMem 				; low memory. We will have copied down an
.19b9	d0 06		bne $19c1			bne 	_EDDelNext 					; extra pile of stuff - technically should
.19bb	a5 11		lda $11				lda 	temp1+1 					; check the upper value (e.g. temp1+y)
.19bd	c5 0f		cmp $0f				cmp 	nextFreeMem+1				; doesn't really matter.
.19bf	f0 08		beq $19c9			beq		_EDDelExit
.19c1					_EDDelNext:
.19c1	e6 10		inc $10				inc 	temp1 						; go to next byte.
.19c3	d0 ec		bne $19b1			bne 	_EDDelLoop
.19c5	e6 11		inc $11				inc 	temp1+1
.19c7	80 e8		bra $19b1			bra 	_EDDelLoop
.19c9					_EDDelExit:
.19c9	60		rts				rts
.19ca					EDInsertLine:
.19ca	20 f7 17	jsr $17f7			jsr 	ClearVariableSpace
.19cd	a5 0e		lda $0e				lda 	nextFreeMem 				; copy high memory to temp3
.19cf	85 14		sta $14				sta 	temp3
.19d1	a5 0f		lda $0f				lda 	nextFreeMem+1
.19d3	85 15		sta $15				sta 	temp3+1
.19d5	ac 10 09	ldy $0910			ldy 	encodeBuffer 				; space to move it to in Y
.19d8	a2 00		ldx #$00			ldx 	#0
.19da					_EDInsLoop:
.19da	a1 14		lda ($14,x)			lda 	(temp3,x)					; copy it up
.19dc	91 14		sta ($14),y			sta 	(temp3),y
.19de	a5 14		lda $14				lda 	temp3 						; reached the insert point (temp1)
.19e0	c5 10		cmp $10				cmp 	temp1
.19e2	d0 06		bne $19ea			bne 	_EDINextShift
.19e4	a5 15		lda $15				lda 	temp3+1
.19e6	c5 11		cmp $11				cmp 	temp1+1
.19e8	f0 0a		beq $19f4			beq 	_EDIShiftOver
.19ea					_EDINextShift:
.19ea	a5 14		lda $14				lda 	temp3 						; decrement the copy pointer.
.19ec	d0 02		bne $19f0			bne 	_EDINoBorrow
.19ee	c6 15		dec $15				dec 	temp3+1
.19f0					_EDINoBorrow:
.19f0	c6 14		dec $14				dec 	temp3
.19f2	80 e6		bra $19da			bra 	_EDInsLoop
.19f4					_EDIShiftOver:
.19f4	a0 00		ldy #$00			ldy 	#0
.19f6					_EDICopyCode:
.19f6	b9 10 09	lda $0910,y			lda 	encodeBuffer,y				; read from the current line
.19f9	91 10		sta ($10),y			sta 	(temp1),y 					; write out
.19fb	c8		iny				iny 								; bump pointers
.19fc	cc 10 09	cpy $0910			cpy 	encodeBuffer 				; done the whole lot ?
.19ff	d0 f5		bne $19f6			bne 	_EDICopyCode
.1a01	60		rts				rts
.1a02					EDFindLine:
.1a02	a9 00		lda #$00			lda 	#(programMemory) & $FF
.1a04	85 10		sta $10				sta 	0+(temp1)
.1a06	a9 40		lda #$40			lda 	#(programMemory) >> 8
.1a08	85 11		sta $11				sta 	1+(temp1)
.1a0a					_EDFLLoop:
.1a0a	b2 10		lda ($10)			lda 	(temp1) 					; check offset
.1a0c	f0 24		beq $1a32			beq 	_EDFLFail 					; then obviously that's the end ;-) (great comment !)
.1a0e	a0 01		ldy #$01			ldy 	#1							; look at line #
.1a10	38		sec				sec
.1a11	ad 11 09	lda $0911			lda 	encodeBuffer+1				; subtract the current from the target
.1a14	f1 10		sbc ($10),y			sbc 	(temp1),y 					; so if searching for 100 and this one is 90,
.1a16	aa		tax				tax	 								; this will return 10.
.1a17	ad 12 09	lda $0912			lda 	encodeBuffer+2
.1a1a	c8		iny				iny
.1a1b	f1 10		sbc ($10),y			sbc 	(temp1),y
.1a1d	90 13		bcc $1a32			bcc 	_EDFLFail					; if target < current then failed.
.1a1f	d0 04		bne $1a25			bne 	_EDFLNext 					; if non-zero then goto next
.1a21	e0 00		cpx #$00			cpx 	#0 							; same for the LSB - zero if match found.
.1a23	f0 0f		beq $1a34			beq 	_EDFLFound
.1a25					_EDFLNext:
.1a25	18		clc				clc
.1a26	a5 10		lda $10				lda 	temp1
.1a28	72 10		adc ($10)			adc 	(temp1)
.1a2a	85 10		sta $10				sta 	temp1
.1a2c	90 02		bcc $1a30			bcc 	_NoCarryAdv
.1a2e	e6 11		inc $11				inc 	temp1+1
.1a30					_NoCarryAdv:
.1a30	80 d8		bra $1a0a			bra 	_EDFLLoop
.1a32					_EDFLFail:
.1a32	18		clc				clc
.1a33	60		rts				rts
.1a34					_EDFLFound:
.1a34	38		sec				sec
.1a35	60		rts				rts

;******  Return to file: files.asm


;******  Processing file: words/system/list.src

.1a36					ListCode:
.1a36	64 1e		stz $1e				stz 	ListLowest 					; zero lowest line#
.1a38	64 1f		stz $1f				stz 	ListLowest+1
.1a3a	a9 18		lda #$18			lda 	#24 						; show max 24 after lowest line
.1a3c	85 1d		sta $1d				sta 	ListCount
.1a3e	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.1a40	85 18		sta $18				sta 	0+(listPtr)
.1a42	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.1a44	85 19		sta $19				sta 	1+(listPtr)
.1a46	86 10		stx $10				stx 	temp1						; S->A
.1a48	ba		tsx				tsx
.1a49	8a		txa				txa
.1a4a	a6 10		ldx $10				ldx 	temp1
.1a4c	c9 80		cmp #$80			cmp 	#NumberStackBase
.1a4e	f0 0e		beq $1a5e			beq 	_LCLoop
.1a50	a5 06		lda $06				lda 	TOS 						; copy TOS to lowest
.1a52	85 1e		sta $1e				sta 	ListLowest
.1a54	a5 07		lda $07				lda 	TOS+1
.1a56	85 1f		sta $1f				sta 	ListLowest+1
.1a58	68		pla				pla
.1a59	85 07		sta $07				sta 	TOS+1
.1a5b	68		pla				pla
.1a5c	85 06		sta $06				sta 	TOS
.1a5e					_LCLoop:
.1a5e	b2 18		lda ($18)			lda 	(listPtr)					; reached end ?
.1a60	f0 4c		beq $1aae			beq 	_LCExit
.1a62	a0 01		ldy #$01			ldy 	#1							; >= list lowest
.1a64	b1 18		lda ($18),y			lda 	(listPtr),y
.1a66	c5 1e		cmp $1e				cmp 	ListLowest
.1a68	c8		iny				iny
.1a69	b1 18		lda ($18),y			lda 	(listPtr),y
.1a6b	e5 1f		sbc $1f				sbc 	ListLowest+1
.1a6d	90 32		bcc $1aa1			bcc 	_LCNext
.1a6f	a9 10		lda #$10			lda 	#(textBuffer) & $FF
.1a71	85 0a		sta $0a				sta 	0+(bufPtr)
.1a73	a9 08		lda #$08			lda 	#(textBuffer) >> 8
.1a75	85 0b		sta $0b				sta 	1+(bufPtr)
.1a77	a5 18		lda $18				lda 	listPtr 					; output the line.
.1a79	a4 19		ldy $19				ldy 	listPtr+1
.1a7b	38		sec				sec
.1a7c	20 51 18	jsr $1851			jsr 	DecodeLineIntoBufPtr
.1a7f	a9 02		lda #$02			lda 	#CTH_LineNo
.1a81	20 bb 24	jsr $24bb			jsr 	ExternColour
.1a84	a0 ff		ldy #$ff			ldy 	#255
.1a86					_LCLoop2:
.1a86	c8		iny				iny
.1a87	b9 10 08	lda $0810,y			lda 	textBuffer,y
.1a8a	f0 0e		beq $1a9a			beq 	_LCEnd
.1a8c	c9 20		cmp #$20			cmp 	#32
.1a8e	b0 05		bcs $1a95			bcs 	_LCPrint
.1a90	20 bb 24	jsr $24bb			jsr 	ExternColour
.1a93	a9 20		lda #$20			lda 	#32
.1a95					_LCPrint:
.1a95	20 af 24	jsr $24af			jsr 	ExternPrint
.1a98	80 ec		bra $1a86			bra 	_LCLoop2
.1a9a	a9 0d		lda #$0d	_LCEnd:	lda 	#13 						; new line
.1a9c	20 af 24	jsr $24af			jsr 	ExternPrint
.1a9f	c6 1d		dec $1d				dec 	ListCount					; done all the lines allowed
.1aa1					_LCNext:
.1aa1	18		clc				clc
.1aa2	a5 18		lda $18				lda 	listPtr
.1aa4	72 18		adc ($18)			adc 	(listPtr)
.1aa6	85 18		sta $18				sta 	listPtr
.1aa8	90 02		bcc $1aac			bcc 	_NoCarryAdv
.1aaa	e6 19		inc $19				inc 	listPtr+1
.1aac					_NoCarryAdv:
.1aac	80 b0		bra $1a5e			bra 	_LCLoop 					; go round again.
.1aae					_LCExit:
.1aae	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: files.asm


;******  Processing file: words/system/miscellany.src

.1ab1					RunProgram:
.1ab1	86 10		stx $10				stx 	temp1
.1ab3	a2 80		ldx #$80			ldx 	#NumberStackBase
.1ab5	9a		txs				txs
.1ab6	a6 10		ldx $10				ldx 	temp1
.1ab8	20 f7 17	jsr $17f7			jsr 	ClearVariableSpace 			; clear variables etc.
.1abb	a2 00		ldx #$00			ldx		#ProgramMemory & $FF		; boot address
.1abd	a0 40		ldy #$40			ldy 	#ProgramMemory >>8
.1abf	20 03 10	jsr $1003			jsr 	InitialiseCoreCode 			; initialise the NEXT routine at $00
.1ac2	4c 00 00	jmp $0000			jmp 	NextCode
.1ac5					Call6502:
.1ac5	a5 06		lda $06				lda 	TOS 						; copy call address
.1ac7	85 10		sta $10				sta 	temp1
.1ac9	a5 07		lda $07				lda 	TOS+1
.1acb	85 11		sta $11				sta 	temp1+1
.1acd	68		pla				pla
.1ace	85 07		sta $07				sta 	TOS+1
.1ad0	68		pla				pla
.1ad1	85 06		sta $06				sta 	TOS
.1ad3	20 d9 1a	jsr $1ad9			jsr 	_CallTemp1 					; call it
.1ad6	4c 00 00	jmp $0000			jmp 	NextCode
.1ad9					_CallTemp1:
.1ad9	6c 10 00	jmp ($0010)			jmp 	(temp1)
.1adc					AssertCode:
.1adc	a5 06		lda $06				lda 	TOS 						; TOS = 0
.1ade	05 07		ora $07				ora 	TOS+1
.1ae0	f0 09		beq $1aeb			beq 	_ASFail 					; if zero fail
.1ae2	68		pla				pla
.1ae3	85 07		sta $07				sta 	TOS+1
.1ae5	68		pla				pla
.1ae6	85 06		sta $06				sta 	TOS
.1ae8	4c 00 00	jmp $0000			jmp 	NextCode
.1aeb					_ASFail:
.1aeb	20 4f 24	jsr $244f			jsr 	ErrorHandler
>1aee	41 53 53 45 52 54 00				.text 	"ASSERT",0
.1af5					StopCode:
.1af5	20 4f 24	jsr $244f			jsr 	ErrorHandler
>1af8	53 54 4f 50 00					.text 	"STOP",0
.1afd					EndProgram:
.1afd	4c d0 23	jmp $23d0			jmp 	WarmStart
.1b00					VlistCode:
.1b00	a9 8d		lda #$8d			lda 	#(Dictionary) & $FF
.1b02	85 10		sta $10				sta 	0+(temp1)
.1b04	a9 25		lda #$25			lda 	#(Dictionary) >> 8
.1b06	85 11		sta $11				sta 	1+(temp1)
.1b08	a0 01		ldy #$01	_VLLoop:ldy 	#1							; type byte
.1b0a	b1 10		lda ($10),y			lda 	(temp1),y
.1b0c	a0 04		ldy #$04			ldy 	#4 							; Y = 4
.1b0e	4a		lsr a				lsr 	a 							; shift bits 4 and 5 to 0,1
.1b0f	4a		lsr a				lsr 	a
.1b10	4a		lsr a				lsr		a
.1b11	4a		lsr a				lsr 	a
.1b12	4a		lsr a				lsr 	a 							; add those bits in
.1b13	90 02		bcc $1b17			bcc 	_VLNoDec
.1b15	c8		iny				iny
.1b16	c8		iny				iny
.1b17					_VLNoDec:
.1b17	4a		lsr a				lsr 	a
.1b18	90 02		bcc $1b1c			bcc 	_VLNoEnc
.1b1a	c8		iny				iny
.1b1b	c8		iny				iny
.1b1c					_VLNoEnc:
.1b1c	b1 10		lda ($10),y			lda 	(temp1),y 					; remove $$ words
.1b1e	c9 24		cmp #$24			cmp 	#"$"
.1b20	d0 06		bne $1b28			bne 	_VLPrint
.1b22	c8		iny				iny
.1b23	51 10		eor ($10),y			eor 	(temp1),y
.1b25	f0 13		beq $1b3a			beq 	_VLNext
.1b27	88		dey				dey
.1b28					_VLPrint:
.1b28	b1 10		lda ($10),y			lda 	(temp1),y
.1b2a	48		pha				pha
.1b2b	c8		iny				iny
.1b2c	29 7f		and #$7f			and 	#$7F
.1b2e	20 af 24	jsr $24af			jsr 	ExternPrint
.1b31	68		pla				pla
.1b32	0a		asl a				asl 	a
.1b33	90 f3		bcc $1b28			bcc 	_VLPrint
.1b35	a9 20		lda #$20			lda 	#32
.1b37	20 af 24	jsr $24af			jsr 	ExternPrint
.1b3a					_VLNext:
.1b3a	18		clc				clc 								; go to next
.1b3b	b2 10		lda ($10)			lda 	(temp1)
.1b3d	65 10		adc $10				adc 	temp1
.1b3f	85 10		sta $10				sta 	temp1
.1b41	90 02		bcc $1b45			bcc 	_VLNoCarry
.1b43	e6 11		inc $11				inc 	temp1+1
.1b45					_VLNoCarry:
.1b45	b2 10		lda ($10)			lda 	(temp1)
.1b47	d0 bf		bne $1b08			bne 	_VLLoop
.1b49	a9 0d		lda #$0d			lda 	#13
.1b4b	20 af 24	jsr $24af			jsr 	ExternPrint
.1b4e	4c 00 00	jmp $0000			jmp 	NextCode
.1b51					DumpStack:
.1b51	a9 5b		lda #$5b			lda		#"["
.1b53	20 af 24	jsr $24af			jsr 	ExternPrint
.1b56	86 10		stx $10				stx 	temp1 						; X -> A
.1b58	ba		tsx				tsx
.1b59	8a		txa				txa
.1b5a	a6 10		ldx $10				ldx 	temp1
.1b5c	c9 80		cmp #$80			cmp 	#NumberStackBase 			; out of range, exit
.1b5e	f0 2f		beq $1b8f			beq 	_DSExit
.1b60	48		pha				pha 								; save it
.1b61	a9 07		lda #$07			lda 	#COL_WHITE
.1b63	20 bb 24	jsr $24bb			jsr 	ExternColour
.1b66	a5 06		lda $06				lda 	TOS 						; print TOS then stack values backwards
.1b68	a4 07		ldy $07				ldy 	TOS+1
.1b6a	38		sec				sec 								; print unsigned.
.1b6b	20 9d 1d	jsr $1d9d			jsr 	PrintYA
.1b6e	a9 06		lda #$06			lda 	#COL_CYAN
.1b70	20 bb 24	jsr $24bb			jsr 	ExternColour
.1b73	7a		ply				ply 								; restore offset
.1b74					_DSLoop:
.1b74	c0 7e		cpy #$7e			cpy 	#NumberStackBase-2 			; till done whole stack.
.1b76	f0 17		beq $1b8f			beq 	_DSExit
.1b78	a9 20		lda #$20			lda 	#" " 						; space
.1b7a	20 af 24	jsr $24af			jsr 	ExternPrint
.1b7d	5a		phy				phy 								; save pos
.1b7e	b9 01 01	lda $0101,y			lda 	$0101,y 					; read stack item
.1b81	48		pha				pha
.1b82	b9 02 01	lda $0102,y			lda 	$0102,y
.1b85	7a		ply				ply
.1b86	38		sec				sec
.1b87	20 9d 1d	jsr $1d9d			jsr 	PrintYA 					; print it
.1b8a	7a		ply				ply 								; restore and advance pos
.1b8b	c8		iny				iny
.1b8c	c8		iny				iny
.1b8d	80 e5		bra $1b74			bra 	_DSLoop
.1b8f					_DSExit:
.1b8f	a9 5d		lda #$5d			lda		#"]"
.1b91	20 af 24	jsr $24af			jsr 	ExternPrint
.1b94	a9 0d		lda #$0d			lda 	#13
.1b96	20 af 24	jsr $24af			jsr 	ExternPrint
.1b99	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: files.asm


;******  Processing file: words/system/old.src

.1b9c					OldCode:
.1b9c	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.1b9e	85 08		sta $08				sta 	0+(srcPtr)
.1ba0	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.1ba2	85 09		sta $09				sta 	1+(srcPtr)
.1ba4	a0 03		ldy #$03			ldy 	#3 							; start after line# / offset
.1ba6					_OldLoop:
.1ba6	b1 08		lda ($08),y			lda 	(srcPtr),y 					; copy the current character to temp1
.1ba8	85 10		sta $10				sta 	temp1 						; must be an execution address.
.1baa	c8		iny				iny
.1bab	b1 08		lda ($08),y			lda 	(srcPtr),y
.1bad	85 11		sta $11				sta 	temp1+1
.1baf	c8		iny				iny
.1bb0	a5 10		lda $10				lda 	temp1 						; have we reached the end ?
.1bb2	c9 8a		cmp #$8a			cmp 	#NextLine & $FF
.1bb4	d0 06		bne $1bbc			bne 	_OldNotEOL
.1bb6	a5 11		lda $11				lda 	temp1+1
.1bb8	c9 1c		cmp #$1c			cmp 	#NextLine >> 8
.1bba	f0 08		beq $1bc4			beq 	_OldEOL
.1bbc					_OldNotEOL:
.1bbc	20 a0 18	jsr $18a0			jsr 	IdentifyCodeWord			; what is it ?
.1bbf	20 d8 18	jsr $18d8			jsr 	AdvanceToNext 				; advance to next entry in the line.
.1bc2	80 e2		bra $1ba6			bra	 	_OldLoop
.1bc4					_OldEOL:
.1bc4	8c 00 40	sty $4000			sty 	ProgramMemory 				; Y is the offset.
.1bc7	20 f7 17	jsr $17f7			jsr 	ClearVariableSpace 			; clear variables, reset pointers
.1bca	4c c9 23	jmp $23c9			jmp 	WarmStartBlankStack

;******  Return to file: files.asm


;******  Processing file: words/system/saveload.src

.1bcd					System_Save:
.1bcd	20 f7 17	jsr $17f7			jsr 	ClearVariableSpace  		; make sure start/end are right
.1bd0	20 4f 1c	jsr $1c4f			jsr 	ExtendWithDictionary 		; attach the dictionary addresses.
.1bd3	20 fb 1b	jsr $1bfb			jsr 	SLGetFileName 				; get filename -> temp3
.1bd6	a5 0e		lda $0e				lda 	nextFreeMem 				; end address
.1bd8	85 10		sta $10				sta 	temp1
.1bda	a5 0f		lda $0f				lda 	nextFreeMem+1
.1bdc	85 11		sta $11				sta 	temp1+1
.1bde	a9 00		lda #$00			lda 	#ProgramMemory & $FF 		; program start to YA
.1be0	a0 40		ldy #$40			ldy 	#ProgramMemory >> 8
.1be2	20 03 25	jsr $2503			jsr 	ExternSave
.1be5	20 f7 17	jsr $17f7			jsr 	ClearVariableSpace  		; make sure start/end are right
.1be8	4c c9 23	jmp $23c9			jmp 	WarmStartBlankStack
.1beb					System_Load:
.1beb	20 fb 1b	jsr $1bfb			jsr 	SLGetFileName 				; get filename -> temp3
.1bee	a9 00		lda #$00			lda 	#ProgramMemory & $FF 		; program start to YA
.1bf0	a0 40		ldy #$40			ldy 	#ProgramMemory >> 8
.1bf2	20 39 25	jsr $2539			jsr 	ExternLoad
.1bf5	20 f7 17	jsr $17f7			jsr 	ClearVariableSpace 			; reset everything.
.1bf8	4c c9 23	jmp $23c9			jmp 	WarmStartBlankStack
.1bfb					SLGetFileName:
.1bfb	ba		tsx				tsx
.1bfc	e0 80		cpx #$80			cpx 	#NumberStackBase
.1bfe	f0 3a		beq $1c3a			beq 	_SLFNFail
.1c00	a9 10		lda #$10			lda 	#textBuffer & $FF 			; f/n in input buffer.
.1c02	85 14		sta $14				sta 	temp3
.1c04	a9 08		lda #$08			lda 	#textBuffer >> 8
.1c06	85 15		sta $15				sta 	temp3+1
.1c08	a0 00		ldy #$00			ldy 	#0
.1c0a	b1 06		lda ($06),y	_SLCopy:lda 	(TOS),y
.1c0c	91 14		sta ($14),y			sta 	(temp3),y
.1c0e	c8		iny				iny
.1c0f	c9 00		cmp #$00			cmp		#0
.1c11	d0 f7		bne $1c0a			bne 	_SLCopy
.1c13	88		dey				dey
.1c14	a2 03		ldx #$03			ldx 	#3 							; check if it ends in .RPL
.1c16					_SLCheckEnd:
.1c16	88		dey				dey
.1c17	bd 4a 1c	lda $1c4a,x			lda 	_SLFNExtension,x
.1c1a	d1 14		cmp ($14),y			cmp 	(temp3),y
.1c1c	d0 05		bne $1c23			bne 	_SLNoExtension
.1c1e	ca		dex				dex
.1c1f	10 f5		bpl $1c16			bpl 	_SLCheckEnd
.1c21	80 16		bra $1c39			bra 	_SLExit
.1c23					_SLNoExtension:
.1c23	a0 ff		ldy #$ff			ldy 	#255						; add the extension.
.1c25					_SLFindend:
.1c25	c8		iny				iny
.1c26	b9 10 08	lda $0810,y			lda 	textBuffer,y
.1c29	d0 fa		bne $1c25			bne 	_SLFindend
.1c2b	a2 00		ldx #$00			ldx 	#0
.1c2d					_SLAppend:
.1c2d	bd 4a 1c	lda $1c4a,x			lda 	_SLFNExtension,x
.1c30	99 10 08	sta $0810,y			sta 	textBuffer,y
.1c33	e8		inx				inx
.1c34	c8		iny				iny
.1c35	c9 00		cmp #$00			cmp 	#0
.1c37	d0 f4		bne $1c2d			bne 	_SLAppend
.1c39					_SLExit:
.1c39	60		rts				rts
.1c3a					_SLFNFail:
.1c3a	20 4f 24	jsr $244f			jsr 	ErrorHandler
>1c3d	42 41 44 20 46 49 4c 45				.text 	"BAD FILENAME",0
>1c45	4e 41 4d 45 00
.1c4a					_SLFNExtension:
>1c4a	2e 52 50 4c 00					.text 	".RPL",0
.1c4f					ExtendWithDictionary:
.1c4f	20 78 1c	jsr $1c78			jsr 	_EWDMarker 					; 8 bytes after the final offset write a marker
.1c52	a9 8d		lda #$8d			lda 	#(Dictionary) & $FF
.1c54	85 10		sta $10				sta 	0+(temp1)
.1c56	a9 25		lda #$25			lda 	#(Dictionary) >> 8
.1c58	85 11		sta $11				sta 	1+(temp1)
.1c5a					_EWDLoop:
.1c5a	b2 10		lda ($10)			lda 	(temp1)						; end
.1c5c	f0 1a		beq $1c78			beq 	_EWDMarker
.1c5e	a0 02		ldy #$02			ldy 	#2 							; output the address
.1c60	b1 10		lda ($10),y			lda 	(temp1),y
.1c62	20 81 1c	jsr $1c81			jsr 	_EWDWrite
.1c65	c8		iny				iny
.1c66	b1 10		lda ($10),y			lda 	(temp1),y
.1c68	20 81 1c	jsr $1c81			jsr 	_EWDWrite
.1c6b	18		clc				clc 								; next entry.
.1c6c	a5 10		lda $10				lda 	temp1
.1c6e	72 10		adc ($10)			adc 	(temp1)
.1c70	85 10		sta $10				sta 	temp1
.1c72	90 e6		bcc $1c5a			bcc 	_EWDLoop
.1c74	e6 11		inc $11				inc 	temp1+1
.1c76	80 e2		bra $1c5a			bra 	_EWDLoop
.1c78					_EWDMarker:
.1c78	a9 ff		lda #$ff			lda 	#$FF
.1c7a	20 81 1c	jsr $1c81			jsr 	_EWDWrite
.1c7d	20 81 1c	jsr $1c81			jsr 	_EWDWrite
.1c80	60		rts				rts
.1c81					_EWDWrite:
.1c81	92 0e		sta ($0e)			sta 	(nextFreeMem)
.1c83	e6 0e		inc $0e				inc 	nextFreeMem
.1c85	d0 02		bne $1c89			bne 	_EWDExit
.1c87	e6 0f		inc $0f				inc 	nextFreeMem+1
.1c89					_EWDExit:
.1c89	60		rts				rts

;******  Return to file: files.asm


;******  Processing file: words/system/skipper.src

.1c8a					NextLine:
.1c8a	18		clc				clc
.1c8b	a5 03		lda $03				lda 	IP
.1c8d	72 03		adc ($03)			adc 	(IP)
.1c8f	85 03		sta $03				sta 	IP
.1c91	90 02		bcc $1c95			bcc 	_NoCarryAdv
.1c93	e6 04		inc $04				inc 	IP+1
.1c95					_NoCarryAdv:
.1c95	b2 03		lda ($03)			lda 	(IP)						; is there any following program ?
.1c97	f0 05		beq $1c9e			beq 	_NLGoEnd
.1c99	a2 01		ldx #$01			ldx 	#1 							; start 3 in (-2 for Next)
.1c9b	4c 00 00	jmp $0000			jmp 	NextCode
.1c9e					_NLGoEnd:
.1c9e	4c d0 23	jmp $23d0			jmp 	WarmStart
.1ca1					SkipComment:
.1ca1	e8		inx				inx									; (IP),X points to the length.
.1ca2	e8		inx				inx
.1ca3	8a		txa				txa
.1ca4	a8		tay				tay 								; put into Y
.1ca5	18		clc				clc
.1ca6	71 03		adc ($03),y			adc 	(IP),y 						; add the length to X
.1ca8	aa		tax				tax 								; put back in X
.1ca9	ca		dex				dex
.1caa	ca		dex				dex
.1cab	4c 00 00	jmp $0000			jmp 	NextCode
.1cae					CommentDecoder:
.1cae	a9 06		lda #$06			lda 	#CTH_Keyword
.1cb0	20 43 19	jsr $1943			jsr 	DecodeWriteBuffer
.1cb3	a9 27		lda #$27			lda 	#"'"
.1cb5	20 43 19	jsr $1943			jsr 	DecodeWriteBuffer
.1cb8	b1 08		lda ($08),y			lda 	(srcPtr),y 					; check if there is no data
.1cba	c9 01		cmp #$01			cmp 	#1
.1cbc	f0 0d		beq $1ccb			beq 	_CDEmpty 					; if so print nothing.
.1cbe	a9 0b		lda #$0b			lda 	#CTH_Comment
.1cc0	20 43 19	jsr $1943			jsr 	DecodeWriteBuffer
.1cc3	20 4c 19	jsr $194c			jsr 	DecodeOutputData
.1cc6	a9 20		lda #$20			lda 	#32
.1cc8	20 43 19	jsr $1943			jsr 	DecodeWriteBuffer
.1ccb					_CDEmpty
.1ccb	60		rts				rts
.1ccc					DefineCode:
.1ccc	20 4f 24	jsr $244f			jsr 	ErrorHandler
>1ccf	52 45 41 43 48 45 44 20				.text 	"REACHED DEFINITION",0
>1cd7	44 45 46 49 4e 49 54 49 4f 4e 00
.1ce2					DefineDecoder:
.1ce2	a9 07		lda #$07			lda 	#CTH_Definition
.1ce4	20 43 19	jsr $1943			jsr 	DecodeWriteBuffer
.1ce7	a9 3a		lda #$3a			lda 	#":"
.1ce9	20 43 19	jsr $1943			jsr 	DecodeWriteBuffer
.1cec	20 4c 19	jsr $194c			jsr 	DecodeOutputData
.1cef	a9 20		lda #$20			lda 	#32
.1cf1	20 43 19	jsr $1943			jsr 	DecodeWriteBuffer
.1cf4	60		rts				rts

;******  Return to file: files.asm


;******  Processing file: words/system/toint.src

.1cf5					ConvertToInteger:
.1cf5	84 17		sty $17				sty 	temp4+1
.1cf7	85 16		sta $16				sta 	temp4
.1cf9	64 14		stz $14				stz 	temp3 						; reset value
.1cfb	64 15		stz $15				stz 	temp3+1
.1cfd	64 10		stz $10				stz 	temp1 						; temp1 = 0 (decimal) 255 (hex)
.1cff	a0 00		ldy #$00			ldy 	#0 							; look at first character
.1d01	b1 16		lda ($16),y			lda 	(temp4),y
.1d03	49 2d		eor #$2d			eor 	#"-"						; zero if '-'
.1d05	85 11		sta $11				sta 	temp1+1 					; save this in temp1+1
.1d07	d0 01		bne $1d0a			bne 	_CTINotMinus
.1d09	c8		iny				iny									; skip -
.1d0a					_CTINotMinus:
.1d0a	b1 16		lda ($16),y			lda 	(temp4),y
.1d0c	c9 24		cmp #$24			cmp		#'$'						; if $ then skip it and set hex flag
.1d0e	d0 03		bne $1d13			bne 	_CTILoop
.1d10	c6 10		dec $10				dec 	temp1
.1d12	c8		iny				iny
.1d13					_CTILoop:
.1d13	b1 16		lda ($16),y			lda 	(temp4),y 					; next digit
.1d15	29 7f		and #$7f			and 	#$7F 						; drop end of word flag
.1d17	38		sec				sec
.1d18	e9 30		sbc #$30			sbc 	#'0' 						; put in range '0'+
.1d1a	90 65		bcc $1d81			bcc 	_CTIFail 					; out of range.
.1d1c	c9 0a		cmp #$0a			cmp 	#10 						; in 0-9 ?
.1d1e	90 0b		bcc $1d2b			bcc 	_CTILegal
.1d20	c9 11		cmp #$11			cmp 	#'A'-'0'					; between 9 and A ?
.1d22	90 5d		bcc $1d81			bcc 	_CTIFail
.1d24	38		sec				sec
.1d25	e9 07		sbc #$07			sbc 	#7 							; hex adjust
.1d27	c9 10		cmp #$10			cmp 	#16 						; out of range ?
.1d29	b0 56		bcs $1d81			bcs 	_CTIFail
.1d2b					_CTILegal:
.1d2b	48		pha				pha 								; save digit value.
.1d2c	06 14		asl $14				asl 	temp3
.1d2e	26 15		rol $15				rol 	temp3+1
.1d30	a5 14		lda $14				lda 	temp3 						; copy x2 into temp2
.1d32	85 12		sta $12				sta 	temp2
.1d34	a5 15		lda $15				lda 	temp3+1
.1d36	85 13		sta $13				sta 	temp2+1
.1d38	06 14		asl $14				asl 	temp3
.1d3a	26 15		rol $15				rol 	temp3+1
.1d3c	06 14		asl $14				asl 	temp3
.1d3e	26 15		rol $15				rol 	temp3+1
.1d40	24 10		bit $10				bit 	temp1 						; hexadecimal
.1d42	10 07		bpl $1d4b			bpl 	_CTIDecimal
.1d44	06 14		asl $14				asl 	temp3
.1d46	26 15		rol $15				rol 	temp3+1
.1d48	68		pla				pla 								; get digit back
.1d49	80 12		bra $1d5d			bra 	_CTIAddLoop
.1d4b					_CTIDecimal:
.1d4b	18		clc				clc 								; x 8 + x 2 = x 10
.1d4c	a5 14		lda $14				lda 	temp3
.1d4e	65 12		adc $12				adc 	temp2
.1d50	85 14		sta $14				sta 	temp3
.1d52	a5 15		lda $15				lda 	temp3+1
.1d54	65 13		adc $13				adc 	temp2+1
.1d56	85 15		sta $15				sta 	temp3+1
.1d58	68		pla				pla 								; check digit 0-9
.1d59	c9 0a		cmp #$0a			cmp 	#10
.1d5b	b0 24		bcs $1d81			bcs 	_CTIFail
.1d5d					_CTIAddLoop:
.1d5d	18		clc				clc
.1d5e	65 14		adc $14				adc 	temp3
.1d60	85 14		sta $14				sta 	temp3
.1d62	90 02		bcc $1d66			bcc 	_CTINoCarry
.1d64	e6 15		inc $15				inc 	temp3+1
.1d66					_CTINoCarry:
.1d66	c8		iny				iny
.1d67	b1 16		lda ($16),y			lda 	(temp4),y 					; was this the last character
.1d69	c9 21		cmp #$21			cmp 	#32+1
.1d6b	b0 a6		bcs $1d13			bcs 	_CTILoop 					; no, go back.
.1d6d	a5 11		lda $11				lda 	temp1+1 					; was it - ?
.1d6f	d0 0d		bne $1d7e			bne 	_CTIOkay
.1d71	38		sec				sec
.1d72	a9 00		lda #$00			lda 	#0 							; negate temp3.
.1d74	e5 14		sbc $14				sbc 	temp3
.1d76	85 14		sta $14				sta 	temp3
.1d78	a9 00		lda #$00			lda 	#0
.1d7a	e5 15		sbc $15				sbc 	temp3+1
.1d7c	85 15		sta $15				sta 	temp3+1
.1d7e					_CTIOkay:
.1d7e	98		tya				tya
.1d7f	38		sec				sec
.1d80	60		rts				rts
.1d81					_CTIFail:
.1d81	18		clc				clc
.1d82	60		rts				rts

;******  Return to file: files.asm


;******  Processing file: words/system/tostr.src

.1d83					IntToString:
.1d83	a9 10		lda #$10			lda 	#(textBuffer) & $FF
.1d85	85 12		sta $12				sta 	0+(temp2)
.1d87	a9 08		lda #$08			lda 	#(textBuffer) >> 8
.1d89	85 13		sta $13				sta 	1+(temp2)
.1d8b	a5 06		lda $06				lda 	TOS 						; value in YA
.1d8d	a4 07		ldy $07				ldy 	TOS+1
.1d8f	20 bf 1d	jsr $1dbf			jsr 	ConvertToString
.1d92	a9 10		lda #$10			lda 	#(textBuffer) & $FF
.1d94	85 06		sta $06				sta 	0+(TOS)
.1d96	a9 08		lda #$08			lda 	#(textBuffer) >> 8
.1d98	85 07		sta $07				sta 	1+(TOS)
.1d9a	4c 00 00	jmp $0000			jmp 	NextCode
.1d9d					PrintYA:
.1d9d	48		pha				pha
.1d9e	da		phx				phx
.1d9f	5a		phy				phy
.1da0	48		pha				pha
.1da1	a9 10		lda #$10			lda 	#(textBuffer) & $FF
.1da3	85 12		sta $12				sta 	0+(temp2)
.1da5	a9 08		lda #$08			lda 	#(textBuffer) >> 8
.1da7	85 13		sta $13				sta 	1+(temp2)
.1da9	68		pla				pla
.1daa	20 c3 1d	jsr $1dc3			jsr 	ConvertToStringMain
.1dad	a2 00		ldx #$00			ldx 	#0
.1daf					_PrintYALoop:
.1daf	bd 10 08	lda $0810,x			lda 	textBuffer,x
.1db2	20 af 24	jsr $24af			jsr 	ExternPrint
.1db5	e8		inx				inx
.1db6	bd 10 08	lda $0810,x			lda 	textBuffer,x
.1db9	d0 f4		bne $1daf			bne 	_PrintYALoop
.1dbb	7a		ply				ply
.1dbc	fa		plx				plx
.1dbd	68		pla				pla
.1dbe	60		rts				rts
.1dbf					ConvertToString:
.1dbf	38		sec				sec
.1dc0	80 01		bra $1dc3			bra 	ConvertToStringMain
.1dc2					ConvertToStringUnsigned:
.1dc2	18		clc				clc
.1dc3					ConvertToStringMain:
.1dc3	da		phx				phx									; save XY
.1dc4	5a		phy				phy
.1dc5	64 1a		stz $1a				stz 	SignCount 					; this is zero suppression
.1dc7	85 10		sta $10				sta 	temp1 						; save YA in temp1
.1dc9	84 11		sty $11				sty 	temp1+1
.1dcb	a0 00		ldy #$00			ldy 	#0 							; index to result.
.1dcd	90 16		bcc $1de5			bcc 	_CTSUnsigned 				; if carry clear do not adjust for -
.1dcf	a5 11		lda $11				lda 	temp1+1 					; is it negative
.1dd1	10 12		bpl $1de5			bpl 	_CTSUnsigned
.1dd3	a9 2d		lda #$2d			lda 	#"-"						; output - sign
.1dd5	91 12		sta ($12),y			sta 	(temp2),y
.1dd7	c8		iny				iny
.1dd8	38		sec				sec 								; negate temp1
.1dd9	a9 00		lda #$00			lda 	#0
.1ddb	e5 10		sbc $10				sbc 	temp1
.1ddd	85 10		sta $10				sta 	temp1
.1ddf	a9 00		lda #$00			lda 	#0
.1de1	e5 11		sbc $11				sbc 	temp1+1
.1de3	85 11		sta $11				sta 	temp1+1
.1de5					_CTSUnsigned:
.1de5	a2 00		ldx #$00			ldx 	#0 							; index into subtraction table
.1de7					_CTSLoop:
.1de7	a9 2f		lda #$2f			lda 	#"0"-1						; set the digit to '0' code.
.1de9	91 12		sta ($12),y			sta 	(temp2),y
.1deb					_CTSSubLoop:
.1deb	b1 12		lda ($12),y			lda 	(temp2),y 					; bump the count
.1ded	1a		inc a				inc 	a
.1dee	91 12		sta ($12),y			sta 	(temp2),y
.1df0	38		sec				sec 								; do subtraction saving interim result
.1df1	a5 10		lda $10				lda 	temp1
.1df3	fd 26 1e	sbc $1e26,x			sbc 	_CTSTable,x
.1df6	48		pha				pha
.1df7	a5 11		lda $11				lda 	temp1+1
.1df9	fd 27 1e	sbc $1e27,x			sbc 	_CTSTable+1,x
.1dfc	90 07		bcc $1e05			bcc 	_CTSCantSubtract 			; end of subtraction.
.1dfe	85 11		sta $11				sta 	temp1+1 					; save result back
.1e00	68		pla				pla
.1e01	85 10		sta $10				sta 	temp1
.1e03	80 e6		bra $1deb			bra 	_CTSSubLoop
.1e05					_CTSCantSubtract:
.1e05	68		pla				pla 								; throw away interim
.1e06	e8		inx				inx 								; next subtractor
.1e07	e8		inx				inx
.1e08	b1 12		lda ($12),y			lda 	(temp2),y 					; update leading zero
.1e0a	49 30		eor #$30			eor 	#"0"
.1e0c	05 1a		ora $1a				ora 	SignCount
.1e0e	85 1a		sta $1a				sta 	SignCount
.1e10	f0 01		beq $1e13			beq		_CTSLZ 						; if all zeros so far suppress.
.1e12	c8		iny				iny 								; next character
.1e13					_CTSLZ:
.1e13	e0 08		cpx #$08			cpx 	#_CTSTableEnd-_CTSTable 	; done them all ?
.1e15	d0 d0		bne $1de7			bne 	_CTSLoop
.1e17					_CTSComplete:
.1e17	a5 10		lda $10				lda		temp1 						; get remainder 0-9
.1e19	09 30		ora #$30			ora 	#48 						; ASCII
.1e1b	91 12		sta ($12),y			sta 	(temp2),y					; write out
.1e1d	c8		iny				iny
.1e1e	a9 00		lda #$00			lda 	#0							; make ASCIIZ
.1e20	91 12		sta ($12),y			sta 	(temp2),y
.1e22	98		tya				tya 								; size in A
.1e23	7a		ply				ply									; pull and exit.
.1e24	fa		plx				plx
.1e25	60		rts				rts
.1e26					_CTSTable:
>1e26	10 27 e8 03 64 00 0a 00				.word 	10000,1000,100,10 			; subtractors, this is a simple version.
.1e2e					_CTSTableEnd:

;******  Return to file: files.asm


;******  Processing file: words/system/varhandlers.src

.1e2e					VarAddressHandler:
.1e2e	18		clc				clc 								; find variable, error if it doesn't exist.
.1e2f	20 d1 1e	jsr $1ed1			jsr 	VariableFind
.1e32	20 ab 1e	jsr $1eab			jsr 	VariableCheckIndex
.1e35	a5 06		lda $06				lda 	TOS
.1e37	48		pha				pha
.1e38	a5 07		lda $07				lda 	TOS+1
.1e3a	48		pha				pha
.1e3b	a5 10		lda $10				lda 	temp1 						; the address is the new value
.1e3d	85 06		sta $06				sta 	TOS
.1e3f	a5 11		lda $11				lda		temp1+1
.1e41	85 07		sta $07				sta 	TOS+1
.1e43	4c 00 00	jmp $0000			jmp 	NextCode
.1e46					VarAddrHandlerDecode:
.1e46	a9 26		lda #$26			lda 	#"&"
.1e48	4c 89 1f	jmp $1f89			jmp 	VarHandlerDecode
.1e4b					VarReadHandler:
.1e4b	18		clc				clc 								; find variable, error if it doesn't exist.
.1e4c	20 d1 1e	jsr $1ed1			jsr 	VariableFind
.1e4f	20 ab 1e	jsr $1eab			jsr 	VariableCheckIndex
.1e52	a5 06		lda $06				lda 	TOS
.1e54	48		pha				pha
.1e55	a5 07		lda $07				lda 	TOS+1
.1e57	48		pha				pha
.1e58	b2 10		lda ($10)			lda 	(temp1)						; read variable address to TOS
.1e5a	85 06		sta $06				sta 	TOS
.1e5c	a0 01		ldy #$01			ldy 	#1
.1e5e	b1 10		lda ($10),y			lda 	(temp1),y
.1e60	85 07		sta $07				sta 	TOS+1
.1e62	4c 00 00	jmp $0000			jmp 	NextCode
.1e65					VarReadHandlerDecode:
.1e65	a9 40		lda #$40			lda 	#"@"
.1e67	4c 89 1f	jmp $1f89			jmp 	VarHandlerDecode
.1e6a					VarWriteHandler:
.1e6a	38		sec				sec 								; find variable, create it if it doesn't exist.
.1e6b	20 d1 1e	jsr $1ed1			jsr 	VariableFind
.1e6e	20 ab 1e	jsr $1eab			jsr 	VariableCheckIndex
.1e71	a5 06		lda $06				lda 	TOS 						; write TOS to that address.
.1e73	92 10		sta ($10)			sta 	(temp1)
.1e75	a5 07		lda $07				lda 	TOS+1
.1e77	a0 01		ldy #$01			ldy 	#1
.1e79	91 10		sta ($10),y			sta 	(temp1),y
.1e7b	68		pla				pla
.1e7c	85 07		sta $07				sta 	TOS+1
.1e7e	68		pla				pla
.1e7f	85 06		sta $06				sta 	TOS
.1e81	4c 00 00	jmp $0000			jmp 	NextCode
.1e84					VarWriteHandlerDecode:
.1e84	a9 21		lda #$21			lda 	#"!"
.1e86	4c 89 1f	jmp $1f89			jmp 	VarHandlerDecode
.1e89					IndexHandler:
.1e89	20 4f 24	jsr $244f			jsr 	ErrorHandler
>1e8c	24 24 49 4e 44 45 58 3a				.text 	"$$INDEX:BUG",0
>1e94	42 55 47 00
.1e98					IndexHandlerDecode:
.1e98	a9 5b		lda #$5b			lda 	#"["
.1e9a	20 43 19	jsr $1943			jsr 	DecodeWriteBuffer
.1e9d	b1 08		lda ($08),y			lda 	(srcPtr),y
.1e9f	a0 00		ldy #$00			ldy 	#0
.1ea1	38		sec				sec
.1ea2	20 65 19	jsr $1965			jsr 	DecodeYAToBuffer
.1ea5	a9 5d		lda #$5d			lda 	#"]"
.1ea7	20 43 19	jsr $1943			jsr 	DecodeWriteBuffer
.1eaa	60		rts				rts
.1eab					VariableCheckIndex:
.1eab	8a		txa				txa 								; next is $$index ?
.1eac	a8		tay				tay
.1ead	c8		iny				iny
.1eae	c8		iny				iny
.1eaf	b1 03		lda ($03),y			lda 	(IP),y
.1eb1	c9 89		cmp #$89			cmp 	#IndexHandler & $FF
.1eb3	d0 1b		bne $1ed0			bne 	_VCIExit
.1eb5	c8		iny				iny
.1eb6	b1 03		lda ($03),y			lda 	(IP),y
.1eb8	c9 1e		cmp #$1e			cmp 	#IndexHandler >> 8
.1eba	d0 14		bne $1ed0			bne 	_VCIExit
.1ebc	98		tya				tya 								; fix X backup 3 on from where we started
.1ebd	aa		tax				tax
.1ebe	c8		iny				iny 								; get the index
.1ebf	b1 03		lda ($03),y			lda 	(IP),y
.1ec1	0a		asl a				asl 	a 							; double it, add to (temp1) -> temp1
.1ec2	a0 01		ldy #$01			ldy 	#1
.1ec4	72 10		adc ($10)			adc 	(temp1) 					; do the indirection e.g. the look up.
.1ec6	48		pha				pha
.1ec7	b1 10		lda ($10),y			lda 	(temp1),y
.1ec9	69 00		adc #$00			adc 	#0
.1ecb	85 11		sta $11				sta 	temp1+1
.1ecd	68		pla				pla
.1ece	85 10		sta $10				sta 	temp1
.1ed0					_VCIExit:
.1ed0	60		rts				rts
.1ed1					VariableFind:
.1ed1	08		php				php 								; save autocreate flag.
.1ed2	e8		inx				inx 								; advance to/over the variable name.
.1ed3	e8		inx				inx
.1ed4	8a		txa				txa 								; put in Y
.1ed5	a8		tay				tay
.1ed6	b1 03		lda ($03),y			lda 	(IP),y 						; copy name word into temp2
.1ed8	85 12		sta $12				sta 	temp2
.1eda	c8		iny				iny
.1edb	b1 03		lda ($03),y			lda 	(IP),y
.1edd	85 13		sta $13				sta 	temp2+1
.1edf	c9 1b		cmp #$1b			cmp 	#27 						; check for A-Z
.1ee1	b0 0f		bcs $1ef2			bcs 	_VFLong
.1ee3	a5 13		lda $13				lda 	temp2+1
.1ee5	d0 0b		bne $1ef2			bne 	_VFLong
.1ee7	a5 12		lda $12				lda 	temp2						; this is the index
.1ee9	0a		asl a				asl 	a 							; double it
.1eea	85 10		sta $10				sta 	temp1
.1eec	a9 06		lda #$06			lda 	#azVariables >> 8			; set the MSB
.1eee	85 11		sta $11				sta 	temp1+1
.1ef0	28		plp				plp 								; throw creation flag, it always exists.
.1ef1	60		rts				rts
.1ef2					_VFLong:
.1ef2	a5 12		lda $12				lda 	temp2 						; built a hash table index into temp3/temp4
.1ef4	6a		ror a				ror 	a
.1ef5	6a		ror a				ror 	a
.1ef6	6a		ror a				ror 	a
.1ef7	6a		ror a				ror 	a
.1ef8	45 12		eor $12				eor 	temp2
.1efa	45 13		eor $13				eor 	temp2+1
.1efc	29 0f		and #$0f			and 	#(hashTableSize-1)			; force into range
.1efe	0a		asl a				asl 	a
.1eff	69 40		adc #$40			adc 	#hashTable & $FF 			; make an address of the head => temp1/3
.1f01	85 10		sta $10				sta 	temp1
.1f03	85 14		sta $14				sta 	temp3
.1f05	a9 06		lda #$06			lda 	#hashTable >> 8
.1f07	85 11		sta $11				sta 	temp1+1
.1f09	85 15		sta $15				sta 	temp3+1
.1f0b					_VFSearch:
.1f0b	a0 01		ldy #$01			ldy 	#1							; read MSB of first record
.1f0d	b1 10		lda ($10),y			lda 	(temp1),y
.1f0f	f0 23		beq $1f34			beq 	_VFNotFound 				; is MSB is zero, can't be a variable record
.1f11	a8		tay				tay 								; follow the link through.
.1f12	b2 10		lda ($10)			lda 	(temp1)
.1f14	85 10		sta $10				sta 	temp1
.1f16	84 11		sty $11				sty 	temp1+1
.1f18	a0 04		ldy #$04			ldy 	#4							; check if the name matches
.1f1a	b1 10		lda ($10),y			lda 	(temp1),y
.1f1c	c5 12		cmp $12				cmp 	temp2
.1f1e	d0 eb		bne $1f0b			bne 	_VFSearch 					; if it doesn't, follow the next link.
.1f20	c8		iny				iny 								; same for 2nd byte of name
.1f21	b1 10		lda ($10),y			lda 	(temp1),y
.1f23	c5 13		cmp $13				cmp 	temp2+1
.1f25	d0 e4		bne $1f0b			bne 	_VFSearch
.1f27	18		clc				clc
.1f28	a5 10		lda $10				lda 	temp1 						; make temp1 point to the data at offset 2
.1f2a	69 02		adc #$02			adc 	#2
.1f2c	85 10		sta $10				sta 	temp1
.1f2e	90 02		bcc $1f32			bcc 	_VFNoPage1
.1f30	e6 11		inc $11				inc 	temp1+1
.1f32					_VFNoPage1:
.1f32	28		plp				plp 								; don't need to worry about creation flag
.1f33	60		rts				rts
.1f34					_VFNotFound:
.1f34	28		plp				plp 								; was carry set, e.g. create a new record if not found ?
.1f35	b0 14		bcs $1f4b			bcs 	_VFCreate
.1f37	20 4f 24	jsr $244f			jsr 	ErrorHandler
>1f3a	4e 4f 20 53 55 43 48 20				.text 	"NO SUCH VARIABLE",0
>1f42	56 41 52 49 41 42 4c 45 00
.1f4b					_VFCreate:
.1f4b	a0 01		ldy #$01			ldy 	#1
.1f4d	b2 14		lda ($14)			lda 	(temp3) 					; copy the head link to the first 2 bytes
.1f4f	92 0e		sta ($0e)			sta 	(nextFreeMem)
.1f51	b1 14		lda ($14),y			lda 	(temp3),y
.1f53	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.1f55	c8		iny				iny
.1f56	a9 00		lda #$00			lda 	#0	 						; write zero initialised data out.
.1f58	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.1f5a	c8		iny				iny
.1f5b	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.1f5d	c8		iny				iny
.1f5e	a5 12		lda $12				lda 	temp2 						; copy the name out
.1f60	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.1f62	c8		iny				iny
.1f63	a5 13		lda $13				lda 	temp2+1
.1f65	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.1f67	a0 01		ldy #$01			ldy 	#1
.1f69	a5 0e		lda $0e				lda 	nextFreeMem 				; update the head link
.1f6b	92 14		sta ($14)			sta 	(temp3)
.1f6d	a5 0f		lda $0f				lda 	nextFreeMem+1
.1f6f	91 14		sta ($14),y			sta 	(temp3),y
.1f71	18		clc				clc
.1f72	a5 0e		lda $0e				lda 	nextFreeMem 				; put nextFreeMem+2 in temp1 (data pointer)
.1f74	69 02		adc #$02			adc 	#2
.1f76	85 10		sta $10				sta 	temp1
.1f78	a5 0f		lda $0f				lda 	nextFreeMem+1
.1f7a	69 00		adc #$00			adc 	#0
.1f7c	85 11		sta $11				sta 	temp1+1
.1f7e	a9 06		lda #$06			lda 	#6							; shift freemem pointer up 6
.1f80	a0 00		ldy #$00			ldy 	#0
.1f82	20 22 18	jsr $1822			jsr 	AdvanceFreeMem
.1f85	20 2f 18	jsr $182f			jsr 	CheckMemory 				; low on memory ?
.1f88	60		rts				rts
.1f89					VarHandlerDecode:
.1f89	48		pha				pha 								; save, leading space
.1f8a	a9 07		lda #$07			lda 	#CTH_Variable
.1f8c	20 43 19	jsr $1943			jsr 	DecodeWriteBuffer
.1f8f	68		pla				pla 								; restore and write type
.1f90	20 43 19	jsr $1943			jsr 	DecodeWriteBuffer
.1f93	b1 08		lda ($08),y			lda 	(srcPtr),y 					; copy to temp1
.1f95	85 10		sta $10				sta 	temp1
.1f97	c8		iny				iny
.1f98	b1 08		lda ($08),y			lda 	(srcPtr),y
.1f9a	85 11		sta $11				sta 	temp1+1
.1f9c	a5 10		lda $10				lda 	temp1 						; output the first character
.1f9e	29 1f		and #$1f			and 	#31
.1fa0	20 cb 1f	jsr $1fcb			jsr 	VHOutVarChar
.1fa3	a2 05		ldx #$05			ldx 	#5 							; divide temp1 by 32
.1fa5					_VHDShift:
.1fa5	46 11		lsr $11				lsr 	temp1+1
.1fa7	66 10		ror $10				ror 	temp1
.1fa9	ca		dex				dex
.1faa	d0 f9		bne $1fa5			bne 	_VHDShift
.1fac	a2 ff		ldx #$ff			ldx 	#255 						; now divide that by 40 by repeated subtraction.
.1fae					_VHDDiv40:
.1fae	e8		inx				inx
.1faf	38		sec				sec
.1fb0	a5 10		lda $10				lda 	temp1
.1fb2	e9 28		sbc #$28			sbc 	#40
.1fb4	a8		tay				tay
.1fb5	a5 11		lda $11				lda 	temp1+1
.1fb7	e9 00		sbc #$00			sbc 	#0
.1fb9	90 06		bcc $1fc1			bcc 	_VHDivDone
.1fbb	85 11		sta $11				sta 	temp1+1
.1fbd	84 10		sty $10				sty 	temp1
.1fbf	80 ed		bra $1fae			bra 	_VHDDiv40
.1fc1					_VHDivDone:
.1fc1	a5 10		lda $10				lda 	temp1 						; remainder
.1fc3	20 cb 1f	jsr $1fcb			jsr 	VHOutVarChar
.1fc6	8a		txa				txa
.1fc7	20 cb 1f	jsr $1fcb			jsr 	VHOutVarChar 				; and result.
.1fca	60		rts				rts
.1fcb					VHOutVarChar:
.1fcb	c9 00		cmp #$00			cmp 	#0
.1fcd	f0 0c		beq $1fdb			beq 	_VHOExit
.1fcf	18		clc				clc
.1fd0	69 40		adc #$40			adc 	#64 						; 65-90 A-Z 91-100 0-9
.1fd2	c9 5b		cmp #$5b			cmp 	#91 						; convert back ?
.1fd4	90 02		bcc $1fd8			bcc 	_VHOOut
.1fd6	e9 2b		sbc #$2b			sbc 	#91-48 						; adjust to digit
.1fd8					_VHOOut:
.1fd8	20 43 19	jsr $1943			jsr 	DecodeWriteBuffer
.1fdb					_VHOExit:
.1fdb	60		rts				rts

;******  Return to file: files.asm


;******  Processing file: words/encode/encode.src

.1fdc					EncodeProgram:
.1fdc	48		pha				pha 								; save registers.
.1fdd	da		phx				phx
.1fde	5a		phy				phy
.1fdf	84 09		sty $09				sty 	srcPtr+1					; save source pointer.
.1fe1	85 08		sta $08				sta		srcPtr
.1fe3	64 05		stz $05				stz 	rsp
.1fe5	a6 05		ldx $05				ldx 	rsp 						; this is the current stack entry type, so $00 means
.1fe7	9e 40 07	stz $0740,x			stz 	returnStackHigh,x 			; an initial "until" will fail as it's looking for "R" here (repeat)
.1fea	20 69 22	jsr $2269			jsr 	EncodeTrimTrailingSpaces 	; remove trailing spaces.
.1fed	a9 03		lda #$03			lda 	#3 							; reset the encode Buffer
.1fef	8d 10 09	sta $0910			sta 	encodeBuffer 				; this is also the write ptr/offset
.1ff2	9c 11 09	stz $0911			stz 	encodeBuffer+1 				; the line number
.1ff5	9c 12 09	stz $0912			stz 	encodeBuffer+2 				; which is initially zero.
.1ff8	b2 08		lda ($08)			lda 	(srcPtr) 					; check if first character is digit
.1ffa	20 14 22	jsr $2214			jsr 	CheckIsDigit
.1ffd	90 09		bcc $2008			bcc 	_EPNoLineNumber 			; if so there is a line number
.1fff	20 36 22	jsr $2236			jsr 	EncodeGetConstant 			; extract that constant from the source
.2002	8d 11 09	sta $0911			sta 	encodeBuffer+1 				; that is the line number
.2005	8c 12 09	sty $0912			sty 	encodeBuffer+2
.2008					_EPNoLineNumber:
.2008					EncodeLoop:
.2008	20 5b 22	jsr $225b			jsr 	EncSkipSpaces 				; skip over spaces
.200b	b2 08		lda ($08)			lda 	(srcPtr) 					; reached end ?
.200d	d0 21		bne $2030			bne 	_EPNotEnd
.200f					_EPEndEncode:
.200f	a9 8a		lda #$8a			lda 	#NextLine & $FF 			; compile $$nextline to mark eol
.2011	a0 1c		ldy #$1c			ldy 	#NextLine >> 8
.2013	20 ec 21	jsr $21ec			jsr 	EncodeWriteWord
.2016	a5 05		lda $05				lda 	rsp 						; is the return stack empty ?
.2018	d0 04		bne $201e			bne 	_EPIncomplete
.201a	7a		ply				ply									; restore and exit.
.201b	fa		plx				plx
.201c	68		pla				pla
.201d	60		rts				rts
.201e					_EPIncomplete:
.201e	20 4f 24	jsr $244f			jsr 	ErrorHandler
>2021	53 54 52 55 43 54 55 52				.text 	"STRUCTURE OPEN",0
>2029	45 20 4f 50 45 4e 00
.2030					_EPNotEnd:
.2030	b2 08		lda ($08)			lda 	(srcPtr)
.2032	c9 22		cmp #$22			cmp 	#'"'						; is it a quoted string or comment ?
.2034	f0 04		beq $203a			beq 	_EPIsComStr
.2036	c9 27		cmp #$27			cmp 	#"'"
.2038	d0 05		bne $203f			bne 	_EPNotComStr
.203a					_EPIsComStr:
.203a	20 39 21	jsr $2139			jsr 	EncodeCommentString
.203d	80 c9		bra $2008			bra 	EncodeLoop
.203f					_EPNotComStr:
.203f	38		sec				sec
.2040	20 48 22	jsr $2248			jsr 	EncSetBit7Word
.2043	20 90 22	jsr $2290			jsr 	EncodeSearchDictionary		; look it up
.2046	90 45		bcc $208d			bcc 	_EPNotInDictionary
.2048	85 10		sta $10				sta 	temp1 						; save dictionary record address
.204a	84 11		sty $11				sty 	temp1+1
.204c	a0 01		ldy #$01			ldy 	#1
.204e	b1 10		lda ($10),y			lda 	(temp1),y 					; check if has an encode bit
.2050	29 20		and #$20			and 	#$20
.2052	d0 12		bne $2066			bne 	_EPEncodeRoutine 			; if so, do special routine.
.2054	a0 02		ldy #$02			ldy 	#2 							; write out the routine address
.2056	b1 10		lda ($10),y			lda 	(temp1),y
.2058	20 f6 21	jsr $21f6			jsr 	EncodeWriteByte
.205b	c8		iny				iny
.205c	b1 10		lda ($10),y			lda 	(temp1),y
.205e	20 f6 21	jsr $21f6			jsr 	EncodeWriteByte
.2061	20 20 22	jsr $2220			jsr 	EncodeMoveNextWord 			; advance to the next and loop
.2064	80 a2		bra $2008			bra 	EncodeLoop
.2066					_EPEncodeRoutine:
.2066	a0 01		ldy #$01			ldy 	#1							; get type bit
.2068	b1 10		lda ($10),y			lda 	(temp1),y
.206a	a0 04		ldy #$04			ldy 	#4							; encoder here if no decoder
.206c	29 10		and #$10			and 	#$10 						; but decoder comes first
.206e	f0 02		beq $2072			beq 	_EPENoDecoder
.2070	c8		iny				iny 								; so if it exists, adjust for it.
.2071	c8		iny				iny
.2072					_EPENoDecoder:
.2072	b1 10		lda ($10),y			lda 	(temp1),y 					; copy exec addr to temp2
.2074	85 12		sta $12				sta 	temp2
.2076	c8		iny				iny
.2077	b1 10		lda ($10),y			lda 	(temp1),y
.2079	85 13		sta $13				sta 	temp2+1
.207b	48		pha				pha 								; call routine preserving state
.207c	da		phx				phx
.207d	5a		phy				phy
.207e	20 8a 20	jsr $208a			jsr 	_EPECallTemp2
.2081	7a		ply				ply
.2082	fa		plx				plx
.2083	68		pla				pla
.2084	20 20 22	jsr $2220			jsr 	EncodeMoveNextWord 			; advance to the next and loop
.2087	4c 08 20	jmp $2008			jmp 	EncodeLoop
.208a					_EPECallTemp2:
.208a	6c 12 00	jmp ($0012)			jmp 	(temp2)
.208d					_EPNotInDictionary:
.208d	20 9e 21	jsr $219e			jsr 	EncodeSearchUserDefined 	; are there any user defined routines
.2090	90 19		bcc $20ab			bcc 	_EPNotDefined
.2092	48		pha				pha
.2093	a9 87		lda #$87			lda	 	#CallHandler & $FF 			; write code call handler
.2095	20 f6 21	jsr $21f6			jsr 	EncodeWriteByte
.2098	a9 16		lda #$16			lda	 	#CallHandler >> 8
.209a	20 f6 21	jsr $21f6			jsr 	EncodeWriteByte
.209d	68		pla				pla 								; write line number
.209e	20 f6 21	jsr $21f6			jsr 	EncodeWriteByte
.20a1	98		tya				tya
.20a2	20 f6 21	jsr $21f6			jsr 	EncodeWriteByte
.20a5	20 20 22	jsr $2220			jsr 	EncodeMoveNextWord 			; advance to the next and loop
.20a8	4c 08 20	jmp $2008			jmp 	EncodeLoop
.20ab					_EPNotDefined:
.20ab	b2 08		lda ($08)			lda 	(srcPtr) 					; first character
.20ad	c9 3a		cmp #$3a			cmp 	#":"						; is it :<routine> ?
.20af	f0 65		beq $2116			beq 	_EPDefinition
.20b1	c9 3c		cmp #$3c			cmp 	#"<"						; is it <line> which is call syntax
.20b3	f0 3b		beq $20f0			beq 	_EPCallDirect
.20b5	c9 21		cmp #$21			cmp 	#"!"						; check for variable operators
.20b7	f0 54		beq $210d			beq 	_EPVariable
.20b9	c9 40		cmp #$40			cmp 	#"@"
.20bb	f0 50		beq $210d			beq 	_EPVariable
.20bd	c9 26		cmp #$26			cmp 	#"&"
.20bf	f0 4c		beq $210d			beq 	_EPVariable
.20c1	c9 24		cmp #$24			cmp 	#"$" 						; is it a hex constant
.20c3	d0 09		bne $20ce			bne 	_EPDecLiteral
.20c5	a9 14		lda #$14			lda 	#HexLiteral2Byte & $FF 		; write out 2 byte literal (hex)
.20c7	a0 10		ldy #$10			ldy 	#HexLiteral2Byte >> 8
.20c9	20 ec 21	jsr $21ec			jsr 	EncodeWriteWord
.20cc	80 07		bra $20d5			bra 	_EPOutputConstant
.20ce					_EPDecLiteral:
.20ce	a9 15		lda #$15			lda 	#Literal2Byte & $FF 		; write out 2 byte literal
.20d0	a0 10		ldy #$10			ldy 	#Literal2Byte >> 8
.20d2	20 ec 21	jsr $21ec			jsr 	EncodeWriteWord
.20d5					_EPOutputConstant:
.20d5	20 36 22	jsr $2236			jsr 	EncodeGetConstant 			; extract that constant from the source
.20d8	90 06		bcc $20e0			bcc 	_EPFail 					; if can't find one, that's us done.
.20da	20 ec 21	jsr $21ec			jsr 	EncodeWriteWord 			; write out the encoded value.
.20dd	4c 08 20	jmp $2008			jmp 	EncodeLoop 					; and go round again.
.20e0					_EPFail:
.20e0	20 4f 24	jsr $244f			jsr 	ErrorHandler
>20e3	53 59 4e 54 41 58 20 45				.text 	"SYNTAX ERROR",0
>20eb	52 52 4f 52 00
.20f0					_EPCallDirect:
.20f0	a9 87		lda #$87			lda	 	#CallHandler & $FF 			; write code call handler
.20f2	a0 16		ldy #$16			ldy	 	#CallHandler >> 8
.20f4	20 ec 21	jsr $21ec			jsr 	EncodeWriteWord
.20f7	a9 01		lda #$01			lda 	#1
.20f9	20 2c 22	jsr $222c			jsr 	EncodeAddSrcPtr 			; skip over the <
.20fc	a0 ff		ldy #$ff			ldy 	#255 						; scan forward for last character.
.20fe					_EPToLast:
.20fe	c8		iny				iny
.20ff	b1 08		lda ($08),y			lda 	(srcPtr),y
.2101	10 fb		bpl $20fe			bpl	 	_EPToLast
.2103	c9 be		cmp #$be			cmp 	#">"+$80 					; must be >
.2105	d0 d9		bne $20e0			bne 	_EPFail
.2107	a9 20		lda #$20			lda 	#" " 						; strip back to a number, erases last char
.2109	91 08		sta ($08),y			sta 	(srcPtr),y
.210b	80 c8		bra $20d5			bra 	_EPOutputConstant 			; borrow the number routines extract/compile constant
.210d					_EPVariable:
.210d	20 e4 22	jsr $22e4			jsr 	EncodeVariableReference
.2110	20 20 22	jsr $2220			jsr 	EncodeMoveNextWord 			; advance to the next and loop
.2113	4c 08 20	jmp $2008			jmp 	EncodeLoop
.2116					_EPDefinition:
.2116	a9 cc		lda #$cc			lda	 	#DefineCode & $FF 			; write code call handler
.2118	a0 1c		ldy #$1c			ldy	 	#DefineCode >> 8
.211a	20 ec 21	jsr $21ec			jsr 	EncodeWriteWord
.211d	ae 10 09	ldx $0910			ldx 	encodeBuffer 				; position
.2120	a9 01		lda #$01			lda 	#1 							; write default size
.2122	20 f6 21	jsr $21f6			jsr 	EncodeWriteByte
.2125	a0 00		ldy #$00			ldy 	#0 							; copy definition over.
.2127	c8		iny		_EPCopy:iny
.2128	b1 08		lda ($08),y			lda 	(srcPtr),y
.212a	20 f6 21	jsr $21f6			jsr 	EncodeWriteByte
.212d	fe 10 09	inc $0910,x			inc 	encodeBuffer,x 				; update length.
.2130	0a		asl a				asl 	a
.2131	90 f4		bcc $2127			bcc 	_EPCopy
.2133	20 20 22	jsr $2220			jsr 	EncodeMoveNextWord 			; advance to the next and loop
.2136	4c 08 20	jmp $2008			jmp 	EncodeLoop

;******  Return to file: files.asm


;******  Processing file: words/encode/comstr.src

.2139					EncodeCommentString:
.2139	b2 08		lda ($08)			lda 	(srcPtr) 					; get first character
.213b	64 10		stz $10				stz 	temp1 						; other terminator = EOL
.213d	aa		tax				tax 								; save in X
.213e	a9 a1		lda #$a1			lda 	#(SkipComment & $FF)		; get the routine to use
.2140	a0 1c		ldy #$1c			ldy 	#(SkipComment >> 8)
.2142	e0 27		cpx #$27			cpx 	#"'"
.2144	f0 06		beq $214c			beq 	_ECSGotCmd
.2146	86 10		stx $10				stx		temp1 						; other terminator = "
.2148	a9 6f		lda #$6f			lda 	#(LiteralString & $FF)
.214a	a0 10		ldy #$10			ldy 	#(LiteralString >> 8)
.214c					_ECSGotCmd:
.214c	20 ec 21	jsr $21ec			jsr 	EncodeWriteWord 			; write word out.
.214f	a9 01		lda #$01			lda 	#1 							; skip over ' or "
.2151	20 2c 22	jsr $222c			jsr 	EncodeAddSrcPtr
.2154	e0 27		cpx #$27			cpx 	#"'"						; if ' then skip spaces
.2156	d0 03		bne $215b			bne 	_ECNoSkipSpaces
.2158	20 5b 22	jsr $225b			jsr 	EncSkipSpaces
.215b					_ECNoSkipSpaces:
.215b	ae 10 09	ldx $0910			ldx 	encodeBuffer 				; keep offset to buffer in X.
.215e	a9 01		lda #$01			lda 	#1
.2160	20 f6 21	jsr $21f6			jsr 	EncodeWriteByte 			; write total length, so far 1.
.2163	a0 00		ldy #$00			ldy 	#0 							; for reading the actual text
.2165					_ECSCopyText:
.2165	b1 08		lda ($08),y			lda 	(srcPtr),y 					; get next
.2167	f0 18		beq $2181			beq 	_ECSEndOfLine 				; end of line ?
.2169	c5 10		cmp $10				cmp 	temp1						; is it the other terminator
.216b	f0 09		beq $2176			beq 	_ECSEndOfString 			; if so must be closing quote.
.216d	20 f6 21	jsr $21f6			jsr 	EncodeWriteByte 			; write the byte out
.2170	fe 10 09	inc $0910,x			inc 	encodeBuffer,x				; increase length
.2173	c8		iny				iny 								; next character
.2174	80 ef		bra $2165			bra 	_ECSCopyText
.2176					_ECSEndOfString:
.2176	c8		iny				iny 								; skip closing quote.
.2177	a9 00		lda #$00			lda 	#0 							; write out ASCIIZ
.2179	20 f6 21	jsr $21f6			jsr 	EncodeWriteByte
.217c	fe 10 09	inc $0910,x			inc 	encodeBuffer,x 				; fix the length up.
.217f	80 18		bra $2199			bra 	_ECSComplete 				; and just patching up srcPtr to do.
.2181					_ECSEndOfLine:
.2181	a5 10		lda $10				lda 	temp1 						; missing closing quote
.2183	f0 14		beq $2199			beq 	_ECSComplete 				; if we were doing a string.
.2185	20 4f 24	jsr $244f			jsr 	ErrorHandler
>2188	4e 4f 20 43 4c 4f 53 49				.text 	"NO CLOSING QUOTE",0
>2190	4e 47 20 51 55 4f 54 45 00
.2199					_ECSComplete:
.2199	98		tya				tya									; skip over.
.219a	20 2c 22	jsr $222c			jsr 	EncodeAddSrcPtr
.219d	60		rts				rts

;******  Return to file: files.asm


;******  Processing file: words/encode/encdef.src

.219e					EncodeSearchUserDefined:
.219e	38		sec				sec 								; temp1 = srcPtr-6 because the
.219f	a5 08		lda $08				lda 	srcPtr				 		; name is 6 in (offset line# $$call len)
.21a1	e9 06		sbc #$06			sbc		#6
.21a3	85 10		sta $10				sta 	temp1
.21a5	a5 09		lda $09				lda 	srcPtr+1
.21a7	e9 00		sbc #$00			sbc 	#0
.21a9	85 11		sta $11				sta 	temp1+1
.21ab	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.21ad	85 12		sta $12				sta 	0+(temp2)
.21af	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.21b1	85 13		sta $13				sta 	1+(temp2)
.21b3					_ESULoop:
.21b3	b2 12		lda ($12)			lda 	(temp2) 					; reached the end (offset 0)
.21b5	f0 33		beq $21ea			beq 	_ESUFail
.21b7	a0 03		ldy #$03			ldy 	#3 							; check it is $$define
.21b9	b1 12		lda ($12),y			lda 	(temp2),y
.21bb	c9 cc		cmp #$cc			cmp 	#DefineCode & $FF
.21bd	d0 1e		bne $21dd			bne 	_ESUNext
.21bf	c8		iny				iny
.21c0	b1 12		lda ($12),y			lda 	(temp2),y
.21c2	c9 1c		cmp #$1c			cmp 	#DefineCode >> 8
.21c4	d0 17		bne $21dd			bne 	_ESUNext
.21c6	c8		iny				iny 								; skip length byte.
.21c7					_ESUCompare:
.21c7	c8		iny				iny
.21c8	b1 12		lda ($12),y			lda 	(temp2),y
.21ca	d1 10		cmp ($10),y			cmp 	(temp1),y
.21cc	d0 0f		bne $21dd			bne 	_ESUNext
.21ce	0a		asl a				asl 	a 							; bit 7 set => found it.
.21cf	90 f6		bcc $21c7			bcc 	_ESUCompare
.21d1	a0 01		ldy #$01			ldy 	#1
.21d3	b1 12		lda ($12),y			lda 	(temp2),y 					; read in the line number to YA
.21d5	aa		tax				tax
.21d6	c8		iny				iny
.21d7	b1 12		lda ($12),y			lda 	(temp2),y
.21d9	a8		tay				tay
.21da	8a		txa				txa
.21db	38		sec				sec 								; return with carry set as found
.21dc	60		rts				rts
.21dd					_ESUNext:
.21dd	18		clc				clc
.21de	a5 12		lda $12				lda 	temp2
.21e0	72 12		adc ($12)			adc 	(temp2)
.21e2	85 12		sta $12				sta 	temp2
.21e4	90 02		bcc $21e8			bcc 	_NoCarryAdv
.21e6	e6 13		inc $13				inc 	temp2+1
.21e8					_NoCarryAdv:
.21e8	80 c9		bra $21b3			bra 	_ESULoop 					; and loop round
.21ea					_ESUFail:
.21ea	18		clc				clc
.21eb	60		rts				rts

;******  Return to file: files.asm


;******  Processing file: words/encode/encutils.src

.21ec					EncodeWriteWord:
.21ec	48		pha				pha
.21ed	20 f6 21	jsr $21f6			jsr 	EncodeWriteByte
.21f0	98		tya				tya
.21f1	20 f6 21	jsr $21f6			jsr 	EncodeWriteByte
.21f4	68		pla				pla
.21f5	60		rts				rts
.21f6					EncodeWriteByte:
.21f6	da		phx				phx
.21f7	ae 10 09	ldx $0910			ldx 	encodeBuffer
.21fa	9d 10 09	sta $0910,x			sta 	encodeBuffer,x
.21fd	9e 11 09	stz $0911,x			stz 	encodeBuffer+1,x
.2200	9e 12 09	stz $0912,x			stz 	encodeBuffer+2,x
.2203	ee 10 09	inc $0910			inc 	encodeBuffer
.2206	fa		plx				plx
.2207	60		rts				rts
.2208					CheckIsLetter:
.2208	c9 41		cmp #$41			cmp 	#"A"						; return CS if A..Z
.220a	90 06		bcc $2212			bcc 	_CILFail
.220c	c9 5b		cmp #$5b			cmp 	#"Z"+1
.220e	b0 02		bcs $2212			bcs 	_CILFail
.2210	38		sec				sec
.2211	60		rts				rts
.2212					_CILFail:
.2212	18		clc				clc
.2213	60		rts				rts
.2214					CheckIsDigit:
.2214	c9 30		cmp #$30			cmp 	#"0"						; return CS if 0..9
.2216	90 06		bcc $221e			bcc 	_CIDFail
.2218	c9 3a		cmp #$3a			cmp 	#"9"+1
.221a	b0 02		bcs $221e			bcs 	_CIDFail
.221c	38		sec				sec
.221d	60		rts				rts
.221e					_CIDFail:
.221e	18		clc				clc
.221f	60		rts				rts
.2220					EncodeMoveNextWord:
.2220	a0 ff		ldy #$ff			ldy 	#255 						; search forward
.2222					_EPNWLoop:
.2222	c8		iny				iny
.2223	b1 08		lda ($08),y			lda 	(srcPtr),y
.2225	c9 21		cmp #$21			cmp 	#" "+1						; looking for <= space
.2227	b0 f9		bcs $2222			bcs 	_EPNWLoop
.2229	98		tya				tya
.222a	80 00		bra $222c			bra 	EncodeAddSrcPtr
.222c					EncodeAddSrcPtr:
.222c	18		clc				clc 								; add offset
.222d	65 08		adc $08				adc 	srcPtr
.222f	85 08		sta $08				sta 	srcPtr
.2231	90 02		bcc $2235			bcc 	_EASPNoCarry
.2233	e6 09		inc $09				inc 	srcPtr+1					; carry through
.2235					_EASPNoCarry:
.2235	60		rts				rts
.2236					EncodeGetConstant:
.2236	a5 08		lda $08				lda 	srcPtr 						; get source
.2238	a4 09		ldy $09				ldy 	srcPtr+1
.223a	20 f5 1c	jsr $1cf5			jsr 	ConvertToInteger 			; call converter
.223d	90 08		bcc $2247			bcc 	_EGCExit
.223f	20 2c 22	jsr $222c			jsr 	EncodeAddSrcPtr 			; if passed add chars to src ptr
.2242	a5 14		lda $14				lda 	temp3 						; get result into YA
.2244	a4 15		ldy $15				ldy 	temp3+1
.2246	38		sec				sec 								; return CS
.2247					_EGCExit:
.2247	60		rts				rts
.2248					EncSetBit7Word:
.2248	08		php				php 								; save carry
.2249	a0 ff		ldy #$ff			ldy 	#255 						; scan forward for space/NULL
.224b					_ESB7Loop:
.224b	c8		iny				iny
.224c	b1 08		lda ($08),y			lda 	(srcPtr),y
.224e	c9 21		cmp #$21			cmp 	#" "+1 						; while > ' '
.2250	b0 f9		bcs $224b			bcs 	_ESB7Loop
.2252	88		dey				dey									; previous character
.2253	b1 08		lda ($08),y			lda 	(srcPtr),y 					; read it
.2255	0a		asl a				asl 	a 							; shift bit 7 out
.2256	28		plp				plp 								; restore carry
.2257	6a		ror a				ror 	a 							; shift it in
.2258	91 08		sta ($08),y			sta 	(srcPtr),y 					; write back and exit
.225a	60		rts				rts
.225b					EncSkipSpaces:
.225b	b2 08		lda ($08)			lda 	(srcPtr) 					; skip over spaces/ reached end
.225d	c9 20		cmp #$20			cmp 	#32
.225f	d0 07		bne $2268			bne 	_ESNotSpace
.2261	a9 01		lda #$01			lda 	#1
.2263	20 2c 22	jsr $222c			jsr 	EncodeAddSrcPtr
.2266	80 f3		bra $225b			bra	 	EncSkipSpaces
.2268					_ESNotSpace:
.2268	60		rts				rts
.2269					EncodeTrimTrailingSpaces:
.2269	a0 ff		ldy #$ff			ldy 	#255 						; find EOS
.226b					_ETTFindEnd:
.226b	c8		iny				iny
.226c	b1 08		lda ($08),y			lda 	(srcPtr),y
.226e	d0 fb		bne $226b			bne 	_ETTFindEnd
.2270					_ETTRemoveSpace:
.2270	c0 00		cpy #$00			cpy 	#0 							; start of string
.2272	f0 0d		beq $2281			beq 	_ETTExit
.2274	88		dey				dey 								; previous character 1..32
.2275	b1 08		lda ($08),y			lda 	(srcPtr),y
.2277	c9 21		cmp #$21			cmp 	#32+1
.2279	b0 06		bcs $2281			bcs 	_ETTExit
.227b	a9 00		lda #$00			lda 	#0 							; erase it and go round again
.227d	91 08		sta ($08),y			sta 	(srcPtr),y
.227f	80 ef		bra $2270			bra 	_ETTRemoveSpace
.2281					_ETTExit:
.2281	60		rts				rts
.2282					EncodePushPosMarkerOnStack:
.2282	e6 05		inc $05				inc 	rsp 						; make space on rstack
.2284	a6 05		ldx $05				ldx 	rsp							; access it
.2286	9d 40 07	sta $0740,x			sta 	returnStackHigh,x			; save marker
.2289	ad 10 09	lda $0910			lda 	encodeBuffer 				; save position in encode buffer
.228c	9d 80 07	sta $0780,x			sta 	returnStackX,x
.228f	60		rts				rts

;******  Return to file: files.asm


;******  Processing file: words/encode/encsearch.src

.2290					EncodeSearchDictionary:
.2290	a9 8d		lda #$8d			lda 	#(Dictionary) & $FF
.2292	85 10		sta $10				sta 	0+(temp1)
.2294	a9 25		lda #$25			lda 	#(Dictionary) >> 8
.2296	85 11		sta $11				sta 	1+(temp1)
.2298					_ESDLoop:
.2298	b2 10		lda ($10)			lda 	(temp1) 					; end of dictionary return with CC.
.229a	18		clc				clc
.229b	f0 46		beq $22e3			beq 	_ESDExit
.229d	a0 01		ldy #$01			ldy 	#1 							; get control bits, get offset to name.
.229f	b1 10		lda ($10),y			lda 	(temp1),y
.22a1	4a		lsr a				lsr 	a 							; encode/decode bits move to 0,1
.22a2	4a		lsr a				lsr 	a
.22a3	4a		lsr a				lsr 	a
.22a4	4a		lsr a				lsr 	a
.22a5	c8		iny				iny 								; Y = 2
.22a6	4a		lsr a				lsr 	a
.22a7	90 01		bcc $22aa			bcc 	_ESDNotDec
.22a9	c8		iny				iny
.22aa					_ESDNotDec:
.22aa	4a		lsr a				lsr 	a
.22ab	90 01		bcc $22ae			bcc 	_ESDNotInc
.22ad	c8		iny				iny
.22ae					_ESDNotInc:
.22ae	98		tya				tya
.22af	0a		asl a				asl 	a 							; A is now 4,6,8 offset to name.
.22b0	a8		tay				tay
.22b1	b1 10		lda ($10),y			lda 	(temp1),y 					; quick check of first character
.22b3	d2 08		cmp ($08)			cmp 	(srcPtr)
.22b5	d0 1f		bne $22d6			bne 	_ESDNext 					; do not match, go to next
.22b7	98		tya				tya 								; make temp2 point to the name in
.22b8	18		clc				clc 								; the dictionary.
.22b9	65 10		adc $10				adc 	temp1
.22bb	85 12		sta $12				sta 	temp2
.22bd	a5 11		lda $11				lda 	temp1+1
.22bf	69 00		adc #$00			adc 	#0
.22c1	85 13		sta $13				sta 	temp2+1
.22c3	a0 ff		ldy #$ff			ldy 	#255 						; now start matching up.
.22c5					_ESDCompare:
.22c5	c8		iny				iny
.22c6	b1 08		lda ($08),y			lda 	(srcPtr),y
.22c8	d1 12		cmp ($12),y			cmp 	(temp2),y
.22ca	d0 0a		bne $22d6			bne 	_ESDNext
.22cc	0a		asl a				asl 	a
.22cd	90 f6		bcc $22c5			bcc 	_ESDCompare
.22cf	a5 10		lda $10				lda 	temp1 						; return address in YA and carry set.
.22d1	a4 11		ldy $11				ldy 	temp1+1
.22d3	38		sec				sec
.22d4	80 0d		bra $22e3			bra 	_ESDExit
.22d6					_ESDNext:
.22d6	18		clc				clc
.22d7	a5 10		lda $10				lda 	temp1
.22d9	72 10		adc ($10)			adc 	(temp1)
.22db	85 10		sta $10				sta 	temp1
.22dd	90 b9		bcc $2298			bcc 	_ESDLoop
.22df	e6 11		inc $11				inc 	temp1+1
.22e1	80 b5		bra $2298			bra 	_ESDLoop
.22e3					_ESDExit:
.22e3	60		rts				rts

;******  Return to file: files.asm


;******  Processing file: words/encode/encvar.src

.22e4					EncodeVariableReference:
.22e4	b2 08		lda ($08)			lda 	(srcPtr)					; get the type, use it to identify the routine
.22e6	a2 2e		ldx #$2e			ldx 	#VarAddressHandler & $FF
.22e8	a0 1e		ldy #$1e			ldy 	#VarAddressHandler >> 8
.22ea	c9 26		cmp #$26			cmp 	#"&"
.22ec	f0 0c		beq $22fa			beq 	_EVFHaveAddress
.22ee	a2 4b		ldx #$4b			ldx 	#VarReadHandler & $FF
.22f0	a0 1e		ldy #$1e			ldy 	#VarReadHandler >> 8
.22f2	c9 40		cmp #$40			cmp 	#"@"
.22f4	f0 04		beq $22fa			beq 	_EVFHaveAddress
.22f6	a2 6a		ldx #$6a			ldx 	#VarWriteHandler & $FF
.22f8	a0 1e		ldy #$1e			ldy 	#VarWriteHandler >> 8
.22fa					_EVFHaveAddress:
.22fa	8a		txa				txa
.22fb	20 ec 21	jsr $21ec			jsr 	EncodeWriteWord 			; write it out.
.22fe	a0 01		ldy #$01			ldy 	#1 							; get the first charactere
.2300	b1 08		lda ($08),y			lda 	(srcPtr),y
.2302	29 7f		and #$7f			and 	#$7F 						; might be the last.
.2304	20 08 22	jsr $2208			jsr 	CheckIsLetter 				; is it A-Z
.2307	90 54		bcc $235d			bcc 	EVFFail
.2309	29 1f		and #$1f			and 	#31 						; make 1-26
.230b	85 10		sta $10				sta 	temp1 						; start building the name in temp1
.230d	64 11		stz $11				stz 	temp1+1
.230f	38		sec				sec 								; possible char 2
.2310	20 72 23	jsr $2372			jsr 	EncVarAlNum
.2313	18		clc				clc 								; possible char 3
.2314	20 72 23	jsr $2372			jsr 	EncVarAlNum
.2317	5a		phy				phy
.2318	a5 10		lda $10				lda 	temp1 						; write out variable identifier.
.231a	a4 11		ldy $11				ldy 	temp1+1
.231c	20 ec 21	jsr $21ec			jsr 	EncodeWriteWord
.231f	7a		ply				ply
.2320	b1 08		lda ($08),y			lda 	(srcPtr),y 					; more text after ?
.2322	10 01		bpl $2325			bpl 	_EVFCheckArray
.2324	60		rts				rts
.2325					_EVFCheckArray:
.2325	c8		iny				iny 								; get the next character
.2326	b1 08		lda ($08),y			lda 	(srcPtr),y
.2328	c9 5b		cmp #$5b			cmp 	#"["						; array index ?
.232a	d0 31		bne $235d			bne 	EVFFail
.232c	64 10		stz $10				stz 	temp1 						; zero temp1.
.232e	c8		iny				iny  								; point to index
.232f					_EVFGetIndex:
.232f	06 10		asl $10				asl 	temp1 						; temp1 x 10
.2331	a5 10		lda $10				lda 	temp1
.2333	0a		asl a				asl 	a
.2334	0a		asl a				asl		a
.2335	65 10		adc $10				adc 	temp1
.2337	85 10		sta $10				sta 	temp1
.2339	b1 08		lda ($08),y			lda 	(srcPtr),y 					; get the digit
.233b	20 14 22	jsr $2214			jsr 	CheckIsDigit
.233e	90 1d		bcc $235d			bcc 	EVFFail 					; failed, not digit
.2340	29 0f		and #$0f			and 	#15
.2342	18		clc				clc
.2343	65 10		adc $10				adc 	temp1
.2345	30 16		bmi $235d			bmi 	EVFFail 					; failed, bad index.
.2347	85 10		sta $10				sta 	temp1
.2349	c8		iny				iny
.234a	b1 08		lda ($08),y			lda 	(srcPtr),y
.234c	c9 dd		cmp #$dd			cmp 	#"]"+$80
.234e	d0 df		bne $232f			bne 	_EVFGetIndex 				; index now in temp1.
.2350	a9 89		lda #$89			lda 	#IndexHandler & $FF 		; output code
.2352	a0 1e		ldy #$1e			ldy 	#IndexHandler >> 8
.2354	20 ec 21	jsr $21ec			jsr 	EncodeWriteWord
.2357	a5 10		lda $10				lda 	temp1	 					; write index
.2359	20 f6 21	jsr $21f6			jsr 	EncodeWriteByte
.235c	60		rts				rts
.235d					EVFFail:
.235d	20 4f 24	jsr $244f			jsr 	ErrorHandler
>2360	42 41 44 20 56 41 52 49				.text 	"BAD VARIABLE NAME",0
>2368	41 42 4c 45 20 4e 41 4d 45 00
.2372					EncVarAlNum:
.2372	b1 08		lda ($08),y			lda 	(srcPtr),y 					; points to the  last char processed.
.2374	10 01		bpl $2377			bpl 	_EVAContinue
.2376	60		rts				rts
.2377					_EVAContinue:
.2377	08		php				php 								; CS x 32 ; CC x 32 x 40
.2378	c8		iny				iny 								; get the next character, strip bit 7
.2379	b1 08		lda ($08),y			lda 	(srcPtr),y
.237b	88		dey				dey
.237c	29 7f		and #$7f			and 	#$7F
.237e	20 08 22	jsr $2208			jsr 	CheckIsLetter 				; letter ?
.2381	b0 08		bcs $238b			bcs 	_EVACharOkay
.2383	20 14 22	jsr $2214			jsr 	CheckIsDigit				; fail if not digit.
.2386	90 32		bcc $23ba			bcc 	_EVAExit
.2388	18		clc				clc
.2389	69 2b		adc #$2b			adc 	#"Z"+1-"0"					; shift 0 so after Z
.238b					_EVACharOkay:
.238b	c8		iny				iny 								; char okay advance to it.
.238c	38		sec				sec 								; range 1-36
.238d	e9 40		sbc #$40			sbc 	#64
.238f	28		plp				plp 								; which multiplier ?
.2390	90 0f		bcc $23a1			bcc 	_EVATimes32x40
.2392	85 12		sta $12				sta 	temp2 						; save in temp2 - A x 32
.2394	64 13		stz $13				stz 	temp2+1
.2396	a2 05		ldx #$05			ldx 	#5
.2398	06 12		asl $12		_EVA32:	asl 	temp2
.239a	26 13		rol $13				rol 	temp2+1
.239c	ca		dex				dex
.239d	d0 f9		bne $2398			bne 	_EVA32
.239f	80 0b		bra $23ac			bra 	_EVAAddVar
.23a1					_EVATimes32x40:
.23a1	85 13		sta $13				sta 	temp2+1						; 32 x 40 = 1280 or $500, so temp2 = A x 256 x 5
.23a3	64 12		stz $12				stz 	temp2
.23a5	0a		asl a				asl 	a
.23a6	0a		asl a				asl 	a
.23a7	18		clc				clc
.23a8	65 13		adc $13				adc 	temp2+1
.23aa	85 13		sta $13				sta 	temp2+1
.23ac					_EVAAddVar:
.23ac	18		clc				clc
.23ad	a5 10		lda $10				lda 	temp1
.23af	65 12		adc $12				adc 	temp2
.23b1	85 10		sta $10				sta 	temp1
.23b3	a5 11		lda $11				lda 	temp1+1
.23b5	65 13		adc $13				adc 	temp2+1
.23b7	85 11		sta $11				sta 	temp1+1
.23b9	08		php				php
.23ba					_EVAExit:
.23ba	28		plp				plp
.23bb	60		rts				rts

;******  Return to file: files.asm


;******  Return to file: kernel.asm

.23bc					ColdStart:
.23bc	a2 ff		ldx #$ff			ldx 	#$FF 						; reset the stack
.23be	9a		txs				txs
.23bf	20 82 24	jsr $2482			jsr 	ExternInitialise
.23c2	a9 fd		lda #$fd			lda 	#BootMsg & $FF
.23c4	a0 23		ldy #$23			ldy 	#BootMsg >> 8
.23c6	20 76 25	jsr $2576			jsr 	EXPrintString
.23c9					WarmStartBlankStack:
.23c9	86 10		stx $10				stx 	temp1
.23cb	a2 80		ldx #$80			ldx 	#NumberStackBase
.23cd	9a		txs				txs
.23ce	a6 10		ldx $10				ldx 	temp1
.23d0					WarmStart:
.23d0	a9 03		lda #$03			lda 	#COL_Yellow
.23d2	20 bb 24	jsr $24bb			jsr 	ExternColour
.23d5	20 de 24	jsr $24de			jsr 	ExternInput
.23d8	a9 06		lda #$06			lda 	#COL_Cyan
.23da	20 bb 24	jsr $24bb			jsr 	ExternColour
.23dd	a2 10		ldx #$10			ldx 	#encodeBuffer & $FF 		; run what is in the encode buffer.
.23df	a0 09		ldy #$09			ldy 	#encodeBuffer >> 8
.23e1	20 03 10	jsr $1003			jsr 	InitialiseCoreCode 			; initialise the NEXT routine at $00 so error line# works
.23e4	a9 10		lda #$10			lda 	#textBuffer & $FF
.23e6	a0 08		ldy #$08			ldy 	#textBuffer >> 8
.23e8	20 dc 1f	jsr $1fdc			jsr 	EncodeProgram
.23eb	ad 11 09	lda $0911			lda 	encodeBuffer+1 				; has a line number been entered ?
.23ee	0d 12 09	ora $0912			ora 	encodeBuffer+2
.23f1	d0 05		bne $23f8			bne 	LineEditor 					; if so, do the line editing code.
.23f3	64 05		stz $05				stz 	rsp
.23f5	4c 00 00	jmp $0000			jmp 	NextCode
.23f8					LineEditor:
.23f8	20 82 19	jsr $1982			jsr 	EditProgram
.23fb	80 cc		bra $23c9			bra 	WarmStartBlankStack
.23fd					BootMsg:
>23fd	2a 2a 2a 20 52 50 4c 2f				.text 	"*** RPL/C INTERPRETER ***",13,13
>2405	43 20 49 4e 54 45 52 50 52 45 54 45 52 20 2a 2a
>2415	2a 0d 0d
>2418	57 52 49 54 54 45 4e 20				.text	"WRITTEN BY PAUL ROBSON 2020",13,13
>2420	42 59 20 50 41 55 4c 20 52 4f 42 53 4f 4e 20 32
>2430	30 32 30 0d 0d
>2435	42 55 49 4c 44 3a 20				.text 	"BUILD: "

;******  Processing file: generated/timestamp.inc

>243c	5b 32 30 2d 30 31 2d 31			.text	"[20-01-17 08:05]"
>2444	37 20 30 38 3a 30 35 5d

;******  Return to file: kernel.asm

>244c	0d 0d 00					.byte 	13,13,0

;******  Processing file: code/error.asm

.244f					ErrorHandler:
.244f	68		pla				pla 								; get message address
.2450	7a		ply				ply
.2451	1a		inc a				inc 	a
.2452	d0 01		bne $2455			bne 	_EHNoCarry
.2454	c8		iny				iny
.2455					_EHNoCarry:
.2455	20 76 25	jsr $2576			jsr 	EXPrintString
.2458	a0 01		ldy #$01			ldy 	#1 							; check if there is a line #
.245a	b1 03		lda ($03),y			lda 	(IP),y
.245c	c8		iny				iny
.245d	11 03		ora ($03),y			ora 	(IP),y
.245f	f0 14		beq $2475			beq 	_EHNoLine
.2461	a9 7d		lda #$7d			lda 	#_EHMsg2 & $FF 				; print " at "
.2463	a0 24		ldy #$24			ldy 	#_EHMsg2 >> 8
.2465	20 76 25	jsr $2576			jsr 	EXPrintString
.2468	a0 02		ldy #$02			ldy 	#2 							; print line number
.246a	b1 03		lda ($03),y			lda 	(IP),y
.246c	48		pha				pha
.246d	88		dey				dey
.246e	b1 03		lda ($03),y			lda 	(IP),y
.2470	7a		ply				ply
.2471	18		clc				clc
.2472	20 9d 1d	jsr $1d9d			jsr 	PrintYA
.2475					_EHNoLine:
.2475	a9 0d		lda #$0d			lda 	#13
.2477	20 af 24	jsr $24af			jsr 	ExternPrint
.247a	4c c9 23	jmp $23c9			jmp 	WarmStartBlankStack			; S is indeterminate
>247d	20 41 54 20 00			_EHMsg2:.text 	" AT ",0

;******  Return to file: kernel.asm


;******  Processing file: code/extern.asm

.2482					ExternInitialise:
.2482	a9 90		lda #$90			lda 	#144 						; set colour
.2484	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.2487	a9 01		lda #$01			lda 	#$01
.2489	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.248c	a9 0e		lda #$0e			lda 	#14							; lower case
.248e	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.2491	a9 93		lda #$93			lda 	#147 						; clear screen
.2493	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.2496	a9 07		lda #$07			lda 	#COL_WHITE 					; white text.
.2498	4c bb 24	jmp $24bb			jmp 	ExternColour
.249b					ExternCheckBreak:
.249b	da		phx				phx 								; make sure we keep XY
.249c	5a		phy				phy
.249d	20 e1 ff	jsr $ffe1			jsr 	$FFE1						; STOP check on CBM KERNAL
.24a0	f0 03		beq $24a5			beq		_ECBExit 					; stopped
.24a2	7a		ply				ply 								; restore and exit.
.24a3	fa		plx				plx
.24a4	60		rts				rts
.24a5					_ECBExit:
.24a5	20 4f 24	jsr $244f			jsr 	ErrorHandler
>24a8	45 53 43 41 50 45 00				.text 	"ESCAPE",0
.24af					ExternPrint:
.24af	48		pha				pha
.24b0	da		phx				phx
.24b1	5a		phy				phy
.24b2	29 7f		and #$7f			and 	#$7F
.24b4	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.24b7	7a		ply				ply
.24b8	fa		plx				plx
.24b9	68		pla				pla
.24ba	60		rts				rts
.24bb					ExternColour:
.24bb	48		pha				pha
.24bc	da		phx				phx
.24bd	48		pha				pha
.24be	29 08		and #$08			and 	#8
.24c0	0a		asl a				asl 	a
.24c1	0a		asl a				asl 	a
.24c2	0a		asl a				asl 	a
.24c3	0a		asl a				asl 	a
.24c4	49 92		eor #$92			eor 	#$92
.24c6	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.24c9	68		pla				pla
.24ca	29 07		and #$07			and 	#7
.24cc	aa		tax				tax
.24cd	bd d6 24	lda $24d6,x			lda 	_ECTable,x
.24d0	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.24d3	fa		plx				plx
.24d4	68		pla				pla
.24d5	60		rts				rts
.24d6					_ECTable:
>24d6	90						.byte 	144
>24d7	1c						.byte 	28
>24d8	1e						.byte 	30
>24d9	9e						.byte 	158
>24da	1f						.byte 	31
>24db	9c						.byte 	156
>24dc	9f						.byte 	159
>24dd	05						.byte 	5
.24de					ExternInput:
.24de	a9 10		lda #$10			lda 	#(textBuffer & $FF)
.24e0	85 14		sta $14				sta 	temp3
.24e2	a9 08		lda #$08			lda 	#(textBuffer >> 8)
.24e4	85 15		sta $15				sta 	temp3+1
.24e6	20 cf ff	jsr $ffcf	_EIRead:jsr 	$FFCF
.24e9	c9 0d		cmp #$0d			cmp 	#13
.24eb	f0 0c		beq $24f9			beq 	_EIExit
.24ed	29 7f		and #$7f			and 	#$7F
.24ef	92 14		sta ($14)			sta 	(temp3)
.24f1	e6 14		inc $14				inc 	temp3
.24f3	d0 f1		bne $24e6			bne 	_EIRead
.24f5	e6 15		inc $15				inc 	temp3+1
.24f7	80 ed		bra $24e6			bra 	_EIRead
.24f9	a9 00		lda #$00	_EIExit:lda 	#0
.24fb	92 14		sta ($14)			sta 	(temp3)
.24fd	a9 0d		lda #$0d			lda 	#13
.24ff	20 af 24	jsr $24af			jsr 	ExternPrint
.2502	60		rts				rts
.2503					ExternSave:
.2503	da		phx				phx
.2504	5a		phy				phy
.2505	85 12		sta $12				sta 	temp2 						; save start
.2507	84 13		sty $13				sty 	temp2+1
.2509	20 6b 25	jsr $256b			jsr 	EXGetLength 				; get length of file into A
.250c	a6 14		ldx $14				ldx 	temp3
.250e	a4 15		ldy $15				ldy 	temp3+1
.2510	20 bd ff	jsr $ffbd			jsr 	$FFBD 						; set name
.2513	a9 01		lda #$01			lda 	#1
.2515	a2 08		ldx #$08			ldx 	#8	 						; device #8
.2517	a0 00		ldy #$00			ldy 	#0
.2519	20 ba ff	jsr $ffba			jsr 	$FFBA 						; set LFS
.251c	a6 10		ldx $10				ldx 	temp1 						; end address
.251e	a4 11		ldy $11				ldy 	temp1+1
.2520	a9 12		lda #$12			lda 	#temp2
.2522	20 d8 ff	jsr $ffd8			jsr 	$FFD8 						; save
.2525	b0 03		bcs $252a			bcs 	_ESSave
.2527	7a		ply				ply
.2528	fa		plx				plx
.2529	60		rts				rts
.252a					_ESSave:
.252a	20 4f 24	jsr $244f			jsr 	ErrorHandler
>252d	53 41 56 45 20 46 41 49				.text 	"SAVE FAILED",0
>2535	4c 45 44 00
.2539					ExternLoad:
.2539	da		phx				phx 								; save XY
.253a	5a		phy				phy
.253b	48		pha				pha 								; save target
.253c	5a		phy				phy
.253d	20 6b 25	jsr $256b			jsr 	EXGetLength 				; get length of file into A
.2540	a6 14		ldx $14				ldx 	temp3
.2542	a4 15		ldy $15				ldy 	temp3+1
.2544	20 bd ff	jsr $ffbd			jsr 	$FFBD 						; set name
.2547	a9 01		lda #$01			lda 	#1
.2549	a2 08		ldx #$08			ldx 	#8	 						; device #8
.254b	a0 00		ldy #$00			ldy 	#0
.254d	20 ba ff	jsr $ffba			jsr 	$FFBA 						; set LFS
.2550	7a		ply				ply 								; restore target to YX and call load
.2551	fa		plx				plx
.2552	a9 00		lda #$00			lda 	#0 							; load command
.2554	20 d5 ff	jsr $ffd5			jsr 	$FFD5
.2557	b0 03		bcs $255c			bcs 	_ESLoad
.2559	7a		ply				ply
.255a	fa		plx				plx
.255b	60		rts				rts
.255c					_ESLoad:
.255c	20 4f 24	jsr $244f			jsr 	ErrorHandler
>255f	4c 4f 41 44 20 46 41 49				.text 	"LOAD FAILED",0
>2567	4c 45 44 00
.256b					EXGetLength:
.256b	5a		phy				phy
.256c	a0 ff		ldy #$ff			ldy 	#255
.256e	c8		iny		_EXGL0:	iny
.256f	b1 14		lda ($14),y			lda 	(temp3),y
.2571	d0 fb		bne $256e			bne 	_EXGL0
.2573	98		tya				tya
.2574	7a		ply				ply
.2575	60		rts				rts
.2576					EXPrintString:
.2576	48		pha				pha
.2577	5a		phy				phy
.2578	84 11		sty $11				sty 	temp1+1
.257a	85 10		sta $10				sta 	temp1
.257c	a0 00		ldy #$00			ldy 	#0
.257e					_EXPSLoop:
.257e	b1 10		lda ($10),y			lda 	(temp1),y
.2580	f0 08		beq $258a			beq 	_EXPSExit
.2582	29 7f		and #$7f			and 	#$7F
.2584	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.2587	c8		iny				iny
.2588	80 f4		bra $257e			bra 	_EXPSLoop
.258a					_EXPSExit:
.258a	7a		ply				ply
.258b	68		pla				pla
.258c	60		rts				rts

;******  Return to file: kernel.asm

.258d					Dictionary:

;******  Processing file: generated/dictionary.inc

>258d	05					.byte	_end0-*
>258e	00					.byte	$00
>258f	b2 14					.word	WordWrite
>2591	a1					.byte	$a1
.2592					_end0:
>2592	10					.byte	_end1-*
>2593	52					.byte	$52
>2594	6a 1e					.word	VarWriteHandler
>2596	84 1e					.word	VarWriteHandlerDecode
>2598	24 24 21 48 41 4e 44 4c			.byte	$24,$24,$21,$48,$41,$4e,$44,$4c,$45,$d2
>25a0	45 d2
.25a2					_end1:
>25a2	10					.byte	_end2-*
>25a3	52					.byte	$52
>25a4	2e 1e					.word	VarAddressHandler
>25a6	46 1e					.word	VarAddrHandlerDecode
>25a8	24 24 26 48 41 4e 44 4c			.byte	$24,$24,$26,$48,$41,$4e,$44,$4c,$45,$d2
>25b0	45 d2
.25b2					_end2:
>25b2	10					.byte	_end3-*
>25b3	52					.byte	$52
>25b4	4b 1e					.word	VarReadHandler
>25b6	65 1e					.word	VarReadHandlerDecode
>25b8	24 24 40 48 41 4e 44 4c			.byte	$24,$24,$40,$48,$41,$4e,$44,$4c,$45,$d2
>25c0	45 d2
.25c2					_end3:
>25c2	0c					.byte	_end4-*
>25c3	52					.byte	$52
>25c4	87 16					.word	CallHandler
>25c6	60 17					.word	CallHandlerDecode
>25c8	24 24 43 41 4c cc			.byte	$24,$24,$43,$41,$4c,$cc
.25ce					_end4:
>25ce	0f					.byte	_end5-*
>25cf	53					.byte	$53
>25d0	a1 1c					.word	SkipComment
>25d2	ae 1c					.word	CommentDecoder
>25d4	24 24 43 4f 4d 4d 45 4e			.byte	$24,$24,$43,$4f,$4d,$4d,$45,$4e,$d4
>25dc	d4
.25dd					_end5:
>25dd	0e					.byte	_end6-*
>25de	53					.byte	$53
>25df	cc 1c					.word	DefineCode
>25e1	e2 1c					.word	DefineDecoder
>25e3	24 24 44 45 46 49 4e c5			.byte	$24,$24,$44,$45,$46,$49,$4e,$c5
.25eb					_end6:
>25eb	0f					.byte	_end7-*
>25ec	52					.byte	$52
>25ed	15 10					.word	Literal2Byte
>25ef	5d 10					.word	Literal2ByteDecode
>25f1	24 24 4c 49 54 45 52 41			.byte	$24,$24,$4c,$49,$54,$45,$52,$41,$cc
>25f9	cc
.25fa					_end7:
>25fa	0e					.byte	_end8-*
>25fb	80					.byte	$80
>25fc	8a 1c					.word	NextLine
>25fe	24 24 4e 45 58 54 4c 49			.byte	$24,$24,$4e,$45,$58,$54,$4c,$49,$4e,$c5
>2606	4e c5
.2608					_end8:
>2608	0e					.byte	_end9-*
>2609	53					.byte	$53
>260a	6f 10					.word	LiteralString
>260c	8e 10					.word	LiteralStringDecoder
>260e	24 24 53 54 52 49 4e c7			.byte	$24,$24,$53,$54,$52,$49,$4e,$c7
.2616					_end9:
>2616	05					.byte	_end10-*
>2617	00					.byte	$00
>2618	2e 12					.word	Multiply16x16
>261a	aa					.byte	$aa
.261b					_end10:
>261b	05					.byte	_end11-*
>261c	00					.byte	$00
>261d	9f 10					.word	Add
>261f	ab					.byte	$ab
.2620					_end11:
>2620	06					.byte	_end12-*
>2621	00					.byte	$00
>2622	c3 14					.word	WordAdd
>2624	2b a1					.byte	$2b,$a1
.2626					_end12:
>2626	05					.byte	_end13-*
>2627	00					.byte	$00
>2628	ae 10					.word	Subtract
>262a	ad					.byte	$ad
.262b					_end13:
>262b	06					.byte	_end14-*
>262c	00					.byte	$00
>262d	6a 13					.word	ConstantMinus1
>262f	2d b1					.byte	$2d,$b1
.2631					_end14:
>2631	06					.byte	_end15-*
>2632	00					.byte	$00
>2633	51 1b					.word	DumpStack
>2635	2e ae					.byte	$2e,$ae
.2637					_end15:
>2637	05					.byte	_end16-*
>2638	00					.byte	$00
>2639	7f 11					.word	Divide16x16
>263b	af					.byte	$af
.263c					_end16:
>263c	05					.byte	_end17-*
>263d	00					.byte	$00
>263e	5d 13					.word	Constant0
>2640	b0					.byte	$b0
.2641					_end17:
>2641	06					.byte	_end18-*
>2642	00					.byte	$00
>2643	c3 12					.word	CheckMinus
>2645	30 bc					.byte	$30,$bc
.2647					_end18:
>2647	06					.byte	_end19-*
>2648	00					.byte	$00
>2649	d7 12					.word	CheckZero
>264b	30 bd					.byte	$30,$bd
.264d					_end19:
>264d	05					.byte	_end20-*
>264e	00					.byte	$00
>264f	79 13					.word	C1
>2651	b1					.byte	$b1
.2652					_end20:
>2652	06					.byte	_end21-*
>2653	00					.byte	$00
>2654	6d 12					.word	Unary1Plus
>2656	31 ab					.byte	$31,$ab
.2658					_end21:
>2658	06					.byte	_end22-*
>2659	00					.byte	$00
>265a	84 12					.word	Unary1Minus
>265c	31 ad					.byte	$31,$ad
.265e					_end22:
>265e	06					.byte	_end23-*
>265f	00					.byte	$00
>2660	91 13					.word	C10
>2662	31 b0					.byte	$31,$b0
.2664					_end23:
>2664	07					.byte	_end24-*
>2665	00					.byte	$00
>2666	ba 13					.word	C100
>2668	31 30 b0				.byte	$31,$30,$b0
.266b					_end24:
>266b	08					.byte	_end25-*
>266c	00					.byte	$00
>266d	e9 13					.word	C1024
>266f	31 30 32 b4				.byte	$31,$30,$32,$b4
.2673					_end25:
>2673	07					.byte	_end26-*
>2674	00					.byte	$00
>2675	be 13					.word	C127
>2677	31 32 b7				.byte	$31,$32,$b7
.267a					_end26:
>267a	07					.byte	_end27-*
>267b	00					.byte	$00
>267c	c2 13					.word	C128
>267e	31 32 b8				.byte	$31,$32,$b8
.2681					_end27:
>2681	06					.byte	_end28-*
>2682	00					.byte	$00
>2683	95 13					.word	C15
>2685	31 b5					.byte	$31,$b5
.2687					_end28:
>2687	06					.byte	_end29-*
>2688	00					.byte	$00
>2689	99 13					.word	C16
>268b	31 b6					.byte	$31,$b6
.268d					_end29:
>268d	07					.byte	_end30-*
>268e	00					.byte	$00
>268f	fb 12					.word	Times16
>2691	31 36 aa				.byte	$31,$36,$aa
.2694					_end30:
>2694	07					.byte	_end31-*
>2695	00					.byte	$00
>2696	0e 13					.word	Divide16
>2698	31 36 af				.byte	$31,$36,$af
.269b					_end31:
>269b	05					.byte	_end32-*
>269c	00					.byte	$00
>269d	7d 13					.word	C2
>269f	b2					.byte	$b2
.26a0					_end32:
>26a0	06					.byte	_end33-*
>26a1	00					.byte	$00
>26a2	07 13					.word	Times2
>26a4	32 aa					.byte	$32,$aa
.26a6					_end33:
>26a6	06					.byte	_end34-*
>26a7	00					.byte	$00
>26a8	76 12					.word	Unary2Plus
>26aa	32 ab					.byte	$32,$ab
.26ac					_end34:
>26ac	06					.byte	_end35-*
>26ad	00					.byte	$00
>26ae	8f 12					.word	Unary2Minus
>26b0	32 ad					.byte	$32,$ad
.26b2					_end35:
>26b2	06					.byte	_end36-*
>26b3	00					.byte	$00
>26b4	1a 13					.word	Divide2
>26b6	32 af					.byte	$32,$af
.26b8					_end36:
>26b8	06					.byte	_end37-*
>26b9	00					.byte	$00
>26ba	9d 13					.word	C24
>26bc	32 b4					.byte	$32,$b4
.26be					_end37:
>26be	07					.byte	_end38-*
>26bf	00					.byte	$00
>26c0	c6 13					.word	C255
>26c2	32 35 b5				.byte	$32,$35,$b5
.26c5					_end38:
>26c5	07					.byte	_end39-*
>26c6	00					.byte	$00
>26c7	d1 13					.word	C256
>26c9	32 35 b6				.byte	$32,$35,$b6
.26cc					_end39:
>26cc	08					.byte	_end40-*
>26cd	00					.byte	$00
>26ce	21 13					.word	Times256
>26d0	32 35 36 aa				.byte	$32,$35,$36,$aa
.26d4					_end40:
>26d4	08					.byte	_end41-*
>26d5	00					.byte	$00
>26d6	2a 13					.word	Divide256
>26d8	32 35 36 af				.byte	$32,$35,$36,$af
.26dc					_end41:
>26dc	05					.byte	_end42-*
>26dd	00					.byte	$00
>26de	81 13					.word	C3
>26e0	b3					.byte	$b3
.26e1					_end42:
>26e1	06					.byte	_end43-*
>26e2	00					.byte	$00
>26e3	ae 13					.word	C32
>26e5	33 b2					.byte	$33,$b2
.26e7					_end43:
>26e7	09					.byte	_end44-*
>26e8	00					.byte	$00
>26e9	01 14					.word	C32767
>26eb	33 32 37 36 b7				.byte	$33,$32,$37,$36,$b7
.26f0					_end44:
>26f0	09					.byte	_end45-*
>26f1	00					.byte	$00
>26f2	0d 14					.word	C32768
>26f4	33 32 37 36 b8				.byte	$33,$32,$37,$36,$b8
.26f9					_end45:
>26f9	05					.byte	_end46-*
>26fa	00					.byte	$00
>26fb	85 13					.word	C4
>26fd	b4					.byte	$b4
.26fe					_end46:
>26fe	06					.byte	_end47-*
>26ff	00					.byte	$00
>2700	03 13					.word	Times4
>2702	34 aa					.byte	$34,$aa
.2704					_end47:
>2704	06					.byte	_end48-*
>2705	00					.byte	$00
>2706	16 13					.word	Divide4
>2708	34 af					.byte	$34,$af
.270a					_end48:
>270a	08					.byte	_end49-*
>270b	00					.byte	$00
>270c	f5 13					.word	C4096
>270e	34 30 39 b6				.byte	$34,$30,$39,$b6
.2712					_end49:
>2712	05					.byte	_end50-*
>2713	00					.byte	$00
>2714	89 13					.word	C5
>2716	b5					.byte	$b5
.2717					_end50:
>2717	07					.byte	_end51-*
>2718	00					.byte	$00
>2719	dd 13					.word	C512
>271b	35 31 b2				.byte	$35,$31,$b2
.271e					_end51:
>271e	06					.byte	_end52-*
>271f	00					.byte	$00
>2720	b2 13					.word	C63
>2722	36 b3					.byte	$36,$b3
.2724					_end52:
>2724	06					.byte	_end53-*
>2725	00					.byte	$00
>2726	b6 13					.word	C64
>2728	36 b4					.byte	$36,$b4
.272a					_end53:
>272a	05					.byte	_end54-*
>272b	00					.byte	$00
>272c	8d 13					.word	C8
>272e	b8					.byte	$b8
.272f					_end54:
>272f	06					.byte	_end55-*
>2730	00					.byte	$00
>2731	ff 12					.word	Times8
>2733	38 aa					.byte	$38,$aa
.2735					_end55:
>2735	06					.byte	_end56-*
>2736	00					.byte	$00
>2737	12 13					.word	Divide8
>2739	38 af					.byte	$38,$af
.273b					_end56:
>273b	05					.byte	_end57-*
>273c	40					.byte	$40
>273d	1d 17					.word	ReturnHandler
>273f	bb					.byte	$bb
.2740					_end57:
>2740	05					.byte	_end58-*
>2741	00					.byte	$00
>2742	1b 11					.word	CheckLess
>2744	bc					.byte	$bc
.2745					_end58:
>2745	06					.byte	_end59-*
>2746	00					.byte	$00
>2747	34 11					.word	CheckLessEq
>2749	3c bd					.byte	$3c,$bd
.274b					_end59:
>274b	06					.byte	_end60-*
>274c	00					.byte	$00
>274d	e4 10					.word	CheckNotEqual
>274f	3c be					.byte	$3c,$be
.2751					_end60:
>2751	05					.byte	_end61-*
>2752	00					.byte	$00
>2753	e7 10					.word	CheckEqual
>2755	bd					.byte	$bd
.2756					_end61:
>2756	05					.byte	_end62-*
>2757	00					.byte	$00
>2758	37 11					.word	CheckGreater
>275a	be					.byte	$be
.275b					_end62:
>275b	06					.byte	_end63-*
>275c	00					.byte	$00
>275d	18 11					.word	CheckGreaterEq
>275f	3e bd					.byte	$3e,$bd
.2761					_end63:
>2761	08					.byte	_end64-*
>2762	00					.byte	$00
>2763	22 14					.word	TestDup
>2765	3f 44 55 d0				.byte	$3f,$44,$55,$d0
.2769					_end64:
>2769	05					.byte	_end65-*
>276a	00					.byte	$00
>276b	97 14					.word	WordRead
>276d	c0					.byte	$c0
.276e					_end65:
>276e	07					.byte	_end66-*
>276f	00					.byte	$00
>2770	9d 12					.word	Absolute
>2772	41 42 d3				.byte	$41,$42,$d3
.2775					_end66:
>2775	09					.byte	_end67-*
>2776	00					.byte	$00
>2777	da 14					.word	AllocateMemory
>2779	41 4c 4c 4f c3				.byte	$41,$4c,$4c,$4f,$c3
.277e					_end67:
>277e	07					.byte	_end68-*
>277f	00					.byte	$00
>2780	bd 10					.word	And
>2782	41 4e c4				.byte	$41,$4e,$c4
.2785					_end68:
>2785	0a					.byte	_end69-*
>2786	00					.byte	$00
>2787	dc 1a					.word	AssertCode
>2789	41 53 53 45 52 d4			.byte	$41,$53,$53,$45,$52,$d4
.278f					_end69:
>278f	09					.byte	_end70-*
>2790	00					.byte	$00
>2791	f0 12					.word	ByteSwap
>2793	42 53 57 41 d0				.byte	$42,$53,$57,$41,$d0
.2798					_end70:
>2798	06					.byte	_end71-*
>2799	00					.byte	$00
>279a	a5 14					.word	ByteWrite
>279c	43 a1					.byte	$43,$a1
.279e					_end71:
>279e	06					.byte	_end72-*
>279f	00					.byte	$00
>27a0	8e 14					.word	ByteRead
>27a2	43 c0					.byte	$43,$c0
.27a4					_end72:
>27a4	07					.byte	_end73-*
>27a5	00					.byte	$00
>27a6	ea 17					.word	ClrHandler
>27a8	43 4c d2				.byte	$43,$4c,$d2
.27ab					_end73:
>27ab	08					.byte	_end74-*
>27ac	00					.byte	$00
>27ad	19 14					.word	Drop
>27af	44 52 4f d0				.byte	$44,$52,$4f,$d0
.27b3					_end74:
>27b3	07					.byte	_end75-*
>27b4	00					.byte	$00
>27b5	2b 14					.word	Dup
>27b7	44 55 d0				.byte	$44,$55,$d0
.27ba					_end75:
>27ba	0a					.byte	_end76-*
>27bb	21					.byte	$21
>27bc	d3 15					.word	ElseHandler
>27be	d6 15					.word	ElseEncoder
>27c0	45 4c 53 c5				.byte	$45,$4c,$53,$c5
.27c4					_end76:
>27c4	07					.byte	_end77-*
>27c5	00					.byte	$00
>27c6	fd 1a					.word	EndProgram
>27c8	45 4e c4				.byte	$45,$4e,$c4
.27cb					_end77:
>27cb	0b					.byte	_end78-*
>27cc	20					.byte	$20
>27cd	f5 15					.word	EndIfHandler
>27cf	f8 15					.word	EndIfEncoder
>27d1	45 4e 44 49 c6				.byte	$45,$4e,$44,$49,$c6
.27d6					_end78:
>27d6	09					.byte	_end79-*
>27d7	20					.byte	$20
>27d8	f3 14					.word	ForHandler
>27da	29 15					.word	ForEncoder
>27dc	46 4f d2				.byte	$46,$4f,$d2
.27df					_end79:
>27df	08					.byte	_end80-*
>27e0	21					.byte	$21
>27e1	be 15					.word	IfHandler
>27e3	c1 15					.word	IfEncoder
>27e5	49 c6					.byte	$49,$c6
.27e7					_end80:
>27e7	09					.byte	_end81-*
>27e8	00					.byte	$00
>27e9	9d 15					.word	GetIndex
>27eb	49 4e 44 45 d8				.byte	$49,$4e,$44,$45,$d8
.27f0					_end81:
>27f0	08					.byte	_end82-*
>27f1	00					.byte	$00
>27f2	36 1a					.word	ListCode
>27f4	4c 49 53 d4				.byte	$4c,$49,$53,$d4
.27f8					_end82:
>27f8	07					.byte	_end83-*
>27f9	00					.byte	$00
>27fa	54 11					.word	Maximum
>27fc	4d 41 d8				.byte	$4d,$41,$d8
.27ff					_end83:
>27ff	07					.byte	_end84-*
>2800	00					.byte	$00
>2801	50 11					.word	Minimum
>2803	4d 49 ce				.byte	$4d,$49,$ce
.2806					_end84:
>2806	07					.byte	_end85-*
>2807	00					.byte	$00
>2808	90 11					.word	Modulus16x16
>280a	4d 4f c4				.byte	$4d,$4f,$c4
.280d					_end85:
>280d	0a					.byte	_end86-*
>280e	00					.byte	$00
>280f	a4 12					.word	Negate
>2811	4e 45 47 41 54 c5			.byte	$4e,$45,$47,$41,$54,$c5
.2817					_end86:
>2817	07					.byte	_end87-*
>2818	00					.byte	$00
>2819	e1 17					.word	NewHandler
>281b	4e 45 d7				.byte	$4e,$45,$d7
.281e					_end87:
>281e	0a					.byte	_end88-*
>281f	21					.byte	$21
>2820	36 15					.word	NextHandler
>2822	75 15					.word	NextEncoder
>2824	4e 45 58 d4				.byte	$4e,$45,$58,$d4
.2828					_end88:
>2828	07					.byte	_end89-*
>2829	00					.byte	$00
>282a	5f 14					.word	Nip
>282c	4e 49 d0				.byte	$4e,$49,$d0
.282f					_end89:
>282f	07					.byte	_end90-*
>2830	00					.byte	$00
>2831	b4 12					.word	OneComplement
>2833	4e 4f d4				.byte	$4e,$4f,$d4
.2836					_end90:
>2836	06					.byte	_end91-*
>2837	00					.byte	$00
>2838	d7 10					.word	LogOr
>283a	4f d2					.byte	$4f,$d2
.283c					_end91:
>283c	08					.byte	_end92-*
>283d	00					.byte	$00
>283e	47 14					.word	Over
>2840	4f 56 45 d2				.byte	$4f,$56,$45,$d2
.2844					_end92:
>2844	0c					.byte	_end93-*
>2845	20					.byte	$20
>2846	27 16					.word	RepeatHandler
>2848	2a 16					.word	RepeatEncoder
>284a	52 45 50 45 41 d4			.byte	$52,$45,$50,$45,$41,$d4
.2850					_end93:
>2850	07					.byte	_end94-*
>2851	00					.byte	$00
>2852	33 13					.word	RandomNumber
>2854	52 4e c4				.byte	$52,$4e,$c4
.2857					_end94:
>2857	07					.byte	_end95-*
>2858	00					.byte	$00
>2859	64 14					.word	Rot
>285b	52 4f d4				.byte	$52,$4f,$d4
.285e					_end95:
>285e	07					.byte	_end96-*
>285f	00					.byte	$00
>2860	b1 1a					.word	RunProgram
>2862	52 55 ce				.byte	$52,$55,$ce
.2865					_end96:
>2865	07					.byte	_end97-*
>2866	00					.byte	$00
>2867	df 12					.word	SignTOS
>2869	53 47 ce				.byte	$53,$47,$ce
.286c					_end97:
>286c	08					.byte	_end98-*
>286d	00					.byte	$00
>286e	f5 1a					.word	StopCode
>2870	53 54 4f d0				.byte	$53,$54,$4f,$d0
.2874					_end98:
>2874	08					.byte	_end99-*
>2875	00					.byte	$00
>2876	34 14					.word	Swap
>2878	53 57 41 d0				.byte	$53,$57,$41,$d0
.287c					_end99:
>287c	07					.byte	_end100-*
>287d	00					.byte	$00
>287e	c5 1a					.word	Call6502
>2880	53 59 d3				.byte	$53,$59,$d3
.2883					_end100:
>2883	0d					.byte	_end101-*
>2884	00					.byte	$00
>2885	83 1d					.word	IntToString
>2887	54 4f 2e 53 54 52 49 4e			.byte	$54,$4f,$2e,$53,$54,$52,$49,$4e,$c7
>288f	c7
.2890					_end101:
>2890	0b					.byte	_end102-*
>2891	21					.byte	$21
>2892	37 16					.word	UntilHandler
>2894	3a 16					.word	UntilEncoder
>2896	55 4e 54 49 cc				.byte	$55,$4e,$54,$49,$cc
.289b					_end102:
>289b	09					.byte	_end103-*
>289c	00					.byte	$00
>289d	00 1b					.word	VlistCode
>289f	56 4c 49 53 d4				.byte	$56,$4c,$49,$53,$d4
.28a4					_end103:
>28a4	0a					.byte	_end104-*
>28a5	40					.byte	$40
>28a6	4d 18					.word	BreakCmd
>28a8	58 42 52 45 41 cb			.byte	$58,$42,$52,$45,$41,$cb
.28ae					_end104:
>28ae	09					.byte	_end105-*
>28af	00					.byte	$00
>28b0	47 18					.word	ExitDump
>28b2	58 44 55 4d d0				.byte	$58,$44,$55,$4d,$d0
.28b7					_end105:
>28b7	07					.byte	_end106-*
>28b8	00					.byte	$00
>28b9	ca 10					.word	Xor
>28bb	58 4f d2				.byte	$58,$4f,$d2
.28be					_end106:
>28be	08					.byte	_end107-*
>28bf	00					.byte	$00
>28c0	cd 1b					.word	System_Save
>28c2	53 41 56 c5				.byte	$53,$41,$56,$c5
.28c6					_end107:
>28c6	08					.byte	_end108-*
>28c7	00					.byte	$00
>28c8	eb 1b					.word	System_Load
>28ca	4c 4f 41 c4				.byte	$4c,$4f,$41,$c4
.28ce					_end108:
>28ce	0d					.byte	_end109-*
>28cf	11					.byte	$11
>28d0	89 1e					.word	IndexHandler
>28d2	98 1e					.word	IndexHandlerDecode
>28d4	24 24 49 4e 44 45 d8			.byte	$24,$24,$49,$4e,$44,$45,$d8
.28db					_end109:
>28db	07					.byte	_end110-*
>28dc	00					.byte	$00
>28dd	9c 1b					.word	OldCode
>28df	4f 4c c4				.byte	$4f,$4c,$c4
.28e2					_end110:
>28e2	12					.byte	_end111-*
>28e3	52					.byte	$52
>28e4	14 10					.word	HexLiteral2Byte
>28e6	2b 10					.word	HexLiteral2ByteDecode
>28e8	24 24 48 45 58 4c 49 54			.byte	$24,$24,$48,$45,$58,$4c,$49,$54,$45,$52,$41,$cc
>28f0	45 52 41 cc
.28f4					_end111:
>28f4	00					.byte	0

;******  Return to file: kernel.asm


;******  Processing file: code/enctest.asm


;******  Return to file: kernel.asm

>3fff	ff						.byte 	$FF
.4000					ProgramMemory:

;******  End of listing
