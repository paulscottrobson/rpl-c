
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -q -D encode=0 -c -o kernel_nocode.prg -L kernel.lst -l kernel.lbl kernel.asm
; Wed Jan 15 11:47:25 2020

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=0					encode=0

;******  Processing input file: kernel.asm

=$1000					RplBuild = $1000 							; code starts here.

;******  Processing file: code/data.asm

.0000					NextCode:
>0000							.fill 	5
=3					IP = NextCode+3 							; the IP which points to the current instruction
.0005					rsp:
>0005							.byte 	?
.0006					tos:
>0006							.word 	?
.0008					srcPtr:
>0008							.word 	?
.000a					bufPtr:
>000a							.word 	?
.000c					matchPtr:
>000c							.word 	?
.000e					nextFreeMem:
>000e							.word 	?
.0010					temp1:
>0010							.word 	?
.0012					temp2:
>0012							.word 	?
.0014					temp3:
>0014							.word 	?
.0016					temp4:
>0016							.word 	?
.0018					listPtr:
>0018							.word 	?
.001a					SignCount:
>001a							.byte 	?
.001b					RandomSeed:
>001b							.word 	?
.001d					ListCount:
>001d							.byte 	?
.001e					ListLowest:
>001e							.word 	?
=$102					stack2Low = $102							; access other stack members following tsx
=$101					stack2High = $101							; (which requires saving X, not on the stack !)
=$104					stack3Low = $104
=$103					stack3High = $103
=$600					azVariables = $600 							; 26 x 2 variables occupying 52 bytes * PAGE BOUNDARY *
=16					hashTableSize = 16 							; hash tables for variables.
=$640					hashTable = $640 							; hash tables start here * ALL ON ONE PAGE *
=$810					textBuffer = $810 							; buffer for text.
=$700					returnStack = $700							; return stack (1 page)
=$700					returnStackLow = returnStack
=1856					returnStackHigh = returnStack+$40
=1920					returnStackX = returnStack+$80
=$80					NumberStackBase = $80 						; number stack down from here.
=$910					encodeBuffer = $910 						; buffer for encoded program
=0					COL_BLACK = 0
=1					COL_RED = 1
=2					COL_GREEN = 2
=3					COL_YELLOW = 3
=4					COL_BLUE = 4
=5					COL_MAGENTA = 5
=6					COL_CYAN = 6
=7					COL_WHITE = 7
=8					COL_RVS = 8
=2					CTH_LineNo = COL_Green
=6					CTH_Keyword = COL_Cyan
=11					CTH_Comment = COL_Yellow+COL_Rvs
=7					CTH_Definition = COL_White
=5					CTH_String = COL_Magenta
=3					CTH_Call = COL_Yellow
=7					CTH_Variable = COL_White

;******  Return to file: kernel.asm

.1000	a2 ff		ldx #$ff			ldx 	#$FF 						; reset the stack
.1002	9a		txs				txs
.1003	20 31 11	jsr $1131			jsr 	ExternInitialise
.1006	a9 43		lda #$43			lda 	#BootMsg & $FF
.1008	a0 10		ldy #$10			ldy 	#BootMsg >> 8
.100a	20 21 12	jsr $1221			jsr 	EXPrintString
.100d					WarmStartBlankStack:
.100d	86 10		stx $10				stx 	temp1
.100f	a2 80		ldx #$80			ldx 	#NumberStackBase
.1011	9a		txs				txs
.1012	a6 10		ldx $10				ldx 	temp1
.1014					WarmStart:
.1014	a9 03		lda #$03			lda 	#COL_Yellow
.1016	20 68 11	jsr $1168			jsr 	ExternColour
.1019	20 8b 11	jsr $118b			jsr 	ExternInput
.101c	a9 06		lda #$06			lda 	#COL_Cyan
.101e	20 68 11	jsr $1168			jsr 	ExternColour
.1021	a2 10		ldx #$10			ldx 	#encodeBuffer & $FF 		; run what is in the encode buffer.
.1023	a0 09		ldy #$09			ldy 	#encodeBuffer >> 8
.1025	20 95 10	jsr $1095			jsr 	InitialiseCoreCode 			; initialise the NEXT routine at $00 so error line# works
.1028	a9 10		lda #$10			lda 	#textBuffer & $FF
.102a	a0 08		ldy #$08			ldy 	#textBuffer >> 8
.102c	20 8d 16	jsr $168d			jsr 	EncodeProgram
.102f	ad 11 09	lda $0911			lda 	encodeBuffer+1 				; has a line number been entered ?
.1032	0d 12 09	ora $0912			ora 	encodeBuffer+2
.1035	d0 07		bne $103e			bne 	LineEditor 					; if so, do the line editing code.
.1037	a9 ff		lda #$ff			lda 	#$FF
.1039	85 05		sta $05				sta 	rsp
.103b	4c 00 00	jmp $0000			jmp 	NextCode
.103e					LineEditor:
.103e	20 9c 1e	jsr $1e9c			jsr 	EditProgram
.1041	80 ca		bra $100d			bra 	WarmStartBlankStack
.1043					BootMsg:
>1043	2a 2a 2a 20 52 50 4c 2f				.text 	"*** RPL/C INTERPRETER ***",13,13
>104b	43 20 49 4e 54 45 52 50 52 45 54 45 52 20 2a 2a
>105b	2a 0d 0d
>105e	57 52 49 54 54 45 4e 20				.text	"WRITTEN BY PAUL ROBSON 2020",13,13
>1066	42 59 20 50 41 55 4c 20 52 4f 42 53 4f 4e 20 32
>1076	30 32 30 0d 0d
>107b	42 55 49 4c 44 3a 20				.text 	"BUILD: "

;******  Processing file: generated/timestamp.inc

>1082	5b 32 30 2d 30 31 2d 31			.text	"[20-01-15 11:47]"
>108a	35 20 31 31 3a 34 37 5d

;******  Return to file: kernel.asm

>1092	0d 0d 00					.byte 	13,13,0

;******  Processing file: code/core.src

.1095					InitialiseCoreCode:
.1095	a9 e8		lda #$e8			lda 	#$E8 					; Copy INX INX 			4 cycles when run
.1097	85 00		sta $00				sta 	NextCode
.1099	85 01		sta $01				sta 	NextCode+1
.109b	a9 7c		lda #$7c			lda 	#$7C 					; Copy JMP ($aaaa,x) 	6 cycles when run
.109d	85 02		sta $02				sta 	NextCode+2
.109f	86 03		stx $03				stx 	NextCode+3 				; set the indirect address (IP)
.10a1	84 04		sty $04				sty 	NextCode+4
.10a3	a2 01		ldx #$01			ldx 	#1 						; set up to run from provided word.
.10a5	60		rts				rts								; (2 INX skip offset and line#)
.10a6					Literal2Byte:
.10a6	a5 06		lda $06				lda 	TOS
.10a8	48		pha				pha
.10a9	a5 07		lda $07				lda 	TOS+1
.10ab	48		pha				pha
.10ac	e8		inx				inx  							; point X to the word
.10ad	e8		inx				inx
.10ae	8a		txa				txa 							; copy into Y
.10af	a8		tay				tay
.10b0	b1 03		lda ($03),y			lda 	(IP),y 					; read it. the LSB
.10b2	85 06		sta $06				sta 	TOS
.10b4	c8		iny				iny 							; read and push the MSB
.10b5	b1 03		lda ($03),y			lda 	(IP),y
.10b7	85 07		sta $07				sta 	TOS+1
.10b9	4c 00 00	jmp $0000			jmp 	NextCode
.10bc					Literal2ByteDecode:
.10bc	a9 06		lda #$06			lda 	#CTH_Keyword
.10be	20 5d 1e	jsr $1e5d			jsr 	DecodeWriteBuffer
.10c1	b1 08		lda ($08),y			lda 	(srcPtr),y
.10c3	aa		tax				tax
.10c4	c8		iny				iny
.10c5	b1 08		lda ($08),y			lda 	(srcPtr),y
.10c7	a8		tay				tay
.10c8	8a		txa				txa
.10c9	38		sec				sec 							; output signed
.10ca	20 7f 1e	jsr $1e7f			jsr 	DecodeYAToBuffer
.10cd	60		rts				rts
.10ce					LiteralString:
.10ce	a5 06		lda $06				lda 	TOS
.10d0	48		pha				pha
.10d1	a5 07		lda $07				lda 	TOS+1
.10d3	48		pha				pha
.10d4	e8		inx				inx
.10d5	e8		inx				inx 							; skip over current word
.10d6	8a		txa				txa 							; add to IP + 1 to give string address
.10d7	a8		tay				tay 							; put in Y
.10d8	38		sec				sec 							; make that TOS
.10d9	65 03		adc $03				adc 	IP
.10db	85 06		sta $06				sta 	TOS
.10dd	a5 04		lda $04				lda 	IP+1
.10df	69 00		adc #$00			adc 	#0
.10e1	85 07		sta $07				sta 	TOS+1
.10e3	8a		txa				txa 							; add data length to X
.10e4	18		clc				clc
.10e5	71 03		adc ($03),y			adc 	(IP),y
.10e7	aa		tax				tax
.10e8	ca		dex				dex
.10e9	ca		dex				dex
.10ea	4c 00 00	jmp $0000			jmp 	NextCode
.10ed					LiteralStringDecoder:
.10ed	a9 05		lda #$05			lda 	#CTH_String
.10ef	20 5d 1e	jsr $1e5d			jsr 	DecodeWriteBuffer
.10f2	a9 22		lda #$22			lda 	#'"'
.10f4	20 5d 1e	jsr $1e5d			jsr 	DecodeWriteBuffer
.10f7	20 66 1e	jsr $1e66			jsr 	DecodeOutputData
.10fa	20 5d 1e	jsr $1e5d			jsr 	DecodeWriteBuffer
.10fd	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: code/error.asm

.10fe					ErrorHandler:
.10fe	68		pla				pla 								; get message address
.10ff	7a		ply				ply
.1100	1a		inc a				inc 	a
.1101	d0 01		bne $1104			bne 	_EHNoCarry
.1103	c8		iny				iny
.1104					_EHNoCarry:
.1104	20 21 12	jsr $1221			jsr 	EXPrintString
.1107	a0 01		ldy #$01			ldy 	#1 							; check if there is a line #
.1109	b1 03		lda ($03),y			lda 	(IP),y
.110b	c8		iny				iny
.110c	11 03		ora ($03),y			ora 	(IP),y
.110e	f0 14		beq $1124			beq 	_EHNoLine
.1110	a9 2c		lda #$2c			lda 	#_EHMsg2 & $FF 				; print " at "
.1112	a0 11		ldy #$11			ldy 	#_EHMsg2 >> 8
.1114	20 21 12	jsr $1221			jsr 	EXPrintString
.1117	a0 02		ldy #$02			ldy 	#2 							; print line number
.1119	b1 03		lda ($03),y			lda 	(IP),y
.111b	48		pha				pha
.111c	88		dey				dey
.111d	b1 03		lda ($03),y			lda 	(IP),y
.111f	7a		ply				ply
.1120	18		clc				clc
.1121	20 c6 21	jsr $21c6			jsr 	PrintYA
.1124					_EHNoLine:
.1124	a9 0d		lda #$0d			lda 	#13
.1126	20 5e 11	jsr $115e			jsr 	ExternPrint
.1129	4c 0d 10	jmp $100d			jmp 	WarmStartBlankStack			; S is indeterminate
>112c	20 41 54 20 00			_EHMsg2:.text 	" AT ",0

;******  Return to file: kernel.asm


;******  Processing file: code/enctest.asm


;******  Return to file: kernel.asm


;******  Processing file: code/extern.asm

.1131					ExternInitialise:
.1131	a9 90		lda #$90			lda 	#144 						; set colour
.1133	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.1136	a9 01		lda #$01			lda 	#$01
.1138	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.113b	a9 0e		lda #$0e			lda 	#14							; lower case
.113d	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.1140	a9 93		lda #$93			lda 	#147 						; clear screen
.1142	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.1145	a9 07		lda #$07			lda 	#COL_WHITE 					; white text.
.1147	4c 68 11	jmp $1168			jmp 	ExternColour
.114a					ExternCheckBreak:
.114a	da		phx				phx 								; make sure we keep XY
.114b	5a		phy				phy
.114c	20 e1 ff	jsr $ffe1			jsr 	$FFE1						; STOP check on CBM KERNAL
.114f	f0 03		beq $1154			beq		_ECBExit 					; stopped
.1151	7a		ply				ply 								; restore and exit.
.1152	fa		plx				plx
.1153	60		rts				rts
.1154					_ECBExit:
.1154	20 fe 10	jsr $10fe			jsr 	ErrorHandler
>1157	45 53 43 41 50 45 00				.text 	"ESCAPE",0
.115e					ExternPrint:
.115e	48		pha				pha
.115f	da		phx				phx
.1160	5a		phy				phy
.1161	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.1164	7a		ply				ply
.1165	fa		plx				plx
.1166	68		pla				pla
.1167	60		rts				rts
.1168					ExternColour:
.1168	48		pha				pha
.1169	da		phx				phx
.116a	48		pha				pha
.116b	29 08		and #$08			and 	#8
.116d	0a		asl a				asl 	a
.116e	0a		asl a				asl 	a
.116f	0a		asl a				asl 	a
.1170	0a		asl a				asl 	a
.1171	49 92		eor #$92			eor 	#$92
.1173	20 5e 11	jsr $115e			jsr 	ExternPrint
.1176	68		pla				pla
.1177	29 07		and #$07			and 	#7
.1179	aa		tax				tax
.117a	bd 83 11	lda $1183,x			lda 	_ECTable,x
.117d	20 5e 11	jsr $115e			jsr 	ExternPrint
.1180	fa		plx				plx
.1181	68		pla				pla
.1182	60		rts				rts
.1183					_ECTable:
>1183	90						.byte 	144
>1184	1c						.byte 	28
>1185	1e						.byte 	30
>1186	9e						.byte 	158
>1187	1f						.byte 	31
>1188	9c						.byte 	156
>1189	9f						.byte 	159
>118a	05						.byte 	5
.118b					ExternInput:
.118b	a9 10		lda #$10			lda 	#(textBuffer & $FF)
.118d	85 14		sta $14				sta 	temp3
.118f	a9 08		lda #$08			lda 	#(textBuffer >> 8)
.1191	85 15		sta $15				sta 	temp3+1
.1193	20 cf ff	jsr $ffcf	_EIRead:jsr 	$FFCF
.1196	29 7f		and #$7f			and 	#$7F
.1198	c9 0d		cmp #$0d			cmp 	#13
.119a	f0 0a		beq $11a6			beq 	_EIExit
.119c	92 14		sta ($14)			sta 	(temp3)
.119e	e6 14		inc $14				inc 	temp3
.11a0	d0 f1		bne $1193			bne 	_EIRead
.11a2	e6 15		inc $15				inc 	temp3+1
.11a4	80 ed		bra $1193			bra 	_EIRead
.11a6	a9 00		lda #$00	_EIExit:lda 	#0
.11a8	92 14		sta ($14)			sta 	(temp3)
.11aa	a9 0d		lda #$0d			lda 	#13
.11ac	20 5e 11	jsr $115e			jsr 	ExternPrint
.11af	60		rts				rts
.11b0					ExternSave:
.11b0	da		phx				phx
.11b1	5a		phy				phy
.11b2	85 12		sta $12				sta 	temp2 						; save start
.11b4	84 13		sty $13				sty 	temp2+1
.11b6	20 18 12	jsr $1218			jsr 	EXGetLength 				; get length of file into A
.11b9	a6 14		ldx $14				ldx 	temp3
.11bb	a4 15		ldy $15				ldy 	temp3+1
.11bd	20 bd ff	jsr $ffbd			jsr 	$FFBD 						; set name
.11c0	a9 01		lda #$01			lda 	#1
.11c2	a2 08		ldx #$08			ldx 	#8	 						; device #8
.11c4	a0 00		ldy #$00			ldy 	#0
.11c6	20 ba ff	jsr $ffba			jsr 	$FFBA 						; set LFS
.11c9	a6 10		ldx $10				ldx 	temp1 						; end address
.11cb	a4 11		ldy $11				ldy 	temp1+1
.11cd	a9 12		lda #$12			lda 	#temp2
.11cf	20 d8 ff	jsr $ffd8			jsr 	$FFD8 						; save
.11d2	b0 03		bcs $11d7			bcs 	_ESSave
.11d4	7a		ply				ply
.11d5	fa		plx				plx
.11d6	60		rts				rts
.11d7					_ESSave:
.11d7	20 fe 10	jsr $10fe			jsr 	ErrorHandler
>11da	53 41 56 45 20 46 41 49				.text 	"SAVE FAILED",0
>11e2	4c 45 44 00
.11e6					ExternLoad:
.11e6	da		phx				phx 								; save XY
.11e7	5a		phy				phy
.11e8	48		pha				pha 								; save target
.11e9	5a		phy				phy
.11ea	20 18 12	jsr $1218			jsr 	EXGetLength 				; get length of file into A
.11ed	a6 14		ldx $14				ldx 	temp3
.11ef	a4 15		ldy $15				ldy 	temp3+1
.11f1	20 bd ff	jsr $ffbd			jsr 	$FFBD 						; set name
.11f4	a9 01		lda #$01			lda 	#1
.11f6	a2 08		ldx #$08			ldx 	#8	 						; device #8
.11f8	a0 00		ldy #$00			ldy 	#0
.11fa	20 ba ff	jsr $ffba			jsr 	$FFBA 						; set LFS
.11fd	7a		ply				ply 								; restore target to YX and call load
.11fe	fa		plx				plx
.11ff	a9 00		lda #$00			lda 	#0 							; load command
.1201	20 d5 ff	jsr $ffd5			jsr 	$FFD5
.1204	b0 03		bcs $1209			bcs 	_ESLoad
.1206	7a		ply				ply
.1207	fa		plx				plx
.1208	60		rts				rts
.1209					_ESLoad:
.1209	20 fe 10	jsr $10fe			jsr 	ErrorHandler
>120c	4c 4f 41 44 20 46 41 49				.text 	"LOAD FAILED",0
>1214	4c 45 44 00
.1218					EXGetLength:
.1218	b2 14		lda ($14)			lda 	(temp3) 					; get name length
.121a	e6 14		inc $14				inc 	temp3 						; bump ptr past it
.121c	d0 02		bne $1220			bne 	_EXGLExit
.121e	e6 15		inc $15				inc 	temp3+1
.1220					_EXGLExit:
.1220	60		rts				rts
.1221					EXPrintString:
.1221	48		pha				pha
.1222	5a		phy				phy
.1223	84 11		sty $11				sty 	temp1+1
.1225	85 10		sta $10				sta 	temp1
.1227	a0 00		ldy #$00			ldy 	#0
.1229					_EXPSLoop:
.1229	b1 10		lda ($10),y			lda 	(temp1),y
.122b	f0 08		beq $1235			beq 	_EXPSExit
.122d	29 7f		and #$7f			and 	#$7F
.122f	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.1232	c8		iny				iny
.1233	80 f4		bra $1229			bra 	_EXPSLoop
.1235					_EXPSExit:
.1235	7a		ply				ply
.1236	68		pla				pla
.1237	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/binary.src

.1238					Add:
.1238	7a		ply				ply
.1239	68		pla				pla
.123a	18		clc				clc
.123b	65 06		adc $06				adc 	TOS
.123d	85 06		sta $06				sta 	TOS
.123f	98		tya				tya
.1240	65 07		adc $07				adc 	TOS+1
.1242	85 07		sta $07				sta 	TOS+1
.1244	4c 00 00	jmp $0000			jmp 	NextCode
.1247					Subtract:
.1247	7a		ply				ply
.1248	68		pla				pla
.1249	38		sec				sec
.124a	49 ff		eor #$ff			eor 	#$FF
.124c	65 06		adc $06				adc 	TOS
.124e	85 06		sta $06				sta 	TOS
.1250	98		tya				tya
.1251	49 ff		eor #$ff			eor 	#$FF
.1253	65 07		adc $07				adc 	TOS+1
.1255	85 07		sta $07				sta 	TOS+1
.1257	4c 00 00	jmp $0000			jmp 	NextCode
.125a					And:
.125a	68		pla				pla
.125b	25 07		and $07				and 	TOS+1
.125d	85 07		sta $07				sta 	TOS+1
.125f	68		pla				pla
.1260	25 06		and $06				and 	TOS
.1262	85 06		sta $06				sta 	TOS
.1264	4c 00 00	jmp $0000			jmp 	NextCode
.1267					Xor:
.1267	68		pla				pla
.1268	45 07		eor $07				eor 	TOS+1
.126a	85 07		sta $07				sta 	TOS+1
.126c	68		pla				pla
.126d	45 06		eor $06				eor 	TOS
.126f	85 06		sta $06				sta 	TOS
.1271	4c 00 00	jmp $0000			jmp 	NextCode
.1274					LogOr:
.1274	68		pla				pla
.1275	05 07		ora $07				ora 	TOS+1
.1277	85 07		sta $07				sta 	TOS+1
.1279	68		pla				pla
.127a	05 06		ora $06				ora 	TOS
.127c	85 06		sta $06				sta 	TOS
.127e	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/compare.src

.1281					CheckNotEqual:
.1281	38		sec				sec
.1282	80 01		bra $1285			bra 	CECode
.1284					CheckEqual:
.1284	18		clc				clc
.1285					CECode:
.1285	86 10		stx $10				stx 	temp1
.1287	ba		tsx				tsx
.1288	08		php				php
.1289	a5 06		lda $06				lda 	TOS
.128b	5d 02 01	eor $0102,x			eor 	Stack2Low,x
.128e	d0 17		bne $12a7			bne	 	CompareFalse
.1290	a5 07		lda $07				lda 	TOS+1
.1292	5d 01 01	eor $0101,x			eor 	Stack2High,x
.1295	d0 10		bne $12a7			bne 	CompareFalse
.1297					CompareTrue:
.1297	a6 10		ldx $10				ldx 	temp1
.1299	28		plp				plp
.129a	b0 10		bcs $12ac			bcs		CompareFalse2
.129c					CompareTrue2:
.129c	68		pla				pla
.129d	68		pla				pla
.129e	a9 ff		lda #$ff			lda 	#$FF
.12a0	85 06		sta $06				sta 	TOS
.12a2	85 07		sta $07				sta 	TOS+1
.12a4	4c 00 00	jmp $0000			jmp 	NextCode
.12a7					CompareFalse:
.12a7	a6 10		ldx $10				ldx 	temp1
.12a9	28		plp				plp
.12aa	b0 f0		bcs $129c			bcs		CompareTrue2
.12ac					CompareFalse2:
.12ac	68		pla				pla
.12ad	68		pla				pla
.12ae	64 06		stz $06				stz 	TOS
.12b0	64 07		stz $07				stz 	TOS+1
.12b2	4c 00 00	jmp $0000			jmp 	NextCode
.12b5					CheckGreaterEq:
.12b5	38		sec				sec
.12b6	80 01		bra $12b9			bra		CLCode
.12b8					CheckLess:
.12b8	18		clc				clc
.12b9	86 10		stx $10		CLCode:	stx 	temp1
.12bb	ba		tsx				tsx
.12bc	08		php				php
.12bd	18		clc				clc
.12be	a5 06		lda $06				lda 	TOS
.12c0	fd 02 01	sbc $0102,x			sbc 	Stack2Low,x
.12c3	a5 07		lda $07				lda 	TOS+1
.12c5	fd 01 01	sbc $0101,x			sbc 	Stack2High,x
.12c8	50 02		bvc $12cc			bvc 	_CLNoFlip
.12ca	49 80		eor #$80			eor 	#$80
.12cc					_CLNoFlip:
.12cc	0a		asl a				asl 	a
.12cd	b0 d8		bcs $12a7			bcs 	CompareFalse
.12cf	80 c6		bra $1297			bra 	CompareTrue
.12d1					CheckLessEq:
.12d1	38		sec				sec
.12d2	80 01		bra $12d5			bra		CGCode
.12d4					CheckGreater:
.12d4	18		clc				clc
.12d5					CGCode:
.12d5	86 10		stx $10				stx 	temp1
.12d7	ba		tsx				tsx
.12d8	08		php				php
.12d9	18		clc				clc
.12da	bd 02 01	lda $0102,x			lda 	Stack2Low,x
.12dd	e5 06		sbc $06				sbc 	TOS
.12df	bd 01 01	lda $0101,x			lda 	Stack2High,x
.12e2	e5 07		sbc $07				sbc 	TOS+1
.12e4	50 02		bvc $12e8			bvc 	_CGNoFlip
.12e6	49 80		eor #$80			eor 	#$80
.12e8					_CGNoFlip:
.12e8	0a		asl a				asl 	a
.12e9	b0 bc		bcs $12a7			bcs 	CompareFalse
.12eb	80 aa		bra $1297			bra 	CompareTrue
.12ed					Minimum:
.12ed	a9 00		lda #$00			lda 	#0
.12ef	80 02		bra $12f3			bra 	MinMaxCode
.12f1					Maximum:
.12f1	a9 80		lda #$80			lda 	#$80
.12f3					MinMaxCode:
.12f3	85 11		sta $11				sta 	temp1+1
.12f5	86 10		stx $10				stx 	temp1
.12f7	ba		tsx				tsx
.12f8	38		sec				sec
.12f9	a5 06		lda $06				lda 	TOS
.12fb	fd 02 01	sbc $0102,x			sbc 	Stack2Low,x
.12fe	a5 07		lda $07				lda 	TOS+1
.1300	fd 01 01	sbc $0101,x			sbc 	Stack2High,x
.1303	50 02		bvc $1307			bvc 	_MMNoFlip
.1305	49 80		eor #$80			eor 	#$80
.1307					_MMNoFlip:
.1307	45 11		eor $11				eor 	temp1+1
.1309	30 0a		bmi $1315			bmi 	_MMNoCopy
.130b	bd 02 01	lda $0102,x			lda 	Stack2Low,x
.130e	85 06		sta $06				sta 	TOS
.1310	bd 01 01	lda $0101,x			lda 	Stack2High,x
.1313	85 07		sta $07				sta 	TOS+1
.1315					_MMNoCopy:
.1315	a6 10		ldx $10				ldx 	temp1
.1317	68		pla				pla
.1318	68		pla				pla
.1319	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/divide.src

.131c					Divide16x16:
.131c	86 12		stx $12				stx 	temp2
.131e	ba		tsx				tsx
.131f	20 42 13	jsr $1342			jsr 	IntegerDivide
.1322	68		pla				pla
.1323	85 07		sta $07				sta 	TOS+1
.1325	68		pla				pla
.1326	85 06		sta $06				sta 	TOS
.1328	a6 12		ldx $12				ldx 	temp2
.132a	4c 00 00	jmp $0000			jmp 	NextCode
.132d					Modulus16x16:
.132d	86 12		stx $12				stx 	temp2
.132f	ba		tsx				tsx
.1330	20 42 13	jsr $1342			jsr 	IntegerDivide
.1333	a6 12		ldx $12				ldx 	temp2
.1335	68		pla				pla
.1336	68		pla				pla
.1337	a5 10		lda $10				lda 	temp1
.1339	85 06		sta $06				sta 	TOS
.133b	a5 11		lda $11				lda 	temp1+1
.133d	85 07		sta $07				sta 	TOS+1
.133f	4c 00 00	jmp $0000			jmp 	NextCode
.1342					IntegerDivide:
.1342	a5 06		lda $06				lda 	TOS 				; check for division by zero.
.1344	05 07		ora $07				ora 	TOS+1
.1346	d0 14		bne $135c			bne 	_BFDOkay
.1348	20 fe 10	jsr $10fe			jsr 	ErrorHandler
>134b	44 49 56 49 53 49 4f 4e				.text 	"DIVISION BY ZERO",0
>1353	20 42 59 20 5a 45 52 4f 00
.135c					_BFDOkay:
.135c	64 10		stz $10				stz 	temp1 						; Q/Dividend/Left in +0
.135e	64 11		stz $11				stz 	temp1+1 					; M/Divisor/Right in +2
.1360	64 1a		stz $1a				stz 	SignCount 					; Count of signs.
.1362	20 9d 13	jsr $139d			jsr 	CheckIntegerNegate 			; negate 2nd (and bump sign count)
.1365	20 b7 13	jsr $13b7			jsr 	CheckTOSNegate 				; negate TOS (and bump sign count)
.1368	5a		phy				phy 								; Y is the counter
.1369	a0 10		ldy #$10			ldy 	#16 						; 16 iterations of the loop.
.136b					_BFDLoop:
.136b	1e 02 01	asl $0102,x			asl 	Stack2Low,x 				; shift AQ left.
.136e	3e 01 01	rol $0101,x			rol 	Stack2High,x
.1371	26 10		rol $10				rol 	temp1
.1373	26 11		rol $11				rol 	temp1+1
.1375	38		sec				sec
.1376	a5 10		lda $10				lda 	temp1+0 					; Calculate A-M on stack.
.1378	e5 06		sbc $06				sbc 	TOS
.137a	48		pha				pha
.137b	a5 11		lda $11				lda 	temp1+1
.137d	e5 07		sbc $07				sbc 	TOS+1
.137f	90 0f		bcc $1390			bcc 	_BFDNoAdd
.1381	85 11		sta $11				sta 	temp1+1
.1383	68		pla				pla
.1384	85 10		sta $10				sta 	temp1+0
.1386	bd 02 01	lda $0102,x			lda 	Stack2Low,x 				; set Q bit 1.
.1389	09 01		ora #$01			ora 	#1
.138b	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.138e	80 01		bra $1391			bra 	_BFDNext
.1390					_BFDNoAdd:
.1390	68		pla				pla 								; Throw away the intermediate calculations
.1391					_BFDNext:
.1391	88		dey				dey
.1392	d0 d7		bne $136b			bne 	_BFDLoop
.1394	7a		ply				ply 								; restore Y
.1395	46 1a		lsr $1a				lsr 	SignCount 					; if sign count odd,
.1397	90 03		bcc $139c			bcc 	_BFDUnsigned 				; then the result is signed
.1399	20 a3 13	jsr $13a3			jsr		IntegerNegateAlways 		; negate the result
.139c					_BFDUnsigned:
.139c	60		rts				rts
.139d					CheckIntegerNegate:
.139d	bd 01 01	lda $0101,x			lda 	Stack2High,x 				; is it -ve = MSB set ?
.13a0	30 01		bmi $13a3			bmi 	IntegerNegateAlways 		; if so negate it
.13a2	60		rts				rts
.13a3					IntegerNegateAlways:
.13a3	e6 1a		inc $1a				inc 	SignCount 					; bump the count of signs
.13a5	38		sec				sec 								; negate
.13a6	a9 00		lda #$00			lda 	#0
.13a8	fd 02 01	sbc $0102,x			sbc 	Stack2Low,x
.13ab	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.13ae	a9 00		lda #$00			lda 	#0
.13b0	fd 01 01	sbc $0101,x			sbc 	Stack2High,x
.13b3	9d 01 01	sta $0101,x			sta 	Stack2High,x
.13b6	60		rts				rts
.13b7					CheckTOSNegate:
.13b7	a5 07		lda $07				lda 	TOS+1
.13b9	10 0f		bpl $13ca			bpl		CTNNoChange
.13bb	e6 1a		inc $1a				inc 	SignCount
.13bd					TOSNegateAlways:
.13bd	38		sec				sec
.13be	a9 00		lda #$00			lda 	#0
.13c0	e5 06		sbc $06				sbc 	TOS
.13c2	85 06		sta $06				sta 	TOS
.13c4	a9 00		lda #$00			lda 	#0
.13c6	e5 07		sbc $07				sbc 	TOS+1
.13c8	85 07		sta $07				sta 	TOS+1
.13ca					CTNNoChange:
.13ca	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/multiply.src

.13cb					Multiply16x16:
.13cb	86 10		stx $10				stx 	temp1
.13cd	ba		tsx				tsx
.13ce	bd 02 01	lda $0102,x			lda 	Stack2Low,x 				; 2nd value on stack to temp1
.13d1	85 12		sta $12				sta 	temp2
.13d3	bd 01 01	lda $0101,x			lda		Stack2High,x
.13d6	85 13		sta $13				sta 	temp2+1
.13d8	9e 02 01	stz $0102,x			stz 	Stack2Low,x 				; zero 2nd value on stack
.13db	9e 01 01	stz $0101,x			stz 	Stack2High,x
.13de					_MultLoop:
.13de	46 13		lsr $13				lsr 	temp2+1 					; ror temp2 into C
.13e0	66 12		ror $12				ror 	temp2
.13e2	90 11		bcc $13f5			bcc 	_MultNoAdd
.13e4	18		clc				clc 								; add 1st to 2nd
.13e5	a5 06		lda $06				lda 	TOS
.13e7	7d 02 01	adc $0102,x			adc 	Stack2Low,x
.13ea	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.13ed	a5 07		lda $07				lda 	TOS+1
.13ef	7d 01 01	adc $0101,x			adc 	Stack2High,x
.13f2	9d 01 01	sta $0101,x			sta 	Stack2High,x
.13f5					_MultNoAdd:
.13f5	06 06		asl $06				asl 	TOS 						; shift 1st left
.13f7	26 07		rol $07				rol 	TOS+1
.13f9	a5 12		lda $12				lda 	temp2	 					; until zero
.13fb	05 13		ora $13				ora 	temp2+1
.13fd	d0 df		bne $13de			bne 	_MultLoop
.13ff	a6 10		ldx $10				ldx 	temp1 						; restore X load result
.1401	68		pla				pla
.1402	85 07		sta $07				sta 	TOS+1
.1404	68		pla				pla
.1405	85 06		sta $06				sta 	TOS
.1407	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/unary.src

.140a					Unary1Plus:
.140a	e6 06		inc $06				inc 	TOS
.140c	d0 02		bne $1410			bne 	_U1PSkip
.140e	e6 07		inc $07				inc 	TOS+1
.1410					_U1PSkip:
.1410	4c 00 00	jmp $0000			jmp 	NextCode
.1413					Unary2Plus:
.1413	18		clc				clc
.1414	a5 06		lda $06				lda 	TOS
.1416	69 02		adc #$02			adc 	#2
.1418	85 06		sta $06				sta 	TOS
.141a	90 02		bcc $141e			bcc 	_U1PSkip
.141c	e6 07		inc $07				inc 	TOS+1
.141e					_U1PSkip:
.141e	4c 00 00	jmp $0000			jmp 	NextCode
.1421					Unary1Minus:
.1421	a5 06		lda $06				lda 	TOS
.1423	d0 02		bne $1427			bne 	_U1MSkip
.1425	c6 07		dec $07				dec 	TOS+1
.1427					_U1MSkip:
.1427	c6 06		dec $06				dec 	TOS
.1429	4c 00 00	jmp $0000			jmp 	NextCode
.142c					Unary2Minus:
.142c	38		sec				sec
.142d	a5 06		lda $06				lda 	TOS
.142f	e9 02		sbc #$02			sbc 	#2
.1431	85 06		sta $06				sta 	TOS
.1433	b0 02		bcs $1437			bcs 	_U1PSkip
.1435	c6 07		dec $07				dec 	TOS+1
.1437					_U1PSkip:
.1437	4c 00 00	jmp $0000			jmp 	NextCode
.143a					Absolute:
.143a	a5 07		lda $07				lda 	TOS+1
.143c	30 03		bmi $1441			bmi 	Negate
.143e	4c 00 00	jmp $0000			jmp 	NextCode
.1441					Negate:
.1441	38		sec				sec
.1442	a9 00		lda #$00			lda 	#0
.1444	e5 06		sbc $06				sbc 	TOS
.1446	85 06		sta $06				sta 	TOS
.1448	a9 00		lda #$00			lda 	#0
.144a	e5 07		sbc $07				sbc 	TOS+1
.144c	85 07		sta $07				sta 	TOS+1
.144e	4c 00 00	jmp $0000			jmp 	NextCode
.1451					OneComplement:
.1451	a5 06		lda $06				lda 	TOS
.1453	49 ff		eor #$ff			eor 	#$FF
.1455	85 06		sta $06				sta 	TOS
.1457	a5 07		lda $07				lda 	TOS+1
.1459	49 ff		eor #$ff			eor 	#$FF
.145b	85 07		sta $07				sta 	TOS+1
.145d	4c 00 00	jmp $0000			jmp 	NextCode
.1460					CheckMinus:
.1460	a5 07		lda $07				lda 	TOS+1
.1462	30 07		bmi $146b			bmi 	UnaryTrue
.1464					UnaryFalse:
.1464	64 06		stz $06				stz 	TOS
.1466	64 07		stz $07				stz 	TOS+1
.1468	4c 00 00	jmp $0000			jmp 	NextCode
.146b					UnaryTrue:
.146b	a9 ff		lda #$ff			lda 	#$FF
.146d	85 06		sta $06				sta 	TOS
.146f	85 07		sta $07				sta 	TOS+1
.1471	4c 00 00	jmp $0000			jmp 	NextCode
.1474					CheckZero:
.1474	a5 06		lda $06				lda 	TOS
.1476	05 07		ora $07				ora 	TOS+1
.1478	d0 ea		bne $1464			bne 	UnaryFalse
.147a	80 ef		bra $146b			bra 	UnaryTrue
.147c					SignTOS:
.147c	a5 07		lda $07				lda 	TOS+1
.147e	30 eb		bmi $146b			bmi		UnaryTrue
.1480	05 06		ora $06				ora 	TOS
.1482	f0 e0		beq $1464			beq 	UnaryFalse
.1484	a9 01		lda #$01			lda 	#1
.1486	85 06		sta $06				sta 	TOS
.1488	64 07		stz $07				stz		TOS+1
.148a	4c 00 00	jmp $0000			jmp 	NextCode
.148d					ByteSwap:
.148d	a5 06		lda $06				lda 	TOS
.148f	a4 07		ldy $07				ldy 	TOS+1
.1491	85 07		sta $07				sta 	TOS+1
.1493	84 06		sty $06				sty 	TOS
.1495	4c 00 00	jmp $0000			jmp 	NextCode
.1498					Times16:
.1498	06 06		asl $06				asl 	TOS
.149a	26 07		rol $07				rol 	TOS+1
.149c					Times8:
.149c	06 06		asl $06				asl 	TOS
.149e	26 07		rol $07				rol 	TOS+1
.14a0					Times4:
.14a0	06 06		asl $06				asl 	TOS
.14a2	26 07		rol $07				rol 	TOS+1
.14a4					Times2:
.14a4	06 06		asl $06				asl 	TOS
.14a6	26 07		rol $07				rol 	TOS+1
.14a8	4c 00 00	jmp $0000			jmp 	NextCode
.14ab					Divide16:
.14ab	46 07		lsr $07				lsr 	TOS+1
.14ad	66 06		ror $06				ror 	TOS
.14af					Divide8:
.14af	46 07		lsr $07				lsr 	TOS+1
.14b1	66 06		ror $06				ror 	TOS
.14b3					Divide4:
.14b3	46 07		lsr $07				lsr 	TOS+1
.14b5	66 06		ror $06				ror 	TOS
.14b7					Divide2:
.14b7	46 07		lsr $07				lsr 	TOS+1
.14b9	66 06		ror $06				ror 	TOS
.14bb	4c 00 00	jmp $0000			jmp 	NextCode
.14be					Times256:
.14be	a5 06		lda $06				lda 	TOS
.14c0	85 07		sta $07				sta 	TOS+1
.14c2	64 06		stz $06				stz 	TOS
.14c4	4c 00 00	jmp $0000			jmp 	NextCode
.14c7					Divide256:
.14c7	a5 07		lda $07				lda 	TOS+1
.14c9	85 06		sta $06				sta 	TOS
.14cb	64 07		stz $07				stz 	TOS+1
.14cd	4c 00 00	jmp $0000			jmp 	NextCode
.14d0					RandomNumber:
.14d0	a5 06		lda $06				lda 	TOS
.14d2	48		pha				pha
.14d3	a5 07		lda $07				lda 	TOS+1
.14d5	48		pha				pha
.14d6	a5 1b		lda $1b				lda 	randomSeed
.14d8	05 1c		ora $1c				ora 	randomSeed+1
.14da	d0 08		bne $14e4			bne 	_RH_NoInit
.14dc	a9 7c		lda #$7c			lda 	#$7C
.14de	85 1b		sta $1b				sta 	randomSeed
.14e0	a9 a1		lda #$a1			lda 	#$A1
.14e2	85 1c		sta $1c				sta 	randomSeed+1
.14e4					_RH_NoInit:
.14e4	a5 1b		lda $1b				lda 	randomSeed
.14e6	4a		lsr a		        lsr		a
.14e7	26 1c		rol $1c		        rol 	randomSeed+1
.14e9	90 02		bcc $14ed	        bcc 	_RH_NoEor
.14eb	49 b4		eor #$b4	        eor 	#$B4
.14ed					_RH_NoEor:
.14ed	85 1b		sta $1b		        sta 	randomSeed
.14ef	45 1c		eor $1c		        eor 	randomSeed+1
.14f1	85 07		sta $07		        sta 	TOS+1
.14f3	a5 1b		lda $1b		        lda 	randomSeed
.14f5	85 06		sta $06		        sta 	TOS
.14f7	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/data/literals.src

.14fa					Constant0:
.14fa	a5 06		lda $06				lda 	TOS
.14fc	48		pha				pha
.14fd	a5 07		lda $07				lda 	TOS+1
.14ff	48		pha				pha
.1500	64 06		stz $06				stz 	TOS
.1502	64 07		stz $07				stz 	TOS+1
.1504	4c 00 00	jmp $0000			jmp 	NextCode
.1507					ConstantMinus1:
.1507	a5 06		lda $06				lda 	TOS
.1509	48		pha				pha
.150a	a5 07		lda $07				lda 	TOS+1
.150c	48		pha				pha
.150d	a9 ff		lda #$ff			lda 	#$FF
.150f	85 06		sta $06				sta 	TOS
.1511	85 07		sta $07				sta 	TOS+1
.1513	4c 00 00	jmp $0000			jmp 	NextCode
.1516					C1:
.1516	a0 01		ldy #$01			ldy 	#1
.1518	80 24		bra $153e			bra 	Const1Byte
.151a					C2:
.151a	a0 02		ldy #$02			ldy 	#2
.151c	80 20		bra $153e			bra 	Const1Byte
.151e					C3:
.151e	a0 03		ldy #$03			ldy 	#3
.1520	80 1c		bra $153e			bra 	Const1Byte
.1522					C4:
.1522	a0 04		ldy #$04			ldy 	#4
.1524	80 18		bra $153e			bra 	Const1Byte
.1526					C5:
.1526	a0 05		ldy #$05			ldy 	#5
.1528	80 14		bra $153e			bra 	Const1Byte
.152a					C8:
.152a	a0 08		ldy #$08			ldy 	#8
.152c	80 10		bra $153e			bra 	Const1Byte
.152e					C10:
.152e	a0 0a		ldy #$0a			ldy 	#10
.1530	80 0c		bra $153e			bra 	Const1Byte
.1532					C15:
.1532	a0 0f		ldy #$0f			ldy 	#15
.1534	80 08		bra $153e			bra 	Const1Byte
.1536					C16:
.1536	a0 10		ldy #$10			ldy 	#16
.1538	80 04		bra $153e			bra 	Const1Byte
.153a					C24:
.153a	a0 18		ldy #$18			ldy 	#24
.153c	80 00		bra $153e			bra 	Const1Byte
.153e					Const1Byte:
.153e	a5 06		lda $06				lda 	TOS
.1540	48		pha				pha
.1541	a5 07		lda $07				lda 	TOS+1
.1543	48		pha				pha
.1544	84 06		sty $06				sty 	TOS
.1546	64 07		stz $07				stz 	TOS+1
.1548	4c 00 00	jmp $0000			jmp 	NextCode
.154b					C32:
.154b	a0 20		ldy #$20			ldy 	#32
.154d	80 ef		bra $153e			bra 	Const1Byte
.154f					C63:
.154f	a0 3f		ldy #$3f			ldy 	#63
.1551	80 eb		bra $153e			bra 	Const1Byte
.1553					C64:
.1553	a0 40		ldy #$40			ldy 	#64
.1555	80 e7		bra $153e			bra 	Const1Byte
.1557					C100:
.1557	a0 64		ldy #$64			ldy 	#100
.1559	80 e3		bra $153e			bra 	Const1Byte
.155b					C127:
.155b	a0 7f		ldy #$7f			ldy 	#127
.155d	80 df		bra $153e			bra 	Const1Byte
.155f					C128:
.155f	a0 80		ldy #$80			ldy 	#128
.1561	80 db		bra $153e			bra 	Const1Byte
.1563					C255:
.1563	a0 ff		ldy #$ff			ldy 	#255
.1565	80 d7		bra $153e			bra 	Const1Byte
.1567					Const2Byte:
.1567	85 06		sta $06				sta 	TOS
.1569	84 07		sty $07				sty 	TOS+1
.156b	4c 00 00	jmp $0000			jmp 	NextCode
.156e					C256:
.156e	a5 06		lda $06				lda 	TOS
.1570	48		pha				pha
.1571	a5 07		lda $07				lda 	TOS+1
.1573	48		pha				pha
.1574	a9 00		lda #$00			lda 	#(256) & $FF
.1576	a0 01		ldy #$01			ldy 	#(256) >> 8
.1578	80 ed		bra $1567			bra 	Const2Byte
.157a					C512:
.157a	a5 06		lda $06				lda 	TOS
.157c	48		pha				pha
.157d	a5 07		lda $07				lda 	TOS+1
.157f	48		pha				pha
.1580	a9 00		lda #$00			lda 	#(512) & $FF
.1582	a0 02		ldy #$02			ldy 	#(512) >> 8
.1584	80 e1		bra $1567			bra 	Const2Byte
.1586					C1024:
.1586	a5 06		lda $06				lda 	TOS
.1588	48		pha				pha
.1589	a5 07		lda $07				lda 	TOS+1
.158b	48		pha				pha
.158c	a9 00		lda #$00			lda 	#(1024) & $FF
.158e	a0 04		ldy #$04			ldy 	#(1024) >> 8
.1590	80 d5		bra $1567			bra 	Const2Byte
.1592					C4096:
.1592	a5 06		lda $06				lda 	TOS
.1594	48		pha				pha
.1595	a5 07		lda $07				lda 	TOS+1
.1597	48		pha				pha
.1598	a9 00		lda #$00			lda 	#(4096) & $FF
.159a	a0 10		ldy #$10			ldy 	#(4096) >> 8
.159c	80 c9		bra $1567			bra 	Const2Byte
.159e					C32767:
.159e	a5 06		lda $06				lda 	TOS
.15a0	48		pha				pha
.15a1	a5 07		lda $07				lda 	TOS+1
.15a3	48		pha				pha
.15a4	a9 ff		lda #$ff			lda 	#(32767) & $FF
.15a6	a0 7f		ldy #$7f			ldy 	#(32767) >> 8
.15a8	80 bd		bra $1567			bra 	Const2Byte
.15aa					C32768:
.15aa	a5 06		lda $06				lda 	TOS
.15ac	48		pha				pha
.15ad	a5 07		lda $07				lda 	TOS+1
.15af	48		pha				pha
.15b0	a9 00		lda #$00			lda 	#(32768) & $FF
.15b2	a0 80		ldy #$80			ldy 	#(32768) >> 8
.15b4	80 b1		bra $1567			bra 	Const2Byte

;******  Return to file: kernel.asm


;******  Processing file: words/data/stack.src

.15b6					Drop:
.15b6	68		pla				pla
.15b7	85 07		sta $07				sta 	TOS+1
.15b9	68		pla				pla
.15ba	85 06		sta $06				sta 	TOS
.15bc	4c 00 00	jmp $0000			jmp 	NextCode
.15bf					TestDup:
.15bf	a5 06		lda $06				lda 	TOS
.15c1	05 07		ora $07				ora 	TOS+1
.15c3	d0 03		bne $15c8			bne 	Dup
.15c5	4c 00 00	jmp $0000			jmp 	NextCode
.15c8					Dup:
.15c8	a5 06		lda $06				lda 	TOS
.15ca	48		pha				pha
.15cb	a5 07		lda $07				lda 	TOS+1
.15cd	48		pha				pha
.15ce	4c 00 00	jmp $0000			jmp 	NextCode
.15d1					Swap:
.15d1	86 10		stx $10				stx 	temp1
.15d3	7a		ply				ply
.15d4	fa		plx				plx
.15d5	a5 06		lda $06				lda 	TOS
.15d7	48		pha				pha
.15d8	a5 07		lda $07				lda 	TOS+1
.15da	48		pha				pha
.15db	86 06		stx $06				stx 	TOS
.15dd	84 07		sty $07				sty 	TOS+1
.15df	a6 10		ldx $10				ldx 	temp1
.15e1	4c 00 00	jmp $0000			jmp 	NextCode
.15e4					Over:
.15e4	a5 06		lda $06				lda 	TOS
.15e6	48		pha				pha
.15e7	a5 07		lda $07				lda 	TOS+1
.15e9	48		pha				pha
.15ea	86 10		stx $10				stx 	temp1
.15ec	ba		tsx				tsx
.15ed	bd 04 01	lda $0104,x			lda 	stack3low,x
.15f0	85 06		sta $06				sta 	TOS
.15f2	bd 03 01	lda $0103,x			lda 	stack3High,x
.15f5	85 07		sta $07				sta 	TOS+1
.15f7	a6 10		ldx $10				ldx 	temp1
.15f9	4c 00 00	jmp $0000			jmp 	NextCode
.15fc					Nip:
.15fc	68		pla				pla
.15fd	68		pla				pla
.15fe	4c 00 00	jmp $0000			jmp 	NextCode
.1601					Rot:
.1601	86 10		stx $10				stx 	temp1
.1603	ba		tsx				tsx
.1604	bd 04 01	lda $0104,x			lda 	Stack3Low,x
.1607	a8		tay				tay
.1608	bd 02 01	lda $0102,x			lda 	Stack2Low,x
.160b	9d 04 01	sta $0104,x			sta 	Stack3Low,x
.160e	a5 06		lda $06				lda 	TOS
.1610	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.1613	84 06		sty $06				sty 	TOS
.1615	bd 03 01	lda $0103,x			lda 	Stack3High,x
.1618	a8		tay				tay
.1619	bd 01 01	lda $0101,x			lda 	Stack2High,x
.161c	9d 03 01	sta $0103,x			sta 	Stack3High,x
.161f	a5 07		lda $07				lda 	TOS+1
.1621	9d 01 01	sta $0101,x			sta 	Stack2High,x
.1624	84 07		sty $07				sty 	TOS+1
.1626	a6 10		ldx $10				ldx 	temp1
.1628	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/data/memory.src

.162b					ByteRead:
.162b	b2 06		lda ($06)			lda 	(TOS)
.162d	85 06		sta $06				sta 	TOS
.162f	64 07		stz $07				stz 	TOS+1
.1631	4c 00 00	jmp $0000			jmp 	NextCode
.1634					WordRead:
.1634	a0 01		ldy #$01			ldy 	#1
.1636	b1 06		lda ($06),y			lda 	(TOS),y
.1638	a8		tay				tay
.1639	b2 06		lda ($06)			lda 	(TOS)
.163b	85 06		sta $06				sta 	TOS
.163d	84 07		sty $07				sty 	TOS+1
.163f	4c 00 00	jmp $0000			jmp 	NextCode
.1642					ByteWrite:
.1642	68		pla				pla
.1643	68		pla				pla
.1644	92 06		sta ($06)			sta 	(TOS)
.1646	68		pla				pla
.1647	85 07		sta $07				sta 	TOS+1
.1649	68		pla				pla
.164a	85 06		sta $06				sta 	TOS
.164c	4c 00 00	jmp $0000			jmp 	NextCode
.164f					WordWrite:
.164f	68		pla				pla
.1650	a0 01		ldy #$01			ldy 	#1
.1652	91 06		sta ($06),y			sta 	(TOS),y
.1654	68		pla				pla
.1655	92 06		sta ($06)			sta 	(TOS)
.1657	68		pla				pla
.1658	85 07		sta $07				sta 	TOS+1
.165a	68		pla				pla
.165b	85 06		sta $06				sta 	TOS
.165d	4c 00 00	jmp $0000			jmp 	NextCode
.1660					WordAdd:
.1660	7a		ply				ply
.1661	68		pla				pla
.1662	18		clc				clc
.1663	72 06		adc ($06)			adc 	(TOS)
.1665	92 06		sta ($06)			sta 	(TOS)
.1667	98		tya				tya
.1668	a0 01		ldy #$01			ldy 	#1
.166a	71 06		adc ($06),y			adc 	(TOS),y
.166c	91 06		sta ($06),y			sta 	(TOS),y
.166e	68		pla				pla
.166f	85 07		sta $07				sta 	TOS+1
.1671	68		pla				pla
.1672	85 06		sta $06				sta 	TOS
.1674	4c 00 00	jmp $0000			jmp 	NextCode
.1677					AllocateMemory:
.1677	a5 06		lda $06				lda 	TOS 						; save memory required on stack.
.1679	48		pha				pha
.167a	a5 07		lda $07				lda 	TOS+1
.167c	48		pha				pha
.167d	a5 0e		lda $0e				lda 	nextFreeMem 				; copy free mem address to TOS
.167f	85 06		sta $06				sta 	TOS
.1681	a5 0f		lda $0f				lda 	nextFreeMem+1
.1683	85 07		sta $07				sta 	TOS+1
.1685	7a		ply				ply 								; advance the free ram pointer
.1686	68		pla				pla
.1687	20 57 1d	jsr $1d57			jsr 	AdvanceFreeMem
.168a	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/encode/encode.src

.168d					EncodeProgram:
.168d	48		pha				pha 								; save registers.
.168e	da		phx				phx
.168f	5a		phy				phy
.1690	84 09		sty $09				sty 	srcPtr+1					; save source pointer.
.1692	85 08		sta $08				sta		srcPtr
.1694	a9 ff		lda #$ff			lda 	#$FF
.1696	85 05		sta $05				sta 	rsp
.1698	a6 05		ldx $05				ldx 	rsp 						; this is the current stack entry type, so $00 means
.169a	9e 40 07	stz $0740,x			stz 	returnStackHigh,x 			; an initial "until" will fail as it's looking for "R" here (repeat)
.169d	20 11 19	jsr $1911			jsr 	EncodeTrimTrailingSpaces 	; remove trailing spaces.
.16a0	a9 03		lda #$03			lda 	#3 							; reset the encode Buffer
.16a2	8d 10 09	sta $0910			sta 	encodeBuffer 				; this is also the write ptr/offset
.16a5	9c 11 09	stz $0911			stz 	encodeBuffer+1 				; the line number
.16a8	9c 12 09	stz $0912			stz 	encodeBuffer+2 				; which is initially zero.
.16ab	b2 08		lda ($08)			lda 	(srcPtr) 					; check if first character is digit
.16ad	20 bc 18	jsr $18bc			jsr 	CheckIsDigit
.16b0	90 09		bcc $16bb			bcc 	_EPNoLineNumber 			; if so there is a line number
.16b2	20 de 18	jsr $18de			jsr 	EncodeGetConstant 			; extract that constant from the source
.16b5	8d 11 09	sta $0911			sta 	encodeBuffer+1 				; that is the line number
.16b8	8c 12 09	sty $0912			sty 	encodeBuffer+2
.16bb					_EPNoLineNumber:
.16bb					EncodeLoop:
.16bb	20 03 19	jsr $1903			jsr 	EncSkipSpaces 				; skip over spaces
.16be	b2 08		lda ($08)			lda 	(srcPtr) 					; reached end ?
.16c0	d0 23		bne $16e5			bne 	_EPNotEnd
.16c2					_EPEndEncode:
.16c2	a9 41		lda #$41			lda 	#NextLine & $FF 			; compile $$nextline to mark eol
.16c4	a0 21		ldy #$21			ldy 	#NextLine >> 8
.16c6	20 94 18	jsr $1894			jsr 	EncodeWriteWord
.16c9	a5 05		lda $05				lda 	rsp 						; is the return stack empty ?
.16cb	c9 ff		cmp #$ff			cmp 	#$FF
.16cd	d0 04		bne $16d3			bne 	_EPIncomplete
.16cf	7a		ply				ply									; restore and exit.
.16d0	fa		plx				plx
.16d1	68		pla				pla
.16d2	60		rts				rts
.16d3					_EPIncomplete:
.16d3	20 fe 10	jsr $10fe			jsr 	ErrorHandler
>16d6	53 54 52 55 43 54 55 52				.text 	"STRUCTURE OPEN",0
>16de	45 20 4f 50 45 4e 00
.16e5					_EPNotEnd:
.16e5	b2 08		lda ($08)			lda 	(srcPtr)
.16e7	c9 22		cmp #$22			cmp 	#'"'						; is it a quoted string or comment ?
.16e9	f0 04		beq $16ef			beq 	_EPIsComStr
.16eb	c9 27		cmp #$27			cmp 	#"'"
.16ed	d0 05		bne $16f4			bne 	_EPNotComStr
.16ef					_EPIsComStr:
.16ef	20 e1 17	jsr $17e1			jsr 	EncodeCommentString
.16f2	80 c7		bra $16bb			bra 	EncodeLoop
.16f4					_EPNotComStr:
.16f4	38		sec				sec
.16f5	20 f0 18	jsr $18f0			jsr 	EncSetBit7Word
.16f8	20 38 19	jsr $1938			jsr 	EncodeSearchDictionary		; look it up
.16fb	90 45		bcc $1742			bcc 	_EPNotInDictionary
.16fd	85 10		sta $10				sta 	temp1 						; save dictionary record address
.16ff	84 11		sty $11				sty 	temp1+1
.1701	a0 01		ldy #$01			ldy 	#1
.1703	b1 10		lda ($10),y			lda 	(temp1),y 					; check if has an encode bit
.1705	29 20		and #$20			and 	#$20
.1707	d0 12		bne $171b			bne 	_EPEncodeRoutine 			; if so, do special routine.
.1709	a0 02		ldy #$02			ldy 	#2 							; write out the routine address
.170b	b1 10		lda ($10),y			lda 	(temp1),y
.170d	20 9e 18	jsr $189e			jsr 	EncodeWriteByte
.1710	c8		iny				iny
.1711	b1 10		lda ($10),y			lda 	(temp1),y
.1713	20 9e 18	jsr $189e			jsr 	EncodeWriteByte
.1716	20 c8 18	jsr $18c8			jsr 	EncodeMoveNextWord 			; advance to the next and loop
.1719	80 a0		bra $16bb			bra 	EncodeLoop
.171b					_EPEncodeRoutine:
.171b	a0 01		ldy #$01			ldy 	#1							; get type bit
.171d	b1 10		lda ($10),y			lda 	(temp1),y
.171f	a0 04		ldy #$04			ldy 	#4							; encoder here if no decoder
.1721	29 10		and #$10			and 	#$10 						; but decoder comes first
.1723	f0 02		beq $1727			beq 	_EPENoDecoder
.1725	c8		iny				iny 								; so if it exists, adjust for it.
.1726	c8		iny				iny
.1727					_EPENoDecoder:
.1727	b1 10		lda ($10),y			lda 	(temp1),y 					; copy exec addr to temp2
.1729	85 12		sta $12				sta 	temp2
.172b	c8		iny				iny
.172c	b1 10		lda ($10),y			lda 	(temp1),y
.172e	85 13		sta $13				sta 	temp2+1
.1730	48		pha				pha 								; call routine preserving state
.1731	da		phx				phx
.1732	5a		phy				phy
.1733	20 3f 17	jsr $173f			jsr 	_EPECallTemp2
.1736	7a		ply				ply
.1737	fa		plx				plx
.1738	68		pla				pla
.1739	20 c8 18	jsr $18c8			jsr 	EncodeMoveNextWord 			; advance to the next and loop
.173c	4c bb 16	jmp $16bb			jmp 	EncodeLoop
.173f					_EPECallTemp2:
.173f	6c 12 00	jmp ($0012)			jmp 	(temp2)
.1742					_EPNotInDictionary:
.1742	20 46 18	jsr $1846			jsr 	EncodeSearchUserDefined 	; are there any user defined routines
.1745	90 19		bcc $1760			bcc 	_EPNotDefined
.1747	48		pha				pha
.1748	a9 ba		lda #$ba			lda	 	#CallHandler & $FF 			; write code call handler
.174a	20 9e 18	jsr $189e			jsr 	EncodeWriteByte
.174d	a9 1b		lda #$1b			lda	 	#CallHandler >> 8
.174f	20 9e 18	jsr $189e			jsr 	EncodeWriteByte
.1752	68		pla				pla 								; write line number
.1753	20 9e 18	jsr $189e			jsr 	EncodeWriteByte
.1756	98		tya				tya
.1757	20 9e 18	jsr $189e			jsr 	EncodeWriteByte
.175a	20 c8 18	jsr $18c8			jsr 	EncodeMoveNextWord 			; advance to the next and loop
.175d	4c bb 16	jmp $16bb			jmp 	EncodeLoop
.1760					_EPNotDefined:
.1760	b2 08		lda ($08)			lda 	(srcPtr) 					; first character
.1762	c9 3a		cmp #$3a			cmp 	#":"						; is it :<routine> ?
.1764	f0 58		beq $17be			beq 	_EPDefinition
.1766	c9 3c		cmp #$3c			cmp 	#"<"						; is it <line> which is call syntax
.1768	f0 2e		beq $1798			beq 	_EPCallDirect
.176a	c9 21		cmp #$21			cmp 	#"!"						; check for variable operators
.176c	f0 47		beq $17b5			beq 	_EPVariable
.176e	c9 40		cmp #$40			cmp 	#"@"
.1770	f0 43		beq $17b5			beq 	_EPVariable
.1772	c9 26		cmp #$26			cmp 	#"&"
.1774	f0 3f		beq $17b5			beq 	_EPVariable
.1776	a9 a6		lda #$a6			lda 	#Literal2Byte & $FF 		; write out 2 byte literal
.1778	a0 10		ldy #$10			ldy 	#Literal2Byte >> 8
.177a	20 94 18	jsr $1894			jsr 	EncodeWriteWord
.177d					_EPOutputConstant:
.177d	20 de 18	jsr $18de			jsr 	EncodeGetConstant 			; extract that constant from the source
.1780	90 06		bcc $1788			bcc 	_EPFail 					; if can't find one, that's us done.
.1782	20 94 18	jsr $1894			jsr 	EncodeWriteWord 			; write out the encoded value.
.1785	4c bb 16	jmp $16bb			jmp 	EncodeLoop 					; and go round again.
.1788					_EPFail:
.1788	20 fe 10	jsr $10fe			jsr 	ErrorHandler
>178b	53 59 4e 54 41 58 20 45				.text 	"SYNTAX ERROR",0
>1793	52 52 4f 52 00
.1798					_EPCallDirect:
.1798	a9 ba		lda #$ba			lda	 	#CallHandler & $FF 			; write code call handler
.179a	a0 1b		ldy #$1b			ldy	 	#CallHandler >> 8
.179c	20 94 18	jsr $1894			jsr 	EncodeWriteWord
.179f	a9 01		lda #$01			lda 	#1
.17a1	20 d4 18	jsr $18d4			jsr 	EncodeAddSrcPtr 			; skip over the <
.17a4	a0 ff		ldy #$ff			ldy 	#255 						; scan forward for last character.
.17a6					_EPToLast:
.17a6	c8		iny				iny
.17a7	b1 08		lda ($08),y			lda 	(srcPtr),y
.17a9	10 fb		bpl $17a6			bpl	 	_EPToLast
.17ab	c9 be		cmp #$be			cmp 	#">"+$80 					; must be >
.17ad	d0 d9		bne $1788			bne 	_EPFail
.17af	a9 20		lda #$20			lda 	#" " 						; strip back to a number, erases last char
.17b1	91 08		sta ($08),y			sta 	(srcPtr),y
.17b3	80 c8		bra $177d			bra 	_EPOutputConstant 			; borrow the number routines extract/compile constant
.17b5					_EPVariable:
.17b5	20 8c 19	jsr $198c			jsr 	EncodeVariableReference
.17b8	20 c8 18	jsr $18c8			jsr 	EncodeMoveNextWord 			; advance to the next and loop
.17bb	4c bb 16	jmp $16bb			jmp 	EncodeLoop
.17be					_EPDefinition:
.17be	a9 83		lda #$83			lda	 	#DefineCode & $FF 			; write code call handler
.17c0	a0 21		ldy #$21			ldy	 	#DefineCode >> 8
.17c2	20 94 18	jsr $1894			jsr 	EncodeWriteWord
.17c5	ae 10 09	ldx $0910			ldx 	encodeBuffer 				; position
.17c8	a9 01		lda #$01			lda 	#1 							; write default size
.17ca	20 9e 18	jsr $189e			jsr 	EncodeWriteByte
.17cd	a0 00		ldy #$00			ldy 	#0 							; copy definition over.
.17cf	c8		iny		_EPCopy:iny
.17d0	b1 08		lda ($08),y			lda 	(srcPtr),y
.17d2	20 9e 18	jsr $189e			jsr 	EncodeWriteByte
.17d5	fe 10 09	inc $0910,x			inc 	encodeBuffer,x 				; update length.
.17d8	0a		asl a				asl 	a
.17d9	90 f4		bcc $17cf			bcc 	_EPCopy
.17db	20 c8 18	jsr $18c8			jsr 	EncodeMoveNextWord 			; advance to the next and loop
.17de	4c bb 16	jmp $16bb			jmp 	EncodeLoop

;******  Return to file: kernel.asm


;******  Processing file: words/encode/comstr.src

.17e1					EncodeCommentString:
.17e1	b2 08		lda ($08)			lda 	(srcPtr) 					; get first character
.17e3	64 10		stz $10				stz 	temp1 						; other terminator = EOL
.17e5	aa		tax				tax 								; save in X
.17e6	a9 58		lda #$58			lda 	#(SkipComment & $FF)		; get the routine to use
.17e8	a0 21		ldy #$21			ldy 	#(SkipComment >> 8)
.17ea	e0 27		cpx #$27			cpx 	#"'"
.17ec	f0 06		beq $17f4			beq 	_ECSGotCmd
.17ee	86 10		stx $10				stx		temp1 						; other terminator = "
.17f0	a9 ce		lda #$ce			lda 	#(LiteralString & $FF)
.17f2	a0 10		ldy #$10			ldy 	#(LiteralString >> 8)
.17f4					_ECSGotCmd:
.17f4	20 94 18	jsr $1894			jsr 	EncodeWriteWord 			; write word out.
.17f7	a9 01		lda #$01			lda 	#1 							; skip over ' or "
.17f9	20 d4 18	jsr $18d4			jsr 	EncodeAddSrcPtr
.17fc	e0 27		cpx #$27			cpx 	#"'"						; if ' then skip spaces
.17fe	d0 03		bne $1803			bne 	_ECNoSkipSpaces
.1800	20 03 19	jsr $1903			jsr 	EncSkipSpaces
.1803					_ECNoSkipSpaces:
.1803	ae 10 09	ldx $0910			ldx 	encodeBuffer 				; keep offset to buffer in X.
.1806	a9 01		lda #$01			lda 	#1
.1808	20 9e 18	jsr $189e			jsr 	EncodeWriteByte 			; write total length, so far 1.
.180b	a0 00		ldy #$00			ldy 	#0 							; for reading the actual text
.180d					_ECSCopyText:
.180d	b1 08		lda ($08),y			lda 	(srcPtr),y 					; get next
.180f	f0 18		beq $1829			beq 	_ECSEndOfLine 				; end of line ?
.1811	c5 10		cmp $10				cmp 	temp1						; is it the other terminator
.1813	f0 09		beq $181e			beq 	_ECSEndOfString 			; if so must be closing quote.
.1815	20 9e 18	jsr $189e			jsr 	EncodeWriteByte 			; write the byte out
.1818	fe 10 09	inc $0910,x			inc 	encodeBuffer,x				; increase length
.181b	c8		iny				iny 								; next character
.181c	80 ef		bra $180d			bra 	_ECSCopyText
.181e					_ECSEndOfString:
.181e	c8		iny				iny 								; skip closing quote.
.181f	a9 00		lda #$00			lda 	#0 							; write out ASCIIZ
.1821	20 9e 18	jsr $189e			jsr 	EncodeWriteByte
.1824	fe 10 09	inc $0910,x			inc 	encodeBuffer,x 				; fix the length up.
.1827	80 18		bra $1841			bra 	_ECSComplete 				; and just patching up srcPtr to do.
.1829					_ECSEndOfLine:
.1829	a5 10		lda $10				lda 	temp1 						; missing closing quote
.182b	f0 14		beq $1841			beq 	_ECSComplete 				; if we were doing a string.
.182d	20 fe 10	jsr $10fe			jsr 	ErrorHandler
>1830	4e 4f 20 43 4c 4f 53 49				.text 	"NO CLOSING QUOTE",0
>1838	4e 47 20 51 55 4f 54 45 00
.1841					_ECSComplete:
.1841	98		tya				tya									; skip over.
.1842	20 d4 18	jsr $18d4			jsr 	EncodeAddSrcPtr
.1845	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/encode/encdef.src

.1846					EncodeSearchUserDefined:
.1846	38		sec				sec 								; temp1 = srcPtr-6 because the
.1847	a5 08		lda $08				lda 	srcPtr				 		; name is 6 in (offset line# $$call len)
.1849	e9 06		sbc #$06			sbc		#6
.184b	85 10		sta $10				sta 	temp1
.184d	a5 09		lda $09				lda 	srcPtr+1
.184f	e9 00		sbc #$00			sbc 	#0
.1851	85 11		sta $11				sta 	temp1+1
.1853	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.1855	85 12		sta $12				sta 	0+(temp2)
.1857	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.1859	85 13		sta $13				sta 	1+(temp2)
.185b					_ESULoop:
.185b	b2 12		lda ($12)			lda 	(temp2) 					; reached the end (offset 0)
.185d	f0 33		beq $1892			beq 	_ESUFail
.185f	a0 03		ldy #$03			ldy 	#3 							; check it is $$define
.1861	b1 12		lda ($12),y			lda 	(temp2),y
.1863	c9 83		cmp #$83			cmp 	#DefineCode & $FF
.1865	d0 1e		bne $1885			bne 	_ESUNext
.1867	c8		iny				iny
.1868	b1 12		lda ($12),y			lda 	(temp2),y
.186a	c9 21		cmp #$21			cmp 	#DefineCode >> 8
.186c	d0 17		bne $1885			bne 	_ESUNext
.186e	c8		iny				iny 								; skip length byte.
.186f					_ESUCompare:
.186f	c8		iny				iny
.1870	b1 12		lda ($12),y			lda 	(temp2),y
.1872	d1 10		cmp ($10),y			cmp 	(temp1),y
.1874	d0 0f		bne $1885			bne 	_ESUNext
.1876	0a		asl a				asl 	a 							; bit 7 set => found it.
.1877	90 f6		bcc $186f			bcc 	_ESUCompare
.1879	a0 01		ldy #$01			ldy 	#1
.187b	b1 12		lda ($12),y			lda 	(temp2),y 					; read in the line number to YA
.187d	aa		tax				tax
.187e	c8		iny				iny
.187f	b1 12		lda ($12),y			lda 	(temp2),y
.1881	a8		tay				tay
.1882	8a		txa				txa
.1883	38		sec				sec 								; return with carry set as found
.1884	60		rts				rts
.1885					_ESUNext:
.1885	18		clc				clc
.1886	a5 12		lda $12				lda 	temp2
.1888	72 12		adc ($12)			adc 	(temp2)
.188a	85 12		sta $12				sta 	temp2
.188c	90 02		bcc $1890			bcc 	_NoCarryAdv
.188e	e6 13		inc $13				inc 	temp2+1
.1890					_NoCarryAdv:
.1890	80 c9		bra $185b			bra 	_ESULoop 					; and loop round
.1892					_ESUFail:
.1892	18		clc				clc
.1893	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/encode/encutils.src

.1894					EncodeWriteWord:
.1894	48		pha				pha
.1895	20 9e 18	jsr $189e			jsr 	EncodeWriteByte
.1898	98		tya				tya
.1899	20 9e 18	jsr $189e			jsr 	EncodeWriteByte
.189c	68		pla				pla
.189d	60		rts				rts
.189e					EncodeWriteByte:
.189e	da		phx				phx
.189f	ae 10 09	ldx $0910			ldx 	encodeBuffer
.18a2	9d 10 09	sta $0910,x			sta 	encodeBuffer,x
.18a5	9e 11 09	stz $0911,x			stz 	encodeBuffer+1,x
.18a8	9e 12 09	stz $0912,x			stz 	encodeBuffer+2,x
.18ab	ee 10 09	inc $0910			inc 	encodeBuffer
.18ae	fa		plx				plx
.18af	60		rts				rts
.18b0					CheckIsLetter:
.18b0	c9 41		cmp #$41			cmp 	#"A"						; return CS if A..Z
.18b2	90 06		bcc $18ba			bcc 	_CILFail
.18b4	c9 5b		cmp #$5b			cmp 	#"Z"+1
.18b6	b0 02		bcs $18ba			bcs 	_CILFail
.18b8	38		sec				sec
.18b9	60		rts				rts
.18ba					_CILFail:
.18ba	18		clc				clc
.18bb	60		rts				rts
.18bc					CheckIsDigit:
.18bc	c9 30		cmp #$30			cmp 	#"0"						; return CS if 0..9
.18be	90 06		bcc $18c6			bcc 	_CIDFail
.18c0	c9 3a		cmp #$3a			cmp 	#"9"+1
.18c2	b0 02		bcs $18c6			bcs 	_CIDFail
.18c4	38		sec				sec
.18c5	60		rts				rts
.18c6					_CIDFail:
.18c6	18		clc				clc
.18c7	60		rts				rts
.18c8					EncodeMoveNextWord:
.18c8	a0 ff		ldy #$ff			ldy 	#255 						; search forward
.18ca					_EPNWLoop:
.18ca	c8		iny				iny
.18cb	b1 08		lda ($08),y			lda 	(srcPtr),y
.18cd	c9 21		cmp #$21			cmp 	#" "+1						; looking for <= space
.18cf	b0 f9		bcs $18ca			bcs 	_EPNWLoop
.18d1	98		tya				tya
.18d2	80 00		bra $18d4			bra 	EncodeAddSrcPtr
.18d4					EncodeAddSrcPtr:
.18d4	18		clc				clc 								; add offset
.18d5	65 08		adc $08				adc 	srcPtr
.18d7	85 08		sta $08				sta 	srcPtr
.18d9	90 02		bcc $18dd			bcc 	_EASPNoCarry
.18db	e6 09		inc $09				inc 	srcPtr+1					; carry through
.18dd					_EASPNoCarry:
.18dd	60		rts				rts
.18de					EncodeGetConstant:
.18de	a5 08		lda $08				lda 	srcPtr 						; get source
.18e0	a4 09		ldy $09				ldy 	srcPtr+1
.18e2	20 b3 20	jsr $20b3			jsr 	ConvertToInteger 			; call converter
.18e5	90 08		bcc $18ef			bcc 	_EGCExit
.18e7	20 d4 18	jsr $18d4			jsr 	EncodeAddSrcPtr 			; if passed add chars to src ptr
.18ea	a5 14		lda $14				lda 	temp3 						; get result into YA
.18ec	a4 15		ldy $15				ldy 	temp3+1
.18ee	38		sec				sec 								; return CS
.18ef					_EGCExit:
.18ef	60		rts				rts
.18f0					EncSetBit7Word:
.18f0	08		php				php 								; save carry
.18f1	a0 ff		ldy #$ff			ldy 	#255 						; scan forward for space/NULL
.18f3					_ESB7Loop:
.18f3	c8		iny				iny
.18f4	b1 08		lda ($08),y			lda 	(srcPtr),y
.18f6	c9 21		cmp #$21			cmp 	#" "+1 						; while > ' '
.18f8	b0 f9		bcs $18f3			bcs 	_ESB7Loop
.18fa	88		dey				dey									; previous character
.18fb	b1 08		lda ($08),y			lda 	(srcPtr),y 					; read it
.18fd	0a		asl a				asl 	a 							; shift bit 7 out
.18fe	28		plp				plp 								; restore carry
.18ff	6a		ror a				ror 	a 							; shift it in
.1900	91 08		sta ($08),y			sta 	(srcPtr),y 					; write back and exit
.1902	60		rts				rts
.1903					EncSkipSpaces:
.1903	b2 08		lda ($08)			lda 	(srcPtr) 					; skip over spaces/ reached end
.1905	c9 20		cmp #$20			cmp 	#32
.1907	d0 07		bne $1910			bne 	_ESNotSpace
.1909	a9 01		lda #$01			lda 	#1
.190b	20 d4 18	jsr $18d4			jsr 	EncodeAddSrcPtr
.190e	80 f3		bra $1903			bra	 	EncSkipSpaces
.1910					_ESNotSpace:
.1910	60		rts				rts
.1911					EncodeTrimTrailingSpaces:
.1911	a0 ff		ldy #$ff			ldy 	#255 						; find EOS
.1913					_ETTFindEnd:
.1913	c8		iny				iny
.1914	b1 08		lda ($08),y			lda 	(srcPtr),y
.1916	d0 fb		bne $1913			bne 	_ETTFindEnd
.1918					_ETTRemoveSpace:
.1918	c0 00		cpy #$00			cpy 	#0 							; start of string
.191a	f0 0d		beq $1929			beq 	_ETTExit
.191c	88		dey				dey 								; previous character 1..32
.191d	b1 08		lda ($08),y			lda 	(srcPtr),y
.191f	c9 21		cmp #$21			cmp 	#32+1
.1921	b0 06		bcs $1929			bcs 	_ETTExit
.1923	a9 00		lda #$00			lda 	#0 							; erase it and go round again
.1925	91 08		sta ($08),y			sta 	(srcPtr),y
.1927	80 ef		bra $1918			bra 	_ETTRemoveSpace
.1929					_ETTExit:
.1929	60		rts				rts
.192a					EncodePushPosMarkerOnStack:
.192a	e6 05		inc $05				inc 	rsp 						; make space on rstack
.192c	a6 05		ldx $05				ldx 	rsp							; access it
.192e	9d 40 07	sta $0740,x			sta 	returnStackHigh,x			; save marker
.1931	ad 10 09	lda $0910			lda 	encodeBuffer 				; save position in encode buffer
.1934	9d 80 07	sta $0780,x			sta 	returnStackX,x
.1937	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/encode/encsearch.src

.1938					EncodeSearchDictionary:
.1938	a9 b1		lda #$b1			lda 	#(Dictionary) & $FF
.193a	85 10		sta $10				sta 	0+(temp1)
.193c	a9 23		lda #$23			lda 	#(Dictionary) >> 8
.193e	85 11		sta $11				sta 	1+(temp1)
.1940					_ESDLoop:
.1940	b2 10		lda ($10)			lda 	(temp1) 					; end of dictionary return with CC.
.1942	18		clc				clc
.1943	f0 46		beq $198b			beq 	_ESDExit
.1945	a0 01		ldy #$01			ldy 	#1 							; get control bits, get offset to name.
.1947	b1 10		lda ($10),y			lda 	(temp1),y
.1949	4a		lsr a				lsr 	a 							; encode/decode bits move to 0,1
.194a	4a		lsr a				lsr 	a
.194b	4a		lsr a				lsr 	a
.194c	4a		lsr a				lsr 	a
.194d	c8		iny				iny 								; Y = 2
.194e	4a		lsr a				lsr 	a
.194f	90 01		bcc $1952			bcc 	_ESDNotDec
.1951	c8		iny				iny
.1952					_ESDNotDec:
.1952	4a		lsr a				lsr 	a
.1953	90 01		bcc $1956			bcc 	_ESDNotInc
.1955	c8		iny				iny
.1956					_ESDNotInc:
.1956	98		tya				tya
.1957	0a		asl a				asl 	a 							; A is now 4,6,8 offset to name.
.1958	a8		tay				tay
.1959	b1 10		lda ($10),y			lda 	(temp1),y 					; quick check of first character
.195b	d2 08		cmp ($08)			cmp 	(srcPtr)
.195d	d0 1f		bne $197e			bne 	_ESDNext 					; do not match, go to next
.195f	98		tya				tya 								; make temp2 point to the name in
.1960	18		clc				clc 								; the dictionary.
.1961	65 10		adc $10				adc 	temp1
.1963	85 12		sta $12				sta 	temp2
.1965	a5 11		lda $11				lda 	temp1+1
.1967	69 00		adc #$00			adc 	#0
.1969	85 13		sta $13				sta 	temp2+1
.196b	a0 ff		ldy #$ff			ldy 	#255 						; now start matching up.
.196d					_ESDCompare:
.196d	c8		iny				iny
.196e	b1 08		lda ($08),y			lda 	(srcPtr),y
.1970	d1 12		cmp ($12),y			cmp 	(temp2),y
.1972	d0 0a		bne $197e			bne 	_ESDNext
.1974	0a		asl a				asl 	a
.1975	90 f6		bcc $196d			bcc 	_ESDCompare
.1977	a5 10		lda $10				lda 	temp1 						; return address in YA and carry set.
.1979	a4 11		ldy $11				ldy 	temp1+1
.197b	38		sec				sec
.197c	80 0d		bra $198b			bra 	_ESDExit
.197e					_ESDNext:
.197e	18		clc				clc
.197f	a5 10		lda $10				lda 	temp1
.1981	72 10		adc ($10)			adc 	(temp1)
.1983	85 10		sta $10				sta 	temp1
.1985	90 b9		bcc $1940			bcc 	_ESDLoop
.1987	e6 11		inc $11				inc 	temp1+1
.1989	80 b5		bra $1940			bra 	_ESDLoop
.198b					_ESDExit:
.198b	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/encode/encvar.src

.198c					EncodeVariableReference:
.198c	b2 08		lda ($08)			lda 	(srcPtr)					; get the type, use it to identify the routine
.198e	a2 57		ldx #$57			ldx 	#VarAddressHandler & $FF
.1990	a0 22		ldy #$22			ldy 	#VarAddressHandler >> 8
.1992	c9 26		cmp #$26			cmp 	#"&"
.1994	f0 0c		beq $19a2			beq 	_EVFHaveAddress
.1996	a2 71		ldx #$71			ldx 	#VarReadHandler & $FF
.1998	a0 22		ldy #$22			ldy 	#VarReadHandler >> 8
.199a	c9 40		cmp #$40			cmp 	#"@"
.199c	f0 04		beq $19a2			beq 	_EVFHaveAddress
.199e	a2 8d		ldx #$8d			ldx 	#VarWriteHandler & $FF
.19a0	a0 22		ldy #$22			ldy 	#VarWriteHandler >> 8
.19a2					_EVFHaveAddress:
.19a2	8a		txa				txa
.19a3	20 94 18	jsr $1894			jsr 	EncodeWriteWord 			; write it out.
.19a6	a0 01		ldy #$01			ldy 	#1 							; get the first charactere
.19a8	b1 08		lda ($08),y			lda 	(srcPtr),y
.19aa	29 7f		and #$7f			and 	#$7F 						; might be the last.
.19ac	20 b0 18	jsr $18b0			jsr 	CheckIsLetter 				; is it A-Z
.19af	90 1a		bcc $19cb			bcc 	EVFFail
.19b1	29 1f		and #$1f			and 	#31 						; make 1-26
.19b3	85 10		sta $10				sta 	temp1 						; start building the name in temp1
.19b5	64 11		stz $11				stz 	temp1+1
.19b7	38		sec				sec 								; possible char 2
.19b8	20 e0 19	jsr $19e0			jsr 	EncVarAlNum
.19bb	18		clc				clc 								; possible char 3
.19bc	20 e0 19	jsr $19e0			jsr 	EncVarAlNum
.19bf	b1 08		lda ($08),y			lda 	(srcPtr),y 					; more text after ?
.19c1	10 08		bpl $19cb			bpl 	EVFFail
.19c3	a5 10		lda $10				lda 	temp1 						; write out variable identifier.
.19c5	a4 11		ldy $11				ldy 	temp1+1
.19c7	20 94 18	jsr $1894			jsr 	EncodeWriteWord
.19ca	60		rts				rts
.19cb					EVFFail:
.19cb	20 fe 10	jsr $10fe			jsr 	ErrorHandler
>19ce	42 41 44 20 56 41 52 49				.text 	"BAD VARIABLE NAME",0
>19d6	41 42 4c 45 20 4e 41 4d 45 00
.19e0					EncVarAlNum:
.19e0	b1 08		lda ($08),y			lda 	(srcPtr),y 					; points to the  last char processed.
.19e2	10 01		bpl $19e5			bpl 	_EVAContinue
.19e4	60		rts				rts
.19e5					_EVAContinue:
.19e5	08		php				php 								; CS x 32 ; CC x 32 x 40
.19e6	c8		iny				iny 								; get the next character, strip bit 7
.19e7	b1 08		lda ($08),y			lda 	(srcPtr),y
.19e9	29 7f		and #$7f			and 	#$7F
.19eb	20 b0 18	jsr $18b0			jsr 	CheckIsLetter 				; letter ?
.19ee	b0 08		bcs $19f8			bcs 	_EVACharOkay
.19f0	20 bc 18	jsr $18bc			jsr 	CheckIsDigit				; fail if not digit.
.19f3	90 d6		bcc $19cb			bcc 	EVFFail
.19f5	18		clc				clc
.19f6	69 2b		adc #$2b			adc 	#"Z"+1-"0"					; shift 0 so after Z
.19f8					_EVACharOkay:
.19f8	38		sec				sec 								; range 1-36
.19f9	e9 40		sbc #$40			sbc 	#64
.19fb	28		plp				plp 								; which multiplier ?
.19fc	90 0f		bcc $1a0d			bcc 	_EVATimes32x40
.19fe	85 12		sta $12				sta 	temp2 						; save in temp2 - A x 32
.1a00	64 13		stz $13				stz 	temp2+1
.1a02	a2 05		ldx #$05			ldx 	#5
.1a04	06 12		asl $12		_EVA32:	asl 	temp2
.1a06	26 13		rol $13				rol 	temp2+1
.1a08	ca		dex				dex
.1a09	d0 f9		bne $1a04			bne 	_EVA32
.1a0b	80 0b		bra $1a18			bra 	_EVAAddVar
.1a0d					_EVATimes32x40:
.1a0d	85 13		sta $13				sta 	temp2+1						; 32 x 40 = 1280 or $500, so temp2 = A x 256 x 5
.1a0f	64 12		stz $12				stz 	temp2
.1a11	0a		asl a				asl 	a
.1a12	0a		asl a				asl 	a
.1a13	18		clc				clc
.1a14	65 13		adc $13				adc 	temp2+1
.1a16	85 13		sta $13				sta 	temp2+1
.1a18					_EVAAddVar:
.1a18	18		clc				clc
.1a19	a5 10		lda $10				lda 	temp1
.1a1b	65 12		adc $12				adc 	temp2
.1a1d	85 10		sta $10				sta 	temp1
.1a1f	a5 11		lda $11				lda 	temp1+1
.1a21	65 13		adc $13				adc 	temp2+1
.1a23	85 11		sta $11				sta 	temp1+1
.1a25	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/structures/fornext.src

.1a26					ForHandler:
.1a26	e6 05		inc $05				inc 	rsp 						; bump the RSP
.1a28	a4 05		ldy $05				ldy 	rsp 						; get return stack and push TOS/$FF on it.
.1a2a	c0 40		cpy #$40			cpy 	#$40 						; overflow
.1a2c	f0 18		beq $1a46			beq 	_FHOverflow
.1a2e	a5 07		lda $07				lda 	TOS+1
.1a30	99 40 07	sta $0740,y			sta 	returnStackHigh,y
.1a33	a5 06		lda $06				lda 	TOS
.1a35	99 00 07	sta $0700,y			sta 	returnStackLow,y
.1a38	a9 ff		lda #$ff			lda 	#$FF
.1a3a	99 80 07	sta $0780,y			sta 	returnStackX,y
.1a3d	68		pla				pla
.1a3e	85 07		sta $07				sta 	TOS+1
.1a40	68		pla				pla
.1a41	85 06		sta $06				sta 	TOS
.1a43	4c 00 00	jmp $0000			jmp 	NextCode
.1a46					_FHOverflow:
.1a46	20 fe 10	jsr $10fe			jsr 	ErrorHandler
>1a49	53 54 52 55 43 54 55 52				.text 	"STRUCTURE OVERFLOW",0
>1a51	45 20 4f 56 45 52 46 4c 4f 57 00
.1a5c					ForEncoder:
.1a5c	a9 26		lda #$26			lda 	#ForHandler & $FF 			; for handler
.1a5e	a0 1a		ldy #$1a			ldy 	#ForHandler >> 8
.1a60	20 94 18	jsr $1894			jsr 	EncodeWriteWord
.1a63	a9 46		lda #$46			lda 	#"F" 						; for marker
.1a65	20 2a 19	jsr $192a			jsr 	EncodePushPosMarkerOnStack
.1a68	60		rts				rts
.1a69					NextHandler:
.1a69	da		phx				phx
.1a6a	a6 05		ldx $05				ldx 	rsp 						; get current stack ptr
.1a6c	bd 80 07	lda $0780,x			lda 	returnStackX,x 				; check it's a FOR Loop
.1a6f	c9 ff		cmp #$ff			cmp 	#$FF
.1a71	d0 21		bne $1a94			bne 	NHNoFor
.1a73	bd 00 07	lda $0700,x			lda 	returnStackLow,x 			; decrement the count
.1a76	d0 03		bne $1a7b			bne 	_NHNoBorrow
.1a78	de 40 07	dec $0740,x			dec 	returnStackHigh,x
.1a7b					_NHNoBorrow:
.1a7b	de 00 07	dec $0700,x			dec 	returnStackLow,x
.1a7e	bd 00 07	lda $0700,x			lda 	returnStackLow,x 			; have we reached the end ?
.1a81	1d 40 07	ora $0740,x			ora 	returnStackHigh,x
.1a84	fa		plx				plx 								; restore X and re-test
.1a85	09 00		ora #$00			ora 	#0
.1a87	f0 05		beq $1a8e			beq 	_NHComplete 				; if so then complete, else loop.
.1a89	e8		inx				inx 								; advance to branch
.1a8a	e8		inx				inx
.1a8b	4c b0 1b	jmp $1bb0			jmp 	BranchAlways
.1a8e					_NHComplete:
.1a8e	e8		inx				inx 								; skip over the branch quantity
.1a8f	c6 05		dec $05				dec 	rsp 						; drop the indx
.1a91	4c 00 00	jmp $0000			jmp 	NextCode
.1a94					NHNoFor:
.1a94	20 fe 10	jsr $10fe			jsr 	ErrorHandler
>1a97	4f 55 54 20 4f 46 20 46				.text 	"OUT OF FOR SCOPE",0
>1a9f	4f 52 20 53 43 4f 50 45 00
.1aa8					NextEncoder:
.1aa8	a9 69		lda #$69			lda 	#NextHandler & $FF 			; next code
.1aaa	a0 1a		ldy #$1a			ldy 	#NextHandler >> 8
.1aac	20 94 18	jsr $1894			jsr 	EncodeWriteWord
.1aaf	a6 05		ldx $05				ldx 	rsp 						; get stack offset and pop
.1ab1	c6 05		dec $05				dec 	rsp
.1ab3	bd 40 07	lda $0740,x			lda 	returnStackHigh,x 			; check it is a for
.1ab6	c9 46		cmp #$46			cmp 	#"F"
.1ab8	d0 07		bne $1ac1			bne 	_NENoFor
.1aba	bd 80 07	lda $0780,x			lda 	returnStackX,x 				; write the branch
.1abd	20 9e 18	jsr $189e			jsr 	EncodeWriteByte
.1ac0	60		rts				rts
.1ac1					_NENoFor:
.1ac1	20 fe 10	jsr $10fe			jsr 	ErrorHandler
>1ac4	4d 49 53 53 49 4e 47 20				.text 	"MISSING FOR",0
>1acc	46 4f 52 00
.1ad0					GetIndex:
.1ad0	a4 05		ldy $05				ldy 	rsp 						; get current stack ptr
.1ad2	b9 80 07	lda $0780,y			lda 	returnStackX,y 				; check it's a FOR Loop
.1ad5	c9 ff		cmp #$ff			cmp 	#$FF
.1ad7	d0 bb		bne $1a94			bne 	NHNoFor
.1ad9	a5 06		lda $06				lda 	TOS
.1adb	48		pha				pha
.1adc	a5 07		lda $07				lda 	TOS+1
.1ade	48		pha				pha
.1adf	b9 00 07	lda $0700,y			lda 	returnStackLow,y 			; put counter-1 out
.1ae2	38		sec				sec
.1ae3	e9 01		sbc #$01			sbc 	#1
.1ae5	85 06		sta $06				sta 	TOS
.1ae7	b9 40 07	lda $0740,y			lda 	returnStackHigh,y
.1aea	e9 00		sbc #$00			sbc 	#0
.1aec	85 07		sta $07				sta 	TOS+1
.1aee	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/structures/ifelseendif.src

.1af1					IfHandler:
.1af1	4c 98 1b	jmp $1b98			jmp 	BranchIfZero
.1af4					IfEncoder:
.1af4	a9 f1		lda #$f1			lda 	#IfHandler & $FF 			; if handler
.1af6	a0 1a		ldy #$1a			ldy 	#IfHandler >> 8
.1af8	20 94 18	jsr $1894			jsr 	EncodeWriteWord
.1afb	a9 49		lda #$49			lda 	#"I" 						; if marker
.1afd	20 2a 19	jsr $192a			jsr 	EncodePushPosMarkerOnStack
.1b00	a9 00		lda #$00			lda 	#0
.1b02	20 9e 18	jsr $189e			jsr 	EncodeWriteByte 			; dummy write.
.1b05	60		rts				rts
.1b06					ElseHandler:
.1b06	4c ae 1b	jmp $1bae			jmp 	BranchTestSucceedsNoPop
.1b09					ElseEncoder:
.1b09	a9 06		lda #$06			lda 	#ElseHandler & $FF 			; else handler
.1b0b	a0 1b		ldy #$1b			ldy 	#ElseHandler >> 8
.1b0d	20 94 18	jsr $1894			jsr 	EncodeWriteWord
.1b10	ad 10 09	lda $0910			lda 	encodeBuffer 				; push current position
.1b13	48		pha				pha
.1b14	a9 00		lda #$00			lda 	#0 							; zero branch
.1b16	20 9e 18	jsr $189e			jsr 	EncodeWriteByte
.1b19	20 36 1b	jsr $1b36			jsr 	IfPatch 					; fix up the branch.
.1b1c	a9 49		lda #$49			lda 	#"I" 						; recreate if marker
.1b1e	20 2a 19	jsr $192a			jsr 	EncodePushPosMarkerOnStack
.1b21	68		pla				pla 								; address to patch
.1b22	a6 05		ldx $05				ldx 	rsp
.1b24	9d 80 07	sta $0780,x			sta 	returnStackX,x 				; and overwrite the target address
.1b27	60		rts				rts
.1b28					EndIfHandler:
.1b28	4c 00 00	jmp $0000			jmp 	NextCode
.1b2b					EndIfEncoder:
.1b2b	a9 28		lda #$28			lda 	#EndIfHandler & $FF 		; endif handler
.1b2d	a0 1b		ldy #$1b			ldy 	#EndIfHandler >> 8
.1b2f	20 94 18	jsr $1894			jsr 	EncodeWriteWord
.1b32	20 36 1b	jsr $1b36			jsr 	IfPatch
.1b35	60		rts				rts
.1b36					IfPatch:
.1b36	a6 05		ldx $05				ldx 	rsp 						; get stack offset and pop
.1b38	c6 05		dec $05				dec 	rsp
.1b3a	bd 40 07	lda $0740,x			lda 	returnStackHigh,x 			; check it is an if.
.1b3d	c9 49		cmp #$49			cmp 	#"I"
.1b3f	d0 0b		bne $1b4c			bne 	_NENoIf
.1b41	bd 80 07	lda $0780,x			lda 	returnStackX,x 				; this is what you patch.
.1b44	aa		tax				tax
.1b45	ad 10 09	lda $0910			lda 	encodeBuffer 				; with the current position.
.1b48	9d 10 09	sta $0910,x			sta 	encodeBuffer,x
.1b4b	60		rts				rts
.1b4c					_NENoIf:
.1b4c	20 fe 10	jsr $10fe			jsr 	ErrorHandler
>1b4f	4d 49 53 53 49 4e 47 20				.text 	"MISSING IF",0
>1b57	49 46 00

;******  Return to file: kernel.asm


;******  Processing file: words/structures/repeatuntil.src

.1b5a					RepeatHandler:
.1b5a	4c 00 00	jmp $0000			jmp 	NextCode
.1b5d					RepeatEncoder:
.1b5d	a9 5a		lda #$5a			lda 	#RepeatHandler & $FF 		; repeat marker
.1b5f	a0 1b		ldy #$1b			ldy 	#RepeatHandler >> 8
.1b61	20 94 18	jsr $1894			jsr 	EncodeWriteWord
.1b64	a9 52		lda #$52			lda 	#"R" 						; repeat marker
.1b66	20 2a 19	jsr $192a			jsr 	EncodePushPosMarkerOnStack
.1b69	60		rts				rts
.1b6a					UntilHandler:
.1b6a	4c 98 1b	jmp $1b98			jmp 	BranchIfZero
.1b6d					UntilEncoder:
.1b6d	a9 6a		lda #$6a			lda 	#UntilHandler & $FF 		; until code
.1b6f	a0 1b		ldy #$1b			ldy 	#UntilHandler >> 8
.1b71	20 94 18	jsr $1894			jsr 	EncodeWriteWord
.1b74	a6 05		ldx $05				ldx 	rsp 						; get stack offset and pop
.1b76	c6 05		dec $05				dec 	rsp
.1b78	bd 40 07	lda $0740,x			lda 	returnStackHigh,x 			; check it is a repeat
.1b7b	c9 52		cmp #$52			cmp 	#"R"
.1b7d	d0 07		bne $1b86			bne 	_UENoRepeat
.1b7f	bd 80 07	lda $0780,x			lda 	returnStackX,x 				; write the branch
.1b82	20 9e 18	jsr $189e			jsr 	EncodeWriteByte
.1b85	60		rts				rts
.1b86					_UENoRepeat:
.1b86	20 fe 10	jsr $10fe			jsr 	ErrorHandler
>1b89	4d 49 53 53 49 4e 47 20				.text 	"MISSING REPEAT",0
>1b91	52 45 50 45 41 54 00

;******  Return to file: kernel.asm


;******  Processing file: words/system/branch.src

.1b98					BranchIfZero:
.1b98	a5 06		lda $06				lda 	TOS 						; check TOS = 0
.1b9a	05 07		ora $07				ora 	TOS+1
.1b9c	f0 0a		beq $1ba8			beq 	BranchTestSucceeds
.1b9e					BranchTestFails:
.1b9e	68		pla				pla
.1b9f	85 07		sta $07				sta 	TOS+1
.1ba1	68		pla				pla
.1ba2	85 06		sta $06				sta 	TOS
.1ba4	e8		inx				inx 								; skip over the relative branch.
.1ba5	4c 00 00	jmp $0000			jmp 	NextCode
.1ba8					BranchTestSucceeds:
.1ba8	68		pla				pla
.1ba9	85 07		sta $07				sta 	TOS+1
.1bab	68		pla				pla
.1bac	85 06		sta $06				sta 	TOS
.1bae					BranchTestSucceedsNoPop:
.1bae	e8		inx				inx 								; advance by two, to the offset
.1baf	e8		inx				inx
.1bb0					BranchAlways:
.1bb0	8a		txa				txa 								; A = Y = position
.1bb1	a8		tay				tay 								; (IP),Y now points to the branch target
.1bb2	b1 03		lda ($03),y			lda 	(IP),y 						; adjust the position
.1bb4	aa		tax				tax 								; position back in this line.
.1bb5	ca		dex				dex
.1bb6	ca		dex				dex
.1bb7	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/system/callhandler.src

.1bba					CallHandler:
.1bba	e8		inx				inx									; bump X to the call address.
.1bbb	e8		inx				inx
.1bbc	e6 05		inc $05				inc 	rsp 						; bump the RSP (first time to zero)
.1bbe	a4 05		ldy $05				ldy 	rsp 						; get return stack and push IP/X on it.
.1bc0	c0 40		cpy #$40			cpy 	#$40 						; overflow
.1bc2	f0 54		beq $1c18			beq 	_CHOverflow
.1bc4	a5 04		lda $04				lda 	IP+1
.1bc6	99 40 07	sta $0740,y			sta 	returnStackHigh,y
.1bc9	a5 03		lda $03				lda 	IP
.1bcb	99 00 07	sta $0700,y			sta 	returnStackLow,y
.1bce	8a		txa				txa
.1bcf	99 80 07	sta $0780,y			sta 	returnStackX,y
.1bd2	8a		txa				txa 								; get the line number into temp1.
.1bd3	a8		tay				tay
.1bd4	b1 03		lda ($03),y			lda 	(IP),y
.1bd6	85 10		sta $10				sta 	temp1
.1bd8	c8		iny				iny
.1bd9	b1 03		lda ($03),y			lda 	(IP),y
.1bdb	85 11		sta $11				sta 	temp1+1
.1bdd	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.1bdf	85 03		sta $03				sta 	0+(IP)
.1be1	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.1be3	85 04		sta $04				sta 	1+(IP)
.1be5	b2 03		lda ($03)			lda 	(IP)						; no program code ?
.1be7	f0 17		beq $1c00			beq 	_CHFail
.1be9	a0 01		ldy #$01			ldy 	#1 							; Y = 1 throughout.
.1beb					_CHSearch:
.1beb	b1 03		lda ($03),y			lda 	(IP),y 						; check LSB of line number
.1bed	c5 10		cmp $10				cmp 	temp1
.1bef	f0 3e		beq $1c2f			beq 	_CHFoundLSB
.1bf1					_CHSearchNext:
.1bf1	18		clc				clc
.1bf2	a5 03		lda $03				lda 	IP
.1bf4	72 03		adc ($03)			adc 	(IP)
.1bf6	85 03		sta $03				sta 	IP
.1bf8	90 02		bcc $1bfc			bcc 	_NoCarryAdv
.1bfa	e6 04		inc $04				inc 	IP+1
.1bfc					_NoCarryAdv:
.1bfc	b2 03		lda ($03)			lda 	(IP)						; check reached the end.
.1bfe	d0 eb		bne $1beb			bne 	_CHSearch
.1c00					_CHFail:
.1c00	20 fe 10	jsr $10fe			jsr 	ErrorHandler
>1c03	43 41 4e 54 20 46 49 4e				.text 	"CANT FIND DEFINITION",0
>1c0b	44 20 44 45 46 49 4e 49 54 49 4f 4e 00
.1c18					_CHOverflow:
.1c18	20 fe 10	jsr $10fe			jsr 	ErrorHandler
>1c1b	43 41 4c 4c 20 53 54 41				.text 	"CALL STACK OVERFLOW",0
>1c23	43 4b 20 4f 56 45 52 46 4c 4f 57 00
.1c2f					_CHFoundLSB:
.1c2f	c8		iny				iny 								; get MSB
.1c30	b1 03		lda ($03),y			lda 	(IP),y
.1c32	88		dey				dey
.1c33	c5 11		cmp $11				cmp 	temp1+1 					; matches, if not contineu
.1c35	d0 ba		bne $1bf1			bne 	_CHSearchNext
.1c37	a0 03		ldy #$03			ldy 	#3	 						; check it begins with $$define
.1c39	b1 03		lda ($03),y			lda 	(IP),y
.1c3b	c9 83		cmp #$83			cmp 	#DefineCode & $FF
.1c3d	d0 c1		bne $1c00			bne 	_CHFail
.1c3f	c8		iny				iny
.1c40	b1 03		lda ($03),y			lda 	(IP),y
.1c42	c9 21		cmp #$21			cmp 	#DefineCode >> 8
.1c44	d0 ba		bne $1c00			bne 	_CHFail
.1c46	c8		iny				iny
.1c47	b1 03		lda ($03),y			lda 	(IP),y 						; this is the length of the define name
.1c49	18		clc				clc
.1c4a	69 03		adc #$03			adc 	#5-2 						; $$define token, line number, offset - 2 for Next
.1c4c	aa		tax				tax
.1c4d	4c 00 00	jmp $0000			jmp 	NextCode
.1c50					ReturnHandler:
.1c50	a4 05		ldy $05				ldy 	rsp 						; get rsp
.1c52	30 15		bmi $1c69			bmi 	_RHUnderflow 				; if -ve underflowed
.1c54	c6 05		dec $05				dec 	rsp 						; decrement rsp
.1c56	b9 40 07	lda $0740,y			lda 	returnStackHigh,y 			; restore IP/X
.1c59	85 04		sta $04				sta 	IP+1
.1c5b	b9 00 07	lda $0700,y			lda 	returnStackLow,y
.1c5e	85 03		sta $03				sta 	IP
.1c60	b9 80 07	lda $0780,y			lda 	returnStackX,y
.1c63	aa		tax				tax
.1c64	f0 15		beq $1c7b			beq 	_RHInLoop 					; this means you have done :something for ; next
.1c66	4c 00 00	jmp $0000			jmp 	NextCode
.1c69					_RHUnderflow:
.1c69	20 fe 10	jsr $10fe			jsr 	ErrorHandler
>1c6c	4d 49 53 53 49 4e 47 20				.text 	"MISSING RETURN",0
>1c74	52 45 54 55 52 4e 00
.1c7b					_RHInLoop:
.1c7b	20 fe 10	jsr $10fe			jsr 	ErrorHandler
>1c7e	52 45 54 55 52 4e 20 49				.text 	"RETURN IN LOOP ERROR",0
>1c86	4e 20 4c 4f 4f 50 20 45 52 52 4f 52 00
.1c93					CallHandlerDecode:
.1c93	a9 03		lda #$03			lda 	#CTH_Call					; space
.1c95	20 5d 1e	jsr $1e5d			jsr 	DecodeWriteBuffer
.1c98	b1 08		lda ($08),y			lda 	(srcPtr),y 					; get line number into YA
.1c9a	aa		tax				tax
.1c9b	c8		iny				iny
.1c9c	b1 08		lda ($08),y			lda 	(srcPtr),y
.1c9e	a8		tay				tay
.1c9f	8a		txa				txa
.1ca0	20 dd 1c	jsr $1cdd			jsr 	FindLine 					; try to locate that line.
.1ca3	b0 11		bcs $1cb6			bcs 	_CHDFound 					; if found .....
.1ca5					_CHDLineOnly:
.1ca5	48		pha				pha
.1ca6	a9 3c		lda #$3c			lda 	#"<"
.1ca8	20 5d 1e	jsr $1e5d			jsr 	DecodeWriteBuffer
.1cab	68		pla				pla
.1cac	18		clc				clc 								; output unsigned
.1cad	20 7f 1e	jsr $1e7f			jsr 	DecodeYAToBuffer
.1cb0	a9 3e		lda #$3e			lda 	#">"
.1cb2	20 5d 1e	jsr $1e5d			jsr 	DecodeWriteBuffer
.1cb5	60		rts				rts
.1cb6					_CHDFound:
.1cb6	48		pha				pha 								; save YA
.1cb7	5a		phy				phy
.1cb8	a0 03		ldy #$03			ldy 	#3 							; check first is $$define
.1cba	b1 10		lda ($10),y			lda 	(temp1),y
.1cbc	c9 83		cmp #$83			cmp 	#DefineCode & 255
.1cbe	d0 07		bne $1cc7			bne 	_CHDNoDefine
.1cc0	c8		iny				iny
.1cc1	b1 10		lda ($10),y			lda 	(temp1),y
.1cc3	c9 21		cmp #$21			cmp 	#DefineCode >> 8
.1cc5	f0 04		beq $1ccb			beq 	_CHDFoundDefine
.1cc7					_CHDNoDefine:
.1cc7	7a		ply				ply									; restore the line number and print it in <>
.1cc8	68		pla				pla
.1cc9	80 da		bra $1ca5			bra 	_CHDLineOnly
.1ccb					_CHDFoundDefine:
.1ccb	68		pla				pla 								; throw saved line number.
.1ccc	68		pla				pla
.1ccd	a0 05		ldy #$05			ldy 	#5 							; 3,4 $$define 5 length, name has bit 7 set at end
.1ccf					_CHDOutName:
.1ccf	c8		iny				iny 								; next
.1cd0	b1 10		lda ($10),y			lda 	(temp1),y 					; print char no bit 7
.1cd2	48		pha				pha
.1cd3	29 7f		and #$7f			and 	#$7F
.1cd5	20 5d 1e	jsr $1e5d			jsr 	DecodeWriteBuffer
.1cd8	68		pla				pla
.1cd9	0a		asl a				asl 	a 							; bit 7 to carry
.1cda	90 f3		bcc $1ccf			bcc 	_CHDOutName
.1cdc	60		rts				rts
.1cdd					FindLine:
.1cdd	48		pha				pha 								; save registers
.1cde	da		phx				phx
.1cdf	5a		phy				phy
.1ce0	85 12		sta $12				sta 	temp2 						; temp2 = target line#
.1ce2	84 13		sty $13				sty 	temp2+1
.1ce4	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.1ce6	85 10		sta $10				sta 	0+(temp1)
.1ce8	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.1cea	85 11		sta $11				sta 	1+(temp1)
.1cec					_FLLoop:
.1cec	b2 10		lda ($10)			lda 	(temp1) 					; found end ?
.1cee	18		clc				clc									; if so exit with CC.
.1cef	f0 1d		beq $1d0e			beq 	_FLExit
.1cf1	a0 01		ldy #$01			ldy 	#1 							; check line # match
.1cf3	b1 10		lda ($10),y			lda 	(temp1),y
.1cf5	c5 12		cmp $12				cmp 	temp2
.1cf7	d0 08		bne $1d01			bne 	_FLNext
.1cf9	c8		iny				iny
.1cfa	b1 10		lda ($10),y			lda 	(temp1),y
.1cfc	c5 13		cmp $13				cmp 	temp2+1
.1cfe	38		sec				sec 								; if so exit with CS
.1cff	f0 0d		beq $1d0e			beq 	_FLExit
.1d01					_FLNext:
.1d01	18		clc				clc
.1d02	a5 10		lda $10				lda 	temp1
.1d04	72 10		adc ($10)			adc 	(temp1)
.1d06	85 10		sta $10				sta 	temp1
.1d08	90 02		bcc $1d0c			bcc 	_NoCarryAdv
.1d0a	e6 11		inc $11				inc 	temp1+1
.1d0c					_NoCarryAdv:
.1d0c	80 de		bra $1cec			bra 	_FLLoop 					; keep looking.
.1d0e					_FLExit:
.1d0e	7a		ply				ply
.1d0f	fa		plx				plx
.1d10	68		pla				pla
.1d11	60		rts				rts
.1d12	18		clc				clc
.1d13	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/clrnew.src

.1d14					NewHandler:
.1d14	9c 00 40	stz $4000			stz 	ProgramMemory 				; Make the first offset zero.
.1d17	20 2a 1d	jsr $1d2a			jsr 	ClearVariableSpace 			; clear variables, reset pointers
.1d1a	4c 00 00	jmp $0000			jmp 	NextCode
.1d1d					ClrHandler:
.1d1d	86 10		stx $10				stx 	temp1
.1d1f	a2 80		ldx #$80			ldx 	#NumberStackBase
.1d21	9a		txs				txs
.1d22	a6 10		ldx $10				ldx 	temp1
.1d24	20 2a 1d	jsr $1d2a			jsr 	ClearVariableSpace 			; clear variables, reset pointers
.1d27	4c 00 00	jmp $0000			jmp 	NextCode
.1d2a					ClearVariableSpace:
.1d2a	a9 ff		lda #$ff			lda 	#$FF
.1d2c	85 05		sta $05				sta 	rsp
.1d2e	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.1d30	85 0e		sta $0e				sta 	0+(nextFreeMem)
.1d32	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.1d34	85 0f		sta $0f				sta 	1+(nextFreeMem)
.1d36	a0 1f		ldy #$1f			ldy 	#hashTableSize*2-1 			; erase the hash table (used for variables)
.1d38					_CVSHashClear:
.1d38	a9 00		lda #$00			lda 	#0 							; all the first record pointers are $00
.1d3a	99 40 06	sta $0640,y			sta 	hashTable,y
.1d3d	88		dey				dey
.1d3e	10 f8		bpl $1d38			bpl 	_CVSHashClear
.1d40					_CVSFindEnd:
.1d40	18		clc				clc
.1d41	a5 0e		lda $0e				lda 	nextFreeMem
.1d43	72 0e		adc ($0e)			adc 	(nextFreeMem)
.1d45	85 0e		sta $0e				sta 	nextFreeMem
.1d47	90 02		bcc $1d4b			bcc 	_NoCarryAdv
.1d49	e6 0f		inc $0f				inc 	nextFreeMem+1
.1d4b					_NoCarryAdv:
.1d4b	b2 0e		lda ($0e)			lda 	(nextFreeMem)
.1d4d	d0 f1		bne $1d40			bne 	_CVSFindEnd
.1d4f	a9 08		lda #$08			lda 	#8 							; this puts a gap in, more for clarity than anything.
.1d51	a0 00		ldy #$00			ldy 	#0
.1d53	20 57 1d	jsr $1d57			jsr 	AdvanceFreeMem				; we need +1 because the previous code leaves the
.1d56	60		rts				rts 								; free mem pointer pointing to the last zero offset
.1d57					AdvanceFreeMem:
.1d57	18		clc				clc
.1d58	65 0e		adc $0e				adc 	nextFreeMem
.1d5a	85 0e		sta $0e				sta 	nextFreeMem
.1d5c	98		tya				tya
.1d5d	65 0f		adc $0f				adc 	nextFreeMem+1
.1d5f	85 0f		sta $0f				sta 	nextFreeMem+1
.1d61	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/debug.src

.1d62					ExitDump:
.1d62	ba		tsx				tsx 								; save Data Stack in temp1
.1d63	86 10		stx $10				stx 	temp1
.1d65	4c ff ff	jmp $ffff			jmp 	$FFFF 						; makes the X16-Emulator dump-exit.
.1d68					BreakCmd:
>1d68	ff						.byte 	$FF
.1d69	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/system/decode.src

.1d6c					DecodeLineIntoBufPtr:
.1d6c	48		pha				pha
.1d6d	da		phx				phx
.1d6e	5a		phy				phy
.1d6f	85 08		sta $08				sta 	srcPtr 						; save the source line.
.1d71	84 09		sty $09				sty 	srcPtr+1
.1d73	90 1b		bcc $1d90			bcc 	_DecodeNoLineNumber
.1d75	a0 01		ldy #$01			ldy 	#1 							; get line # to YA
.1d77	b1 08		lda ($08),y			lda 	(srcPtr),y
.1d79	aa		tax				tax
.1d7a	c8		iny				iny
.1d7b	b1 08		lda ($08),y			lda 	(srcPtr),y
.1d7d	a8		tay				tay
.1d7e	8a		txa				txa
.1d7f	18		clc				clc
.1d80	20 7f 1e	jsr $1e7f			jsr 	DecodeYAToBuffer 			; convert to string in buffer
.1d83	aa		tax				tax 								; count in X
.1d84					_DecodeLineSpace:
.1d84	e0 05		cpx #$05			cpx 	#5
.1d86	f0 08		beq $1d90			beq 	_DecodeNoLineNumber
.1d88	a9 20		lda #$20			lda 	#" " 						; pad to 5 spaces
.1d8a	20 5d 1e	jsr $1e5d			jsr 	DecodeWriteBuffer
.1d8d	e8		inx				inx
.1d8e	80 f4		bra $1d84			bra 	_DecodeLineSpace
.1d90					_DecodeNoLineNumber:
.1d90	a0 03		ldy #$03			ldy 	#3 							; initial position.
.1d92					_DecodeLoop:
.1d92	b1 08		lda ($08),y			lda 	(srcPtr),y 					; copy the current character to temp1
.1d94	85 10		sta $10				sta 	temp1 						; must be an execution address.
.1d96	c8		iny				iny
.1d97	b1 08		lda ($08),y			lda 	(srcPtr),y
.1d99	85 11		sta $11				sta 	temp1+1
.1d9b	c8		iny				iny 								; y points to the byte after it.
.1d9c	a5 10		lda $10				lda 	temp1
.1d9e	c9 41		cmp #$41			cmp 	#NextLine & $FF
.1da0	d0 06		bne $1da8			bne 	_DecodeNotEOL
.1da2	a5 11		lda $11				lda 	temp1+1
.1da4	c9 21		cmp #$21			cmp 	#NextLine >> 8
.1da6	f0 0b		beq $1db3			beq 	_DecodeEOL
.1da8					_DecodeNotEOL:
.1da8	20 bb 1d	jsr $1dbb			jsr 	IdentifyCodeWord
.1dab	20 08 1e	jsr $1e08			jsr 	DecodeFoundWord
.1dae	20 f2 1d	jsr $1df2			jsr 	AdvanceToNext 				; advance to next entry in the line.
.1db1	80 df		bra $1d92			bra 	_DecodeLoop 				; and go round again
.1db3					_DecodeEOL:
.1db3	a9 00		lda #$00			lda 	#0
.1db5	92 0a		sta ($0a)			sta 	(bufPtr)
.1db7	7a		ply				ply 								; restore registers and exit
.1db8	fa		plx				plx
.1db9	68		pla				pla
.1dba	60		rts				rts
.1dbb					IdentifyCodeWord:
.1dbb	5a		phy				phy 								; save current position on the stack.
.1dbc	a9 b1		lda #$b1			lda 	#(Dictionary) & $FF
.1dbe	85 0c		sta $0c				sta 	0+(matchPtr)
.1dc0	a9 23		lda #$23			lda 	#(Dictionary) >> 8
.1dc2	85 0d		sta $0d				sta 	1+(matchPtr)
.1dc4					_DecodeIdentify:
.1dc4	a0 02		ldy #$02			ldy 	#2 							; have we found a match ?
.1dc6	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.1dc8	c5 10		cmp $10				cmp 	temp1
.1dca	d0 07		bne $1dd3			bne 	_DecodeIdNext
.1dcc	c8		iny				iny
.1dcd	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.1dcf	c5 11		cmp $11				cmp 	temp1+1
.1dd1	f0 1d		beq $1df0			beq 	_DecodeIdFound
.1dd3					_DecodeIdNext:
.1dd3	18		clc				clc
.1dd4	b2 0c		lda ($0c)			lda 	(matchPtr)
.1dd6	f0 0a		beq $1de2			beq 	_DecodeIdIssue
.1dd8	65 0c		adc $0c				adc 	matchPtr
.1dda	85 0c		sta $0c				sta 	matchPtr
.1ddc	90 e6		bcc $1dc4			bcc 	_DecodeIdentify
.1dde	e6 0d		inc $0d				inc 	matchPtr+1
.1de0	80 e2		bra $1dc4			bra 	_DecodeIdentify
.1de2					_DecodeIdIssue:
.1de2	20 fe 10	jsr $10fe			jsr 	ErrorHandler
>1de5	44 45 43 4f 44 45 2f 42				.text 	"DECODE/BUG",0
>1ded	55 47 00
.1df0					_DecodeIdFound:
.1df0	7a		ply				ply 								; restore position.
.1df1	60		rts				rts
.1df2					AdvanceToNext:
.1df2	5a		phy				phy 								; get the parameter count from bits 0-1 of the type byte
.1df3	a0 01		ldy #$01			ldy 	#1
.1df5	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.1df7	29 03		and #$03			and 	#3 							; bits 0-1.
.1df9	7a		ply				ply
.1dfa	c9 03		cmp #$03			cmp 	#3 							; is it n-bytes e.g. specified by the next byte
.1dfc	d0 02		bne $1e00			bne 	_ATN012
.1dfe	b1 08		lda ($08),y			lda 	(srcPtr),y 					; if so, use that byte as the overall length.
.1e00					_ATN012:
.1e00	85 12		sta $12				sta 	temp2 						; now add that to Y
.1e02	98		tya				tya
.1e03	18		clc				clc
.1e04	65 12		adc $12				adc 	temp2
.1e06	a8		tay				tay
.1e07	60		rts				rts
.1e08					DecodeFoundWord:
.1e08	5a		phy				phy 								; save current position
.1e09	84 12		sty $12				sty		temp2 						; put it in temp2 as well.
.1e0b	a0 01		ldy #$01			ldy 	#1 							; get the type byte
.1e0d	b1 0c		lda ($0c),y			lda 	(matchPtr),y 				; is there a special decoder check (bit 4 set) ?
.1e0f	29 10		and #$10			and 	#$10
.1e11	d0 0e		bne $1e21			bne 	_DFWSpecialDecoder
.1e13	b1 0c		lda ($0c),y			lda 	(matchPtr),y 				; reget it.
.1e15	30 08		bmi $1e1f			bmi 	_DFWExit 					; if hidden word (bit 7 set)
.1e17	a9 06		lda #$06			lda 	#CTH_Keyword				; output a space to the buffer
.1e19	20 5d 1e	jsr $1e5d			jsr 	DecodeWriteBuffer
.1e1c	20 3a 1e	jsr $1e3a			jsr 	DecodeCurrentWord 			; expand that.
.1e1f					_DFWExit:
.1e1f	7a		ply				ply 								; restore current position
.1e20	60		rts				rts
.1e21					_DFWSpecialDecoder:
.1e21	a0 04		ldy #$04			ldy 	#4 							; the decode word address is at offset 4,5
.1e23	b1 0c		lda ($0c),y			lda 	(matchPtr),y 				; copy this into temp2
.1e25	85 12		sta $12				sta 	temp2
.1e27	c8		iny				iny
.1e28	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.1e2a	85 13		sta $13				sta 	temp2+1
.1e2c	7a		ply				ply 	 							; restore current position into Y
.1e2d	48		pha				pha 								; save registers
.1e2e	da		phx				phx
.1e2f	5a		phy				phy
.1e30	20 37 1e	jsr $1e37			jsr 	_DFWCallDecoder				; call the decoder routine
.1e33	7a		ply				ply 								; restore registers and exit
.1e34	fa		plx				plx
.1e35	68		pla				pla
.1e36	60		rts				rts
.1e37					_DFWCallDecoder:
.1e37	6c 12 00	jmp ($0012)			jmp 	(temp2)
.1e3a					DecodeCurrentWord:
.1e3a	5a		phy				phy
.1e3b	a0 01		ldy #$01			ldy 	#1 							; read type byte
.1e3d	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.1e3f	a0 04		ldy #$04			ldy 	#4 							; original offset
.1e41	4a		lsr a				lsr 	a 							; encoder/decoder bits in 0-1
.1e42	4a		lsr a				lsr 	a 							; add 2 to Y for each encoder/decoder
.1e43	4a		lsr a				lsr 	a 							; bit set.
.1e44	4a		lsr a				lsr 	a
.1e45	4a		lsr a				lsr 	a 							; decoder bit
.1e46	90 02		bcc $1e4a			bcc 	_DWBNoDec
.1e48	c8		iny				iny
.1e49	c8		iny				iny
.1e4a					_DWBNoDec:
.1e4a	4a		lsr a				lsr 	a
.1e4b	90 02		bcc $1e4f			bcc 	_DWBNoEnc
.1e4d	c8		iny				iny
.1e4e	c8		iny				iny
.1e4f					_DWBNoEnc:
.1e4f					_DWBWordOut:
.1e4f	b1 0c		lda ($0c),y			lda 	(matchPtr),y 				; output until bit 7 set.
.1e51	48		pha				pha
.1e52	29 7f		and #$7f			and 	#$7F
.1e54	20 5d 1e	jsr $1e5d			jsr		DecodeWriteBuffer
.1e57	c8		iny				iny
.1e58	68		pla				pla
.1e59	10 f4		bpl $1e4f			bpl 	_DWBWordOut
.1e5b	7a		ply				ply 								; restore Y and exit
.1e5c	60		rts				rts
.1e5d					DecodeWriteBuffer:
.1e5d	92 0a		sta ($0a)			sta 	(bufPtr)
.1e5f	e6 0a		inc $0a				inc 	bufPtr
.1e61	d0 02		bne $1e65			bne 	_DWBNoCarry
.1e63	e6 0b		inc $0b				inc 	bufPtr+1
.1e65					_DWBNoCarry:
.1e65	60		rts				rts
.1e66					DecodeOutputData:
.1e66	48		pha				pha
.1e67	da		phx				phx
.1e68	5a		phy				phy
.1e69	b1 08		lda ($08),y			lda 	(srcPtr),y 					; length + 1
.1e6b	aa		tax				tax
.1e6c					_DODLoop:
.1e6c	ca		dex				dex 								; done it all ?
.1e6d	f0 0c		beq $1e7b			beq		_DODExit
.1e6f	c8		iny				iny 								; output next character
.1e70	b1 08		lda ($08),y			lda 	(srcPtr),y
.1e72	29 7f		and #$7f			and 	#$7F
.1e74	f0 f6		beq $1e6c			beq 	_DODLoop 					; don't print NULL
.1e76	20 5d 1e	jsr $1e5d			jsr 	DecodeWriteBuffer
.1e79	80 f1		bra $1e6c			bra 	_DODLoop
.1e7b					_DODExit:
.1e7b	7a		ply				ply
.1e7c	fa		plx				plx
.1e7d	68		pla				pla
.1e7e	60		rts				rts
.1e7f					DecodeYAToBuffer:
.1e7f	da		phx				phx
.1e80	5a		phy				phy
.1e81	48		pha				pha
.1e82	a5 0a		lda $0a				lda 	bufPtr 						; copy bufPtr to temp2
.1e84	85 12		sta $12				sta 	temp2
.1e86	a5 0b		lda $0b				lda 	bufPtr+1
.1e88	85 13		sta $13				sta 	temp2+1
.1e8a	68		pla				pla
.1e8b	20 ec 21	jsr $21ec			jsr 	ConvertToStringMain 		; convert YA to string there
.1e8e	aa		tax				tax 								; chars output to X
.1e8f	18		clc				clc
.1e90	65 0a		adc $0a				adc 	bufPtr 						; add to buffer pointer
.1e92	85 0a		sta $0a				sta 	bufPtr
.1e94	90 02		bcc $1e98			bcc 	_DYABNoCarry
.1e96	e6 0b		inc $0b				inc 	bufPtr+1
.1e98					_DYABNoCarry:
.1e98	8a		txa				txa 								; count in A
.1e99	7a		ply				ply									; restore and exit.
.1e9a	fa		plx				plx
.1e9b	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/edit.src

.1e9c					EditProgram:
.1e9c	20 19 1f	jsr $1f19			jsr 	EDFindLine					; find line address -> temp1
.1e9f	90 0f		bcc $1eb0			bcc 	_EPNotFound 				; if missing don't delete it.
.1ea1	a5 10		lda $10				lda 	temp1 						; save line address
.1ea3	48		pha				pha
.1ea4	a5 11		lda $11				lda 	temp1+1
.1ea6	48		pha				pha
.1ea7	20 be 1e	jsr $1ebe			jsr 	EDDeleteLine 				; delete the line
.1eaa	68		pla				pla 								; restore line address
.1eab	85 11		sta $11				sta 	temp1+1
.1ead	68		pla				pla
.1eae	85 10		sta $10				sta 	temp1
.1eb0					_EPNotFound:
.1eb0	ad 10 09	lda $0910			lda 	encodeBuffer 				; is there anything in the line.
.1eb3	c9 05		cmp #$05			cmp 	#5 							; <offset> <line#> <next line>
.1eb5	f0 03		beq $1eba			beq 	_EPNoInsert
.1eb7	20 e1 1e	jsr $1ee1			jsr 	EDInsertLine 				; insert line back in.
.1eba					_EPNoInsert:
.1eba	20 2a 1d	jsr $1d2a			jsr 	ClearVariableSpace
.1ebd	60		rts				rts
.1ebe					EDDeleteLine:
.1ebe	20 2a 1d	jsr $1d2a			jsr 	ClearVariableSpace
.1ec1	a0 00		ldy #$00			ldy 	#0 							; this is the offset to copy down.
.1ec3	a2 00		ldx #$00			ldx 	#0
.1ec5	b1 10		lda ($10),y			lda 	(temp1),y
.1ec7	a8		tay				tay 								; put in Y
.1ec8					_EDDelLoop:
.1ec8	b1 10		lda ($10),y			lda 	(temp1),y 					; get it
.1eca	81 10		sta ($10,x)			sta 	(temp1,x) 					; write it.
.1ecc	a5 10		lda $10				lda 	temp1 						; check if pointer has reached the end of
.1ece	c5 0e		cmp $0e				cmp		nextFreeMem 				; low memory. We will have copied down an
.1ed0	d0 06		bne $1ed8			bne 	_EDDelNext 					; extra pile of stuff - technically should
.1ed2	a5 11		lda $11				lda 	temp1+1 					; check the upper value (e.g. temp1+y)
.1ed4	c5 0f		cmp $0f				cmp 	nextFreeMem+1				; doesn't really matter.
.1ed6	f0 08		beq $1ee0			beq		_EDDelExit
.1ed8					_EDDelNext:
.1ed8	e6 10		inc $10				inc 	temp1 						; go to next byte.
.1eda	d0 ec		bne $1ec8			bne 	_EDDelLoop
.1edc	e6 11		inc $11				inc 	temp1+1
.1ede	80 e8		bra $1ec8			bra 	_EDDelLoop
.1ee0					_EDDelExit:
.1ee0	60		rts				rts
.1ee1					EDInsertLine:
.1ee1	20 2a 1d	jsr $1d2a			jsr 	ClearVariableSpace
.1ee4	a5 0e		lda $0e				lda 	nextFreeMem 				; copy high memory to temp3
.1ee6	85 14		sta $14				sta 	temp3
.1ee8	a5 0f		lda $0f				lda 	nextFreeMem+1
.1eea	85 15		sta $15				sta 	temp3+1
.1eec	ac 10 09	ldy $0910			ldy 	encodeBuffer 				; space to move it to in Y
.1eef	a2 00		ldx #$00			ldx 	#0
.1ef1					_EDInsLoop:
.1ef1	a1 14		lda ($14,x)			lda 	(temp3,x)					; copy it up
.1ef3	91 14		sta ($14),y			sta 	(temp3),y
.1ef5	a5 14		lda $14				lda 	temp3 						; reached the insert point (temp1)
.1ef7	c5 10		cmp $10				cmp 	temp1
.1ef9	d0 06		bne $1f01			bne 	_EDINextShift
.1efb	a5 15		lda $15				lda 	temp3+1
.1efd	c5 11		cmp $11				cmp 	temp1+1
.1eff	f0 0a		beq $1f0b			beq 	_EDIShiftOver
.1f01					_EDINextShift:
.1f01	a5 14		lda $14				lda 	temp3 						; decrement the copy pointer.
.1f03	d0 02		bne $1f07			bne 	_EDINoBorrow
.1f05	c6 15		dec $15				dec 	temp3+1
.1f07					_EDINoBorrow:
.1f07	c6 14		dec $14				dec 	temp3
.1f09	80 e6		bra $1ef1			bra 	_EDInsLoop
.1f0b					_EDIShiftOver:
.1f0b	a0 00		ldy #$00			ldy 	#0
.1f0d					_EDICopyCode:
.1f0d	b9 10 09	lda $0910,y			lda 	encodeBuffer,y				; read from the current line
.1f10	91 10		sta ($10),y			sta 	(temp1),y 					; write out
.1f12	c8		iny				iny 								; bump pointers
.1f13	cc 10 09	cpy $0910			cpy 	encodeBuffer 				; done the whole lot ?
.1f16	d0 f5		bne $1f0d			bne 	_EDICopyCode
.1f18	60		rts				rts
.1f19					EDFindLine:
.1f19	a9 00		lda #$00			lda 	#(programMemory) & $FF
.1f1b	85 10		sta $10				sta 	0+(temp1)
.1f1d	a9 40		lda #$40			lda 	#(programMemory) >> 8
.1f1f	85 11		sta $11				sta 	1+(temp1)
.1f21					_EDFLLoop:
.1f21	b2 10		lda ($10)			lda 	(temp1) 					; check offset
.1f23	f0 24		beq $1f49			beq 	_EDFLFail 					; then obviously that's the end ;-) (great comment !)
.1f25	a0 01		ldy #$01			ldy 	#1							; look at line #
.1f27	38		sec				sec
.1f28	ad 11 09	lda $0911			lda 	encodeBuffer+1				; subtract the current from the target
.1f2b	f1 10		sbc ($10),y			sbc 	(temp1),y 					; so if searching for 100 and this one is 90,
.1f2d	aa		tax				tax	 								; this will return 10.
.1f2e	ad 12 09	lda $0912			lda 	encodeBuffer+2
.1f31	c8		iny				iny
.1f32	f1 10		sbc ($10),y			sbc 	(temp1),y
.1f34	90 13		bcc $1f49			bcc 	_EDFLFail					; if target < current then failed.
.1f36	d0 04		bne $1f3c			bne 	_EDFLNext 					; if non-zero then goto next
.1f38	e0 00		cpx #$00			cpx 	#0 							; same for the LSB - zero if match found.
.1f3a	f0 0f		beq $1f4b			beq 	_EDFLFound
.1f3c					_EDFLNext:
.1f3c	18		clc				clc
.1f3d	a5 10		lda $10				lda 	temp1
.1f3f	72 10		adc ($10)			adc 	(temp1)
.1f41	85 10		sta $10				sta 	temp1
.1f43	90 02		bcc $1f47			bcc 	_NoCarryAdv
.1f45	e6 11		inc $11				inc 	temp1+1
.1f47					_NoCarryAdv:
.1f47	80 d8		bra $1f21			bra 	_EDFLLoop
.1f49					_EDFLFail:
.1f49	18		clc				clc
.1f4a	60		rts				rts
.1f4b					_EDFLFound:
.1f4b	38		sec				sec
.1f4c	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/list.src

.1f4d					ListCode:
.1f4d	64 1e		stz $1e				stz 	ListLowest 					; zero lowest line#
.1f4f	64 1f		stz $1f				stz 	ListLowest+1
.1f51	a9 18		lda #$18			lda 	#24 						; show max 24 after lowest line
.1f53	85 1d		sta $1d				sta 	ListCount
.1f55	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.1f57	85 18		sta $18				sta 	0+(listPtr)
.1f59	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.1f5b	85 19		sta $19				sta 	1+(listPtr)
.1f5d	86 10		stx $10				stx 	temp1						; S->A
.1f5f	ba		tsx				tsx
.1f60	8a		txa				txa
.1f61	a6 10		ldx $10				ldx 	temp1
.1f63	c9 80		cmp #$80			cmp 	#NumberStackBase
.1f65	f0 0e		beq $1f75			beq 	_LCLoop
.1f67	a5 06		lda $06				lda 	TOS 						; copy TOS to lowest
.1f69	85 1e		sta $1e				sta 	ListLowest
.1f6b	a5 07		lda $07				lda 	TOS+1
.1f6d	85 1f		sta $1f				sta 	ListLowest+1
.1f6f	68		pla				pla
.1f70	85 07		sta $07				sta 	TOS+1
.1f72	68		pla				pla
.1f73	85 06		sta $06				sta 	TOS
.1f75					_LCLoop:
.1f75	b2 18		lda ($18)			lda 	(listPtr)					; reached end ?
.1f77	f0 4c		beq $1fc5			beq 	_LCExit
.1f79	a0 01		ldy #$01			ldy 	#1							; >= list lowest
.1f7b	b1 18		lda ($18),y			lda 	(listPtr),y
.1f7d	c5 1e		cmp $1e				cmp 	ListLowest
.1f7f	c8		iny				iny
.1f80	b1 18		lda ($18),y			lda 	(listPtr),y
.1f82	e5 1f		sbc $1f				sbc 	ListLowest+1
.1f84	90 32		bcc $1fb8			bcc 	_LCNext
.1f86	a9 10		lda #$10			lda 	#(textBuffer) & $FF
.1f88	85 0a		sta $0a				sta 	0+(bufPtr)
.1f8a	a9 08		lda #$08			lda 	#(textBuffer) >> 8
.1f8c	85 0b		sta $0b				sta 	1+(bufPtr)
.1f8e	a5 18		lda $18				lda 	listPtr 					; output the line.
.1f90	a4 19		ldy $19				ldy 	listPtr+1
.1f92	38		sec				sec
.1f93	20 6c 1d	jsr $1d6c			jsr 	DecodeLineIntoBufPtr
.1f96	a9 02		lda #$02			lda 	#CTH_LineNo
.1f98	20 68 11	jsr $1168			jsr 	ExternColour
.1f9b	a0 ff		ldy #$ff			ldy 	#255
.1f9d					_LCLoop2:
.1f9d	c8		iny				iny
.1f9e	b9 10 08	lda $0810,y			lda 	textBuffer,y
.1fa1	f0 0e		beq $1fb1			beq 	_LCEnd
.1fa3	c9 20		cmp #$20			cmp 	#32
.1fa5	b0 05		bcs $1fac			bcs 	_LCPrint
.1fa7	20 68 11	jsr $1168			jsr 	ExternColour
.1faa	a9 20		lda #$20			lda 	#32
.1fac					_LCPrint:
.1fac	20 5e 11	jsr $115e			jsr 	ExternPrint
.1faf	80 ec		bra $1f9d			bra 	_LCLoop2
.1fb1	a9 0d		lda #$0d	_LCEnd:	lda 	#13 						; new line
.1fb3	20 5e 11	jsr $115e			jsr 	ExternPrint
.1fb6	c6 1d		dec $1d				dec 	ListCount					; done all the lines allowed
.1fb8					_LCNext:
.1fb8	18		clc				clc
.1fb9	a5 18		lda $18				lda 	listPtr
.1fbb	72 18		adc ($18)			adc 	(listPtr)
.1fbd	85 18		sta $18				sta 	listPtr
.1fbf	90 02		bcc $1fc3			bcc 	_NoCarryAdv
.1fc1	e6 19		inc $19				inc 	listPtr+1
.1fc3					_NoCarryAdv:
.1fc3	80 b0		bra $1f75			bra 	_LCLoop 					; go round again.
.1fc5					_LCExit:
.1fc5	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/system/miscellany.src

.1fc8					RunProgram:
.1fc8	86 10		stx $10				stx 	temp1
.1fca	a2 80		ldx #$80			ldx 	#NumberStackBase
.1fcc	9a		txs				txs
.1fcd	a6 10		ldx $10				ldx 	temp1
.1fcf	20 2a 1d	jsr $1d2a			jsr 	ClearVariableSpace 			; clear variables etc.
.1fd2	a2 00		ldx #$00			ldx		#ProgramMemory & $FF		; boot address
.1fd4	a0 40		ldy #$40			ldy 	#ProgramMemory >>8
.1fd6	20 95 10	jsr $1095			jsr 	InitialiseCoreCode 			; initialise the NEXT routine at $00
.1fd9	4c 00 00	jmp $0000			jmp 	NextCode
.1fdc					Call6502:
.1fdc	a5 06		lda $06				lda 	TOS 						; copy call address
.1fde	85 10		sta $10				sta 	temp1
.1fe0	a5 07		lda $07				lda 	TOS+1
.1fe2	85 11		sta $11				sta 	temp1+1
.1fe4	68		pla				pla
.1fe5	85 07		sta $07				sta 	TOS+1
.1fe7	68		pla				pla
.1fe8	85 06		sta $06				sta 	TOS
.1fea	20 f0 1f	jsr $1ff0			jsr 	_CallTemp1 					; call it
.1fed	4c 00 00	jmp $0000			jmp 	NextCode
.1ff0					_CallTemp1:
.1ff0	6c 10 00	jmp ($0010)			jmp 	(temp1)
.1ff3					AssertCode:
.1ff3	a5 06		lda $06				lda 	TOS 						; TOS = 0
.1ff5	05 07		ora $07				ora 	TOS+1
.1ff7	f0 09		beq $2002			beq 	_ASFail 					; if zero fail
.1ff9	68		pla				pla
.1ffa	85 07		sta $07				sta 	TOS+1
.1ffc	68		pla				pla
.1ffd	85 06		sta $06				sta 	TOS
.1fff	4c 00 00	jmp $0000			jmp 	NextCode
.2002					_ASFail:
.2002	20 fe 10	jsr $10fe			jsr 	ErrorHandler
>2005	41 53 53 45 52 54 00				.text 	"ASSERT",0
.200c					StopCode:
.200c	20 fe 10	jsr $10fe			jsr 	ErrorHandler
>200f	53 54 4f 50 00					.text 	"STOP",0
.2014					EndProgram:
.2014	4c 14 10	jmp $1014			jmp 	WarmStart
.2017					VlistCode:
.2017	a9 b1		lda #$b1			lda 	#(Dictionary) & $FF
.2019	85 10		sta $10				sta 	0+(temp1)
.201b	a9 23		lda #$23			lda 	#(Dictionary) >> 8
.201d	85 11		sta $11				sta 	1+(temp1)
.201f	a0 01		ldy #$01	_VLLoop:ldy 	#1							; type byte
.2021	b1 10		lda ($10),y			lda 	(temp1),y
.2023	a0 04		ldy #$04			ldy 	#4 							; Y = 4
.2025	4a		lsr a				lsr 	a 							; shift bits 4 and 5 to 0,1
.2026	4a		lsr a				lsr 	a
.2027	4a		lsr a				lsr		a
.2028	4a		lsr a				lsr 	a
.2029	4a		lsr a				lsr 	a 							; add those bits in
.202a	90 02		bcc $202e			bcc 	_VLNoDec
.202c	c8		iny				iny
.202d	c8		iny				iny
.202e					_VLNoDec:
.202e	4a		lsr a				lsr 	a
.202f	90 02		bcc $2033			bcc 	_VLNoEnc
.2031	c8		iny				iny
.2032	c8		iny				iny
.2033					_VLNoEnc:
.2033	b1 10		lda ($10),y			lda 	(temp1),y 					; remove $$ words
.2035	c9 24		cmp #$24			cmp 	#"$"
.2037	d0 06		bne $203f			bne 	_VLPrint
.2039	c8		iny				iny
.203a	51 10		eor ($10),y			eor 	(temp1),y
.203c	f0 13		beq $2051			beq 	_VLNext
.203e	88		dey				dey
.203f					_VLPrint:
.203f	b1 10		lda ($10),y			lda 	(temp1),y
.2041	48		pha				pha
.2042	c8		iny				iny
.2043	29 7f		and #$7f			and 	#$7F
.2045	20 5e 11	jsr $115e			jsr 	ExternPrint
.2048	68		pla				pla
.2049	0a		asl a				asl 	a
.204a	90 f3		bcc $203f			bcc 	_VLPrint
.204c	a9 20		lda #$20			lda 	#32
.204e	20 5e 11	jsr $115e			jsr 	ExternPrint
.2051					_VLNext:
.2051	18		clc				clc 								; go to next
.2052	b2 10		lda ($10)			lda 	(temp1)
.2054	65 10		adc $10				adc 	temp1
.2056	85 10		sta $10				sta 	temp1
.2058	90 02		bcc $205c			bcc 	_VLNoCarry
.205a	e6 11		inc $11				inc 	temp1+1
.205c					_VLNoCarry:
.205c	b2 10		lda ($10)			lda 	(temp1)
.205e	d0 bf		bne $201f			bne 	_VLLoop
.2060	a9 0d		lda #$0d			lda 	#13
.2062	20 5e 11	jsr $115e			jsr 	ExternPrint
.2065	4c 00 00	jmp $0000			jmp 	NextCode
.2068					DumpStack:
.2068	a9 5b		lda #$5b			lda		#"["
.206a	20 5e 11	jsr $115e			jsr 	ExternPrint
.206d	86 10		stx $10				stx 	temp1 						; X -> A
.206f	ba		tsx				tsx
.2070	8a		txa				txa
.2071	a6 10		ldx $10				ldx 	temp1
.2073	c9 80		cmp #$80			cmp 	#NumberStackBase 			; out of range, exit
.2075	f0 2f		beq $20a6			beq 	_DSExit
.2077	48		pha				pha 								; save it
.2078	a9 07		lda #$07			lda 	#COL_WHITE
.207a	20 68 11	jsr $1168			jsr 	ExternColour
.207d	a5 06		lda $06				lda 	TOS 						; print TOS then stack values backwards
.207f	a4 07		ldy $07				ldy 	TOS+1
.2081	38		sec				sec 								; print unsigned.
.2082	20 c6 21	jsr $21c6			jsr 	PrintYA
.2085	a9 06		lda #$06			lda 	#COL_CYAN
.2087	20 68 11	jsr $1168			jsr 	ExternColour
.208a	7a		ply				ply 								; restore offset
.208b					_DSLoop:
.208b	c0 7e		cpy #$7e			cpy 	#NumberStackBase-2 			; till done whole stack.
.208d	f0 17		beq $20a6			beq 	_DSExit
.208f	a9 20		lda #$20			lda 	#" " 						; space
.2091	20 5e 11	jsr $115e			jsr 	ExternPrint
.2094	5a		phy				phy 								; save pos
.2095	b9 01 01	lda $0101,y			lda 	$0101,y 					; read stack item
.2098	48		pha				pha
.2099	b9 02 01	lda $0102,y			lda 	$0102,y
.209c	7a		ply				ply
.209d	38		sec				sec
.209e	20 c6 21	jsr $21c6			jsr 	PrintYA 					; print it
.20a1	7a		ply				ply 								; restore and advance pos
.20a2	c8		iny				iny
.20a3	c8		iny				iny
.20a4	80 e5		bra $208b			bra 	_DSLoop
.20a6					_DSExit:
.20a6	a9 5d		lda #$5d			lda		#"]"
.20a8	20 5e 11	jsr $115e			jsr 	ExternPrint
.20ab	a9 0d		lda #$0d			lda 	#13
.20ad	20 5e 11	jsr $115e			jsr 	ExternPrint
.20b0	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/system/toint.src

.20b3					ConvertToInteger:
.20b3	84 17		sty $17				sty 	temp4+1
.20b5	85 16		sta $16				sta 	temp4
.20b7	64 14		stz $14				stz 	temp3 						; reset value
.20b9	64 15		stz $15				stz 	temp3+1
.20bb	64 10		stz $10				stz 	temp1 						; temp1 = 0 (decimal) 255 (hex)
.20bd	a0 00		ldy #$00			ldy 	#0 							; look at first character
.20bf	b1 16		lda ($16),y			lda 	(temp4),y
.20c1	49 2d		eor #$2d			eor 	#"-"						; zero if '-'
.20c3	85 11		sta $11				sta 	temp1+1 					; save this in temp1+1
.20c5	d0 01		bne $20c8			bne 	_CTINotMinus
.20c7	c8		iny				iny									; skip -
.20c8					_CTINotMinus:
.20c8	b1 16		lda ($16),y			lda 	(temp4),y
.20ca	c9 24		cmp #$24			cmp		#'$'						; if $ then skip it and set hex flag
.20cc	d0 03		bne $20d1			bne 	_CTILoop
.20ce	c6 10		dec $10				dec 	temp1
.20d0	c8		iny				iny
.20d1					_CTILoop:
.20d1	b1 16		lda ($16),y			lda 	(temp4),y 					; next digit
.20d3	29 7f		and #$7f			and 	#$7F 						; drop end of word flag
.20d5	38		sec				sec
.20d6	e9 30		sbc #$30			sbc 	#'0' 						; put in range '0'+
.20d8	90 65		bcc $213f			bcc 	_CTIFail 					; out of range.
.20da	c9 0a		cmp #$0a			cmp 	#10 						; in 0-9 ?
.20dc	90 0b		bcc $20e9			bcc 	_CTILegal
.20de	c9 11		cmp #$11			cmp 	#'A'-'0'					; between 9 and A ?
.20e0	90 5d		bcc $213f			bcc 	_CTIFail
.20e2	38		sec				sec
.20e3	e9 07		sbc #$07			sbc 	#7 							; hex adjust
.20e5	c9 10		cmp #$10			cmp 	#16 						; out of range ?
.20e7	b0 56		bcs $213f			bcs 	_CTIFail
.20e9					_CTILegal:
.20e9	48		pha				pha 								; save digit value.
.20ea	06 14		asl $14				asl 	temp3
.20ec	26 15		rol $15				rol 	temp3+1
.20ee	a5 14		lda $14				lda 	temp3 						; copy x2 into temp2
.20f0	85 12		sta $12				sta 	temp2
.20f2	a5 15		lda $15				lda 	temp3+1
.20f4	85 13		sta $13				sta 	temp2+1
.20f6	06 14		asl $14				asl 	temp3
.20f8	26 15		rol $15				rol 	temp3+1
.20fa	06 14		asl $14				asl 	temp3
.20fc	26 15		rol $15				rol 	temp3+1
.20fe	24 10		bit $10				bit 	temp1 						; hexadecimal
.2100	10 07		bpl $2109			bpl 	_CTIDecimal
.2102	06 14		asl $14				asl 	temp3
.2104	26 15		rol $15				rol 	temp3+1
.2106	68		pla				pla 								; get digit back
.2107	80 12		bra $211b			bra 	_CTIAddLoop
.2109					_CTIDecimal:
.2109	18		clc				clc 								; x 8 + x 2 = x 10
.210a	a5 14		lda $14				lda 	temp3
.210c	65 12		adc $12				adc 	temp2
.210e	85 14		sta $14				sta 	temp3
.2110	a5 15		lda $15				lda 	temp3+1
.2112	65 13		adc $13				adc 	temp2+1
.2114	85 15		sta $15				sta 	temp3+1
.2116	68		pla				pla 								; check digit 0-9
.2117	c9 0a		cmp #$0a			cmp 	#10
.2119	b0 24		bcs $213f			bcs 	_CTIFail
.211b					_CTIAddLoop:
.211b	18		clc				clc
.211c	65 14		adc $14				adc 	temp3
.211e	85 14		sta $14				sta 	temp3
.2120	90 02		bcc $2124			bcc 	_CTINoCarry
.2122	e6 15		inc $15				inc 	temp3+1
.2124					_CTINoCarry:
.2124	c8		iny				iny
.2125	b1 16		lda ($16),y			lda 	(temp4),y 					; was this the last character
.2127	c9 21		cmp #$21			cmp 	#32+1
.2129	b0 a6		bcs $20d1			bcs 	_CTILoop 					; no, go back.
.212b	a5 11		lda $11				lda 	temp1+1 					; was it - ?
.212d	d0 0d		bne $213c			bne 	_CTIOkay
.212f	38		sec				sec
.2130	a9 00		lda #$00			lda 	#0 							; negate temp3.
.2132	e5 14		sbc $14				sbc 	temp3
.2134	85 14		sta $14				sta 	temp3
.2136	a9 00		lda #$00			lda 	#0
.2138	e5 15		sbc $15				sbc 	temp3+1
.213a	85 15		sta $15				sta 	temp3+1
.213c					_CTIOkay:
.213c	98		tya				tya
.213d	38		sec				sec
.213e	60		rts				rts
.213f					_CTIFail:
.213f	18		clc				clc
.2140	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/skipper.src

.2141					NextLine:
.2141	18		clc				clc
.2142	a5 03		lda $03				lda 	IP
.2144	72 03		adc ($03)			adc 	(IP)
.2146	85 03		sta $03				sta 	IP
.2148	90 02		bcc $214c			bcc 	_NoCarryAdv
.214a	e6 04		inc $04				inc 	IP+1
.214c					_NoCarryAdv:
.214c	b2 03		lda ($03)			lda 	(IP)						; is there any following program ?
.214e	f0 05		beq $2155			beq 	_NLGoEnd
.2150	a2 01		ldx #$01			ldx 	#1 							; start 3 in (-2 for Next)
.2152	4c 00 00	jmp $0000			jmp 	NextCode
.2155					_NLGoEnd:
.2155	4c 14 10	jmp $1014			jmp 	WarmStart
.2158					SkipComment:
.2158	e8		inx				inx									; (IP),X points to the length.
.2159	e8		inx				inx
.215a	8a		txa				txa
.215b	a8		tay				tay 								; put into Y
.215c	18		clc				clc
.215d	71 03		adc ($03),y			adc 	(IP),y 						; add the length to X
.215f	aa		tax				tax 								; put back in X
.2160	ca		dex				dex
.2161	ca		dex				dex
.2162	4c 00 00	jmp $0000			jmp 	NextCode
.2165					CommentDecoder:
.2165	a9 06		lda #$06			lda 	#CTH_Keyword
.2167	20 5d 1e	jsr $1e5d			jsr 	DecodeWriteBuffer
.216a	a9 27		lda #$27			lda 	#"'"
.216c	20 5d 1e	jsr $1e5d			jsr 	DecodeWriteBuffer
.216f	b1 08		lda ($08),y			lda 	(srcPtr),y 					; check if there is no data
.2171	c9 01		cmp #$01			cmp 	#1
.2173	f0 0d		beq $2182			beq 	_CDEmpty 					; if so print nothing.
.2175	a9 0b		lda #$0b			lda 	#CTH_Comment
.2177	20 5d 1e	jsr $1e5d			jsr 	DecodeWriteBuffer
.217a	20 66 1e	jsr $1e66			jsr 	DecodeOutputData
.217d	a9 20		lda #$20			lda 	#32
.217f	20 5d 1e	jsr $1e5d			jsr 	DecodeWriteBuffer
.2182					_CDEmpty
.2182	60		rts				rts
.2183					DefineCode:
.2183	20 fe 10	jsr $10fe			jsr 	ErrorHandler
>2186	52 45 41 43 48 45 44 20				.text 	"REACHED DEFINITION",0
>218e	44 45 46 49 4e 49 54 49 4f 4e 00
.2199					DefineDecoder:
.2199	a9 07		lda #$07			lda 	#CTH_Definition
.219b	20 5d 1e	jsr $1e5d			jsr 	DecodeWriteBuffer
.219e	a9 3a		lda #$3a			lda 	#":"
.21a0	20 5d 1e	jsr $1e5d			jsr 	DecodeWriteBuffer
.21a3	20 66 1e	jsr $1e66			jsr 	DecodeOutputData
.21a6	a9 20		lda #$20			lda 	#32
.21a8	20 5d 1e	jsr $1e5d			jsr 	DecodeWriteBuffer
.21ab	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/tostr.src

.21ac					IntToString:
.21ac	a9 10		lda #$10			lda 	#(textBuffer) & $FF
.21ae	85 12		sta $12				sta 	0+(temp2)
.21b0	a9 08		lda #$08			lda 	#(textBuffer) >> 8
.21b2	85 13		sta $13				sta 	1+(temp2)
.21b4	a5 06		lda $06				lda 	TOS 						; value in YA
.21b6	a4 07		ldy $07				ldy 	TOS+1
.21b8	20 e8 21	jsr $21e8			jsr 	ConvertToString
.21bb	a9 10		lda #$10			lda 	#(textBuffer) & $FF
.21bd	85 06		sta $06				sta 	0+(TOS)
.21bf	a9 08		lda #$08			lda 	#(textBuffer) >> 8
.21c1	85 07		sta $07				sta 	1+(TOS)
.21c3	4c 00 00	jmp $0000			jmp 	NextCode
.21c6					PrintYA:
.21c6	48		pha				pha
.21c7	da		phx				phx
.21c8	5a		phy				phy
.21c9	48		pha				pha
.21ca	a9 10		lda #$10			lda 	#(textBuffer) & $FF
.21cc	85 12		sta $12				sta 	0+(temp2)
.21ce	a9 08		lda #$08			lda 	#(textBuffer) >> 8
.21d0	85 13		sta $13				sta 	1+(temp2)
.21d2	68		pla				pla
.21d3	20 ec 21	jsr $21ec			jsr 	ConvertToStringMain
.21d6	a2 00		ldx #$00			ldx 	#0
.21d8					_PrintYALoop:
.21d8	bd 10 08	lda $0810,x			lda 	textBuffer,x
.21db	20 5e 11	jsr $115e			jsr 	ExternPrint
.21de	e8		inx				inx
.21df	bd 10 08	lda $0810,x			lda 	textBuffer,x
.21e2	d0 f4		bne $21d8			bne 	_PrintYALoop
.21e4	7a		ply				ply
.21e5	fa		plx				plx
.21e6	68		pla				pla
.21e7	60		rts				rts
.21e8					ConvertToString:
.21e8	38		sec				sec
.21e9	80 01		bra $21ec			bra 	ConvertToStringMain
.21eb					ConvertToStringUnsigned:
.21eb	18		clc				clc
.21ec					ConvertToStringMain:
.21ec	da		phx				phx									; save XY
.21ed	5a		phy				phy
.21ee	64 1a		stz $1a				stz 	SignCount 					; this is zero suppression
.21f0	85 10		sta $10				sta 	temp1 						; save YA in temp1
.21f2	84 11		sty $11				sty 	temp1+1
.21f4	a0 00		ldy #$00			ldy 	#0 							; index to result.
.21f6	90 16		bcc $220e			bcc 	_CTSUnsigned 				; if carry clear do not adjust for -
.21f8	a5 11		lda $11				lda 	temp1+1 					; is it negative
.21fa	10 12		bpl $220e			bpl 	_CTSUnsigned
.21fc	a9 2d		lda #$2d			lda 	#"-"						; output - sign
.21fe	91 12		sta ($12),y			sta 	(temp2),y
.2200	c8		iny				iny
.2201	38		sec				sec 								; negate temp1
.2202	a9 00		lda #$00			lda 	#0
.2204	e5 10		sbc $10				sbc 	temp1
.2206	85 10		sta $10				sta 	temp1
.2208	a9 00		lda #$00			lda 	#0
.220a	e5 11		sbc $11				sbc 	temp1+1
.220c	85 11		sta $11				sta 	temp1+1
.220e					_CTSUnsigned:
.220e	a2 00		ldx #$00			ldx 	#0 							; index into subtraction table
.2210					_CTSLoop:
.2210	a9 2f		lda #$2f			lda 	#"0"-1						; set the digit to '0' code.
.2212	91 12		sta ($12),y			sta 	(temp2),y
.2214					_CTSSubLoop:
.2214	b1 12		lda ($12),y			lda 	(temp2),y 					; bump the count
.2216	1a		inc a				inc 	a
.2217	91 12		sta ($12),y			sta 	(temp2),y
.2219	38		sec				sec 								; do subtraction saving interim result
.221a	a5 10		lda $10				lda 	temp1
.221c	fd 4f 22	sbc $224f,x			sbc 	_CTSTable,x
.221f	48		pha				pha
.2220	a5 11		lda $11				lda 	temp1+1
.2222	fd 50 22	sbc $2250,x			sbc 	_CTSTable+1,x
.2225	90 07		bcc $222e			bcc 	_CTSCantSubtract 			; end of subtraction.
.2227	85 11		sta $11				sta 	temp1+1 					; save result back
.2229	68		pla				pla
.222a	85 10		sta $10				sta 	temp1
.222c	80 e6		bra $2214			bra 	_CTSSubLoop
.222e					_CTSCantSubtract:
.222e	68		pla				pla 								; throw away interim
.222f	e8		inx				inx 								; next subtractor
.2230	e8		inx				inx
.2231	b1 12		lda ($12),y			lda 	(temp2),y 					; update leading zero
.2233	49 30		eor #$30			eor 	#"0"
.2235	05 1a		ora $1a				ora 	SignCount
.2237	85 1a		sta $1a				sta 	SignCount
.2239	f0 01		beq $223c			beq		_CTSLZ 						; if all zeros so far suppress.
.223b	c8		iny				iny 								; next character
.223c					_CTSLZ:
.223c	e0 08		cpx #$08			cpx 	#_CTSTableEnd-_CTSTable 	; done them all ?
.223e	d0 d0		bne $2210			bne 	_CTSLoop
.2240					_CTSComplete:
.2240	a5 10		lda $10				lda		temp1 						; get remainder 0-9
.2242	09 30		ora #$30			ora 	#48 						; ASCII
.2244	91 12		sta ($12),y			sta 	(temp2),y					; write out
.2246	c8		iny				iny
.2247	a9 00		lda #$00			lda 	#0							; make ASCIIZ
.2249	91 12		sta ($12),y			sta 	(temp2),y
.224b	98		tya				tya 								; size in A
.224c	7a		ply				ply									; pull and exit.
.224d	fa		plx				plx
.224e	60		rts				rts
.224f					_CTSTable:
>224f	10 27 e8 03 64 00 0a 00				.word 	10000,1000,100,10 			; subtractors, this is a simple version.
.2257					_CTSTableEnd:

;******  Return to file: kernel.asm


;******  Processing file: words/system/varhandlers.src

.2257					VarAddressHandler:
.2257	18		clc				clc 								; find variable, error if it doesn't exist.
.2258	20 a9 22	jsr $22a9			jsr 	VariableFind
.225b	a5 06		lda $06				lda 	TOS
.225d	48		pha				pha
.225e	a5 07		lda $07				lda 	TOS+1
.2260	48		pha				pha
.2261	a5 10		lda $10				lda 	temp1 						; the address is the new value
.2263	85 06		sta $06				sta 	TOS
.2265	a5 11		lda $11				lda		temp1+1
.2267	85 07		sta $07				sta 	TOS+1
.2269	4c 00 00	jmp $0000			jmp 	NextCode
.226c					VarAddrHandlerDecode:
.226c	a9 26		lda #$26			lda 	#"&"
.226e	4c 5e 23	jmp $235e			jmp 	VarHandlerDecode
.2271					VarReadHandler:
.2271	18		clc				clc 								; find variable, error if it doesn't exist.
.2272	20 a9 22	jsr $22a9			jsr 	VariableFind
.2275	a5 06		lda $06				lda 	TOS
.2277	48		pha				pha
.2278	a5 07		lda $07				lda 	TOS+1
.227a	48		pha				pha
.227b	b2 10		lda ($10)			lda 	(temp1)						; read variable address to TOS
.227d	85 06		sta $06				sta 	TOS
.227f	a0 01		ldy #$01			ldy 	#1
.2281	b1 10		lda ($10),y			lda 	(temp1),y
.2283	85 07		sta $07				sta 	TOS+1
.2285	4c 00 00	jmp $0000			jmp 	NextCode
.2288					VarReadHandlerDecode:
.2288	a9 40		lda #$40			lda 	#"@"
.228a	4c 5e 23	jmp $235e			jmp 	VarHandlerDecode
.228d					VarWriteHandler:
.228d	38		sec				sec 								; find variable, create it if it doesn't exist.
.228e	20 a9 22	jsr $22a9			jsr 	VariableFind
.2291	a5 06		lda $06				lda 	TOS 						; write TOS to that address.
.2293	92 10		sta ($10)			sta 	(temp1)
.2295	a5 07		lda $07				lda 	TOS+1
.2297	a0 01		ldy #$01			ldy 	#1
.2299	91 10		sta ($10),y			sta 	(temp1),y
.229b	68		pla				pla
.229c	85 07		sta $07				sta 	TOS+1
.229e	68		pla				pla
.229f	85 06		sta $06				sta 	TOS
.22a1	4c 00 00	jmp $0000			jmp 	NextCode
.22a4					VarWriteHandlerDecode:
.22a4	a9 21		lda #$21			lda 	#"!"
.22a6	4c 5e 23	jmp $235e			jmp 	VarHandlerDecode
.22a9					VariableFind:
.22a9	08		php				php 								; save autocreate flag.
.22aa	e8		inx				inx 								; advance to/over the variable name.
.22ab	e8		inx				inx
.22ac	8a		txa				txa 								; put in Y
.22ad	a8		tay				tay
.22ae	b1 03		lda ($03),y			lda 	(IP),y 						; copy name word into temp2
.22b0	85 12		sta $12				sta 	temp2
.22b2	c8		iny				iny
.22b3	b1 03		lda ($03),y			lda 	(IP),y
.22b5	85 13		sta $13				sta 	temp2+1
.22b7	c9 1b		cmp #$1b			cmp 	#27 						; check for A-Z
.22b9	b0 0f		bcs $22ca			bcs 	_VFLong
.22bb	a5 13		lda $13				lda 	temp2+1
.22bd	d0 0b		bne $22ca			bne 	_VFLong
.22bf	a5 12		lda $12				lda 	temp2						; this is the index
.22c1	0a		asl a				asl 	a 							; double it
.22c2	85 10		sta $10				sta 	temp1
.22c4	a9 06		lda #$06			lda 	#azVariables >> 8			; set the MSB
.22c6	85 11		sta $11				sta 	temp1+1
.22c8	28		plp				plp 								; throw creation flag, it always exists.
.22c9	60		rts				rts
.22ca					_VFLong:
.22ca	a5 12		lda $12				lda 	temp2 						; built a hash table index into temp3/temp4
.22cc	6a		ror a				ror 	a
.22cd	6a		ror a				ror 	a
.22ce	6a		ror a				ror 	a
.22cf	6a		ror a				ror 	a
.22d0	45 12		eor $12				eor 	temp2
.22d2	45 13		eor $13				eor 	temp2+1
.22d4	29 0f		and #$0f			and 	#(hashTableSize-1)			; force into range
.22d6	0a		asl a				asl 	a
.22d7	69 40		adc #$40			adc 	#hashTable & $FF 			; make an address of the head => temp1/3
.22d9	85 10		sta $10				sta 	temp1
.22db	85 14		sta $14				sta 	temp3
.22dd	a9 06		lda #$06			lda 	#hashTable >> 8
.22df	85 11		sta $11				sta 	temp1+1
.22e1	85 15		sta $15				sta 	temp3+1
.22e3					_VFSearch:
.22e3	a0 01		ldy #$01			ldy 	#1							; read MSB of first record
.22e5	b1 10		lda ($10),y			lda 	(temp1),y
.22e7	f0 23		beq $230c			beq 	_VFNotFound 				; is MSB is zero, can't be a variable record
.22e9	a8		tay				tay 								; follow the link through.
.22ea	b2 10		lda ($10)			lda 	(temp1)
.22ec	85 10		sta $10				sta 	temp1
.22ee	84 11		sty $11				sty 	temp1+1
.22f0	a0 04		ldy #$04			ldy 	#4							; check if the name matches
.22f2	b1 10		lda ($10),y			lda 	(temp1),y
.22f4	c5 12		cmp $12				cmp 	temp2
.22f6	d0 eb		bne $22e3			bne 	_VFSearch 					; if it doesn't, follow the next link.
.22f8	c8		iny				iny 								; same for 2nd byte of name
.22f9	b1 10		lda ($10),y			lda 	(temp1),y
.22fb	c5 13		cmp $13				cmp 	temp2+1
.22fd	d0 e4		bne $22e3			bne 	_VFSearch
.22ff	18		clc				clc
.2300	a5 10		lda $10				lda 	temp1 						; make temp1 point to the data at offset 2
.2302	69 02		adc #$02			adc 	#2
.2304	85 10		sta $10				sta 	temp1
.2306	90 02		bcc $230a			bcc 	_VFNoPage1
.2308	e6 11		inc $11				inc 	temp1+1
.230a					_VFNoPage1:
.230a	28		plp				plp 								; don't need to worry about creation flag
.230b	60		rts				rts
.230c					_VFNotFound:
.230c	28		plp				plp 								; was carry set, e.g. create a new record if not found ?
.230d	b0 14		bcs $2323			bcs 	_VFCreate
.230f	20 fe 10	jsr $10fe			jsr 	ErrorHandler
>2312	4e 4f 20 53 55 43 48 20				.text 	"NO SUCH VARIABLE",0
>231a	56 41 52 49 41 42 4c 45 00
.2323					_VFCreate:
.2323	a0 01		ldy #$01			ldy 	#1
.2325	b2 14		lda ($14)			lda 	(temp3) 					; copy the head link to the first 2 bytes
.2327	92 0e		sta ($0e)			sta 	(nextFreeMem)
.2329	b1 14		lda ($14),y			lda 	(temp3),y
.232b	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.232d	c8		iny				iny
.232e	a9 00		lda #$00			lda 	#0	 						; write zero initialised data out.
.2330	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.2332	c8		iny				iny
.2333	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.2335	c8		iny				iny
.2336	a5 12		lda $12				lda 	temp2 						; copy the name out
.2338	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.233a	c8		iny				iny
.233b	a5 13		lda $13				lda 	temp2+1
.233d	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.233f	a0 01		ldy #$01			ldy 	#1
.2341	a5 0e		lda $0e				lda 	nextFreeMem 				; update the head link
.2343	92 14		sta ($14)			sta 	(temp3)
.2345	a5 0f		lda $0f				lda 	nextFreeMem+1
.2347	91 14		sta ($14),y			sta 	(temp3),y
.2349	18		clc				clc
.234a	a5 0e		lda $0e				lda 	nextFreeMem 				; put nextFreeMem+2 in temp1 (data pointer)
.234c	69 02		adc #$02			adc 	#2
.234e	85 10		sta $10				sta 	temp1
.2350	a5 0f		lda $0f				lda 	nextFreeMem+1
.2352	69 00		adc #$00			adc 	#0
.2354	85 11		sta $11				sta 	temp1+1
.2356	a9 06		lda #$06			lda 	#6							; shift freemem pointer up 6
.2358	a0 00		ldy #$00			ldy 	#0
.235a	20 57 1d	jsr $1d57			jsr 	AdvanceFreeMem
.235d	60		rts				rts
.235e					VarHandlerDecode:
.235e	48		pha				pha 								; save, leading space
.235f	a9 07		lda #$07			lda 	#CTH_Variable
.2361	20 5d 1e	jsr $1e5d			jsr 	DecodeWriteBuffer
.2364	68		pla				pla 								; restore and write type
.2365	20 5d 1e	jsr $1e5d			jsr 	DecodeWriteBuffer
.2368	b1 08		lda ($08),y			lda 	(srcPtr),y 					; copy to temp1
.236a	85 10		sta $10				sta 	temp1
.236c	c8		iny				iny
.236d	b1 08		lda ($08),y			lda 	(srcPtr),y
.236f	85 11		sta $11				sta 	temp1+1
.2371	a5 10		lda $10				lda 	temp1 						; output the first character
.2373	29 1f		and #$1f			and 	#31
.2375	20 a0 23	jsr $23a0			jsr 	VHOutVarChar
.2378	a2 05		ldx #$05			ldx 	#5 							; divide temp1 by 32
.237a					_VHDShift:
.237a	46 11		lsr $11				lsr 	temp1+1
.237c	66 10		ror $10				ror 	temp1
.237e	ca		dex				dex
.237f	d0 f9		bne $237a			bne 	_VHDShift
.2381	a2 ff		ldx #$ff			ldx 	#255 						; now divide that by 40 by repeated subtraction.
.2383					_VHDDiv40:
.2383	e8		inx				inx
.2384	38		sec				sec
.2385	a5 10		lda $10				lda 	temp1
.2387	e9 28		sbc #$28			sbc 	#40
.2389	a8		tay				tay
.238a	a5 11		lda $11				lda 	temp1+1
.238c	e9 00		sbc #$00			sbc 	#0
.238e	90 06		bcc $2396			bcc 	_VHDivDone
.2390	85 11		sta $11				sta 	temp1+1
.2392	84 10		sty $10				sty 	temp1
.2394	80 ed		bra $2383			bra 	_VHDDiv40
.2396					_VHDivDone:
.2396	a5 10		lda $10				lda 	temp1 						; remainder
.2398	20 a0 23	jsr $23a0			jsr 	VHOutVarChar
.239b	8a		txa				txa
.239c	20 a0 23	jsr $23a0			jsr 	VHOutVarChar 				; and result.
.239f	60		rts				rts
.23a0					VHOutVarChar:
.23a0	c9 00		cmp #$00			cmp 	#0
.23a2	f0 0c		beq $23b0			beq 	_VHOExit
.23a4	18		clc				clc
.23a5	69 40		adc #$40			adc 	#64 						; 65-90 A-Z 91-100 0-9
.23a7	c9 5b		cmp #$5b			cmp 	#91 						; convert back ?
.23a9	90 02		bcc $23ad			bcc 	_VHOOut
.23ab	e9 2b		sbc #$2b			sbc 	#91-48 						; adjust to digit
.23ad					_VHOOut:
.23ad	20 5d 1e	jsr $1e5d			jsr 	DecodeWriteBuffer
.23b0					_VHOExit:
.23b0	60		rts				rts

;******  Return to file: kernel.asm

.23b1					Dictionary:

;******  Processing file: generated/dictionary.inc

>23b1	05					.byte	_end0-*
>23b2	00					.byte	$00
>23b3	4f 16					.word	WordWrite
>23b5	a1					.byte	$a1
.23b6					_end0:
>23b6	10					.byte	_end1-*
>23b7	52					.byte	$52
>23b8	8d 22					.word	VarWriteHandler
>23ba	a4 22					.word	VarWriteHandlerDecode
>23bc	24 24 21 48 41 4e 44 4c			.byte	$24,$24,$21,$48,$41,$4e,$44,$4c,$45,$d2
>23c4	45 d2
.23c6					_end1:
>23c6	10					.byte	_end2-*
>23c7	52					.byte	$52
>23c8	57 22					.word	VarAddressHandler
>23ca	6c 22					.word	VarAddrHandlerDecode
>23cc	24 24 26 48 41 4e 44 4c			.byte	$24,$24,$26,$48,$41,$4e,$44,$4c,$45,$d2
>23d4	45 d2
.23d6					_end2:
>23d6	10					.byte	_end3-*
>23d7	52					.byte	$52
>23d8	71 22					.word	VarReadHandler
>23da	88 22					.word	VarReadHandlerDecode
>23dc	24 24 40 48 41 4e 44 4c			.byte	$24,$24,$40,$48,$41,$4e,$44,$4c,$45,$d2
>23e4	45 d2
.23e6					_end3:
>23e6	0c					.byte	_end4-*
>23e7	52					.byte	$52
>23e8	ba 1b					.word	CallHandler
>23ea	93 1c					.word	CallHandlerDecode
>23ec	24 24 43 41 4c cc			.byte	$24,$24,$43,$41,$4c,$cc
.23f2					_end4:
>23f2	0f					.byte	_end5-*
>23f3	53					.byte	$53
>23f4	58 21					.word	SkipComment
>23f6	65 21					.word	CommentDecoder
>23f8	24 24 43 4f 4d 4d 45 4e			.byte	$24,$24,$43,$4f,$4d,$4d,$45,$4e,$d4
>2400	d4
.2401					_end5:
>2401	0e					.byte	_end6-*
>2402	53					.byte	$53
>2403	83 21					.word	DefineCode
>2405	99 21					.word	DefineDecoder
>2407	24 24 44 45 46 49 4e c5			.byte	$24,$24,$44,$45,$46,$49,$4e,$c5
.240f					_end6:
>240f	0f					.byte	_end7-*
>2410	52					.byte	$52
>2411	a6 10					.word	Literal2Byte
>2413	bc 10					.word	Literal2ByteDecode
>2415	24 24 4c 49 54 45 52 41			.byte	$24,$24,$4c,$49,$54,$45,$52,$41,$cc
>241d	cc
.241e					_end7:
>241e	0e					.byte	_end8-*
>241f	80					.byte	$80
>2420	41 21					.word	NextLine
>2422	24 24 4e 45 58 54 4c 49			.byte	$24,$24,$4e,$45,$58,$54,$4c,$49,$4e,$c5
>242a	4e c5
.242c					_end8:
>242c	0e					.byte	_end9-*
>242d	53					.byte	$53
>242e	ce 10					.word	LiteralString
>2430	ed 10					.word	LiteralStringDecoder
>2432	24 24 53 54 52 49 4e c7			.byte	$24,$24,$53,$54,$52,$49,$4e,$c7
.243a					_end9:
>243a	05					.byte	_end10-*
>243b	00					.byte	$00
>243c	cb 13					.word	Multiply16x16
>243e	aa					.byte	$aa
.243f					_end10:
>243f	05					.byte	_end11-*
>2440	00					.byte	$00
>2441	38 12					.word	Add
>2443	ab					.byte	$ab
.2444					_end11:
>2444	06					.byte	_end12-*
>2445	00					.byte	$00
>2446	60 16					.word	WordAdd
>2448	2b a1					.byte	$2b,$a1
.244a					_end12:
>244a	05					.byte	_end13-*
>244b	00					.byte	$00
>244c	47 12					.word	Subtract
>244e	ad					.byte	$ad
.244f					_end13:
>244f	06					.byte	_end14-*
>2450	00					.byte	$00
>2451	07 15					.word	ConstantMinus1
>2453	2d b1					.byte	$2d,$b1
.2455					_end14:
>2455	06					.byte	_end15-*
>2456	00					.byte	$00
>2457	68 20					.word	DumpStack
>2459	2e ae					.byte	$2e,$ae
.245b					_end15:
>245b	05					.byte	_end16-*
>245c	00					.byte	$00
>245d	1c 13					.word	Divide16x16
>245f	af					.byte	$af
.2460					_end16:
>2460	05					.byte	_end17-*
>2461	00					.byte	$00
>2462	fa 14					.word	Constant0
>2464	b0					.byte	$b0
.2465					_end17:
>2465	06					.byte	_end18-*
>2466	00					.byte	$00
>2467	60 14					.word	CheckMinus
>2469	30 bc					.byte	$30,$bc
.246b					_end18:
>246b	06					.byte	_end19-*
>246c	00					.byte	$00
>246d	74 14					.word	CheckZero
>246f	30 bd					.byte	$30,$bd
.2471					_end19:
>2471	05					.byte	_end20-*
>2472	00					.byte	$00
>2473	16 15					.word	C1
>2475	b1					.byte	$b1
.2476					_end20:
>2476	06					.byte	_end21-*
>2477	00					.byte	$00
>2478	0a 14					.word	Unary1Plus
>247a	31 ab					.byte	$31,$ab
.247c					_end21:
>247c	06					.byte	_end22-*
>247d	00					.byte	$00
>247e	21 14					.word	Unary1Minus
>2480	31 ad					.byte	$31,$ad
.2482					_end22:
>2482	06					.byte	_end23-*
>2483	00					.byte	$00
>2484	2e 15					.word	C10
>2486	31 b0					.byte	$31,$b0
.2488					_end23:
>2488	07					.byte	_end24-*
>2489	00					.byte	$00
>248a	57 15					.word	C100
>248c	31 30 b0				.byte	$31,$30,$b0
.248f					_end24:
>248f	08					.byte	_end25-*
>2490	00					.byte	$00
>2491	86 15					.word	C1024
>2493	31 30 32 b4				.byte	$31,$30,$32,$b4
.2497					_end25:
>2497	07					.byte	_end26-*
>2498	00					.byte	$00
>2499	5b 15					.word	C127
>249b	31 32 b7				.byte	$31,$32,$b7
.249e					_end26:
>249e	07					.byte	_end27-*
>249f	00					.byte	$00
>24a0	5f 15					.word	C128
>24a2	31 32 b8				.byte	$31,$32,$b8
.24a5					_end27:
>24a5	06					.byte	_end28-*
>24a6	00					.byte	$00
>24a7	32 15					.word	C15
>24a9	31 b5					.byte	$31,$b5
.24ab					_end28:
>24ab	06					.byte	_end29-*
>24ac	00					.byte	$00
>24ad	36 15					.word	C16
>24af	31 b6					.byte	$31,$b6
.24b1					_end29:
>24b1	07					.byte	_end30-*
>24b2	00					.byte	$00
>24b3	98 14					.word	Times16
>24b5	31 36 aa				.byte	$31,$36,$aa
.24b8					_end30:
>24b8	07					.byte	_end31-*
>24b9	00					.byte	$00
>24ba	ab 14					.word	Divide16
>24bc	31 36 af				.byte	$31,$36,$af
.24bf					_end31:
>24bf	05					.byte	_end32-*
>24c0	00					.byte	$00
>24c1	1a 15					.word	C2
>24c3	b2					.byte	$b2
.24c4					_end32:
>24c4	06					.byte	_end33-*
>24c5	00					.byte	$00
>24c6	a4 14					.word	Times2
>24c8	32 aa					.byte	$32,$aa
.24ca					_end33:
>24ca	06					.byte	_end34-*
>24cb	00					.byte	$00
>24cc	13 14					.word	Unary2Plus
>24ce	32 ab					.byte	$32,$ab
.24d0					_end34:
>24d0	06					.byte	_end35-*
>24d1	00					.byte	$00
>24d2	2c 14					.word	Unary2Minus
>24d4	32 ad					.byte	$32,$ad
.24d6					_end35:
>24d6	06					.byte	_end36-*
>24d7	00					.byte	$00
>24d8	b7 14					.word	Divide2
>24da	32 af					.byte	$32,$af
.24dc					_end36:
>24dc	06					.byte	_end37-*
>24dd	00					.byte	$00
>24de	3a 15					.word	C24
>24e0	32 b4					.byte	$32,$b4
.24e2					_end37:
>24e2	07					.byte	_end38-*
>24e3	00					.byte	$00
>24e4	63 15					.word	C255
>24e6	32 35 b5				.byte	$32,$35,$b5
.24e9					_end38:
>24e9	07					.byte	_end39-*
>24ea	00					.byte	$00
>24eb	6e 15					.word	C256
>24ed	32 35 b6				.byte	$32,$35,$b6
.24f0					_end39:
>24f0	08					.byte	_end40-*
>24f1	00					.byte	$00
>24f2	be 14					.word	Times256
>24f4	32 35 36 aa				.byte	$32,$35,$36,$aa
.24f8					_end40:
>24f8	08					.byte	_end41-*
>24f9	00					.byte	$00
>24fa	c7 14					.word	Divide256
>24fc	32 35 36 af				.byte	$32,$35,$36,$af
.2500					_end41:
>2500	05					.byte	_end42-*
>2501	00					.byte	$00
>2502	1e 15					.word	C3
>2504	b3					.byte	$b3
.2505					_end42:
>2505	06					.byte	_end43-*
>2506	00					.byte	$00
>2507	4b 15					.word	C32
>2509	33 b2					.byte	$33,$b2
.250b					_end43:
>250b	09					.byte	_end44-*
>250c	00					.byte	$00
>250d	9e 15					.word	C32767
>250f	33 32 37 36 b7				.byte	$33,$32,$37,$36,$b7
.2514					_end44:
>2514	09					.byte	_end45-*
>2515	00					.byte	$00
>2516	aa 15					.word	C32768
>2518	33 32 37 36 b8				.byte	$33,$32,$37,$36,$b8
.251d					_end45:
>251d	05					.byte	_end46-*
>251e	00					.byte	$00
>251f	22 15					.word	C4
>2521	b4					.byte	$b4
.2522					_end46:
>2522	06					.byte	_end47-*
>2523	00					.byte	$00
>2524	a0 14					.word	Times4
>2526	34 aa					.byte	$34,$aa
.2528					_end47:
>2528	06					.byte	_end48-*
>2529	00					.byte	$00
>252a	b3 14					.word	Divide4
>252c	34 af					.byte	$34,$af
.252e					_end48:
>252e	08					.byte	_end49-*
>252f	00					.byte	$00
>2530	92 15					.word	C4096
>2532	34 30 39 b6				.byte	$34,$30,$39,$b6
.2536					_end49:
>2536	05					.byte	_end50-*
>2537	00					.byte	$00
>2538	26 15					.word	C5
>253a	b5					.byte	$b5
.253b					_end50:
>253b	07					.byte	_end51-*
>253c	00					.byte	$00
>253d	7a 15					.word	C512
>253f	35 31 b2				.byte	$35,$31,$b2
.2542					_end51:
>2542	06					.byte	_end52-*
>2543	00					.byte	$00
>2544	4f 15					.word	C63
>2546	36 b3					.byte	$36,$b3
.2548					_end52:
>2548	06					.byte	_end53-*
>2549	00					.byte	$00
>254a	53 15					.word	C64
>254c	36 b4					.byte	$36,$b4
.254e					_end53:
>254e	05					.byte	_end54-*
>254f	00					.byte	$00
>2550	2a 15					.word	C8
>2552	b8					.byte	$b8
.2553					_end54:
>2553	06					.byte	_end55-*
>2554	00					.byte	$00
>2555	9c 14					.word	Times8
>2557	38 aa					.byte	$38,$aa
.2559					_end55:
>2559	06					.byte	_end56-*
>255a	00					.byte	$00
>255b	af 14					.word	Divide8
>255d	38 af					.byte	$38,$af
.255f					_end56:
>255f	05					.byte	_end57-*
>2560	40					.byte	$40
>2561	50 1c					.word	ReturnHandler
>2563	bb					.byte	$bb
.2564					_end57:
>2564	05					.byte	_end58-*
>2565	00					.byte	$00
>2566	b8 12					.word	CheckLess
>2568	bc					.byte	$bc
.2569					_end58:
>2569	06					.byte	_end59-*
>256a	00					.byte	$00
>256b	d1 12					.word	CheckLessEq
>256d	3c bd					.byte	$3c,$bd
.256f					_end59:
>256f	06					.byte	_end60-*
>2570	00					.byte	$00
>2571	81 12					.word	CheckNotEqual
>2573	3c be					.byte	$3c,$be
.2575					_end60:
>2575	05					.byte	_end61-*
>2576	00					.byte	$00
>2577	84 12					.word	CheckEqual
>2579	bd					.byte	$bd
.257a					_end61:
>257a	05					.byte	_end62-*
>257b	00					.byte	$00
>257c	d4 12					.word	CheckGreater
>257e	be					.byte	$be
.257f					_end62:
>257f	06					.byte	_end63-*
>2580	00					.byte	$00
>2581	b5 12					.word	CheckGreaterEq
>2583	3e bd					.byte	$3e,$bd
.2585					_end63:
>2585	08					.byte	_end64-*
>2586	00					.byte	$00
>2587	bf 15					.word	TestDup
>2589	3f 44 55 d0				.byte	$3f,$44,$55,$d0
.258d					_end64:
>258d	05					.byte	_end65-*
>258e	00					.byte	$00
>258f	34 16					.word	WordRead
>2591	c0					.byte	$c0
.2592					_end65:
>2592	07					.byte	_end66-*
>2593	00					.byte	$00
>2594	3a 14					.word	Absolute
>2596	41 42 d3				.byte	$41,$42,$d3
.2599					_end66:
>2599	09					.byte	_end67-*
>259a	00					.byte	$00
>259b	77 16					.word	AllocateMemory
>259d	41 4c 4c 4f c3				.byte	$41,$4c,$4c,$4f,$c3
.25a2					_end67:
>25a2	07					.byte	_end68-*
>25a3	00					.byte	$00
>25a4	5a 12					.word	And
>25a6	41 4e c4				.byte	$41,$4e,$c4
.25a9					_end68:
>25a9	0a					.byte	_end69-*
>25aa	00					.byte	$00
>25ab	f3 1f					.word	AssertCode
>25ad	41 53 53 45 52 d4			.byte	$41,$53,$53,$45,$52,$d4
.25b3					_end69:
>25b3	09					.byte	_end70-*
>25b4	00					.byte	$00
>25b5	8d 14					.word	ByteSwap
>25b7	42 53 57 41 d0				.byte	$42,$53,$57,$41,$d0
.25bc					_end70:
>25bc	06					.byte	_end71-*
>25bd	00					.byte	$00
>25be	42 16					.word	ByteWrite
>25c0	43 a1					.byte	$43,$a1
.25c2					_end71:
>25c2	06					.byte	_end72-*
>25c3	00					.byte	$00
>25c4	2b 16					.word	ByteRead
>25c6	43 c0					.byte	$43,$c0
.25c8					_end72:
>25c8	07					.byte	_end73-*
>25c9	00					.byte	$00
>25ca	1d 1d					.word	ClrHandler
>25cc	43 4c d2				.byte	$43,$4c,$d2
.25cf					_end73:
>25cf	08					.byte	_end74-*
>25d0	00					.byte	$00
>25d1	b6 15					.word	Drop
>25d3	44 52 4f d0				.byte	$44,$52,$4f,$d0
.25d7					_end74:
>25d7	07					.byte	_end75-*
>25d8	00					.byte	$00
>25d9	c8 15					.word	Dup
>25db	44 55 d0				.byte	$44,$55,$d0
.25de					_end75:
>25de	0a					.byte	_end76-*
>25df	21					.byte	$21
>25e0	06 1b					.word	ElseHandler
>25e2	09 1b					.word	ElseEncoder
>25e4	45 4c 53 c5				.byte	$45,$4c,$53,$c5
.25e8					_end76:
>25e8	07					.byte	_end77-*
>25e9	00					.byte	$00
>25ea	14 20					.word	EndProgram
>25ec	45 4e c4				.byte	$45,$4e,$c4
.25ef					_end77:
>25ef	0b					.byte	_end78-*
>25f0	20					.byte	$20
>25f1	28 1b					.word	EndIfHandler
>25f3	2b 1b					.word	EndIfEncoder
>25f5	45 4e 44 49 c6				.byte	$45,$4e,$44,$49,$c6
.25fa					_end78:
>25fa	09					.byte	_end79-*
>25fb	20					.byte	$20
>25fc	26 1a					.word	ForHandler
>25fe	5c 1a					.word	ForEncoder
>2600	46 4f d2				.byte	$46,$4f,$d2
.2603					_end79:
>2603	08					.byte	_end80-*
>2604	21					.byte	$21
>2605	f1 1a					.word	IfHandler
>2607	f4 1a					.word	IfEncoder
>2609	49 c6					.byte	$49,$c6
.260b					_end80:
>260b	09					.byte	_end81-*
>260c	00					.byte	$00
>260d	d0 1a					.word	GetIndex
>260f	49 4e 44 45 d8				.byte	$49,$4e,$44,$45,$d8
.2614					_end81:
>2614	08					.byte	_end82-*
>2615	00					.byte	$00
>2616	4d 1f					.word	ListCode
>2618	4c 49 53 d4				.byte	$4c,$49,$53,$d4
.261c					_end82:
>261c	07					.byte	_end83-*
>261d	00					.byte	$00
>261e	f1 12					.word	Maximum
>2620	4d 41 d8				.byte	$4d,$41,$d8
.2623					_end83:
>2623	07					.byte	_end84-*
>2624	00					.byte	$00
>2625	ed 12					.word	Minimum
>2627	4d 49 ce				.byte	$4d,$49,$ce
.262a					_end84:
>262a	07					.byte	_end85-*
>262b	00					.byte	$00
>262c	2d 13					.word	Modulus16x16
>262e	4d 4f c4				.byte	$4d,$4f,$c4
.2631					_end85:
>2631	0a					.byte	_end86-*
>2632	00					.byte	$00
>2633	41 14					.word	Negate
>2635	4e 45 47 41 54 c5			.byte	$4e,$45,$47,$41,$54,$c5
.263b					_end86:
>263b	07					.byte	_end87-*
>263c	00					.byte	$00
>263d	14 1d					.word	NewHandler
>263f	4e 45 d7				.byte	$4e,$45,$d7
.2642					_end87:
>2642	0a					.byte	_end88-*
>2643	21					.byte	$21
>2644	69 1a					.word	NextHandler
>2646	a8 1a					.word	NextEncoder
>2648	4e 45 58 d4				.byte	$4e,$45,$58,$d4
.264c					_end88:
>264c	07					.byte	_end89-*
>264d	00					.byte	$00
>264e	fc 15					.word	Nip
>2650	4e 49 d0				.byte	$4e,$49,$d0
.2653					_end89:
>2653	07					.byte	_end90-*
>2654	00					.byte	$00
>2655	51 14					.word	OneComplement
>2657	4e 4f d4				.byte	$4e,$4f,$d4
.265a					_end90:
>265a	06					.byte	_end91-*
>265b	00					.byte	$00
>265c	74 12					.word	LogOr
>265e	4f d2					.byte	$4f,$d2
.2660					_end91:
>2660	08					.byte	_end92-*
>2661	00					.byte	$00
>2662	e4 15					.word	Over
>2664	4f 56 45 d2				.byte	$4f,$56,$45,$d2
.2668					_end92:
>2668	0c					.byte	_end93-*
>2669	20					.byte	$20
>266a	5a 1b					.word	RepeatHandler
>266c	5d 1b					.word	RepeatEncoder
>266e	52 45 50 45 41 d4			.byte	$52,$45,$50,$45,$41,$d4
.2674					_end93:
>2674	07					.byte	_end94-*
>2675	00					.byte	$00
>2676	d0 14					.word	RandomNumber
>2678	52 4e c4				.byte	$52,$4e,$c4
.267b					_end94:
>267b	07					.byte	_end95-*
>267c	00					.byte	$00
>267d	01 16					.word	Rot
>267f	52 4f d4				.byte	$52,$4f,$d4
.2682					_end95:
>2682	07					.byte	_end96-*
>2683	00					.byte	$00
>2684	c8 1f					.word	RunProgram
>2686	52 55 ce				.byte	$52,$55,$ce
.2689					_end96:
>2689	07					.byte	_end97-*
>268a	00					.byte	$00
>268b	7c 14					.word	SignTOS
>268d	53 47 ce				.byte	$53,$47,$ce
.2690					_end97:
>2690	08					.byte	_end98-*
>2691	00					.byte	$00
>2692	0c 20					.word	StopCode
>2694	53 54 4f d0				.byte	$53,$54,$4f,$d0
.2698					_end98:
>2698	08					.byte	_end99-*
>2699	00					.byte	$00
>269a	d1 15					.word	Swap
>269c	53 57 41 d0				.byte	$53,$57,$41,$d0
.26a0					_end99:
>26a0	07					.byte	_end100-*
>26a1	00					.byte	$00
>26a2	dc 1f					.word	Call6502
>26a4	53 59 d3				.byte	$53,$59,$d3
.26a7					_end100:
>26a7	0d					.byte	_end101-*
>26a8	00					.byte	$00
>26a9	ac 21					.word	IntToString
>26ab	54 4f 2e 53 54 52 49 4e			.byte	$54,$4f,$2e,$53,$54,$52,$49,$4e,$c7
>26b3	c7
.26b4					_end101:
>26b4	0b					.byte	_end102-*
>26b5	21					.byte	$21
>26b6	6a 1b					.word	UntilHandler
>26b8	6d 1b					.word	UntilEncoder
>26ba	55 4e 54 49 cc				.byte	$55,$4e,$54,$49,$cc
.26bf					_end102:
>26bf	09					.byte	_end103-*
>26c0	00					.byte	$00
>26c1	17 20					.word	VlistCode
>26c3	56 4c 49 53 d4				.byte	$56,$4c,$49,$53,$d4
.26c8					_end103:
>26c8	0a					.byte	_end104-*
>26c9	40					.byte	$40
>26ca	68 1d					.word	BreakCmd
>26cc	58 42 52 45 41 cb			.byte	$58,$42,$52,$45,$41,$cb
.26d2					_end104:
>26d2	09					.byte	_end105-*
>26d3	00					.byte	$00
>26d4	62 1d					.word	ExitDump
>26d6	58 44 55 4d d0				.byte	$58,$44,$55,$4d,$d0
.26db					_end105:
>26db	07					.byte	_end106-*
>26dc	00					.byte	$00
>26dd	67 12					.word	Xor
>26df	58 4f d2				.byte	$58,$4f,$d2
.26e2					_end106:
>26e2	00					.byte	0

;******  Return to file: kernel.asm

>3fff	ff						.byte 	$FF
.4000					ProgramMemory:

;******  End of listing
