
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -q -c -o kernel_nocode.prg -L kernel.lst -l kernel.lbl kernel.asm
; Sat Jan 11 08:22:44 2020

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: kernel.asm

=$1000					RplBuild = $1000 							; code starts here.

;******  Processing file: data.asm

.0000					Next:
>0000							.fill 	5
=3					IP = Next+3 								; the IP which points to the current instruction
.0005					rsp:
>0005							.byte 	?
.0006					tos:
>0006							.word 	?
.0008					srcPtr:
>0008							.word 	?
.000a					bufPtr:
>000a							.word 	?
.000c					matchPtr:
>000c							.word 	?
.000e					nextFreeMem:
>000e							.word 	?
.0010					temp1:
>0010							.word 	?
.0012					temp2:
>0012							.word 	?
.0014					temp3:
>0014							.word 	?
.0016					temp4:
>0016							.word 	?
.0018					listPtr:
>0018							.word 	?
.001a					SignCount:
>001a							.byte 	?
.001b					RandomSeed:
>001b							.word 	?
.001d					ListCount:
>001d							.byte 	?
.001e					ListLowest:
>001e							.word 	?
=$102					stack2Low = $102							; access other stack members following tsx
=$101					stack2High = $101							; (which requires saving X, not on the stack !)
=$104					stack3Low = $104
=$103					stack3High = $103
=$600					azVariables = $600 							; 26 x 2 variables occupying 52 bytes * PAGE BOUNDARY *
=16					hashTableSize = 16 							; hash tables for variables.
=$640					hashTable = $640 							; hash tables start here * ALL ON ONE PAGE *
=$810					textBuffer = $810 							; buffer for text.
=$700					returnStack = $700							; return stack (1 page)
=$700					returnStackLow = returnStack
=1856					returnStackHigh = returnStack+$40
=1920					returnStackX = returnStack+$80
=$80					NumberStackBase = $80 						; number stack down from here.
=0					COL_BLACK = 0
=1					COL_RED = 1
=2					COL_GREEN = 2
=3					COL_YELLOW = 3
=4					COL_BLUE = 4
=5					COL_MAGENTA = 5
=6					COL_CYAN = 6
=7					COL_WHITE = 7
=8					COL_RVS = 8
=2					CTH_LineNo = COL_Green
=6					CTH_Keyword = COL_Cyan
=11					CTH_Comment = COL_Yellow+COL_Rvs
=7					CTH_Definition = COL_White
=5					CTH_String = COL_Magenta
=3					CTH_Call = COL_Yellow

;******  Return to file: kernel.asm

.1000	a2 ff		ldx #$ff			ldx 		#$FF 					; reset the stack
.1002	9a		txs				txs
.1003	20 d9 10	jsr $10d9			jsr 		ExternInitialise
.1006	a9 20		lda #$20			lda 	#BootMsg & $FF
.1008	a0 10		ldy #$10			ldy 	#BootMsg >> 8
.100a	20 c9 11	jsr $11c9			jsr 	EXPrintString
.100d					WarmStartBlankStack:
.100d	a2 80		ldx #$80			ldx 	#NumberStackBase
.100f	9a		txs				txs
.1010					WarmStart:
.1010	a9 03		lda #$03			lda 	#COL_Yellow
.1012	20 10 11	jsr $1110			jsr 	ExternColour
.1015	a9 06		lda #$06			lda 	#COL_Cyan
.1017	20 10 11	jsr $1110			jsr 	ExternColour
.101a	4c 21 1a	jmp $1a21			jmp 	RunProgram
.101d					ErrorHandler:
>101d	ff						.byte 	$FF
.101e	a2 5e		ldx #$5e			ldx 	#$5E
.1020					BootMsg:
>1020	2a 2a 2a 20 52 50 4c 2f				.text 	"*** RPL/C INTERPRETER ***",13,13
>1028	43 20 49 4e 54 45 52 50 52 45 54 45 52 20 2a 2a
>1038	2a 0d 0d
>103b	57 52 49 54 54 45 4e 20				.text	"WRITTEN BY PAUL ROBSON 2020",13,13
>1043	42 59 20 50 41 55 4c 20 52 4f 42 53 4f 4e 20 32
>1053	30 32 30 0d 0d
>1058	42 55 49 4c 44 3a 20				.text 	"BUILD: "

;******  Processing file: generated/timestamp.inc

>105f	5b 32 30 2d 30 31 2d 31			.text	"[20-01-11 08:22]"
>1067	31 20 30 38 3a 32 32 5d

;******  Return to file: kernel.asm

>106f	0d 0d 00					.byte 	13,13,0

;******  Processing file: core.src

.1072					InitialiseCoreCode:
.1072	a9 e8		lda #$e8			lda 	#$E8 					; Copy INX INX 			4 cycles when run
.1074	85 00		sta $00				sta 	Next
.1076	85 01		sta $01				sta 	Next+1
.1078	a9 7c		lda #$7c			lda 	#$7C 					; Copy JMP ($aaaa,x) 	6 cycles when run
.107a	85 02		sta $02				sta 	Next+2
.107c	86 03		stx $03				stx 	Next+3 					; set the indirect address (IP)
.107e	84 04		sty $04				sty 	Next+4
.1080	a2 01		ldx #$01			ldx 	#1 						; set up to run from provided word.
.1082	60		rts				rts								; (2 INX skip offset and line#)
.1083					Literal2Byte:
.1083	a5 06		lda $06				lda 	TOS
.1085	48		pha				pha
.1086	a5 07		lda $07				lda 	TOS+1
.1088	48		pha				pha
.1089	e8		inx				inx  							; point X to the word
.108a	e8		inx				inx
.108b	8a		txa				txa 							; copy into Y
.108c	a8		tay				tay
.108d	b1 03		lda ($03),y			lda 	(IP),y 					; read it. the LSB
.108f	85 06		sta $06				sta 	TOS
.1091	c8		iny				iny 							; read and push the MSB
.1092	b1 03		lda ($03),y			lda 	(IP),y
.1094	85 07		sta $07				sta 	TOS+1
.1096	4c 00 00	jmp $0000			jmp 	Next
.1099					Literal2ByteDecode:
.1099	a9 06		lda #$06			lda 	#CTH_Keyword
.109b	20 65 19	jsr $1965			jsr 	DecodeWriteBuffer
.109e	b1 08		lda ($08),y			lda 	(srcPtr),y
.10a0	aa		tax				tax
.10a1	c8		iny				iny
.10a2	b1 08		lda ($08),y			lda 	(srcPtr),y
.10a4	a8		tay				tay
.10a5	8a		txa				txa
.10a6	38		sec				sec 							; output signed
.10a7	20 87 19	jsr $1987			jsr 	DecodeYAToBuffer
.10aa	60		rts				rts
.10ab					LiteralString:
.10ab	a5 06		lda $06				lda 	TOS
.10ad	48		pha				pha
.10ae	a5 07		lda $07				lda 	TOS+1
.10b0	48		pha				pha
.10b1	e8		inx				inx
.10b2	e8		inx				inx 							; skip over current word
.10b3	8a		txa				txa 							; add to IP + 1 to give string address
.10b4	a8		tay				tay 							; put in Y
.10b5	38		sec				sec 							; make that TOS
.10b6	65 03		adc $03				adc 	IP
.10b8	85 06		sta $06				sta 	TOS
.10ba	a5 04		lda $04				lda 	IP+1
.10bc	69 00		adc #$00			adc 	#0
.10be	85 07		sta $07				sta 	TOS+1
.10c0	8a		txa				txa 							; add data length to X
.10c1	18		clc				clc
.10c2	71 03		adc ($03),y			adc 	(IP),y
.10c4	aa		tax				tax
.10c5	4c 02 00	jmp $0002			jmp 	Next+2 					; jump without pre-increment
.10c8					LiteralStringDecoder:
.10c8	a9 05		lda #$05			lda 	#CTH_String
.10ca	20 65 19	jsr $1965			jsr 	DecodeWriteBuffer
.10cd	a9 22		lda #$22			lda 	#'"'
.10cf	20 65 19	jsr $1965			jsr 	DecodeWriteBuffer
.10d2	20 6e 19	jsr $196e			jsr 	DecodeOutputData
.10d5	20 65 19	jsr $1965			jsr 	DecodeWriteBuffer
.10d8	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: extern.asm

.10d9					ExternInitialise:
.10d9	a9 90		lda #$90			lda 	#144 						; set colour
.10db	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.10de	a9 01		lda #$01			lda 	#$01
.10e0	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.10e3	a9 0e		lda #$0e			lda 	#14							; lower case
.10e5	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.10e8	a9 93		lda #$93			lda 	#147 						; clear screen
.10ea	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.10ed	a9 07		lda #$07			lda 	#COL_WHITE 					; white text.
.10ef	4c 10 11	jmp $1110			jmp 	ExternColour
.10f2					ExternCheckBreak:
.10f2	da		phx				phx 								; make sure we keep XY
.10f3	5a		phy				phy
.10f4	20 e1 ff	jsr $ffe1			jsr 	$FFE1						; STOP check on CBM KERNAL
.10f7	f0 03		beq $10fc			beq		_ECBExit 					; stopped
.10f9	7a		ply				ply 								; restore and exit.
.10fa	fa		plx				plx
.10fb	60		rts				rts
.10fc					_ECBExit:
.10fc	20 1d 10	jsr $101d			jsr 	ErrorHandler
>10ff	45 53 43 41 50 45 00				.text 	"ESCAPE",0
.1106					ExternPrint:
.1106	48		pha				pha
.1107	da		phx				phx
.1108	5a		phy				phy
.1109	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.110c	7a		ply				ply
.110d	fa		plx				plx
.110e	68		pla				pla
.110f	60		rts				rts
.1110					ExternColour:
.1110	48		pha				pha
.1111	da		phx				phx
.1112	48		pha				pha
.1113	29 08		and #$08			and 	#8
.1115	0a		asl a				asl 	a
.1116	0a		asl a				asl 	a
.1117	0a		asl a				asl 	a
.1118	0a		asl a				asl 	a
.1119	49 92		eor #$92			eor 	#$92
.111b	20 06 11	jsr $1106			jsr 	ExternPrint
.111e	68		pla				pla
.111f	29 07		and #$07			and 	#7
.1121	aa		tax				tax
.1122	bd 2b 11	lda $112b,x			lda 	_ECTable,x
.1125	20 06 11	jsr $1106			jsr 	ExternPrint
.1128	fa		plx				plx
.1129	68		pla				pla
.112a	60		rts				rts
.112b					_ECTable:
>112b	90						.byte 	144
>112c	1c						.byte 	28
>112d	1e						.byte 	30
>112e	9e						.byte 	158
>112f	1f						.byte 	31
>1130	9c						.byte 	156
>1131	9f						.byte 	159
>1132	05						.byte 	5
.1133					ExternInput:
.1133	a9 10		lda #$10			lda 	#(textBuffer & $FF)
.1135	85 14		sta $14				sta 	temp3
.1137	a9 08		lda #$08			lda 	#(textBuffer >> 8)
.1139	85 15		sta $15				sta 	temp3+1
.113b	20 cf ff	jsr $ffcf	_EIRead:jsr 	$FFCF
.113e	29 7f		and #$7f			and 	#$7F
.1140	c9 0d		cmp #$0d			cmp 	#13
.1142	f0 0a		beq $114e			beq 	_EIExit
.1144	92 14		sta ($14)			sta 	(temp3)
.1146	e6 14		inc $14				inc 	temp3
.1148	d0 f1		bne $113b			bne 	_EIRead
.114a	e6 15		inc $15				inc 	temp3+1
.114c	80 ed		bra $113b			bra 	_EIRead
.114e	a9 00		lda #$00	_EIExit:lda 	#0
.1150	92 14		sta ($14)			sta 	(temp3)
.1152	a9 0d		lda #$0d			lda 	#13
.1154	20 06 11	jsr $1106			jsr 	ExternPrint
.1157	60		rts				rts
.1158					ExternSave:
.1158	da		phx				phx
.1159	5a		phy				phy
.115a	85 12		sta $12				sta 	temp2 						; save start
.115c	84 13		sty $13				sty 	temp2+1
.115e	20 c0 11	jsr $11c0			jsr 	EXGetLength 				; get length of file into A
.1161	a6 14		ldx $14				ldx 	temp3
.1163	a4 15		ldy $15				ldy 	temp3+1
.1165	20 bd ff	jsr $ffbd			jsr 	$FFBD 						; set name
.1168	a9 01		lda #$01			lda 	#1
.116a	a2 08		ldx #$08			ldx 	#8	 						; device #8
.116c	a0 00		ldy #$00			ldy 	#0
.116e	20 ba ff	jsr $ffba			jsr 	$FFBA 						; set LFS
.1171	a6 10		ldx $10				ldx 	temp1 						; end address
.1173	a4 11		ldy $11				ldy 	temp1+1
.1175	a9 12		lda #$12			lda 	#temp2
.1177	20 d8 ff	jsr $ffd8			jsr 	$FFD8 						; save
.117a	b0 03		bcs $117f			bcs 	_ESSave
.117c	7a		ply				ply
.117d	fa		plx				plx
.117e	60		rts				rts
.117f					_ESSave:
.117f	20 1d 10	jsr $101d			jsr 	ErrorHandler
>1182	53 41 56 45 20 46 41 49				.text 	"SAVE FAILED",0
>118a	4c 45 44 00
.118e					ExternLoad:
.118e	da		phx				phx 								; save XY
.118f	5a		phy				phy
.1190	48		pha				pha 								; save target
.1191	5a		phy				phy
.1192	20 c0 11	jsr $11c0			jsr 	EXGetLength 				; get length of file into A
.1195	a6 14		ldx $14				ldx 	temp3
.1197	a4 15		ldy $15				ldy 	temp3+1
.1199	20 bd ff	jsr $ffbd			jsr 	$FFBD 						; set name
.119c	a9 01		lda #$01			lda 	#1
.119e	a2 08		ldx #$08			ldx 	#8	 						; device #8
.11a0	a0 00		ldy #$00			ldy 	#0
.11a2	20 ba ff	jsr $ffba			jsr 	$FFBA 						; set LFS
.11a5	7a		ply				ply 								; restore target to YX and call load
.11a6	fa		plx				plx
.11a7	a9 00		lda #$00			lda 	#0 							; load command
.11a9	20 d5 ff	jsr $ffd5			jsr 	$FFD5
.11ac	b0 03		bcs $11b1			bcs 	_ESLoad
.11ae	7a		ply				ply
.11af	fa		plx				plx
.11b0	60		rts				rts
.11b1					_ESLoad:
.11b1	20 1d 10	jsr $101d			jsr 	ErrorHandler
>11b4	4c 4f 41 44 20 46 41 49				.text 	"LOAD FAILED",0
>11bc	4c 45 44 00
.11c0					EXGetLength:
.11c0	b2 14		lda ($14)			lda 	(temp3) 					; get name length
.11c2	e6 14		inc $14				inc 	temp3 						; bump ptr past it
.11c4	d0 02		bne $11c8			bne 	_EXGLExit
.11c6	e6 15		inc $15				inc 	temp3+1
.11c8					_EXGLExit:
.11c8	60		rts				rts
.11c9					EXPrintString:
.11c9	48		pha				pha
.11ca	5a		phy				phy
.11cb	84 11		sty $11				sty 	temp1+1
.11cd	85 10		sta $10				sta 	temp1
.11cf	a0 00		ldy #$00			ldy 	#0
.11d1					_EXPSLoop:
.11d1	b1 10		lda ($10),y			lda 	(temp1),y
.11d3	f0 08		beq $11dd			beq 	_EXPSExit
.11d5	29 7f		and #$7f			and 	#$7F
.11d7	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.11da	c8		iny				iny
.11db	80 f4		bra $11d1			bra 	_EXPSLoop
.11dd					_EXPSExit:
.11dd	7a		ply				ply
.11de	68		pla				pla
.11df	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/binary.src

.11e0					Add:
.11e0	7a		ply				ply
.11e1	68		pla				pla
.11e2	18		clc				clc
.11e3	65 06		adc $06				adc 	TOS
.11e5	85 06		sta $06				sta 	TOS
.11e7	98		tya				tya
.11e8	65 07		adc $07				adc 	TOS+1
.11ea	85 07		sta $07				sta 	TOS+1
.11ec	4c 00 00	jmp $0000			jmp 	Next
.11ef					Subtract:
.11ef	7a		ply				ply
.11f0	68		pla				pla
.11f1	38		sec				sec
.11f2	49 ff		eor #$ff			eor 	#$FF
.11f4	65 06		adc $06				adc 	TOS
.11f6	85 06		sta $06				sta 	TOS
.11f8	98		tya				tya
.11f9	49 ff		eor #$ff			eor 	#$FF
.11fb	65 07		adc $07				adc 	TOS+1
.11fd	85 07		sta $07				sta 	TOS+1
.11ff	4c 00 00	jmp $0000			jmp 	Next
.1202					And:
.1202	68		pla				pla
.1203	25 07		and $07				and 	TOS+1
.1205	85 07		sta $07				sta 	TOS+1
.1207	68		pla				pla
.1208	25 06		and $06				and 	TOS
.120a	85 06		sta $06				sta 	TOS
.120c	4c 00 00	jmp $0000			jmp 	Next
.120f					Xor:
.120f	68		pla				pla
.1210	45 07		eor $07				eor 	TOS+1
.1212	85 07		sta $07				sta 	TOS+1
.1214	68		pla				pla
.1215	45 06		eor $06				eor 	TOS
.1217	85 06		sta $06				sta 	TOS
.1219	4c 00 00	jmp $0000			jmp 	Next
.121c					LogOr:
.121c	68		pla				pla
.121d	05 07		ora $07				ora 	TOS+1
.121f	85 07		sta $07				sta 	TOS+1
.1221	68		pla				pla
.1222	05 06		ora $06				ora 	TOS
.1224	85 06		sta $06				sta 	TOS
.1226	4c 00 00	jmp $0000			jmp 	Next

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/compare.src

.1229					CheckNotEqual:
.1229	38		sec				sec
.122a	80 01		bra $122d			bra 	CECode
.122c					CheckEqual:
.122c	18		clc				clc
.122d					CECode:
.122d	86 10		stx $10				stx 	temp1
.122f	ba		tsx				tsx
.1230	08		php				php
.1231	a5 06		lda $06				lda 	TOS
.1233	5d 02 01	eor $0102,x			eor 	Stack2Low,x
.1236	d0 17		bne $124f			bne	 	CompareFalse
.1238	a5 07		lda $07				lda 	TOS+1
.123a	5d 01 01	eor $0101,x			eor 	Stack2High,x
.123d	d0 10		bne $124f			bne 	CompareFalse
.123f					CompareTrue:
.123f	a6 10		ldx $10				ldx 	temp1
.1241	28		plp				plp
.1242	b0 10		bcs $1254			bcs		CompareFalse2
.1244					CompareTrue2:
.1244	68		pla				pla
.1245	68		pla				pla
.1246	a9 ff		lda #$ff			lda 	#$FF
.1248	85 06		sta $06				sta 	TOS
.124a	85 07		sta $07				sta 	TOS+1
.124c	4c 00 00	jmp $0000			jmp 	Next
.124f					CompareFalse:
.124f	a6 10		ldx $10				ldx 	temp1
.1251	28		plp				plp
.1252	b0 f0		bcs $1244			bcs		CompareTrue2
.1254					CompareFalse2:
.1254	68		pla				pla
.1255	68		pla				pla
.1256	64 06		stz $06				stz 	TOS
.1258	64 07		stz $07				stz 	TOS+1
.125a	4c 00 00	jmp $0000			jmp 	Next
.125d					CheckGreaterEq:
.125d	38		sec				sec
.125e	80 01		bra $1261			bra		CLCode
.1260					CheckLess:
.1260	18		clc				clc
.1261	86 10		stx $10		CLCode:	stx 	temp1
.1263	ba		tsx				tsx
.1264	08		php				php
.1265	18		clc				clc
.1266	a5 06		lda $06				lda 	TOS
.1268	fd 02 01	sbc $0102,x			sbc 	Stack2Low,x
.126b	a5 07		lda $07				lda 	TOS+1
.126d	fd 01 01	sbc $0101,x			sbc 	Stack2High,x
.1270	50 02		bvc $1274			bvc 	_CLNoFlip
.1272	49 80		eor #$80			eor 	#$80
.1274					_CLNoFlip:
.1274	0a		asl a				asl 	a
.1275	b0 d8		bcs $124f			bcs 	CompareFalse
.1277	80 c6		bra $123f			bra 	CompareTrue
.1279					CheckLessEq:
.1279	38		sec				sec
.127a	80 01		bra $127d			bra		CGCode
.127c					CheckGreater:
.127c	18		clc				clc
.127d					CGCode:
.127d	86 10		stx $10				stx 	temp1
.127f	ba		tsx				tsx
.1280	08		php				php
.1281	18		clc				clc
.1282	bd 02 01	lda $0102,x			lda 	Stack2Low,x
.1285	e5 06		sbc $06				sbc 	TOS
.1287	bd 01 01	lda $0101,x			lda 	Stack2High,x
.128a	e5 07		sbc $07				sbc 	TOS+1
.128c	50 02		bvc $1290			bvc 	_CGNoFlip
.128e	49 80		eor #$80			eor 	#$80
.1290					_CGNoFlip:
.1290	0a		asl a				asl 	a
.1291	b0 bc		bcs $124f			bcs 	CompareFalse
.1293	80 aa		bra $123f			bra 	CompareTrue
.1295					Minimum:
.1295	a9 00		lda #$00			lda 	#0
.1297	80 02		bra $129b			bra 	MinMaxCode
.1299					Maximum:
.1299	a9 80		lda #$80			lda 	#$80
.129b					MinMaxCode:
.129b	85 11		sta $11				sta 	temp1+1
.129d	86 10		stx $10				stx 	temp1
.129f	ba		tsx				tsx
.12a0	38		sec				sec
.12a1	a5 06		lda $06				lda 	TOS
.12a3	fd 02 01	sbc $0102,x			sbc 	Stack2Low,x
.12a6	a5 07		lda $07				lda 	TOS+1
.12a8	fd 01 01	sbc $0101,x			sbc 	Stack2High,x
.12ab	50 02		bvc $12af			bvc 	_MMNoFlip
.12ad	49 80		eor #$80			eor 	#$80
.12af					_MMNoFlip:
.12af	45 11		eor $11				eor 	temp1+1
.12b1	30 0a		bmi $12bd			bmi 	_MMNoCopy
.12b3	bd 02 01	lda $0102,x			lda 	Stack2Low,x
.12b6	85 06		sta $06				sta 	TOS
.12b8	bd 01 01	lda $0101,x			lda 	Stack2High,x
.12bb	85 07		sta $07				sta 	TOS+1
.12bd					_MMNoCopy:
.12bd	a6 10		ldx $10				ldx 	temp1
.12bf	68		pla				pla
.12c0	68		pla				pla
.12c1	4c 00 00	jmp $0000			jmp 	Next

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/divide.src

.12c4					Divide16x16:
.12c4	86 12		stx $12				stx 	temp2
.12c6	ba		tsx				tsx
.12c7	20 ea 12	jsr $12ea			jsr 	IntegerDivide
.12ca	68		pla				pla
.12cb	85 07		sta $07				sta 	TOS+1
.12cd	68		pla				pla
.12ce	85 06		sta $06				sta 	TOS
.12d0	a6 12		ldx $12				ldx 	temp2
.12d2	4c 00 00	jmp $0000			jmp 	Next
.12d5					Modulus16x16:
.12d5	86 12		stx $12				stx 	temp2
.12d7	ba		tsx				tsx
.12d8	20 ea 12	jsr $12ea			jsr 	IntegerDivide
.12db	a6 12		ldx $12				ldx 	temp2
.12dd	68		pla				pla
.12de	68		pla				pla
.12df	a5 10		lda $10				lda 	temp1
.12e1	85 06		sta $06				sta 	TOS
.12e3	a5 11		lda $11				lda 	temp1+1
.12e5	85 07		sta $07				sta 	TOS+1
.12e7	4c 00 00	jmp $0000			jmp 	Next
.12ea					IntegerDivide:
.12ea	a5 06		lda $06				lda 	TOS 				; check for division by zero.
.12ec	05 07		ora $07				ora 	TOS+1
.12ee	d0 14		bne $1304			bne 	_BFDOkay
.12f0	20 1d 10	jsr $101d			jsr 	ErrorHandler
>12f3	44 49 56 49 53 49 4f 4e				.text 	"DIVISION BY ZERO",0
>12fb	20 42 59 20 5a 45 52 4f 00
.1304					_BFDOkay:
.1304	64 10		stz $10				stz 	temp1 						; Q/Dividend/Left in +0
.1306	64 11		stz $11				stz 	temp1+1 					; M/Divisor/Right in +2
.1308	64 1a		stz $1a				stz 	SignCount 					; Count of signs.
.130a	20 45 13	jsr $1345			jsr 	CheckIntegerNegate 			; negate 2nd (and bump sign count)
.130d	20 5f 13	jsr $135f			jsr 	CheckTOSNegate 				; negate TOS (and bump sign count)
.1310	5a		phy				phy 								; Y is the counter
.1311	a0 10		ldy #$10			ldy 	#16 						; 16 iterations of the loop.
.1313					_BFDLoop:
.1313	1e 02 01	asl $0102,x			asl 	Stack2Low,x 				; shift AQ left.
.1316	3e 01 01	rol $0101,x			rol 	Stack2High,x
.1319	26 10		rol $10				rol 	temp1
.131b	26 11		rol $11				rol 	temp1+1
.131d	38		sec				sec
.131e	a5 10		lda $10				lda 	temp1+0 					; Calculate A-M on stack.
.1320	e5 06		sbc $06				sbc 	TOS
.1322	48		pha				pha
.1323	a5 11		lda $11				lda 	temp1+1
.1325	e5 07		sbc $07				sbc 	TOS+1
.1327	90 0f		bcc $1338			bcc 	_BFDNoAdd
.1329	85 11		sta $11				sta 	temp1+1
.132b	68		pla				pla
.132c	85 10		sta $10				sta 	temp1+0
.132e	bd 02 01	lda $0102,x			lda 	Stack2Low,x 				; set Q bit 1.
.1331	09 01		ora #$01			ora 	#1
.1333	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.1336	80 01		bra $1339			bra 	_BFDNext
.1338					_BFDNoAdd:
.1338	68		pla				pla 								; Throw away the intermediate calculations
.1339					_BFDNext:
.1339	88		dey				dey
.133a	d0 d7		bne $1313			bne 	_BFDLoop
.133c	7a		ply				ply 								; restore Y
.133d	46 1a		lsr $1a				lsr 	SignCount 					; if sign count odd,
.133f	90 03		bcc $1344			bcc 	_BFDUnsigned 				; then the result is signed
.1341	20 4b 13	jsr $134b			jsr		IntegerNegateAlways 		; negate the result
.1344					_BFDUnsigned:
.1344	60		rts				rts
.1345					CheckIntegerNegate:
.1345	bd 01 01	lda $0101,x			lda 	Stack2High,x 				; is it -ve = MSB set ?
.1348	30 01		bmi $134b			bmi 	IntegerNegateAlways 		; if so negate it
.134a	60		rts				rts
.134b					IntegerNegateAlways:
.134b	e6 1a		inc $1a				inc 	SignCount 					; bump the count of signs
.134d	38		sec				sec 								; negate
.134e	a9 00		lda #$00			lda 	#0
.1350	fd 02 01	sbc $0102,x			sbc 	Stack2Low,x
.1353	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.1356	a9 00		lda #$00			lda 	#0
.1358	fd 01 01	sbc $0101,x			sbc 	Stack2High,x
.135b	9d 01 01	sta $0101,x			sta 	Stack2High,x
.135e	60		rts				rts
.135f					CheckTOSNegate:
.135f	a5 07		lda $07				lda 	TOS+1
.1361	10 0f		bpl $1372			bpl		CTNNoChange
.1363	e6 1a		inc $1a				inc 	SignCount
.1365					TOSNegateAlways:
.1365	38		sec				sec
.1366	a9 00		lda #$00			lda 	#0
.1368	e5 06		sbc $06				sbc 	TOS
.136a	85 06		sta $06				sta 	TOS
.136c	a9 00		lda #$00			lda 	#0
.136e	e5 07		sbc $07				sbc 	TOS+1
.1370	85 07		sta $07				sta 	TOS+1
.1372					CTNNoChange:
.1372	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/multiply.src

.1373					Multiply16x16:
.1373	86 10		stx $10				stx 	temp1
.1375	ba		tsx				tsx
.1376	bd 02 01	lda $0102,x			lda 	Stack2Low,x 				; 2nd value on stack to temp1
.1379	85 12		sta $12				sta 	temp2
.137b	bd 01 01	lda $0101,x			lda		Stack2High,x
.137e	85 13		sta $13				sta 	temp2+1
.1380	9e 02 01	stz $0102,x			stz 	Stack2Low,x 				; zero 2nd value on stack
.1383	9e 01 01	stz $0101,x			stz 	Stack2High,x
.1386					_MultLoop:
.1386	46 13		lsr $13				lsr 	temp2+1 					; ror temp2 into C
.1388	66 12		ror $12				ror 	temp2
.138a	90 11		bcc $139d			bcc 	_MultNoAdd
.138c	18		clc				clc 								; add 1st to 2nd
.138d	a5 06		lda $06				lda 	TOS
.138f	7d 02 01	adc $0102,x			adc 	Stack2Low,x
.1392	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.1395	a5 07		lda $07				lda 	TOS+1
.1397	7d 01 01	adc $0101,x			adc 	Stack2High,x
.139a	9d 01 01	sta $0101,x			sta 	Stack2High,x
.139d					_MultNoAdd:
.139d	06 06		asl $06				asl 	TOS 						; shift 1st left
.139f	26 07		rol $07				rol 	TOS+1
.13a1	a5 12		lda $12				lda 	temp2	 					; until zero
.13a3	05 13		ora $13				ora 	temp2+1
.13a5	d0 df		bne $1386			bne 	_MultLoop
.13a7	a6 10		ldx $10				ldx 	temp1 						; restore X load result
.13a9	68		pla				pla
.13aa	85 07		sta $07				sta 	TOS+1
.13ac	68		pla				pla
.13ad	85 06		sta $06				sta 	TOS
.13af	4c 00 00	jmp $0000			jmp 	Next

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/unary.src

.13b2					Unary1Plus:
.13b2	e6 06		inc $06				inc 	TOS
.13b4	d0 02		bne $13b8			bne 	_U1PSkip
.13b6	e6 07		inc $07				inc 	TOS+1
.13b8					_U1PSkip:
.13b8	4c 00 00	jmp $0000			jmp 	Next
.13bb					Unary2Plus:
.13bb	18		clc				clc
.13bc	a5 06		lda $06				lda 	TOS
.13be	69 02		adc #$02			adc 	#2
.13c0	85 06		sta $06				sta 	TOS
.13c2	90 02		bcc $13c6			bcc 	_U1PSkip
.13c4	e6 07		inc $07				inc 	TOS+1
.13c6					_U1PSkip:
.13c6	4c 00 00	jmp $0000			jmp 	Next
.13c9					Unary1Minus:
.13c9	a5 06		lda $06				lda 	TOS
.13cb	d0 02		bne $13cf			bne 	_U1MSkip
.13cd	c6 07		dec $07				dec 	TOS+1
.13cf					_U1MSkip:
.13cf	c6 06		dec $06				dec 	TOS
.13d1	4c 00 00	jmp $0000			jmp 	Next
.13d4					Unary2Minus:
.13d4	38		sec				sec
.13d5	a5 06		lda $06				lda 	TOS
.13d7	e9 02		sbc #$02			sbc 	#2
.13d9	85 06		sta $06				sta 	TOS
.13db	b0 02		bcs $13df			bcs 	_U1PSkip
.13dd	c6 07		dec $07				dec 	TOS+1
.13df					_U1PSkip:
.13df	4c 00 00	jmp $0000			jmp 	Next
.13e2					Absolute:
.13e2	a5 07		lda $07				lda 	TOS+1
.13e4	30 03		bmi $13e9			bmi 	Negate
.13e6	4c 00 00	jmp $0000			jmp 	Next
.13e9					Negate:
.13e9	38		sec				sec
.13ea	a9 00		lda #$00			lda 	#0
.13ec	e5 06		sbc $06				sbc 	TOS
.13ee	85 06		sta $06				sta 	TOS
.13f0	a9 00		lda #$00			lda 	#0
.13f2	e5 07		sbc $07				sbc 	TOS+1
.13f4	85 07		sta $07				sta 	TOS+1
.13f6	4c 00 00	jmp $0000			jmp 	Next
.13f9					OneComplement:
.13f9	a5 06		lda $06				lda 	TOS
.13fb	49 ff		eor #$ff			eor 	#$FF
.13fd	85 06		sta $06				sta 	TOS
.13ff	a5 07		lda $07				lda 	TOS+1
.1401	49 ff		eor #$ff			eor 	#$FF
.1403	85 07		sta $07				sta 	TOS+1
.1405	4c 00 00	jmp $0000			jmp 	Next
.1408					CheckMinus:
.1408	a5 07		lda $07				lda 	TOS+1
.140a	30 07		bmi $1413			bmi 	UnaryTrue
.140c					UnaryFalse:
.140c	64 06		stz $06				stz 	TOS
.140e	64 07		stz $07				stz 	TOS+1
.1410	4c 00 00	jmp $0000			jmp 	Next
.1413					UnaryTrue:
.1413	a9 ff		lda #$ff			lda 	#$FF
.1415	85 06		sta $06				sta 	TOS
.1417	85 07		sta $07				sta 	TOS+1
.1419	4c 00 00	jmp $0000			jmp 	Next
.141c					CheckZero:
.141c	a5 06		lda $06				lda 	TOS
.141e	05 07		ora $07				ora 	TOS+1
.1420	d0 ea		bne $140c			bne 	UnaryFalse
.1422	80 ef		bra $1413			bra 	UnaryTrue
.1424					SignTOS:
.1424	a5 07		lda $07				lda 	TOS+1
.1426	30 eb		bmi $1413			bmi		UnaryTrue
.1428	05 06		ora $06				ora 	TOS
.142a	f0 e0		beq $140c			beq 	UnaryFalse
.142c	a9 01		lda #$01			lda 	#1
.142e	85 06		sta $06				sta 	TOS
.1430	64 07		stz $07				stz		TOS+1
.1432	4c 00 00	jmp $0000			jmp 	Next
.1435					ByteSwap:
.1435	a5 06		lda $06				lda 	TOS
.1437	a4 07		ldy $07				ldy 	TOS+1
.1439	85 07		sta $07				sta 	TOS+1
.143b	84 06		sty $06				sty 	TOS
.143d	4c 00 00	jmp $0000			jmp 	Next
.1440					Times16:
.1440	06 06		asl $06				asl 	TOS
.1442	26 07		rol $07				rol 	TOS+1
.1444					Times8:
.1444	06 06		asl $06				asl 	TOS
.1446	26 07		rol $07				rol 	TOS+1
.1448					Times4:
.1448	06 06		asl $06				asl 	TOS
.144a	26 07		rol $07				rol 	TOS+1
.144c					Times2:
.144c	06 06		asl $06				asl 	TOS
.144e	26 07		rol $07				rol 	TOS+1
.1450	4c 00 00	jmp $0000			jmp 	Next
.1453					Divide16:
.1453	46 07		lsr $07				lsr 	TOS+1
.1455	66 06		ror $06				ror 	TOS
.1457					Divide8:
.1457	46 07		lsr $07				lsr 	TOS+1
.1459	66 06		ror $06				ror 	TOS
.145b					Divide4:
.145b	46 07		lsr $07				lsr 	TOS+1
.145d	66 06		ror $06				ror 	TOS
.145f					Divide2:
.145f	46 07		lsr $07				lsr 	TOS+1
.1461	66 06		ror $06				ror 	TOS
.1463	4c 00 00	jmp $0000			jmp 	Next
.1466					Times256:
.1466	a5 06		lda $06				lda 	TOS
.1468	85 07		sta $07				sta 	TOS+1
.146a	64 06		stz $06				stz 	TOS
.146c	4c 00 00	jmp $0000			jmp 	Next
.146f					Divide256:
.146f	a5 07		lda $07				lda 	TOS+1
.1471	85 06		sta $06				sta 	TOS
.1473	64 07		stz $07				stz 	TOS+1
.1475	4c 00 00	jmp $0000			jmp 	Next
.1478					RandomNumber:
.1478	a5 06		lda $06				lda 	TOS
.147a	48		pha				pha
.147b	a5 07		lda $07				lda 	TOS+1
.147d	48		pha				pha
.147e	a5 1b		lda $1b				lda 	randomSeed
.1480	05 1c		ora $1c				ora 	randomSeed+1
.1482	d0 08		bne $148c			bne 	_RH_NoInit
.1484	a9 7c		lda #$7c			lda 	#$7C
.1486	85 1b		sta $1b				sta 	randomSeed
.1488	a9 a1		lda #$a1			lda 	#$A1
.148a	85 1c		sta $1c				sta 	randomSeed+1
.148c					_RH_NoInit:
.148c	a5 1b		lda $1b				lda 	randomSeed
.148e	4a		lsr a		        lsr		a
.148f	26 1c		rol $1c		        rol 	randomSeed+1
.1491	90 02		bcc $1495	        bcc 	_RH_NoEor
.1493	49 b4		eor #$b4	        eor 	#$B4
.1495					_RH_NoEor:
.1495	85 1b		sta $1b		        sta 	randomSeed
.1497	45 1c		eor $1c		        eor 	randomSeed+1
.1499	85 07		sta $07		        sta 	TOS+1
.149b	a5 1b		lda $1b		        lda 	randomSeed
.149d	85 06		sta $06		        sta 	TOS
.149f	4c 00 00	jmp $0000			jmp 	Next

;******  Return to file: kernel.asm


;******  Processing file: words/data/literals.src

.14a2					Constant0:
.14a2	a5 06		lda $06				lda 	TOS
.14a4	48		pha				pha
.14a5	a5 07		lda $07				lda 	TOS+1
.14a7	48		pha				pha
.14a8	64 06		stz $06				stz 	TOS
.14aa	64 07		stz $07				stz 	TOS+1
.14ac	4c 00 00	jmp $0000			jmp 	Next
.14af					ConstantMinus1:
.14af	a5 06		lda $06				lda 	TOS
.14b1	48		pha				pha
.14b2	a5 07		lda $07				lda 	TOS+1
.14b4	48		pha				pha
.14b5	a9 ff		lda #$ff			lda 	#$FF
.14b7	85 06		sta $06				sta 	TOS
.14b9	85 07		sta $07				sta 	TOS+1
.14bb	4c 00 00	jmp $0000			jmp 	Next
.14be					C1:
.14be	a0 01		ldy #$01			ldy 	#1
.14c0	80 24		bra $14e6			bra 	Const1Byte
.14c2					C2:
.14c2	a0 02		ldy #$02			ldy 	#2
.14c4	80 20		bra $14e6			bra 	Const1Byte
.14c6					C3:
.14c6	a0 03		ldy #$03			ldy 	#3
.14c8	80 1c		bra $14e6			bra 	Const1Byte
.14ca					C4:
.14ca	a0 04		ldy #$04			ldy 	#4
.14cc	80 18		bra $14e6			bra 	Const1Byte
.14ce					C5:
.14ce	a0 05		ldy #$05			ldy 	#5
.14d0	80 14		bra $14e6			bra 	Const1Byte
.14d2					C8:
.14d2	a0 08		ldy #$08			ldy 	#8
.14d4	80 10		bra $14e6			bra 	Const1Byte
.14d6					C10:
.14d6	a0 0a		ldy #$0a			ldy 	#10
.14d8	80 0c		bra $14e6			bra 	Const1Byte
.14da					C15:
.14da	a0 0f		ldy #$0f			ldy 	#15
.14dc	80 08		bra $14e6			bra 	Const1Byte
.14de					C16:
.14de	a0 10		ldy #$10			ldy 	#16
.14e0	80 04		bra $14e6			bra 	Const1Byte
.14e2					C24:
.14e2	a0 18		ldy #$18			ldy 	#24
.14e4	80 00		bra $14e6			bra 	Const1Byte
.14e6					Const1Byte:
.14e6	a5 06		lda $06				lda 	TOS
.14e8	48		pha				pha
.14e9	a5 07		lda $07				lda 	TOS+1
.14eb	48		pha				pha
.14ec	84 06		sty $06				sty 	TOS
.14ee	64 07		stz $07				stz 	TOS+1
.14f0	4c 00 00	jmp $0000			jmp 	Next
.14f3					C32:
.14f3	a0 20		ldy #$20			ldy 	#32
.14f5	80 ef		bra $14e6			bra 	Const1Byte
.14f7					C63:
.14f7	a0 3f		ldy #$3f			ldy 	#63
.14f9	80 eb		bra $14e6			bra 	Const1Byte
.14fb					C64:
.14fb	a0 40		ldy #$40			ldy 	#64
.14fd	80 e7		bra $14e6			bra 	Const1Byte
.14ff					C100:
.14ff	a0 64		ldy #$64			ldy 	#100
.1501	80 e3		bra $14e6			bra 	Const1Byte
.1503					C127:
.1503	a0 7f		ldy #$7f			ldy 	#127
.1505	80 df		bra $14e6			bra 	Const1Byte
.1507					C128:
.1507	a0 80		ldy #$80			ldy 	#128
.1509	80 db		bra $14e6			bra 	Const1Byte
.150b					C255:
.150b	a0 ff		ldy #$ff			ldy 	#255
.150d	80 d7		bra $14e6			bra 	Const1Byte
.150f					Const2Byte:
.150f	85 06		sta $06				sta 	TOS
.1511	84 07		sty $07				sty 	TOS+1
.1513	4c 00 00	jmp $0000			jmp 	Next
.1516					C256:
.1516	a5 06		lda $06				lda 	TOS
.1518	48		pha				pha
.1519	a5 07		lda $07				lda 	TOS+1
.151b	48		pha				pha
.151c	a9 00		lda #$00			lda 	#(256) & $FF
.151e	a0 01		ldy #$01			ldy 	#(256) >> 8
.1520	80 ed		bra $150f			bra 	Const2Byte
.1522					C512:
.1522	a5 06		lda $06				lda 	TOS
.1524	48		pha				pha
.1525	a5 07		lda $07				lda 	TOS+1
.1527	48		pha				pha
.1528	a9 00		lda #$00			lda 	#(512) & $FF
.152a	a0 02		ldy #$02			ldy 	#(512) >> 8
.152c	80 e1		bra $150f			bra 	Const2Byte
.152e					C1024:
.152e	a5 06		lda $06				lda 	TOS
.1530	48		pha				pha
.1531	a5 07		lda $07				lda 	TOS+1
.1533	48		pha				pha
.1534	a9 00		lda #$00			lda 	#(1024) & $FF
.1536	a0 04		ldy #$04			ldy 	#(1024) >> 8
.1538	80 d5		bra $150f			bra 	Const2Byte
.153a					C4096:
.153a	a5 06		lda $06				lda 	TOS
.153c	48		pha				pha
.153d	a5 07		lda $07				lda 	TOS+1
.153f	48		pha				pha
.1540	a9 00		lda #$00			lda 	#(4096) & $FF
.1542	a0 10		ldy #$10			ldy 	#(4096) >> 8
.1544	80 c9		bra $150f			bra 	Const2Byte
.1546					C32767:
.1546	a5 06		lda $06				lda 	TOS
.1548	48		pha				pha
.1549	a5 07		lda $07				lda 	TOS+1
.154b	48		pha				pha
.154c	a9 ff		lda #$ff			lda 	#(32767) & $FF
.154e	a0 7f		ldy #$7f			ldy 	#(32767) >> 8
.1550	80 bd		bra $150f			bra 	Const2Byte
.1552					C32768:
.1552	a5 06		lda $06				lda 	TOS
.1554	48		pha				pha
.1555	a5 07		lda $07				lda 	TOS+1
.1557	48		pha				pha
.1558	a9 00		lda #$00			lda 	#(32768) & $FF
.155a	a0 80		ldy #$80			ldy 	#(32768) >> 8
.155c	80 b1		bra $150f			bra 	Const2Byte

;******  Return to file: kernel.asm


;******  Processing file: words/data/stack.src

.155e					Drop:
.155e	68		pla				pla
.155f	85 07		sta $07				sta 	TOS+1
.1561	68		pla				pla
.1562	85 06		sta $06				sta 	TOS
.1564	4c 00 00	jmp $0000			jmp 	Next
.1567					TestDup:
.1567	a5 06		lda $06				lda 	TOS
.1569	05 07		ora $07				ora 	TOS+1
.156b	d0 03		bne $1570			bne 	Dup
.156d	4c 00 00	jmp $0000			jmp 	Next
.1570					Dup:
.1570	a5 06		lda $06				lda 	TOS
.1572	48		pha				pha
.1573	a5 07		lda $07				lda 	TOS+1
.1575	48		pha				pha
.1576	4c 00 00	jmp $0000			jmp 	Next
.1579					Swap:
.1579	86 10		stx $10				stx 	temp1
.157b	7a		ply				ply
.157c	fa		plx				plx
.157d	a5 06		lda $06				lda 	TOS
.157f	48		pha				pha
.1580	a5 07		lda $07				lda 	TOS+1
.1582	48		pha				pha
.1583	86 06		stx $06				stx 	TOS
.1585	84 07		sty $07				sty 	TOS+1
.1587	a6 10		ldx $10				ldx 	temp1
.1589	4c 00 00	jmp $0000			jmp 	Next
.158c					Over:
.158c	a5 06		lda $06				lda 	TOS
.158e	48		pha				pha
.158f	a5 07		lda $07				lda 	TOS+1
.1591	48		pha				pha
.1592	86 10		stx $10				stx 	temp1
.1594	ba		tsx				tsx
.1595	bd 04 01	lda $0104,x			lda 	stack3low,x
.1598	85 06		sta $06				sta 	TOS
.159a	bd 03 01	lda $0103,x			lda 	stack3High,x
.159d	85 07		sta $07				sta 	TOS+1
.159f	a6 10		ldx $10				ldx 	temp1
.15a1	4c 00 00	jmp $0000			jmp 	Next
.15a4					Nip:
.15a4	68		pla				pla
.15a5	68		pla				pla
.15a6	4c 00 00	jmp $0000			jmp 	Next
.15a9					Rot:
.15a9	86 10		stx $10				stx 	temp1
.15ab	ba		tsx				tsx
.15ac	bd 04 01	lda $0104,x			lda 	Stack3Low,x
.15af	a8		tay				tay
.15b0	bd 02 01	lda $0102,x			lda 	Stack2Low,x
.15b3	9d 04 01	sta $0104,x			sta 	Stack3Low,x
.15b6	a5 06		lda $06				lda 	TOS
.15b8	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.15bb	84 06		sty $06				sty 	TOS
.15bd	bd 03 01	lda $0103,x			lda 	Stack3High,x
.15c0	a8		tay				tay
.15c1	bd 01 01	lda $0101,x			lda 	Stack2High,x
.15c4	9d 03 01	sta $0103,x			sta 	Stack3High,x
.15c7	a5 07		lda $07				lda 	TOS+1
.15c9	9d 01 01	sta $0101,x			sta 	Stack2High,x
.15cc	84 07		sty $07				sty 	TOS+1
.15ce	a6 10		ldx $10				ldx 	temp1
.15d0	4c 00 00	jmp $0000			jmp 	Next

;******  Return to file: kernel.asm


;******  Processing file: words/data/memory.src

.15d3					ByteRead:
.15d3	b2 06		lda ($06)			lda 	(TOS)
.15d5	85 06		sta $06				sta 	TOS
.15d7	64 07		stz $07				stz 	TOS+1
.15d9	4c 00 00	jmp $0000			jmp 	Next
.15dc					WordRead:
.15dc	a0 01		ldy #$01			ldy 	#1
.15de	b1 06		lda ($06),y			lda 	(TOS),y
.15e0	a8		tay				tay
.15e1	b2 06		lda ($06)			lda 	(TOS)
.15e3	85 06		sta $06				sta 	TOS
.15e5	84 07		sty $07				sty 	TOS+1
.15e7	4c 00 00	jmp $0000			jmp 	Next
.15ea					ByteWrite:
.15ea	68		pla				pla
.15eb	68		pla				pla
.15ec	92 06		sta ($06)			sta 	(TOS)
.15ee	68		pla				pla
.15ef	85 07		sta $07				sta 	TOS+1
.15f1	68		pla				pla
.15f2	85 06		sta $06				sta 	TOS
.15f4	4c 00 00	jmp $0000			jmp 	Next
.15f7					WordWrite:
.15f7	68		pla				pla
.15f8	a0 01		ldy #$01			ldy 	#1
.15fa	91 06		sta ($06),y			sta 	(TOS),y
.15fc	68		pla				pla
.15fd	92 06		sta ($06)			sta 	(TOS)
.15ff	68		pla				pla
.1600	85 07		sta $07				sta 	TOS+1
.1602	68		pla				pla
.1603	85 06		sta $06				sta 	TOS
.1605	4c 00 00	jmp $0000			jmp 	Next
.1608					WordAdd:
.1608	7a		ply				ply
.1609	68		pla				pla
.160a	18		clc				clc
.160b	72 06		adc ($06)			adc 	(TOS)
.160d	92 06		sta ($06)			sta 	(TOS)
.160f	98		tya				tya
.1610	a0 01		ldy #$01			ldy 	#1
.1612	71 06		adc ($06),y			adc 	(TOS),y
.1614	91 06		sta ($06),y			sta 	(TOS),y
.1616	68		pla				pla
.1617	85 07		sta $07				sta 	TOS+1
.1619	68		pla				pla
.161a	85 06		sta $06				sta 	TOS
.161c	4c 00 00	jmp $0000			jmp 	Next
.161f					AllocateMemory:
.161f	a5 06		lda $06				lda 	TOS 						; save memory required on stack.
.1621	48		pha				pha
.1622	a5 07		lda $07				lda 	TOS+1
.1624	48		pha				pha
.1625	a5 0e		lda $0e				lda 	nextFreeMem 				; copy free mem address to TOS
.1627	85 06		sta $06				sta 	TOS
.1629	a5 0f		lda $0f				lda 	nextFreeMem+1
.162b	85 07		sta $07				sta 	TOS+1
.162d	7a		ply				ply 								; advance the free ram pointer
.162e	68		pla				pla
.162f	20 62 18	jsr $1862			jsr 	AdvanceFreeMem
.1632	4c 00 00	jmp $0000			jmp 	Next 						; and continue

;******  Return to file: kernel.asm


;******  Processing file: words/structures/fornext.src

.1635					ForHandler:
.1635	e6 05		inc $05				inc 	rsp 						; bump the RSP
.1637	a4 05		ldy $05				ldy 	rsp 						; get return stack and push TOS/$FF on it.
.1639	c0 40		cpy #$40			cpy 	#$40 						; overflow
.163b	f0 18		beq $1655			beq 	_FHOverflow
.163d	a5 07		lda $07				lda 	TOS+1
.163f	99 40 07	sta $0740,y			sta 	returnStackHigh,y
.1642	a5 06		lda $06				lda 	TOS
.1644	99 00 07	sta $0700,y			sta 	returnStackLow,y
.1647	a9 ff		lda #$ff			lda 	#$FF
.1649	99 80 07	sta $0780,y			sta 	returnStackX,y
.164c	68		pla				pla
.164d	85 07		sta $07				sta 	TOS+1
.164f	68		pla				pla
.1650	85 06		sta $06				sta 	TOS
.1652	4c 00 00	jmp $0000			jmp 	Next
.1655					_FHOverflow:
.1655	20 1d 10	jsr $101d			jsr 	ErrorHandler
>1658	46 4f 52 20 53 54 41 43				.text 	"FOR STACK?",0
>1660	4b 3f 00
.1663					NextHandler:
.1663	da		phx				phx
.1664	a6 05		ldx $05				ldx 	rsp 						; get current stack ptr
.1666	bd 80 07	lda $0780,x			lda 	returnStackX,x 				; check it's a FOR Loop
.1669	c9 ff		cmp #$ff			cmp 	#$FF
.166b	d0 21		bne $168e			bne 	NHNoFor
.166d	bd 00 07	lda $0700,x			lda 	returnStackLow,x 			; decrement the count
.1670	d0 03		bne $1675			bne 	_NHNoBorrow
.1672	de 40 07	dec $0740,x			dec 	returnStackHigh,x
.1675					_NHNoBorrow:
.1675	de 00 07	dec $0700,x			dec 	returnStackLow,x
.1678	bd 00 07	lda $0700,x			lda 	returnStackLow,x 			; have we reached the end ?
.167b	1d 40 07	ora $0740,x			ora 	returnStackHigh,x
.167e	fa		plx				plx 								; restore X and re-test
.167f	09 00		ora #$00			ora 	#0
.1681	f0 05		beq $1688			beq 	_NHComplete 				; if so then complete, else loop.
.1683	e8		inx				inx 								; advance to branch
.1684	e8		inx				inx
.1685	4c e1 16	jmp $16e1			jmp 	BranchAlways
.1688					_NHComplete:
.1688	e8		inx				inx 								; skip over the branch quantity
.1689	c6 05		dec $05				dec 	rsp 						; drop the indx
.168b	4c 00 00	jmp $0000			jmp 	Next
.168e					NHNoFor:
.168e	20 1d 10	jsr $101d			jsr 	ErrorHandler
>1691	4e 4f 20 46 4f 52 3f 00				.text 	"NO FOR?",0
.1699					GetIndex:
.1699	a4 05		ldy $05				ldy 	rsp 						; get current stack ptr
.169b	b9 80 07	lda $0780,y			lda 	returnStackX,y 				; check it's a FOR Loop
.169e	c9 ff		cmp #$ff			cmp 	#$FF
.16a0	d0 ec		bne $168e			bne 	NHNoFor
.16a2	a5 06		lda $06				lda 	TOS
.16a4	48		pha				pha
.16a5	a5 07		lda $07				lda 	TOS+1
.16a7	48		pha				pha
.16a8	b9 00 07	lda $0700,y			lda 	returnStackLow,y 			; put counter-1 out
.16ab	38		sec				sec
.16ac	e9 01		sbc #$01			sbc 	#1
.16ae	85 06		sta $06				sta 	TOS
.16b0	b9 40 07	lda $0740,y			lda 	returnStackHigh,y
.16b3	e9 00		sbc #$00			sbc 	#0
.16b5	85 07		sta $07				sta 	TOS+1
.16b7	4c 00 00	jmp $0000			jmp 	Next

;******  Return to file: kernel.asm


;******  Processing file: words/structures/ifelseendif.src

.16ba					IfHandler:
.16ba	4c c9 16	jmp $16c9			jmp 	BranchIfZero
.16bd					ElseHandler:
.16bd	4c df 16	jmp $16df			jmp 	BranchTestSucceedsNoPop
.16c0					EndIfHandler:
.16c0	4c 00 00	jmp $0000			jmp 	Next

;******  Return to file: kernel.asm


;******  Processing file: words/structures/repeatuntil.src

.16c3					RepeatHandler:
.16c3	4c 00 00	jmp $0000			jmp 	Next
.16c6					UntilHandler:
.16c6	4c c9 16	jmp $16c9			jmp 	BranchIfZero

;******  Return to file: kernel.asm


;******  Processing file: words/system/branch.src

.16c9					BranchIfZero:
.16c9	a5 06		lda $06				lda 	TOS 						; check TOS = 0
.16cb	05 07		ora $07				ora 	TOS+1
.16cd	f0 0a		beq $16d9			beq 	BranchTestSucceeds
.16cf					BranchTestFails:
.16cf	68		pla				pla
.16d0	85 07		sta $07				sta 	TOS+1
.16d2	68		pla				pla
.16d3	85 06		sta $06				sta 	TOS
.16d5	e8		inx				inx 								; skip over the relative branch.
.16d6	4c 00 00	jmp $0000			jmp 	Next
.16d9					BranchTestSucceeds:
.16d9	68		pla				pla
.16da	85 07		sta $07				sta 	TOS+1
.16dc	68		pla				pla
.16dd	85 06		sta $06				sta 	TOS
.16df					BranchTestSucceedsNoPop:
.16df	e8		inx				inx 								; advance by two, to the offset
.16e0	e8		inx				inx
.16e1					BranchAlways:
.16e1	8a		txa				txa 								; A = Y = position
.16e2	a8		tay				tay 								; (IP),Y now points to the branch target
.16e3	b1 03		lda ($03),y			lda 	(IP),y 						; adjust the position
.16e5	aa		tax				tax 								; position back in this line.
.16e6	4c 02 00	jmp $0002			jmp 	Next+2 						; and continue

;******  Return to file: kernel.asm


;******  Processing file: words/system/callhandler.src

.16e9					CallHandler:
.16e9	e8		inx				inx									; bump X to the call address.
.16ea	e8		inx				inx
.16eb	e6 05		inc $05				inc 	rsp 						; bump the RSP (first time to zero)
.16ed	a4 05		ldy $05				ldy 	rsp 						; get return stack and push IP/X on it.
.16ef	c0 40		cpy #$40			cpy 	#$40 						; overflow
.16f1	f0 4b		beq $173e			beq 	_CHOverflow
.16f3	a5 04		lda $04				lda 	IP+1
.16f5	99 40 07	sta $0740,y			sta 	returnStackHigh,y
.16f8	a5 03		lda $03				lda 	IP
.16fa	99 00 07	sta $0700,y			sta 	returnStackLow,y
.16fd	8a		txa				txa
.16fe	99 80 07	sta $0780,y			sta 	returnStackX,y
.1701	8a		txa				txa 								; get the line number into temp1.
.1702	a8		tay				tay
.1703	b1 03		lda ($03),y			lda 	(IP),y
.1705	85 10		sta $10				sta 	temp1
.1707	c8		iny				iny
.1708	b1 03		lda ($03),y			lda 	(IP),y
.170a	85 11		sta $11				sta 	temp1+1
.170c	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.170e	85 03		sta $03				sta 	0+(IP)
.1710	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.1712	85 04		sta $04				sta 	1+(IP)
.1714	b2 03		lda ($03)			lda 	(IP)						; no program code ?
.1716	f0 17		beq $172f			beq 	_CHFail
.1718	a0 01		ldy #$01			ldy 	#1 							; Y = 1 throughout.
.171a					_CHSearch:
.171a	b1 03		lda ($03),y			lda 	(IP),y 						; check LSB of line number
.171c	c5 10		cmp $10				cmp 	temp1
.171e	f0 2d		beq $174d			beq 	_CHFoundLSB
.1720					_CHSearchNext:
.1720	18		clc				clc
.1721	a5 03		lda $03				lda 	IP
.1723	72 03		adc ($03)			adc 	(IP)
.1725	85 03		sta $03				sta 	IP
.1727	90 02		bcc $172b			bcc 	_NoCarryAdv
.1729	e6 04		inc $04				inc 	IP+1
.172b					_NoCarryAdv:
.172b	b2 03		lda ($03)			lda 	(IP)						; check reached the end.
.172d	d0 eb		bne $171a			bne 	_CHSearch
.172f					_CHFail:
.172f	20 1d 10	jsr $101d			jsr 	ErrorHandler
>1732	44 45 46 49 4e 49 54 49				.text 	"DEFINITION?",0
>173a	4f 4e 3f 00
.173e					_CHOverflow:
.173e	20 1d 10	jsr $101d			jsr 	ErrorHandler
>1741	53 54 41 43 4b 44 45 50				.text 	"STACKDEPTH?",0
>1749	54 48 3f 00
.174d					_CHFoundLSB:
.174d	c8		iny				iny 								; get MSB
.174e	b1 03		lda ($03),y			lda 	(IP),y
.1750	88		dey				dey
.1751	c5 11		cmp $11				cmp 	temp1+1 					; matches, if not contineu
.1753	d0 cb		bne $1720			bne 	_CHSearchNext
.1755	a0 03		ldy #$03			ldy 	#3	 						; check it begins with $$define
.1757	b1 03		lda ($03),y			lda 	(IP),y
.1759	c9 a7		cmp #$a7			cmp 	#DefineCode & $FF
.175b	d0 d2		bne $172f			bne 	_CHFail
.175d	c8		iny				iny
.175e	b1 03		lda ($03),y			lda 	(IP),y
.1760	c9 1b		cmp #$1b			cmp 	#DefineCode >> 8
.1762	d0 cb		bne $172f			bne 	_CHFail
.1764	c8		iny				iny
.1765	b1 03		lda ($03),y			lda 	(IP),y 						; this is the length of the define name
.1767	18		clc				clc
.1768	69 05		adc #$05			adc 	#5 							; $$define token, line number, offset
.176a	aa		tax				tax
.176b	4c 02 00	jmp $0002			jmp 	Next+2 						; and execute
.176e					ReturnHandler:
.176e	a4 05		ldy $05				ldy 	rsp 						; get rsp
.1770	30 15		bmi $1787			bmi 	_RHUnderflow 				; if -ve underflowed
.1772	c6 05		dec $05				dec 	rsp 						; decrement rsp
.1774	b9 40 07	lda $0740,y			lda 	returnStackHigh,y 			; restore IP/X
.1777	85 04		sta $04				sta 	IP+1
.1779	b9 00 07	lda $0700,y			lda 	returnStackLow,y
.177c	85 03		sta $03				sta 	IP
.177e	b9 80 07	lda $0780,y			lda 	returnStackX,y
.1781	aa		tax				tax
.1782	f0 0e		beq $1792			beq 	_RHInLoop 					; this means you have done :something for ; next
.1784	4c 00 00	jmp $0000			jmp 	Next
.1787					_RHUnderflow:
.1787	20 1d 10	jsr $101d			jsr 	ErrorHandler
>178a	52 45 54 55 52 4e 3f 00				.text 	"RETURN?",0
.1792					_RHInLoop:
.1792	20 1d 10	jsr $101d			jsr 	ErrorHandler
>1795	52 45 54 55 52 4e 20 49				.text 	"RETURN IN LOOP?",0
>179d	4e 20 4c 4f 4f 50 3f 00
.17a5					CallHandlerDecode:
.17a5	a9 03		lda #$03			lda 	#CTH_Call					; space
.17a7	20 65 19	jsr $1965			jsr 	DecodeWriteBuffer
.17aa	b1 08		lda ($08),y			lda 	(srcPtr),y 					; get line number into YA
.17ac	aa		tax				tax
.17ad	c8		iny				iny
.17ae	b1 08		lda ($08),y			lda 	(srcPtr),y
.17b0	a8		tay				tay
.17b1	8a		txa				txa
.17b2	20 ef 17	jsr $17ef			jsr 	FindLine 					; try to locate that line.
.17b5	b0 11		bcs $17c8			bcs 	_CHDFound 					; if found .....
.17b7					_CHDLineOnly:
.17b7	48		pha				pha
.17b8	a9 3c		lda #$3c			lda 	#"<"
.17ba	20 65 19	jsr $1965			jsr 	DecodeWriteBuffer
.17bd	68		pla				pla
.17be	18		clc				clc 								; output unsigned
.17bf	20 87 19	jsr $1987			jsr 	DecodeYAToBuffer
.17c2	a9 3e		lda #$3e			lda 	#">"
.17c4	20 65 19	jsr $1965			jsr 	DecodeWriteBuffer
.17c7	60		rts				rts
.17c8					_CHDFound:
.17c8	48		pha				pha 								; save YA
.17c9	5a		phy				phy
.17ca	a0 03		ldy #$03			ldy 	#3 							; check first is $$define
.17cc	b1 10		lda ($10),y			lda 	(temp1),y
.17ce	c9 a7		cmp #$a7			cmp 	#DefineCode & 255
.17d0	d0 07		bne $17d9			bne 	_CHDNoDefine
.17d2	c8		iny				iny
.17d3	b1 10		lda ($10),y			lda 	(temp1),y
.17d5	c9 1b		cmp #$1b			cmp 	#DefineCode >> 8
.17d7	f0 04		beq $17dd			beq 	_CHDFoundDefine
.17d9					_CHDNoDefine:
.17d9	7a		ply				ply									; restore the line number and print it in <>
.17da	68		pla				pla
.17db	80 da		bra $17b7			bra 	_CHDLineOnly
.17dd					_CHDFoundDefine:
.17dd	68		pla				pla 								; throw saved line number.
.17de	68		pla				pla
.17df	a0 05		ldy #$05			ldy 	#5 							; 3,4 $$define 5 length, name has bit 7 set at end
.17e1					_CHDOutName:
.17e1	c8		iny				iny 								; next
.17e2	b1 10		lda ($10),y			lda 	(temp1),y 					; print char no bit 7
.17e4	48		pha				pha
.17e5	29 7f		and #$7f			and 	#$7F
.17e7	20 65 19	jsr $1965			jsr 	DecodeWriteBuffer
.17ea	68		pla				pla
.17eb	0a		asl a				asl 	a 							; bit 7 to carry
.17ec	90 f3		bcc $17e1			bcc 	_CHDOutName
.17ee	60		rts				rts
.17ef					FindLine:
.17ef	48		pha				pha 								; save registers
.17f0	da		phx				phx
.17f1	5a		phy				phy
.17f2	85 12		sta $12				sta 	temp2 						; temp2 = target line#
.17f4	84 13		sty $13				sty 	temp2+1
.17f6	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.17f8	85 10		sta $10				sta 	0+(temp1)
.17fa	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.17fc	85 11		sta $11				sta 	1+(temp1)
.17fe					_FLLoop:
.17fe	b2 10		lda ($10)			lda 	(temp1) 					; found end ?
.1800	18		clc				clc									; if so exit with CC.
.1801	f0 1d		beq $1820			beq 	_FLExit
.1803	a0 01		ldy #$01			ldy 	#1 							; check line # match
.1805	b1 10		lda ($10),y			lda 	(temp1),y
.1807	c5 12		cmp $12				cmp 	temp2
.1809	d0 08		bne $1813			bne 	_FLNext
.180b	c8		iny				iny
.180c	b1 10		lda ($10),y			lda 	(temp1),y
.180e	c5 13		cmp $13				cmp 	temp2+1
.1810	38		sec				sec 								; if so exit with CS
.1811	f0 0d		beq $1820			beq 	_FLExit
.1813					_FLNext:
.1813	18		clc				clc
.1814	a5 10		lda $10				lda 	temp1
.1816	72 10		adc ($10)			adc 	(temp1)
.1818	85 10		sta $10				sta 	temp1
.181a	90 02		bcc $181e			bcc 	_NoCarryAdv
.181c	e6 11		inc $11				inc 	temp1+1
.181e					_NoCarryAdv:
.181e	80 de		bra $17fe			bra 	_FLLoop 					; keep looking.
.1820					_FLExit:
.1820	7a		ply				ply
.1821	fa		plx				plx
.1822	68		pla				pla
.1823	60		rts				rts
.1824	18		clc				clc
.1825	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/clrnew.src

.1826					NewHandler:
.1826	9c 00 40	stz $4000			stz 	ProgramMemory 				; Make the first offset zero.
.1829	20 35 18	jsr $1835			jsr 	ClearVariableSpace 			; clear variables, reset pointers
.182c	4c 00 00	jmp $0000			jmp 	Next
.182f					ClrHandler:
.182f	20 35 18	jsr $1835			jsr 	ClearVariableSpace 			; clear variables, reset pointers
.1832	4c 00 00	jmp $0000			jmp 	Next
.1835					ClearVariableSpace:
.1835	a9 ff		lda #$ff			lda 	#$FF 						; empty return stack
.1837	85 05		sta $05				sta 	rsp
.1839	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.183b	85 0e		sta $0e				sta 	0+(nextFreeMem)
.183d	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.183f	85 0f		sta $0f				sta 	1+(nextFreeMem)
.1841	a0 1f		ldy #$1f			ldy 	#hashTableSize*2-1 			; erase the hash table (used for variables)
.1843					_CVSHashClear:
.1843	a9 00		lda #$00			lda 	#0 							; all the first record pointers are $00
.1845	99 40 06	sta $0640,y			sta 	hashTable,y
.1848	88		dey				dey
.1849	10 f8		bpl $1843			bpl 	_CVSHashClear
.184b					_CVSFindEnd:
.184b	18		clc				clc
.184c	a5 0e		lda $0e				lda 	nextFreeMem
.184e	72 0e		adc ($0e)			adc 	(nextFreeMem)
.1850	85 0e		sta $0e				sta 	nextFreeMem
.1852	90 02		bcc $1856			bcc 	_NoCarryAdv
.1854	e6 0f		inc $0f				inc 	nextFreeMem+1
.1856					_NoCarryAdv:
.1856	b2 0e		lda ($0e)			lda 	(nextFreeMem)
.1858	d0 f1		bne $184b			bne 	_CVSFindEnd
.185a	a9 08		lda #$08			lda 	#8 							; this puts a gap in, more for clarity than anything.
.185c	a0 00		ldy #$00			ldy 	#0
.185e	20 62 18	jsr $1862			jsr 	AdvanceFreeMem				; we need +1 because the previous code leaves the
.1861	60		rts				rts 								; free mem pointer pointing to the last zero offset
.1862					AdvanceFreeMem:
.1862	18		clc				clc
.1863	65 0e		adc $0e				adc 	nextFreeMem
.1865	85 0e		sta $0e				sta 	nextFreeMem
.1867	98		tya				tya
.1868	65 0f		adc $0f				adc 	nextFreeMem+1
.186a	85 0f		sta $0f				sta 	nextFreeMem+1
.186c	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/debug.src

.186d					ExitDump:
.186d	ba		tsx				tsx 								; save Data Stack in temp1
.186e	86 10		stx $10				stx 	temp1
.1870	4c ff ff	jmp $ffff			jmp 	$FFFF 						; makes the X16-Emulator dump-exit.
.1873					BreakCmd:
>1873	ff						.byte 	$FF
.1874	4c 00 00	jmp $0000			jmp 	Next

;******  Return to file: kernel.asm


;******  Processing file: words/system/decode.src

.1877					DecodeLineIntoBufPtr:
.1877	48		pha				pha
.1878	da		phx				phx
.1879	5a		phy				phy
.187a	85 08		sta $08				sta 	srcPtr 						; save the source line.
.187c	84 09		sty $09				sty 	srcPtr+1
.187e	90 1b		bcc $189b			bcc 	_DecodeNoLineNumber
.1880	a0 01		ldy #$01			ldy 	#1 							; get line # to YA
.1882	b1 08		lda ($08),y			lda 	(srcPtr),y
.1884	aa		tax				tax
.1885	c8		iny				iny
.1886	b1 08		lda ($08),y			lda 	(srcPtr),y
.1888	a8		tay				tay
.1889	8a		txa				txa
.188a	18		clc				clc
.188b	20 87 19	jsr $1987			jsr 	DecodeYAToBuffer 			; convert to string in buffer
.188e	aa		tax				tax 								; count in X
.188f					_DecodeLineSpace:
.188f	e0 05		cpx #$05			cpx 	#5
.1891	f0 08		beq $189b			beq 	_DecodeNoLineNumber
.1893	a9 20		lda #$20			lda 	#" " 						; pad to 5 spaces
.1895	20 65 19	jsr $1965			jsr 	DecodeWriteBuffer
.1898	e8		inx				inx
.1899	80 f4		bra $188f			bra 	_DecodeLineSpace
.189b					_DecodeNoLineNumber:
.189b	a0 03		ldy #$03			ldy 	#3 							; initial position.
.189d					_DecodeLoop:
.189d	b1 08		lda ($08),y			lda 	(srcPtr),y 					; copy the current character to temp1
.189f	85 10		sta $10				sta 	temp1 						; must be an execution address.
.18a1	c8		iny				iny
.18a2	b1 08		lda ($08),y			lda 	(srcPtr),y
.18a4	85 11		sta $11				sta 	temp1+1
.18a6	c8		iny				iny 								; y points to the byte after it.
.18a7	a5 10		lda $10				lda 	temp1
.18a9	c9 6d		cmp #$6d			cmp 	#NextLine & $FF
.18ab	d0 06		bne $18b3			bne 	_DecodeNotEOL
.18ad	a5 11		lda $11				lda 	temp1+1
.18af	c9 1b		cmp #$1b			cmp 	#NextLine >> 8
.18b1	f0 0b		beq $18be			beq 	_DecodeEOL
.18b3					_DecodeNotEOL:
.18b3	20 c6 18	jsr $18c6			jsr 	IdentifyCodeWord
.18b6	20 10 19	jsr $1910			jsr 	DecodeFoundWord
.18b9	20 fa 18	jsr $18fa			jsr 	AdvanceToNext 				; advance to next entry in the line.
.18bc	80 df		bra $189d			bra 	_DecodeLoop 				; and go round again
.18be					_DecodeEOL:
.18be	a9 00		lda #$00			lda 	#0
.18c0	92 0a		sta ($0a)			sta 	(bufPtr)
.18c2	7a		ply				ply 								; restore registers and exit
.18c3	fa		plx				plx
.18c4	68		pla				pla
.18c5	60		rts				rts
.18c6					IdentifyCodeWord:
.18c6	5a		phy				phy 								; save current position on the stack.
.18c7	a9 a5		lda #$a5			lda 	#(Dictionary) & $FF
.18c9	85 0c		sta $0c				sta 	0+(matchPtr)
.18cb	a9 1d		lda #$1d			lda 	#(Dictionary) >> 8
.18cd	85 0d		sta $0d				sta 	1+(matchPtr)
.18cf					_DecodeIdentify:
.18cf	a0 02		ldy #$02			ldy 	#2 							; have we found a match ?
.18d1	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.18d3	c5 10		cmp $10				cmp 	temp1
.18d5	d0 07		bne $18de			bne 	_DecodeIdNext
.18d7	c8		iny				iny
.18d8	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.18da	c5 11		cmp $11				cmp 	temp1+1
.18dc	f0 1a		beq $18f8			beq 	_DecodeIdFound
.18de					_DecodeIdNext:
.18de	18		clc				clc
.18df	b2 0c		lda ($0c)			lda 	(matchPtr)
.18e1	f0 0a		beq $18ed			beq 	_DecodeIdIssue
.18e3	65 0c		adc $0c				adc 	matchPtr
.18e5	85 0c		sta $0c				sta 	matchPtr
.18e7	90 e6		bcc $18cf			bcc 	_DecodeIdentify
.18e9	e6 0d		inc $0d				inc 	matchPtr+1
.18eb	80 e2		bra $18cf			bra 	_DecodeIdentify
.18ed					_DecodeIdIssue:
.18ed	20 1d 10	jsr $101d			jsr 	ErrorHandler
>18f0	44 45 43 4f 44 45 3f 00				.text 	"DECODE?",0
.18f8					_DecodeIdFound:
.18f8	7a		ply				ply 								; restore position.
.18f9	60		rts				rts
.18fa					AdvanceToNext:
.18fa	5a		phy				phy 								; get the parameter count from bits 0-1 of the type byte
.18fb	a0 01		ldy #$01			ldy 	#1
.18fd	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.18ff	29 03		and #$03			and 	#3 							; bits 0-1.
.1901	7a		ply				ply
.1902	c9 03		cmp #$03			cmp 	#3 							; is it n-bytes e.g. specified by the next byte
.1904	d0 02		bne $1908			bne 	_ATN012
.1906	b1 08		lda ($08),y			lda 	(srcPtr),y 					; if so, use that byte as the overall length.
.1908					_ATN012:
.1908	85 12		sta $12				sta 	temp2 						; now add that to Y
.190a	98		tya				tya
.190b	18		clc				clc
.190c	65 12		adc $12				adc 	temp2
.190e	a8		tay				tay
.190f	60		rts				rts
.1910					DecodeFoundWord:
.1910	5a		phy				phy 								; save current position
.1911	84 12		sty $12				sty		temp2 						; put it in temp2 as well.
.1913	a0 01		ldy #$01			ldy 	#1 							; get the type byte
.1915	b1 0c		lda ($0c),y			lda 	(matchPtr),y 				; is there a special decoder check (bit 4 set) ?
.1917	29 10		and #$10			and 	#$10
.1919	d0 0e		bne $1929			bne 	_DFWSpecialDecoder
.191b	b1 0c		lda ($0c),y			lda 	(matchPtr),y 				; reget it.
.191d	30 08		bmi $1927			bmi 	_DFWExit 					; if hidden word (bit 7 set)
.191f	a9 06		lda #$06			lda 	#CTH_Keyword				; output a space to the buffer
.1921	20 65 19	jsr $1965			jsr 	DecodeWriteBuffer
.1924	20 42 19	jsr $1942			jsr 	DecodeCurrentWord 			; expand that.
.1927					_DFWExit:
.1927	7a		ply				ply 								; restore current position
.1928	60		rts				rts
.1929					_DFWSpecialDecoder:
.1929	a0 04		ldy #$04			ldy 	#4 							; the decode word address is at offset 4,5
.192b	b1 0c		lda ($0c),y			lda 	(matchPtr),y 				; copy this into temp2
.192d	85 12		sta $12				sta 	temp2
.192f	c8		iny				iny
.1930	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.1932	85 13		sta $13				sta 	temp2+1
.1934	7a		ply				ply 	 							; restore current position into Y
.1935	48		pha				pha 								; save registers
.1936	da		phx				phx
.1937	5a		phy				phy
.1938	20 3f 19	jsr $193f			jsr 	_DFWCallDecoder				; call the decoder routine
.193b	7a		ply				ply 								; restore registers and exit
.193c	fa		plx				plx
.193d	68		pla				pla
.193e	60		rts				rts
.193f					_DFWCallDecoder:
.193f	6c 12 00	jmp ($0012)			jmp 	(temp2)
.1942					DecodeCurrentWord:
.1942	5a		phy				phy
.1943	a0 01		ldy #$01			ldy 	#1 							; read type byte
.1945	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.1947	a0 04		ldy #$04			ldy 	#4 							; original offset
.1949	4a		lsr a				lsr 	a 							; encoder/decoder bits in 0-1
.194a	4a		lsr a				lsr 	a 							; add 2 to Y for each encoder/decoder
.194b	4a		lsr a				lsr 	a 							; bit set.
.194c	4a		lsr a				lsr 	a
.194d	4a		lsr a				lsr 	a 							; decoder bit
.194e	90 02		bcc $1952			bcc 	_DWBNoDec
.1950	c8		iny				iny
.1951	c8		iny				iny
.1952					_DWBNoDec:
.1952	4a		lsr a				lsr 	a
.1953	90 02		bcc $1957			bcc 	_DWBNoEnc
.1955	c8		iny				iny
.1956	c8		iny				iny
.1957					_DWBNoEnc:
.1957					_DWBWordOut:
.1957	b1 0c		lda ($0c),y			lda 	(matchPtr),y 				; output until bit 7 set.
.1959	48		pha				pha
.195a	29 7f		and #$7f			and 	#$7F
.195c	20 65 19	jsr $1965			jsr		DecodeWriteBuffer
.195f	c8		iny				iny
.1960	68		pla				pla
.1961	10 f4		bpl $1957			bpl 	_DWBWordOut
.1963	7a		ply				ply 								; restore Y and exit
.1964	60		rts				rts
.1965					DecodeWriteBuffer:
.1965	92 0a		sta ($0a)			sta 	(bufPtr)
.1967	e6 0a		inc $0a				inc 	bufPtr
.1969	d0 02		bne $196d			bne 	_DWBNoCarry
.196b	e6 0b		inc $0b				inc 	bufPtr+1
.196d					_DWBNoCarry:
.196d	60		rts				rts
.196e					DecodeOutputData:
.196e	48		pha				pha
.196f	da		phx				phx
.1970	5a		phy				phy
.1971	b1 08		lda ($08),y			lda 	(srcPtr),y 					; length + 1
.1973	aa		tax				tax
.1974					_DODLoop:
.1974	ca		dex				dex 								; done it all ?
.1975	f0 0c		beq $1983			beq		_DODExit
.1977	c8		iny				iny 								; output next character
.1978	b1 08		lda ($08),y			lda 	(srcPtr),y
.197a	29 7f		and #$7f			and 	#$7F
.197c	f0 f6		beq $1974			beq 	_DODLoop 					; don't print NULL
.197e	20 65 19	jsr $1965			jsr 	DecodeWriteBuffer
.1981	80 f1		bra $1974			bra 	_DODLoop
.1983					_DODExit:
.1983	7a		ply				ply
.1984	fa		plx				plx
.1985	68		pla				pla
.1986	60		rts				rts
.1987					DecodeYAToBuffer:
.1987	da		phx				phx
.1988	5a		phy				phy
.1989	48		pha				pha
.198a	a5 0a		lda $0a				lda 	bufPtr 						; copy bufPtr to temp2
.198c	85 12		sta $12				sta 	temp2
.198e	a5 0b		lda $0b				lda 	bufPtr+1
.1990	85 13		sta $13				sta 	temp2+1
.1992	68		pla				pla
.1993	20 e7 1b	jsr $1be7			jsr 	ConvertToStringMain 		; convert YA to string there
.1996	aa		tax				tax 								; chars output to X
.1997	18		clc				clc
.1998	65 0a		adc $0a				adc 	bufPtr 						; add to buffer pointer
.199a	85 0a		sta $0a				sta 	bufPtr
.199c	90 02		bcc $19a0			bcc 	_DYABNoCarry
.199e	e6 0b		inc $0b				inc 	bufPtr+1
.19a0					_DYABNoCarry:
.19a0	8a		txa				txa 								; count in A
.19a1	7a		ply				ply									; restore and exit.
.19a2	fa		plx				plx
.19a3	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/list.src

.19a4					ListCode:
.19a4	64 1e		stz $1e				stz 	ListLowest 					; zero lowest line#
.19a6	64 1f		stz $1f				stz 	ListLowest+1
.19a8	a9 14		lda #$14			lda 	#20 						; show max 20 after lowest line
.19aa	85 1d		sta $1d				sta 	ListCount
.19ac	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.19ae	85 18		sta $18				sta 	0+(listPtr)
.19b0	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.19b2	85 19		sta $19				sta 	1+(listPtr)
.19b4	86 10		stx $10				stx 	temp1						; S->A
.19b6	ba		tsx				tsx
.19b7	8a		txa				txa
.19b8	a6 10		ldx $10				ldx 	temp1
.19ba	c9 80		cmp #$80			cmp 	#NumberStackBase
.19bc	f0 0e		beq $19cc			beq 	_LCLoop
.19be	a5 06		lda $06				lda 	TOS 						; copy TOS to lowest
.19c0	85 1e		sta $1e				sta 	ListLowest
.19c2	a5 07		lda $07				lda 	TOS+1
.19c4	85 1f		sta $1f				sta 	ListLowest+1
.19c6	68		pla				pla
.19c7	85 07		sta $07				sta 	TOS+1
.19c9	68		pla				pla
.19ca	85 06		sta $06				sta 	TOS
.19cc					_LCLoop:
.19cc	b2 18		lda ($18)			lda 	(listPtr)					; reached end ?
.19ce	f0 4e		beq $1a1e			beq 	_LCExit
.19d0	a0 01		ldy #$01			ldy 	#1							; >= list lowest
.19d2	b1 18		lda ($18),y			lda 	(listPtr),y
.19d4	c5 1e		cmp $1e				cmp 	ListLowest
.19d6	c8		iny				iny
.19d7	b1 18		lda ($18),y			lda 	(listPtr),y
.19d9	e5 1f		sbc $1f				sbc 	ListLowest+1
.19db	90 34		bcc $1a11			bcc 	_LCNext
.19dd	a9 10		lda #$10			lda 	#(textBuffer) & $FF
.19df	85 0a		sta $0a				sta 	0+(bufPtr)
.19e1	a9 08		lda #$08			lda 	#(textBuffer) >> 8
.19e3	85 0b		sta $0b				sta 	1+(bufPtr)
.19e5	a5 18		lda $18				lda 	listPtr 					; output the line.
.19e7	a4 19		ldy $19				ldy 	listPtr+1
.19e9	38		sec				sec
.19ea	20 77 18	jsr $1877			jsr 	DecodeLineIntoBufPtr
.19ed	a9 02		lda #$02			lda 	#CTH_LineNo
.19ef	20 10 11	jsr $1110			jsr 	ExternColour
.19f2	a0 ff		ldy #$ff			ldy 	#255
.19f4					_LCLoop2:
.19f4	c8		iny				iny
.19f5	b9 10 08	lda $0810,y			lda 	textBuffer,y
.19f8	f0 0e		beq $1a08			beq 	_LCEnd
.19fa	c9 20		cmp #$20			cmp 	#32
.19fc	b0 05		bcs $1a03			bcs 	_LCPrint
.19fe	20 10 11	jsr $1110			jsr 	ExternColour
.1a01	a9 20		lda #$20			lda 	#32
.1a03					_LCPrint:
.1a03	20 06 11	jsr $1106			jsr 	ExternPrint
.1a06	80 ec		bra $19f4			bra 	_LCLoop2
.1a08	a9 0d		lda #$0d	_LCEnd:	lda 	#13 						; new line
.1a0a	20 06 11	jsr $1106			jsr 	ExternPrint
.1a0d	c6 1d		dec $1d				dec 	ListCount					; done all the lines allowed
.1a0f	f0 0d		beq $1a1e			beq 	_LCExit
.1a11					_LCNext:
.1a11	18		clc				clc
.1a12	a5 18		lda $18				lda 	listPtr
.1a14	72 18		adc ($18)			adc 	(listPtr)
.1a16	85 18		sta $18				sta 	listPtr
.1a18	90 02		bcc $1a1c			bcc 	_NoCarryAdv
.1a1a	e6 19		inc $19				inc 	listPtr+1
.1a1c					_NoCarryAdv:
.1a1c	80 ae		bra $19cc			bra 	_LCLoop 					; go round again.
.1a1e					_LCExit:
.1a1e	4c 00 00	jmp $0000			jmp 	Next

;******  Return to file: kernel.asm


;******  Processing file: words/system/miscellany.src

.1a21					RunProgram:
.1a21	a2 80		ldx #$80			ldx 	#NumberStackBase
.1a23	9a		txs				txs
.1a24	20 35 18	jsr $1835			jsr 		ClearVariableSpace 		; clear variables etc.
.1a27	a2 00		ldx #$00			ldx			#ProgramMemory & $FF	; boot address
.1a29	a0 40		ldy #$40			ldy 		#ProgramMemory >>8
.1a2b	20 72 10	jsr $1072			jsr 		InitialiseCoreCode 		; initialise the NEXT routine at $00
.1a2e	4c 00 00	jmp $0000			jmp 		Next
.1a31					Call6502:
.1a31	a5 06		lda $06				lda 	TOS 						; copy call address
.1a33	85 10		sta $10				sta 	temp1
.1a35	a5 07		lda $07				lda 	TOS+1
.1a37	85 11		sta $11				sta 	temp1+1
.1a39	68		pla				pla
.1a3a	85 07		sta $07				sta 	TOS+1
.1a3c	68		pla				pla
.1a3d	85 06		sta $06				sta 	TOS
.1a3f	20 45 1a	jsr $1a45			jsr 	_CallTemp1 					; call it
.1a42	4c 00 00	jmp $0000			jmp 	Next
.1a45					_CallTemp1:
.1a45	6c 10 00	jmp ($0010)			jmp 	(temp1)
.1a48					AssertCode:
.1a48	a5 06		lda $06				lda 	TOS 						; TOS = 0
.1a4a	05 07		ora $07				ora 	TOS+1
.1a4c	f0 09		beq $1a57			beq 	_ASFail 					; if zero fail
.1a4e	68		pla				pla
.1a4f	85 07		sta $07				sta 	TOS+1
.1a51	68		pla				pla
.1a52	85 06		sta $06				sta 	TOS
.1a54	4c 00 00	jmp $0000			jmp 	Next
.1a57					_ASFail:
.1a57	20 1d 10	jsr $101d			jsr 	ErrorHandler
>1a5a	41 53 53 45 52 54 00				.text 	"ASSERT",0
.1a61					StopCode:
.1a61	20 1d 10	jsr $101d			jsr 	ErrorHandler
>1a64	53 54 4f 50 00					.text 	"STOP",0
.1a69					EndProgram:
.1a69	4c 10 10	jmp $1010			jmp 	WarmStart
.1a6c					VlistCode:
.1a6c	a9 a5		lda #$a5			lda 	#(Dictionary) & $FF
.1a6e	85 10		sta $10				sta 	0+(temp1)
.1a70	a9 1d		lda #$1d			lda 	#(Dictionary) >> 8
.1a72	85 11		sta $11				sta 	1+(temp1)
.1a74	a0 01		ldy #$01	_VLLoop:ldy 	#1							; type byte
.1a76	b1 10		lda ($10),y			lda 	(temp1),y
.1a78	a0 04		ldy #$04			ldy 	#4 							; Y = 4
.1a7a	4a		lsr a				lsr 	a 							; shift bits 4 and 5 to 0,1
.1a7b	4a		lsr a				lsr 	a
.1a7c	4a		lsr a				lsr		a
.1a7d	4a		lsr a				lsr 	a
.1a7e	4a		lsr a				lsr 	a 							; add those bits in
.1a7f	90 02		bcc $1a83			bcc 	_VLNoDec
.1a81	c8		iny				iny
.1a82	c8		iny				iny
.1a83					_VLNoDec:
.1a83	4a		lsr a				lsr 	a
.1a84	90 02		bcc $1a88			bcc 	_VLNoEnc
.1a86	c8		iny				iny
.1a87	c8		iny				iny
.1a88					_VLNoEnc:
.1a88	b1 10		lda ($10),y			lda 	(temp1),y 					; remove $$ words
.1a8a	c9 24		cmp #$24			cmp 	#"$"
.1a8c	d0 06		bne $1a94			bne 	_VLPrint
.1a8e	c8		iny				iny
.1a8f	51 10		eor ($10),y			eor 	(temp1),y
.1a91	f0 13		beq $1aa6			beq 	_VLNext
.1a93	88		dey				dey
.1a94					_VLPrint:
.1a94	b1 10		lda ($10),y			lda 	(temp1),y
.1a96	48		pha				pha
.1a97	c8		iny				iny
.1a98	29 7f		and #$7f			and 	#$7F
.1a9a	20 06 11	jsr $1106			jsr 	ExternPrint
.1a9d	68		pla				pla
.1a9e	0a		asl a				asl 	a
.1a9f	90 f3		bcc $1a94			bcc 	_VLPrint
.1aa1	a9 20		lda #$20			lda 	#32
.1aa3	20 06 11	jsr $1106			jsr 	ExternPrint
.1aa6					_VLNext:
.1aa6	18		clc				clc 								; go to next
.1aa7	b2 10		lda ($10)			lda 	(temp1)
.1aa9	65 10		adc $10				adc 	temp1
.1aab	85 10		sta $10				sta 	temp1
.1aad	90 02		bcc $1ab1			bcc 	_VLNoCarry
.1aaf	e6 11		inc $11				inc 	temp1+1
.1ab1					_VLNoCarry:
.1ab1	b2 10		lda ($10)			lda 	(temp1)
.1ab3	d0 bf		bne $1a74			bne 	_VLLoop
.1ab5	a9 0d		lda #$0d			lda 	#13
.1ab7	20 06 11	jsr $1106			jsr 	ExternPrint
.1aba	4c 00 00	jmp $0000			jmp 	Next

;******  Return to file: kernel.asm


;******  Processing file: words/system/toint.src

.1abd					NumToInt:
.1abd	a5 06		lda $06				lda 	TOS 						; TOS to temp4
.1abf	85 16		sta $16				sta 	temp4
.1ac1	a5 07		lda $07				lda		TOS+1
.1ac3	85 17		sta $17				sta 	temp4+1
.1ac5	20 e6 1a	jsr $1ae6			jsr 	ConvertToInteger
.1ac8	90 0f		bcc $1ad9			bcc 	_NTIFail
.1aca	a5 14		lda $14				lda 	temp3
.1acc	48		pha				pha
.1acd	a5 15		lda $15				lda 	temp3+1
.1acf	48		pha				pha
.1ad0	a9 ff		lda #$ff			lda 	#$FF 						; TOS = -1
.1ad2	85 06		sta $06				sta 	TOS
.1ad4	85 07		sta $07				sta 	TOS+1
.1ad6	4c 00 00	jmp $0000			jmp 	Next
.1ad9					_NTIFail:
.1ad9	64 06		stz $06				stz 	TOS 						; zero TOS and push on stack as null answer
.1adb	64 07		stz $07				stz 	TOS+1
.1add	a5 06		lda $06				lda 	TOS
.1adf	48		pha				pha
.1ae0	a5 07		lda $07				lda 	TOS+1
.1ae2	48		pha				pha
.1ae3	4c 00 00	jmp $0000			jmp 	Next
.1ae6					ConvertToInteger:
.1ae6	64 14		stz $14				stz 	temp3 						; reset value
.1ae8	64 15		stz $15				stz 	temp3+1
.1aea	64 10		stz $10				stz 	temp1 						; temp1 = 0 (decimal) 255 (hex)
.1aec	a0 00		ldy #$00			ldy 	#0 							; look at first character
.1aee	b1 16		lda ($16),y			lda 	(temp4),y
.1af0	49 2d		eor #$2d			eor 	#"-"						; zero if '-'
.1af2	85 11		sta $11				sta 	temp1+1 					; save this in temp1+1
.1af4	d0 01		bne $1af7			bne 	_CTINotMinus
.1af6	c8		iny				iny									; skip -
.1af7					_CTINotMinus:
.1af7	b1 16		lda ($16),y			lda 	(temp4),y
.1af9	c9 24		cmp #$24			cmp		#'$'						; if $ then skip it and set hex flag
.1afb	d0 03		bne $1b00			bne 	_CTILoop
.1afd	c6 10		dec $10				dec 	temp1
.1aff	c8		iny				iny
.1b00					_CTILoop:
.1b00	b1 16		lda ($16),y			lda 	(temp4),y 					; next digit
.1b02	29 7f		and #$7f			and 	#$7F 						; drop end of word flag
.1b04	38		sec				sec
.1b05	e9 30		sbc #$30			sbc 	#'0' 						; put in range '0'+
.1b07	90 62		bcc $1b6b			bcc 	_CTIFail 					; out of range.
.1b09	c9 0a		cmp #$0a			cmp 	#10 						; in 0-9 ?
.1b0b	90 0b		bcc $1b18			bcc 	_CTILegal
.1b0d	c9 11		cmp #$11			cmp 	#'A'-'0'					; between 9 and A ?
.1b0f	90 5a		bcc $1b6b			bcc 	_CTIFail
.1b11	38		sec				sec
.1b12	e9 07		sbc #$07			sbc 	#7 							; hex adjust
.1b14	c9 10		cmp #$10			cmp 	#16 						; out of range ?
.1b16	b0 53		bcs $1b6b			bcs 	_CTIFail
.1b18					_CTILegal:
.1b18	48		pha				pha 								; save digit value.
.1b19	06 14		asl $14				asl 	temp3
.1b1b	26 15		rol $15				rol 	temp3+1
.1b1d	a5 14		lda $14				lda 	temp3 						; copy x2 into temp2
.1b1f	85 12		sta $12				sta 	temp2
.1b21	a5 15		lda $15				lda 	temp3+1
.1b23	85 13		sta $13				sta 	temp2+1
.1b25	06 14		asl $14				asl 	temp3
.1b27	26 15		rol $15				rol 	temp3+1
.1b29	06 14		asl $14				asl 	temp3
.1b2b	26 15		rol $15				rol 	temp3+1
.1b2d	24 10		bit $10				bit 	temp1 						; hexadecimal
.1b2f	10 07		bpl $1b38			bpl 	_CTIDecimal
.1b31	06 14		asl $14				asl 	temp3
.1b33	26 15		rol $15				rol 	temp3+1
.1b35	68		pla				pla 								; get digit back
.1b36	80 12		bra $1b4a			bra 	_CTIAddLoop
.1b38					_CTIDecimal:
.1b38	18		clc				clc 								; x 8 + x 2 = x 10
.1b39	a5 14		lda $14				lda 	temp3
.1b3b	65 12		adc $12				adc 	temp2
.1b3d	85 14		sta $14				sta 	temp3
.1b3f	a5 15		lda $15				lda 	temp3+1
.1b41	65 13		adc $13				adc 	temp2+1
.1b43	85 15		sta $15				sta 	temp3+1
.1b45	68		pla				pla 					; check digit 0-9
.1b46	c9 0a		cmp #$0a			cmp 	#10
.1b48	b0 21		bcs $1b6b			bcs 	_CTIFail
.1b4a					_CTIAddLoop:
.1b4a	18		clc				clc
.1b4b	65 14		adc $14				adc 	temp3
.1b4d	85 14		sta $14				sta 	temp3
.1b4f	90 02		bcc $1b53			bcc 	_CTINoCarry
.1b51	e6 15		inc $15				inc 	temp3+1
.1b53					_CTINoCarry:
.1b53	c8		iny				iny
.1b54	b1 16		lda ($16),y			lda 	(temp4),y 					; was this the last character
.1b56	d0 a8		bne $1b00			bne 	_CTILoop 					; no, go back.
.1b58	a5 11		lda $11				lda 	temp1+1 					; was it - ?
.1b5a	d0 0d		bne $1b69			bne 	_CTIOkay
.1b5c	38		sec				sec
.1b5d	a9 00		lda #$00			lda 	#0 							; negate temp3.
.1b5f	e5 14		sbc $14				sbc 	temp3
.1b61	85 14		sta $14				sta 	temp3
.1b63	a9 00		lda #$00			lda 	#0
.1b65	e5 15		sbc $15				sbc 	temp3+1
.1b67	85 15		sta $15				sta 	temp3+1
.1b69					_CTIOkay:
.1b69	38		sec				sec
.1b6a	60		rts				rts
.1b6b					_CTIFail:
.1b6b	18		clc				clc
.1b6c	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/skipper.src

.1b6d					NextLine:
.1b6d	18		clc				clc
.1b6e	a5 03		lda $03				lda 	IP
.1b70	72 03		adc ($03)			adc 	(IP)
.1b72	85 03		sta $03				sta 	IP
.1b74	90 02		bcc $1b78			bcc 	_NoCarryAdv
.1b76	e6 04		inc $04				inc 	IP+1
.1b78					_NoCarryAdv:
.1b78	b2 03		lda ($03)			lda 	(IP)						; is there any following program ?
.1b7a	f0 05		beq $1b81			beq 	_NLGoEnd
.1b7c	a2 03		ldx #$03			ldx 	#3 							; start 3 in
.1b7e	4c 02 00	jmp $0002			jmp 	Next+2 						; avoid the first two INXs
.1b81					_NLGoEnd:
.1b81	4c 10 10	jmp $1010			jmp 	WarmStart
.1b84					SkipComment:
.1b84	e8		inx				inx									; (IP),X points to the length.
.1b85	e8		inx				inx
.1b86	8a		txa				txa
.1b87	a8		tay				tay 								; put into Y
.1b88	18		clc				clc
.1b89	71 03		adc ($03),y			adc 	(IP),y 						; add the length to X
.1b8b	aa		tax				tax 								; put back in X
.1b8c	4c 02 00	jmp $0002			jmp 	Next+2 						; continue skipping the pre-increment.
.1b8f					CommentDecoder:
.1b8f	a9 06		lda #$06			lda 	#CTH_Keyword
.1b91	20 65 19	jsr $1965			jsr 	DecodeWriteBuffer
.1b94	a9 27		lda #$27			lda 	#"'"
.1b96	20 65 19	jsr $1965			jsr 	DecodeWriteBuffer
.1b99	a9 0b		lda #$0b			lda 	#CTH_Comment
.1b9b	20 65 19	jsr $1965			jsr 	DecodeWriteBuffer
.1b9e	20 6e 19	jsr $196e			jsr 	DecodeOutputData
.1ba1	a9 20		lda #$20			lda 	#32
.1ba3	20 65 19	jsr $1965			jsr 	DecodeWriteBuffer
.1ba6	60		rts				rts
.1ba7					DefineCode:
.1ba7	20 1d 10	jsr $101d			jsr 	ErrorHandler
>1baa	44 45 46 49 4e 49 54 49				.text 	"DEFINITION?",0
>1bb2	4f 4e 3f 00
.1bb6					DefineDecoder:
.1bb6	a9 07		lda #$07			lda 	#CTH_Definition
.1bb8	20 65 19	jsr $1965			jsr 	DecodeWriteBuffer
.1bbb	a9 3a		lda #$3a			lda 	#":"
.1bbd	20 65 19	jsr $1965			jsr 	DecodeWriteBuffer
.1bc0	20 6e 19	jsr $196e			jsr 	DecodeOutputData
.1bc3	a9 20		lda #$20			lda 	#32
.1bc5	20 65 19	jsr $1965			jsr 	DecodeWriteBuffer
.1bc8	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/tostr.src

.1bc9					IntToString:
.1bc9	a9 10		lda #$10			lda 	#(textBuffer) & $FF
.1bcb	85 12		sta $12				sta 	0+(temp2)
.1bcd	a9 08		lda #$08			lda 	#(textBuffer) >> 8
.1bcf	85 13		sta $13				sta 	1+(temp2)
.1bd1	a5 06		lda $06				lda 	TOS 						; value in YA
.1bd3	a4 07		ldy $07				ldy 	TOS+1
.1bd5	20 e3 1b	jsr $1be3			jsr 	ConvertToString
.1bd8	a9 10		lda #$10			lda 	#(textBuffer) & $FF
.1bda	85 06		sta $06				sta 	0+(TOS)
.1bdc	a9 08		lda #$08			lda 	#(textBuffer) >> 8
.1bde	85 07		sta $07				sta 	1+(TOS)
.1be0	4c 00 00	jmp $0000			jmp 	Next
.1be3					ConvertToString:
.1be3	38		sec				sec
.1be4	80 01		bra $1be7			bra 	ConvertToStringMain
.1be6					ConvertToStringUnsigned:
.1be6	18		clc				clc
.1be7					ConvertToStringMain:
.1be7	da		phx				phx									; save XY
.1be8	5a		phy				phy
.1be9	64 1a		stz $1a				stz 	SignCount 					; this is zero suppression
.1beb	85 10		sta $10				sta 	temp1 						; save YA in temp1
.1bed	84 11		sty $11				sty 	temp1+1
.1bef	a0 00		ldy #$00			ldy 	#0 							; index to result.
.1bf1	90 16		bcc $1c09			bcc 	_CTSUnsigned 				; if carry clear do not adjust for -
.1bf3	a5 11		lda $11				lda 	temp1+1 					; is it negative
.1bf5	10 12		bpl $1c09			bpl 	_CTSUnsigned
.1bf7	a9 2d		lda #$2d			lda 	#"-"						; output - sign
.1bf9	91 12		sta ($12),y			sta 	(temp2),y
.1bfb	c8		iny				iny
.1bfc	38		sec				sec 								; negate temp1
.1bfd	a9 00		lda #$00			lda 	#0
.1bff	e5 10		sbc $10				sbc 	temp1
.1c01	85 10		sta $10				sta 	temp1
.1c03	a9 00		lda #$00			lda 	#0
.1c05	e5 11		sbc $11				sbc 	temp1+1
.1c07	85 11		sta $11				sta 	temp1+1
.1c09					_CTSUnsigned:
.1c09	a2 00		ldx #$00			ldx 	#0 							; index into subtraction table
.1c0b					_CTSLoop:
.1c0b	a9 2f		lda #$2f			lda 	#"0"-1						; set the digit to '0' code.
.1c0d	91 12		sta ($12),y			sta 	(temp2),y
.1c0f					_CTSSubLoop:
.1c0f	b1 12		lda ($12),y			lda 	(temp2),y 					; bump the count
.1c11	1a		inc a				inc 	a
.1c12	91 12		sta ($12),y			sta 	(temp2),y
.1c14	38		sec				sec 								; do subtraction saving interim result
.1c15	a5 10		lda $10				lda 	temp1
.1c17	fd 4a 1c	sbc $1c4a,x			sbc 	_CTSTable,x
.1c1a	48		pha				pha
.1c1b	a5 11		lda $11				lda 	temp1+1
.1c1d	fd 4b 1c	sbc $1c4b,x			sbc 	_CTSTable+1,x
.1c20	90 07		bcc $1c29			bcc 	_CTSCantSubtract 			; end of subtraction.
.1c22	85 11		sta $11				sta 	temp1+1 					; save result back
.1c24	68		pla				pla
.1c25	85 10		sta $10				sta 	temp1
.1c27	80 e6		bra $1c0f			bra 	_CTSSubLoop
.1c29					_CTSCantSubtract:
.1c29	68		pla				pla 								; throw away interim
.1c2a	e8		inx				inx 								; next subtractor
.1c2b	e8		inx				inx
.1c2c	b1 12		lda ($12),y			lda 	(temp2),y 					; update leading zero
.1c2e	49 30		eor #$30			eor 	#"0"
.1c30	05 1a		ora $1a				ora 	SignCount
.1c32	85 1a		sta $1a				sta 	SignCount
.1c34	f0 01		beq $1c37			beq		_CTSLZ 						; if all zeros so far suppress.
.1c36	c8		iny				iny 								; next character
.1c37					_CTSLZ:
.1c37	e0 08		cpx #$08			cpx 	#_CTSTableEnd-_CTSTable 	; done them all ?
.1c39	d0 d0		bne $1c0b			bne 	_CTSLoop
.1c3b					_CTSComplete:
.1c3b	a5 10		lda $10				lda		temp1 						; get remainder 0-9
.1c3d	09 30		ora #$30			ora 	#48 						; ASCII
.1c3f	91 12		sta ($12),y			sta 	(temp2),y					; write out
.1c41	c8		iny				iny
.1c42	a9 00		lda #$00			lda 	#0							; make ASCIIZ
.1c44	91 12		sta ($12),y			sta 	(temp2),y
.1c46	98		tya				tya 								; size in A
.1c47	7a		ply				ply									; pull and exit.
.1c48	fa		plx				plx
.1c49	60		rts				rts
.1c4a					_CTSTable:
>1c4a	10 27 e8 03 64 00 0a 00				.word 	10000,1000,100,10 			; subtractors, this is a simple version.
.1c52					_CTSTableEnd:

;******  Return to file: kernel.asm


;******  Processing file: words/system/varhandlers.src

.1c52					VarAddressHandler:
.1c52	18		clc				clc 								; find variable, error if it doesn't exist.
.1c53	20 a4 1c	jsr $1ca4			jsr 	VariableFind
.1c56	a5 06		lda $06				lda 	TOS
.1c58	48		pha				pha
.1c59	a5 07		lda $07				lda 	TOS+1
.1c5b	48		pha				pha
.1c5c	a5 10		lda $10				lda 	temp1 						; the address is the new value
.1c5e	85 06		sta $06				sta 	TOS
.1c60	a5 11		lda $11				lda		temp1+1
.1c62	85 07		sta $07				sta 	TOS+1
.1c64	4c 00 00	jmp $0000			jmp 	Next
.1c67					VarAddrHandlerDecode:
.1c67	a9 26		lda #$26			lda 	#"&"
.1c69	4c 52 1d	jmp $1d52			jmp 	VarHandlerDecode
.1c6c					VarReadHandler:
.1c6c	18		clc				clc 								; find variable, error if it doesn't exist.
.1c6d	20 a4 1c	jsr $1ca4			jsr 	VariableFind
.1c70	a5 06		lda $06				lda 	TOS
.1c72	48		pha				pha
.1c73	a5 07		lda $07				lda 	TOS+1
.1c75	48		pha				pha
.1c76	b2 10		lda ($10)			lda 	(temp1)						; read variable address to TOS
.1c78	85 06		sta $06				sta 	TOS
.1c7a	a0 01		ldy #$01			ldy 	#1
.1c7c	b1 10		lda ($10),y			lda 	(temp1),y
.1c7e	85 07		sta $07				sta 	TOS+1
.1c80	4c 00 00	jmp $0000			jmp 	Next
.1c83					VarReadHandlerDecode:
.1c83	a9 40		lda #$40			lda 	#"@"
.1c85	4c 52 1d	jmp $1d52			jmp 	VarHandlerDecode
.1c88					VarWriteHandler:
.1c88	38		sec				sec 								; find variable, create it if it doesn't exist.
.1c89	20 a4 1c	jsr $1ca4			jsr 	VariableFind
.1c8c	a5 06		lda $06				lda 	TOS 						; write TOS to that address.
.1c8e	92 10		sta ($10)			sta 	(temp1)
.1c90	a5 07		lda $07				lda 	TOS+1
.1c92	a0 01		ldy #$01			ldy 	#1
.1c94	91 10		sta ($10),y			sta 	(temp1),y
.1c96	68		pla				pla
.1c97	85 07		sta $07				sta 	TOS+1
.1c99	68		pla				pla
.1c9a	85 06		sta $06				sta 	TOS
.1c9c	4c 00 00	jmp $0000			jmp 	Next
.1c9f					VarWriteHandlerDecode:
.1c9f	a9 21		lda #$21			lda 	#"!"
.1ca1	4c 52 1d	jmp $1d52			jmp 	VarHandlerDecode
.1ca4					VariableFind:
.1ca4	08		php				php 								; save autocreate flag.
.1ca5	e8		inx				inx 								; advance to/over the variable name.
.1ca6	e8		inx				inx
.1ca7	8a		txa				txa 								; put in Y
.1ca8	a8		tay				tay
.1ca9	b1 03		lda ($03),y			lda 	(IP),y 						; copy name word into temp2
.1cab	85 12		sta $12				sta 	temp2
.1cad	c8		iny				iny
.1cae	b1 03		lda ($03),y			lda 	(IP),y
.1cb0	85 13		sta $13				sta 	temp2+1
.1cb2	c9 1b		cmp #$1b			cmp 	#27 						; check for A-Z
.1cb4	b0 0f		bcs $1cc5			bcs 	_VFLong
.1cb6	a5 13		lda $13				lda 	temp2+1
.1cb8	d0 0b		bne $1cc5			bne 	_VFLong
.1cba	a5 12		lda $12				lda 	temp2						; this is the index
.1cbc	0a		asl a				asl 	a 							; double it
.1cbd	85 10		sta $10				sta 	temp1
.1cbf	a9 06		lda #$06			lda 	#azVariables >> 8			; set the MSB
.1cc1	85 11		sta $11				sta 	temp1+1
.1cc3	28		plp				plp 								; throw creation flag, it always exists.
.1cc4	60		rts				rts
.1cc5					_VFLong:
.1cc5	a5 12		lda $12				lda 	temp2 						; built a hash table index into temp3/temp4
.1cc7	6a		ror a				ror 	a
.1cc8	6a		ror a				ror 	a
.1cc9	6a		ror a				ror 	a
.1cca	6a		ror a				ror 	a
.1ccb	45 12		eor $12				eor 	temp2
.1ccd	45 13		eor $13				eor 	temp2+1
.1ccf	29 0f		and #$0f			and 	#(hashTableSize-1)			; force into range
.1cd1	0a		asl a				asl 	a
.1cd2	69 40		adc #$40			adc 	#hashTable & $FF 			; make an address of the head => temp1/3
.1cd4	85 10		sta $10				sta 	temp1
.1cd6	85 14		sta $14				sta 	temp3
.1cd8	a9 06		lda #$06			lda 	#hashTable >> 8
.1cda	85 11		sta $11				sta 	temp1+1
.1cdc	85 15		sta $15				sta 	temp3+1
.1cde					_VFSearch:
.1cde	a0 01		ldy #$01			ldy 	#1							; read MSB of first record
.1ce0	b1 10		lda ($10),y			lda 	(temp1),y
.1ce2	f0 23		beq $1d07			beq 	_VFNotFound 				; is MSB is zero, can't be a variable record
.1ce4	a8		tay				tay 								; follow the link through.
.1ce5	b2 10		lda ($10)			lda 	(temp1)
.1ce7	85 10		sta $10				sta 	temp1
.1ce9	84 11		sty $11				sty 	temp1+1
.1ceb	a0 04		ldy #$04			ldy 	#4							; check if the name matches
.1ced	b1 10		lda ($10),y			lda 	(temp1),y
.1cef	c5 12		cmp $12				cmp 	temp2
.1cf1	d0 eb		bne $1cde			bne 	_VFSearch 					; if it doesn't, follow the next link.
.1cf3	c8		iny				iny 								; same for 2nd byte of name
.1cf4	b1 10		lda ($10),y			lda 	(temp1),y
.1cf6	c5 13		cmp $13				cmp 	temp2+1
.1cf8	d0 e4		bne $1cde			bne 	_VFSearch
.1cfa	18		clc				clc
.1cfb	a5 10		lda $10				lda 	temp1 						; make temp1 point to the data at offset 2
.1cfd	69 02		adc #$02			adc 	#2
.1cff	85 10		sta $10				sta 	temp1
.1d01	90 02		bcc $1d05			bcc 	_VFNoPage1
.1d03	e6 11		inc $11				inc 	temp1+1
.1d05					_VFNoPage1:
.1d05	28		plp				plp 								; don't need to worry about creation flag
.1d06	60		rts				rts
.1d07					_VFNotFound:
.1d07	28		plp				plp 								; was carry set, e.g. create a new record if not found ?
.1d08	b0 0d		bcs $1d17			bcs 	_VFCreate
.1d0a	20 1d 10	jsr $101d			jsr 	ErrorHandler
>1d0d	56 41 52 49 41 42 4c 45				.text 	"VARIABLE?",0
>1d15	3f 00
.1d17					_VFCreate:
.1d17	a0 01		ldy #$01			ldy 	#1
.1d19	b2 14		lda ($14)			lda 	(temp3) 					; copy the head link to the first 2 bytes
.1d1b	92 0e		sta ($0e)			sta 	(nextFreeMem)
.1d1d	b1 14		lda ($14),y			lda 	(temp3),y
.1d1f	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.1d21	c8		iny				iny
.1d22	a9 00		lda #$00			lda 	#0	 						; write zero initialised data out.
.1d24	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.1d26	c8		iny				iny
.1d27	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.1d29	c8		iny				iny
.1d2a	a5 12		lda $12				lda 	temp2 						; copy the name out
.1d2c	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.1d2e	c8		iny				iny
.1d2f	a5 13		lda $13				lda 	temp2+1
.1d31	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.1d33	a0 01		ldy #$01			ldy 	#1
.1d35	a5 0e		lda $0e				lda 	nextFreeMem 				; update the head link
.1d37	92 14		sta ($14)			sta 	(temp3)
.1d39	a5 0f		lda $0f				lda 	nextFreeMem+1
.1d3b	91 14		sta ($14),y			sta 	(temp3),y
.1d3d	18		clc				clc
.1d3e	a5 0e		lda $0e				lda 	nextFreeMem 				; put nextFreeMem+2 in temp1 (data pointer)
.1d40	69 02		adc #$02			adc 	#2
.1d42	85 10		sta $10				sta 	temp1
.1d44	a5 0f		lda $0f				lda 	nextFreeMem+1
.1d46	69 00		adc #$00			adc 	#0
.1d48	85 11		sta $11				sta 	temp1+1
.1d4a	a9 06		lda #$06			lda 	#6							; shift freemem pointer up 6
.1d4c	a0 00		ldy #$00			ldy 	#0
.1d4e	20 62 18	jsr $1862			jsr 	AdvanceFreeMem
.1d51	60		rts				rts
.1d52					VarHandlerDecode:
.1d52	48		pha				pha 								; save, leading space
.1d53	a9 20		lda #$20			lda 	#" "
.1d55	20 65 19	jsr $1965			jsr 	DecodeWriteBuffer
.1d58	68		pla				pla 								; restore and write type
.1d59	20 65 19	jsr $1965			jsr 	DecodeWriteBuffer
.1d5c	b1 08		lda ($08),y			lda 	(srcPtr),y 					; copy to temp1
.1d5e	85 10		sta $10				sta 	temp1
.1d60	c8		iny				iny
.1d61	b1 08		lda ($08),y			lda 	(srcPtr),y
.1d63	85 11		sta $11				sta 	temp1+1
.1d65	a5 10		lda $10				lda 	temp1 						; output the first character
.1d67	29 1f		and #$1f			and 	#31
.1d69	20 94 1d	jsr $1d94			jsr 	VHOutVarChar
.1d6c	a2 05		ldx #$05			ldx 	#5 							; divide temp1 by 32
.1d6e					_VHDShift:
.1d6e	46 11		lsr $11				lsr 	temp1+1
.1d70	66 10		ror $10				ror 	temp1
.1d72	ca		dex				dex
.1d73	d0 f9		bne $1d6e			bne 	_VHDShift
.1d75	a2 ff		ldx #$ff			ldx 	#255 						; now divide that by 40 by repeated subtraction.
.1d77					_VHDDiv40:
.1d77	e8		inx				inx
.1d78	38		sec				sec
.1d79	a5 10		lda $10				lda 	temp1
.1d7b	e9 28		sbc #$28			sbc 	#40
.1d7d	a8		tay				tay
.1d7e	a5 11		lda $11				lda 	temp1+1
.1d80	e9 00		sbc #$00			sbc 	#0
.1d82	90 06		bcc $1d8a			bcc 	_VHDivDone
.1d84	85 11		sta $11				sta 	temp1+1
.1d86	84 10		sty $10				sty 	temp1
.1d88	80 ed		bra $1d77			bra 	_VHDDiv40
.1d8a					_VHDivDone:
.1d8a	a5 10		lda $10				lda 	temp1 						; remainder
.1d8c	20 94 1d	jsr $1d94			jsr 	VHOutVarChar
.1d8f	8a		txa				txa
.1d90	20 94 1d	jsr $1d94			jsr 	VHOutVarChar 				; and result.
.1d93	60		rts				rts
.1d94					VHOutVarChar:
.1d94	c9 00		cmp #$00			cmp 	#0
.1d96	f0 0c		beq $1da4			beq 	_VHOExit
.1d98	18		clc				clc
.1d99	69 40		adc #$40			adc 	#64 						; 65-90 A-Z 91-100 0-9
.1d9b	c9 5b		cmp #$5b			cmp 	#91 						; convert back ?
.1d9d	90 02		bcc $1da1			bcc 	_VHOOut
.1d9f	e9 2b		sbc #$2b			sbc 	#91-48 						; adjust to digit
.1da1					_VHOOut:
.1da1	20 65 19	jsr $1965			jsr 	DecodeWriteBuffer
.1da4					_VHOExit:
.1da4	60		rts				rts

;******  Return to file: kernel.asm

.1da5					Dictionary:

;******  Processing file: generated/dictionary.inc

>1da5	05					.byte	_end1-*
>1da6	00					.byte	$00
>1da7	f7 15					.word	WordWrite
>1da9	a1					.byte	$a1
.1daa					_end1:
>1daa	10					.byte	_end2-*
>1dab	52					.byte	$52
>1dac	88 1c					.word	VarWriteHandler
>1dae	9f 1c					.word	VarWriteHandlerDecode
>1db0	24 24 21 48 41 4e 44 4c			.byte	$24,$24,$21,$48,$41,$4e,$44,$4c,$45,$d2
>1db8	45 d2
.1dba					_end2:
>1dba	10					.byte	_end3-*
>1dbb	52					.byte	$52
>1dbc	52 1c					.word	VarAddressHandler
>1dbe	67 1c					.word	VarAddrHandlerDecode
>1dc0	24 24 26 48 41 4e 44 4c			.byte	$24,$24,$26,$48,$41,$4e,$44,$4c,$45,$d2
>1dc8	45 d2
.1dca					_end3:
>1dca	10					.byte	_end4-*
>1dcb	52					.byte	$52
>1dcc	6c 1c					.word	VarReadHandler
>1dce	83 1c					.word	VarReadHandlerDecode
>1dd0	24 24 40 48 41 4e 44 4c			.byte	$24,$24,$40,$48,$41,$4e,$44,$4c,$45,$d2
>1dd8	45 d2
.1dda					_end4:
>1dda	0c					.byte	_end5-*
>1ddb	52					.byte	$52
>1ddc	e9 16					.word	CallHandler
>1dde	a5 17					.word	CallHandlerDecode
>1de0	24 24 43 41 4c cc			.byte	$24,$24,$43,$41,$4c,$cc
.1de6					_end5:
>1de6	0f					.byte	_end6-*
>1de7	53					.byte	$53
>1de8	84 1b					.word	SkipComment
>1dea	8f 1b					.word	CommentDecoder
>1dec	24 24 43 4f 4d 4d 45 4e			.byte	$24,$24,$43,$4f,$4d,$4d,$45,$4e,$d4
>1df4	d4
.1df5					_end6:
>1df5	0e					.byte	_end7-*
>1df6	53					.byte	$53
>1df7	a7 1b					.word	DefineCode
>1df9	b6 1b					.word	DefineDecoder
>1dfb	24 24 44 45 46 49 4e c5			.byte	$24,$24,$44,$45,$46,$49,$4e,$c5
.1e03					_end7:
>1e03	0f					.byte	_end8-*
>1e04	52					.byte	$52
>1e05	83 10					.word	Literal2Byte
>1e07	99 10					.word	Literal2ByteDecode
>1e09	24 24 4c 49 54 45 52 41			.byte	$24,$24,$4c,$49,$54,$45,$52,$41,$cc
>1e11	cc
.1e12					_end8:
>1e12	0e					.byte	_end9-*
>1e13	80					.byte	$80
>1e14	6d 1b					.word	NextLine
>1e16	24 24 4e 45 58 54 4c 49			.byte	$24,$24,$4e,$45,$58,$54,$4c,$49,$4e,$c5
>1e1e	4e c5
.1e20					_end9:
>1e20	0e					.byte	_end10-*
>1e21	53					.byte	$53
>1e22	ab 10					.word	LiteralString
>1e24	c8 10					.word	LiteralStringDecoder
>1e26	24 24 53 54 52 49 4e c7			.byte	$24,$24,$53,$54,$52,$49,$4e,$c7
.1e2e					_end10:
>1e2e	05					.byte	_end11-*
>1e2f	00					.byte	$00
>1e30	73 13					.word	Multiply16x16
>1e32	aa					.byte	$aa
.1e33					_end11:
>1e33	05					.byte	_end12-*
>1e34	00					.byte	$00
>1e35	e0 11					.word	Add
>1e37	ab					.byte	$ab
.1e38					_end12:
>1e38	06					.byte	_end13-*
>1e39	00					.byte	$00
>1e3a	08 16					.word	WordAdd
>1e3c	2b a1					.byte	$2b,$a1
.1e3e					_end13:
>1e3e	05					.byte	_end14-*
>1e3f	00					.byte	$00
>1e40	ef 11					.word	Subtract
>1e42	ad					.byte	$ad
.1e43					_end14:
>1e43	06					.byte	_end15-*
>1e44	00					.byte	$00
>1e45	af 14					.word	ConstantMinus1
>1e47	2d b1					.byte	$2d,$b1
.1e49					_end15:
>1e49	05					.byte	_end16-*
>1e4a	00					.byte	$00
>1e4b	c4 12					.word	Divide16x16
>1e4d	af					.byte	$af
.1e4e					_end16:
>1e4e	05					.byte	_end17-*
>1e4f	00					.byte	$00
>1e50	a2 14					.word	Constant0
>1e52	b0					.byte	$b0
.1e53					_end17:
>1e53	06					.byte	_end18-*
>1e54	00					.byte	$00
>1e55	08 14					.word	CheckMinus
>1e57	30 bc					.byte	$30,$bc
.1e59					_end18:
>1e59	06					.byte	_end19-*
>1e5a	00					.byte	$00
>1e5b	1c 14					.word	CheckZero
>1e5d	30 bd					.byte	$30,$bd
.1e5f					_end19:
>1e5f	05					.byte	_end20-*
>1e60	00					.byte	$00
>1e61	be 14					.word	C1
>1e63	b1					.byte	$b1
.1e64					_end20:
>1e64	06					.byte	_end21-*
>1e65	00					.byte	$00
>1e66	b2 13					.word	Unary1Plus
>1e68	31 ab					.byte	$31,$ab
.1e6a					_end21:
>1e6a	06					.byte	_end22-*
>1e6b	00					.byte	$00
>1e6c	c9 13					.word	Unary1Minus
>1e6e	31 ad					.byte	$31,$ad
.1e70					_end22:
>1e70	06					.byte	_end23-*
>1e71	00					.byte	$00
>1e72	d6 14					.word	C10
>1e74	31 b0					.byte	$31,$b0
.1e76					_end23:
>1e76	07					.byte	_end24-*
>1e77	00					.byte	$00
>1e78	ff 14					.word	C100
>1e7a	31 30 b0				.byte	$31,$30,$b0
.1e7d					_end24:
>1e7d	08					.byte	_end25-*
>1e7e	00					.byte	$00
>1e7f	2e 15					.word	C1024
>1e81	31 30 32 b4				.byte	$31,$30,$32,$b4
.1e85					_end25:
>1e85	07					.byte	_end26-*
>1e86	00					.byte	$00
>1e87	03 15					.word	C127
>1e89	31 32 b7				.byte	$31,$32,$b7
.1e8c					_end26:
>1e8c	07					.byte	_end27-*
>1e8d	00					.byte	$00
>1e8e	07 15					.word	C128
>1e90	31 32 b8				.byte	$31,$32,$b8
.1e93					_end27:
>1e93	06					.byte	_end28-*
>1e94	00					.byte	$00
>1e95	da 14					.word	C15
>1e97	31 b5					.byte	$31,$b5
.1e99					_end28:
>1e99	06					.byte	_end29-*
>1e9a	00					.byte	$00
>1e9b	de 14					.word	C16
>1e9d	31 b6					.byte	$31,$b6
.1e9f					_end29:
>1e9f	07					.byte	_end30-*
>1ea0	00					.byte	$00
>1ea1	40 14					.word	Times16
>1ea3	31 36 aa				.byte	$31,$36,$aa
.1ea6					_end30:
>1ea6	07					.byte	_end31-*
>1ea7	00					.byte	$00
>1ea8	53 14					.word	Divide16
>1eaa	31 36 af				.byte	$31,$36,$af
.1ead					_end31:
>1ead	05					.byte	_end32-*
>1eae	00					.byte	$00
>1eaf	c2 14					.word	C2
>1eb1	b2					.byte	$b2
.1eb2					_end32:
>1eb2	06					.byte	_end33-*
>1eb3	00					.byte	$00
>1eb4	4c 14					.word	Times2
>1eb6	32 aa					.byte	$32,$aa
.1eb8					_end33:
>1eb8	06					.byte	_end34-*
>1eb9	00					.byte	$00
>1eba	bb 13					.word	Unary2Plus
>1ebc	32 ab					.byte	$32,$ab
.1ebe					_end34:
>1ebe	06					.byte	_end35-*
>1ebf	00					.byte	$00
>1ec0	d4 13					.word	Unary2Minus
>1ec2	32 ad					.byte	$32,$ad
.1ec4					_end35:
>1ec4	06					.byte	_end36-*
>1ec5	00					.byte	$00
>1ec6	5f 14					.word	Divide2
>1ec8	32 af					.byte	$32,$af
.1eca					_end36:
>1eca	06					.byte	_end37-*
>1ecb	00					.byte	$00
>1ecc	e2 14					.word	C24
>1ece	32 b4					.byte	$32,$b4
.1ed0					_end37:
>1ed0	07					.byte	_end38-*
>1ed1	00					.byte	$00
>1ed2	0b 15					.word	C255
>1ed4	32 35 b5				.byte	$32,$35,$b5
.1ed7					_end38:
>1ed7	07					.byte	_end39-*
>1ed8	00					.byte	$00
>1ed9	16 15					.word	C256
>1edb	32 35 b6				.byte	$32,$35,$b6
.1ede					_end39:
>1ede	08					.byte	_end40-*
>1edf	00					.byte	$00
>1ee0	66 14					.word	Times256
>1ee2	32 35 36 aa				.byte	$32,$35,$36,$aa
.1ee6					_end40:
>1ee6	08					.byte	_end41-*
>1ee7	00					.byte	$00
>1ee8	6f 14					.word	Divide256
>1eea	32 35 36 af				.byte	$32,$35,$36,$af
.1eee					_end41:
>1eee	05					.byte	_end42-*
>1eef	00					.byte	$00
>1ef0	c6 14					.word	C3
>1ef2	b3					.byte	$b3
.1ef3					_end42:
>1ef3	06					.byte	_end43-*
>1ef4	00					.byte	$00
>1ef5	f3 14					.word	C32
>1ef7	33 b2					.byte	$33,$b2
.1ef9					_end43:
>1ef9	09					.byte	_end44-*
>1efa	00					.byte	$00
>1efb	46 15					.word	C32767
>1efd	33 32 37 36 b7				.byte	$33,$32,$37,$36,$b7
.1f02					_end44:
>1f02	09					.byte	_end45-*
>1f03	00					.byte	$00
>1f04	52 15					.word	C32768
>1f06	33 32 37 36 b8				.byte	$33,$32,$37,$36,$b8
.1f0b					_end45:
>1f0b	05					.byte	_end46-*
>1f0c	00					.byte	$00
>1f0d	ca 14					.word	C4
>1f0f	b4					.byte	$b4
.1f10					_end46:
>1f10	06					.byte	_end47-*
>1f11	00					.byte	$00
>1f12	48 14					.word	Times4
>1f14	34 aa					.byte	$34,$aa
.1f16					_end47:
>1f16	06					.byte	_end48-*
>1f17	00					.byte	$00
>1f18	5b 14					.word	Divide4
>1f1a	34 af					.byte	$34,$af
.1f1c					_end48:
>1f1c	08					.byte	_end49-*
>1f1d	00					.byte	$00
>1f1e	3a 15					.word	C4096
>1f20	34 30 39 b6				.byte	$34,$30,$39,$b6
.1f24					_end49:
>1f24	05					.byte	_end50-*
>1f25	00					.byte	$00
>1f26	ce 14					.word	C5
>1f28	b5					.byte	$b5
.1f29					_end50:
>1f29	07					.byte	_end51-*
>1f2a	00					.byte	$00
>1f2b	22 15					.word	C512
>1f2d	35 31 b2				.byte	$35,$31,$b2
.1f30					_end51:
>1f30	06					.byte	_end52-*
>1f31	00					.byte	$00
>1f32	f7 14					.word	C63
>1f34	36 b3					.byte	$36,$b3
.1f36					_end52:
>1f36	06					.byte	_end53-*
>1f37	00					.byte	$00
>1f38	fb 14					.word	C64
>1f3a	36 b4					.byte	$36,$b4
.1f3c					_end53:
>1f3c	05					.byte	_end54-*
>1f3d	00					.byte	$00
>1f3e	d2 14					.word	C8
>1f40	b8					.byte	$b8
.1f41					_end54:
>1f41	06					.byte	_end55-*
>1f42	00					.byte	$00
>1f43	44 14					.word	Times8
>1f45	38 aa					.byte	$38,$aa
.1f47					_end55:
>1f47	06					.byte	_end56-*
>1f48	00					.byte	$00
>1f49	57 14					.word	Divide8
>1f4b	38 af					.byte	$38,$af
.1f4d					_end56:
>1f4d	05					.byte	_end57-*
>1f4e	40					.byte	$40
>1f4f	6e 17					.word	ReturnHandler
>1f51	bb					.byte	$bb
.1f52					_end57:
>1f52	05					.byte	_end58-*
>1f53	00					.byte	$00
>1f54	60 12					.word	CheckLess
>1f56	bc					.byte	$bc
.1f57					_end58:
>1f57	06					.byte	_end59-*
>1f58	00					.byte	$00
>1f59	79 12					.word	CheckLessEq
>1f5b	3c bd					.byte	$3c,$bd
.1f5d					_end59:
>1f5d	06					.byte	_end60-*
>1f5e	00					.byte	$00
>1f5f	29 12					.word	CheckNotEqual
>1f61	3c be					.byte	$3c,$be
.1f63					_end60:
>1f63	05					.byte	_end61-*
>1f64	00					.byte	$00
>1f65	2c 12					.word	CheckEqual
>1f67	bd					.byte	$bd
.1f68					_end61:
>1f68	05					.byte	_end62-*
>1f69	00					.byte	$00
>1f6a	7c 12					.word	CheckGreater
>1f6c	be					.byte	$be
.1f6d					_end62:
>1f6d	06					.byte	_end63-*
>1f6e	00					.byte	$00
>1f6f	5d 12					.word	CheckGreaterEq
>1f71	3e bd					.byte	$3e,$bd
.1f73					_end63:
>1f73	08					.byte	_end64-*
>1f74	00					.byte	$00
>1f75	67 15					.word	TestDup
>1f77	3f 44 55 d0				.byte	$3f,$44,$55,$d0
.1f7b					_end64:
>1f7b	05					.byte	_end65-*
>1f7c	00					.byte	$00
>1f7d	dc 15					.word	WordRead
>1f7f	c0					.byte	$c0
.1f80					_end65:
>1f80	07					.byte	_end66-*
>1f81	00					.byte	$00
>1f82	e2 13					.word	Absolute
>1f84	41 42 d3				.byte	$41,$42,$d3
.1f87					_end66:
>1f87	09					.byte	_end67-*
>1f88	00					.byte	$00
>1f89	1f 16					.word	AllocateMemory
>1f8b	41 4c 4c 4f c3				.byte	$41,$4c,$4c,$4f,$c3
.1f90					_end67:
>1f90	07					.byte	_end68-*
>1f91	00					.byte	$00
>1f92	02 12					.word	And
>1f94	41 4e c4				.byte	$41,$4e,$c4
.1f97					_end68:
>1f97	0a					.byte	_end69-*
>1f98	00					.byte	$00
>1f99	48 1a					.word	AssertCode
>1f9b	41 53 53 45 52 d4			.byte	$41,$53,$53,$45,$52,$d4
.1fa1					_end69:
>1fa1	09					.byte	_end70-*
>1fa2	00					.byte	$00
>1fa3	35 14					.word	ByteSwap
>1fa5	42 53 57 41 d0				.byte	$42,$53,$57,$41,$d0
.1faa					_end70:
>1faa	06					.byte	_end71-*
>1fab	00					.byte	$00
>1fac	ea 15					.word	ByteWrite
>1fae	43 a1					.byte	$43,$a1
.1fb0					_end71:
>1fb0	06					.byte	_end72-*
>1fb1	00					.byte	$00
>1fb2	d3 15					.word	ByteRead
>1fb4	43 c0					.byte	$43,$c0
.1fb6					_end72:
>1fb6	07					.byte	_end73-*
>1fb7	00					.byte	$00
>1fb8	2f 18					.word	ClrHandler
>1fba	43 4c d2				.byte	$43,$4c,$d2
.1fbd					_end73:
>1fbd	08					.byte	_end74-*
>1fbe	00					.byte	$00
>1fbf	5e 15					.word	Drop
>1fc1	44 52 4f d0				.byte	$44,$52,$4f,$d0
.1fc5					_end74:
>1fc5	07					.byte	_end75-*
>1fc6	00					.byte	$00
>1fc7	70 15					.word	Dup
>1fc9	44 55 d0				.byte	$44,$55,$d0
.1fcc					_end75:
>1fcc	08					.byte	_end76-*
>1fcd	01					.byte	$01
>1fce	bd 16					.word	ElseHandler
>1fd0	45 4c 53 c5				.byte	$45,$4c,$53,$c5
.1fd4					_end76:
>1fd4	07					.byte	_end77-*
>1fd5	00					.byte	$00
>1fd6	69 1a					.word	EndProgram
>1fd8	45 4e c4				.byte	$45,$4e,$c4
.1fdb					_end77:
>1fdb	09					.byte	_end78-*
>1fdc	00					.byte	$00
>1fdd	c0 16					.word	EndIfHandler
>1fdf	45 4e 44 49 c6				.byte	$45,$4e,$44,$49,$c6
.1fe4					_end78:
>1fe4	07					.byte	_end79-*
>1fe5	00					.byte	$00
>1fe6	35 16					.word	ForHandler
>1fe8	46 4f d2				.byte	$46,$4f,$d2
.1feb					_end79:
>1feb	06					.byte	_end80-*
>1fec	01					.byte	$01
>1fed	ba 16					.word	IfHandler
>1fef	49 c6					.byte	$49,$c6
.1ff1					_end80:
>1ff1	09					.byte	_end81-*
>1ff2	00					.byte	$00
>1ff3	99 16					.word	GetIndex
>1ff5	49 4e 44 45 d8				.byte	$49,$4e,$44,$45,$d8
.1ffa					_end81:
>1ffa	08					.byte	_end82-*
>1ffb	00					.byte	$00
>1ffc	a4 19					.word	ListCode
>1ffe	4c 49 53 d4				.byte	$4c,$49,$53,$d4
.2002					_end82:
>2002	07					.byte	_end83-*
>2003	00					.byte	$00
>2004	99 12					.word	Maximum
>2006	4d 41 d8				.byte	$4d,$41,$d8
.2009					_end83:
>2009	07					.byte	_end84-*
>200a	00					.byte	$00
>200b	95 12					.word	Minimum
>200d	4d 49 ce				.byte	$4d,$49,$ce
.2010					_end84:
>2010	07					.byte	_end85-*
>2011	00					.byte	$00
>2012	d5 12					.word	Modulus16x16
>2014	4d 4f c4				.byte	$4d,$4f,$c4
.2017					_end85:
>2017	0a					.byte	_end86-*
>2018	00					.byte	$00
>2019	e9 13					.word	Negate
>201b	4e 45 47 41 54 c5			.byte	$4e,$45,$47,$41,$54,$c5
.2021					_end86:
>2021	07					.byte	_end87-*
>2022	00					.byte	$00
>2023	26 18					.word	NewHandler
>2025	4e 45 d7				.byte	$4e,$45,$d7
.2028					_end87:
>2028	08					.byte	_end88-*
>2029	01					.byte	$01
>202a	63 16					.word	NextHandler
>202c	4e 45 58 d4				.byte	$4e,$45,$58,$d4
.2030					_end88:
>2030	07					.byte	_end89-*
>2031	00					.byte	$00
>2032	a4 15					.word	Nip
>2034	4e 49 d0				.byte	$4e,$49,$d0
.2037					_end89:
>2037	07					.byte	_end90-*
>2038	00					.byte	$00
>2039	f9 13					.word	OneComplement
>203b	4e 4f d4				.byte	$4e,$4f,$d4
.203e					_end90:
>203e	06					.byte	_end91-*
>203f	00					.byte	$00
>2040	1c 12					.word	LogOr
>2042	4f d2					.byte	$4f,$d2
.2044					_end91:
>2044	08					.byte	_end92-*
>2045	00					.byte	$00
>2046	8c 15					.word	Over
>2048	4f 56 45 d2				.byte	$4f,$56,$45,$d2
.204c					_end92:
>204c	0a					.byte	_end93-*
>204d	00					.byte	$00
>204e	c3 16					.word	RepeatHandler
>2050	52 45 50 45 41 d4			.byte	$52,$45,$50,$45,$41,$d4
.2056					_end93:
>2056	07					.byte	_end94-*
>2057	00					.byte	$00
>2058	78 14					.word	RandomNumber
>205a	52 4e c4				.byte	$52,$4e,$c4
.205d					_end94:
>205d	07					.byte	_end95-*
>205e	00					.byte	$00
>205f	a9 15					.word	Rot
>2061	52 4f d4				.byte	$52,$4f,$d4
.2064					_end95:
>2064	07					.byte	_end96-*
>2065	00					.byte	$00
>2066	21 1a					.word	RunProgram
>2068	52 55 ce				.byte	$52,$55,$ce
.206b					_end96:
>206b	07					.byte	_end97-*
>206c	00					.byte	$00
>206d	24 14					.word	SignTOS
>206f	53 47 ce				.byte	$53,$47,$ce
.2072					_end97:
>2072	08					.byte	_end98-*
>2073	00					.byte	$00
>2074	61 1a					.word	StopCode
>2076	53 54 4f d0				.byte	$53,$54,$4f,$d0
.207a					_end98:
>207a	08					.byte	_end99-*
>207b	00					.byte	$00
>207c	79 15					.word	Swap
>207e	53 57 41 d0				.byte	$53,$57,$41,$d0
.2082					_end99:
>2082	07					.byte	_end100-*
>2083	00					.byte	$00
>2084	31 1a					.word	Call6502
>2086	53 59 d3				.byte	$53,$59,$d3
.2089					_end100:
>2089	0e					.byte	_end101-*
>208a	00					.byte	$00
>208b	bd 1a					.word	NumToInt
>208d	54 4f 2e 49 4e 54 45 47			.byte	$54,$4f,$2e,$49,$4e,$54,$45,$47,$45,$d2
>2095	45 d2
.2097					_end101:
>2097	0d					.byte	_end102-*
>2098	00					.byte	$00
>2099	c9 1b					.word	IntToString
>209b	54 4f 2e 53 54 52 49 4e			.byte	$54,$4f,$2e,$53,$54,$52,$49,$4e,$c7
>20a3	c7
.20a4					_end102:
>20a4	09					.byte	_end103-*
>20a5	01					.byte	$01
>20a6	c6 16					.word	UntilHandler
>20a8	55 4e 54 49 cc				.byte	$55,$4e,$54,$49,$cc
.20ad					_end103:
>20ad	09					.byte	_end104-*
>20ae	00					.byte	$00
>20af	6c 1a					.word	VlistCode
>20b1	56 4c 49 53 d4				.byte	$56,$4c,$49,$53,$d4
.20b6					_end104:
>20b6	0a					.byte	_end105-*
>20b7	40					.byte	$40
>20b8	73 18					.word	BreakCmd
>20ba	58 42 52 45 41 cb			.byte	$58,$42,$52,$45,$41,$cb
.20c0					_end105:
>20c0	09					.byte	_end106-*
>20c1	00					.byte	$00
>20c2	6d 18					.word	ExitDump
>20c4	58 44 55 4d d0				.byte	$58,$44,$55,$4d,$d0
.20c9					_end106:
>20c9	07					.byte	_end107-*
>20ca	00					.byte	$00
>20cb	0f 12					.word	Xor
>20cd	58 4f d2				.byte	$58,$4f,$d2
.20d0					_end107:
>20d0	00					.byte	0

;******  Return to file: kernel.asm

>3fff	ff						.byte 	$FF
.4000					ProgramMemory:

;******  End of listing
