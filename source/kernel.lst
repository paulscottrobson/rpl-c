
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -q -D encode=0 -c -o kernel_nocode.prg -L kernel.lst -l kernel.lbl kernel.asm
; Thu Jan 16 08:17:12 2020

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=0					encode=0

;******  Processing input file: kernel.asm

=$1000					RplBuild = $1000 							; code starts here.

;******  Processing file: code/data.asm

.0000					NextCode:
>0000							.fill 	5
=3					IP = NextCode+3 							; the IP which points to the current instruction
.0005					rsp:
>0005							.byte 	?
.0006					tos:
>0006							.word 	?
.0008					srcPtr:
>0008							.word 	?
.000a					bufPtr:
>000a							.word 	?
.000c					matchPtr:
>000c							.word 	?
.000e					nextFreeMem:
>000e							.word 	?
.0010					temp1:
>0010							.word 	?
.0012					temp2:
>0012							.word 	?
.0014					temp3:
>0014							.word 	?
.0016					temp4:
>0016							.word 	?
.0018					listPtr:
>0018							.word 	?
.001a					SignCount:
>001a							.byte 	?
.001b					RandomSeed:
>001b							.word 	?
.001d					ListCount:
>001d							.byte 	?
.001e					ListLowest:
>001e							.word 	?
=$102					stack2Low = $102							; access other stack members following tsx
=$101					stack2High = $101							; (which requires saving X, not on the stack !)
=$104					stack3Low = $104
=$103					stack3High = $103
=$600					azVariables = $600 							; 26 x 2 variables occupying 52 bytes * PAGE BOUNDARY *
=16					hashTableSize = 16 							; hash tables for variables.
=$640					hashTable = $640 							; hash tables start here * ALL ON ONE PAGE *
=$810					textBuffer = $810 							; buffer for text.
=$700					returnStack = $700							; return stack (1 page)
=$700					returnStackLow = returnStack
=1856					returnStackHigh = returnStack+$40
=1920					returnStackX = returnStack+$80
=$80					NumberStackBase = $80 						; number stack down from here.
=$910					encodeBuffer = $910 						; buffer for encoded program
=0					COL_BLACK = 0
=1					COL_RED = 1
=2					COL_GREEN = 2
=3					COL_YELLOW = 3
=4					COL_BLUE = 4
=5					COL_MAGENTA = 5
=6					COL_CYAN = 6
=7					COL_WHITE = 7
=8					COL_RVS = 8
=2					CTH_LineNo = COL_Green
=6					CTH_Keyword = COL_Cyan
=11					CTH_Comment = COL_Yellow+COL_Rvs
=7					CTH_Definition = COL_White
=5					CTH_String = COL_Magenta
=3					CTH_Call = COL_Yellow
=7					CTH_Variable = COL_White

;******  Return to file: kernel.asm

.1000	a2 ff		ldx #$ff			ldx 	#$FF 						; reset the stack
.1002	9a		txs				txs
.1003	20 2f 11	jsr $112f			jsr 	ExternInitialise
.1006	a9 41		lda #$41			lda 	#BootMsg & $FF
.1008	a0 10		ldy #$10			ldy 	#BootMsg >> 8
.100a	20 23 12	jsr $1223			jsr 	EXPrintString
.100d					WarmStartBlankStack:
.100d	86 10		stx $10				stx 	temp1
.100f	a2 80		ldx #$80			ldx 	#NumberStackBase
.1011	9a		txs				txs
.1012	a6 10		ldx $10				ldx 	temp1
.1014					WarmStart:
.1014	a9 03		lda #$03			lda 	#COL_Yellow
.1016	20 68 11	jsr $1168			jsr 	ExternColour
.1019	20 8b 11	jsr $118b			jsr 	ExternInput
.101c	a9 06		lda #$06			lda 	#COL_Cyan
.101e	20 68 11	jsr $1168			jsr 	ExternColour
.1021	a2 10		ldx #$10			ldx 	#encodeBuffer & $FF 		; run what is in the encode buffer.
.1023	a0 09		ldy #$09			ldy 	#encodeBuffer >> 8
.1025	20 93 10	jsr $1093			jsr 	InitialiseCoreCode 			; initialise the NEXT routine at $00 so error line# works
.1028	a9 10		lda #$10			lda 	#textBuffer & $FF
.102a	a0 08		ldy #$08			ldy 	#textBuffer >> 8
.102c	20 8b 16	jsr $168b			jsr 	EncodeProgram
.102f	ad 11 09	lda $0911			lda 	encodeBuffer+1 				; has a line number been entered ?
.1032	0d 12 09	ora $0912			ora 	encodeBuffer+2
.1035	d0 05		bne $103c			bne 	LineEditor 					; if so, do the line editing code.
.1037	64 05		stz $05				stz 	rsp
.1039	4c 00 00	jmp $0000			jmp 	NextCode
.103c					LineEditor:
.103c	20 d3 1e	jsr $1ed3			jsr 	EditProgram
.103f	80 cc		bra $100d			bra 	WarmStartBlankStack
.1041					BootMsg:
>1041	2a 2a 2a 20 52 50 4c 2f				.text 	"*** RPL/C INTERPRETER ***",13,13
>1049	43 20 49 4e 54 45 52 50 52 45 54 45 52 20 2a 2a
>1059	2a 0d 0d
>105c	57 52 49 54 54 45 4e 20				.text	"WRITTEN BY PAUL ROBSON 2020",13,13
>1064	42 59 20 50 41 55 4c 20 52 4f 42 53 4f 4e 20 32
>1074	30 32 30 0d 0d
>1079	42 55 49 4c 44 3a 20				.text 	"BUILD: "

;******  Processing file: generated/timestamp.inc

>1080	5b 32 30 2d 30 31 2d 31			.text	"[20-01-16 08:17]"
>1088	36 20 30 38 3a 31 37 5d

;******  Return to file: kernel.asm

>1090	0d 0d 00					.byte 	13,13,0

;******  Processing file: code/core.src

.1093					InitialiseCoreCode:
.1093	a9 e8		lda #$e8			lda 	#$E8 					; Copy INX INX 			4 cycles when run
.1095	85 00		sta $00				sta 	NextCode
.1097	85 01		sta $01				sta 	NextCode+1
.1099	a9 7c		lda #$7c			lda 	#$7C 					; Copy JMP ($aaaa,x) 	6 cycles when run
.109b	85 02		sta $02				sta 	NextCode+2
.109d	86 03		stx $03				stx 	NextCode+3 				; set the indirect address (IP)
.109f	84 04		sty $04				sty 	NextCode+4
.10a1	a2 01		ldx #$01			ldx 	#1 						; set up to run from provided word.
.10a3	60		rts				rts								; (2 INX skip offset and line#)
.10a4					Literal2Byte:
.10a4	a5 06		lda $06				lda 	TOS
.10a6	48		pha				pha
.10a7	a5 07		lda $07				lda 	TOS+1
.10a9	48		pha				pha
.10aa	e8		inx				inx  							; point X to the word
.10ab	e8		inx				inx
.10ac	8a		txa				txa 							; copy into Y
.10ad	a8		tay				tay
.10ae	b1 03		lda ($03),y			lda 	(IP),y 					; read it. the LSB
.10b0	85 06		sta $06				sta 	TOS
.10b2	c8		iny				iny 							; read and push the MSB
.10b3	b1 03		lda ($03),y			lda 	(IP),y
.10b5	85 07		sta $07				sta 	TOS+1
.10b7	4c 00 00	jmp $0000			jmp 	NextCode
.10ba					Literal2ByteDecode:
.10ba	a9 06		lda #$06			lda 	#CTH_Keyword
.10bc	20 94 1e	jsr $1e94			jsr 	DecodeWriteBuffer
.10bf	b1 08		lda ($08),y			lda 	(srcPtr),y
.10c1	aa		tax				tax
.10c2	c8		iny				iny
.10c3	b1 08		lda ($08),y			lda 	(srcPtr),y
.10c5	a8		tay				tay
.10c6	8a		txa				txa
.10c7	38		sec				sec 							; output signed
.10c8	20 b6 1e	jsr $1eb6			jsr 	DecodeYAToBuffer
.10cb	60		rts				rts
.10cc					LiteralString:
.10cc	a5 06		lda $06				lda 	TOS
.10ce	48		pha				pha
.10cf	a5 07		lda $07				lda 	TOS+1
.10d1	48		pha				pha
.10d2	e8		inx				inx
.10d3	e8		inx				inx 							; skip over current word
.10d4	8a		txa				txa 							; add to IP + 1 to give string address
.10d5	a8		tay				tay 							; put in Y
.10d6	38		sec				sec 							; make that TOS
.10d7	65 03		adc $03				adc 	IP
.10d9	85 06		sta $06				sta 	TOS
.10db	a5 04		lda $04				lda 	IP+1
.10dd	69 00		adc #$00			adc 	#0
.10df	85 07		sta $07				sta 	TOS+1
.10e1	8a		txa				txa 							; add data length to X
.10e2	18		clc				clc
.10e3	71 03		adc ($03),y			adc 	(IP),y
.10e5	aa		tax				tax
.10e6	ca		dex				dex
.10e7	ca		dex				dex
.10e8	4c 00 00	jmp $0000			jmp 	NextCode
.10eb					LiteralStringDecoder:
.10eb	a9 05		lda #$05			lda 	#CTH_String
.10ed	20 94 1e	jsr $1e94			jsr 	DecodeWriteBuffer
.10f0	a9 22		lda #$22			lda 	#'"'
.10f2	20 94 1e	jsr $1e94			jsr 	DecodeWriteBuffer
.10f5	20 9d 1e	jsr $1e9d			jsr 	DecodeOutputData
.10f8	20 94 1e	jsr $1e94			jsr 	DecodeWriteBuffer
.10fb	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: code/error.asm

.10fc					ErrorHandler:
.10fc	68		pla				pla 								; get message address
.10fd	7a		ply				ply
.10fe	1a		inc a				inc 	a
.10ff	d0 01		bne $1102			bne 	_EHNoCarry
.1101	c8		iny				iny
.1102					_EHNoCarry:
.1102	20 23 12	jsr $1223			jsr 	EXPrintString
.1105	a0 01		ldy #$01			ldy 	#1 							; check if there is a line #
.1107	b1 03		lda ($03),y			lda 	(IP),y
.1109	c8		iny				iny
.110a	11 03		ora ($03),y			ora 	(IP),y
.110c	f0 14		beq $1122			beq 	_EHNoLine
.110e	a9 2a		lda #$2a			lda 	#_EHMsg2 & $FF 				; print " at "
.1110	a0 11		ldy #$11			ldy 	#_EHMsg2 >> 8
.1112	20 23 12	jsr $1223			jsr 	EXPrintString
.1115	a0 02		ldy #$02			ldy 	#2 							; print line number
.1117	b1 03		lda ($03),y			lda 	(IP),y
.1119	48		pha				pha
.111a	88		dey				dey
.111b	b1 03		lda ($03),y			lda 	(IP),y
.111d	7a		ply				ply
.111e	18		clc				clc
.111f	20 ba 22	jsr $22ba			jsr 	PrintYA
.1122					_EHNoLine:
.1122	a9 0d		lda #$0d			lda 	#13
.1124	20 5c 11	jsr $115c			jsr 	ExternPrint
.1127	4c 0d 10	jmp $100d			jmp 	WarmStartBlankStack			; S is indeterminate
>112a	20 41 54 20 00			_EHMsg2:.text 	" AT ",0

;******  Return to file: kernel.asm


;******  Processing file: code/extern.asm

.112f					ExternInitialise:
.112f	a9 90		lda #$90			lda 	#144 						; set colour
.1131	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.1134	a9 01		lda #$01			lda 	#$01
.1136	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.1139	a9 0e		lda #$0e			lda 	#14							; lower case
.113b	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.113e	a9 93		lda #$93			lda 	#147 						; clear screen
.1140	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.1143	a9 07		lda #$07			lda 	#COL_WHITE 					; white text.
.1145	4c 68 11	jmp $1168			jmp 	ExternColour
.1148					ExternCheckBreak:
.1148	da		phx				phx 								; make sure we keep XY
.1149	5a		phy				phy
.114a	20 e1 ff	jsr $ffe1			jsr 	$FFE1						; STOP check on CBM KERNAL
.114d	f0 03		beq $1152			beq		_ECBExit 					; stopped
.114f	7a		ply				ply 								; restore and exit.
.1150	fa		plx				plx
.1151	60		rts				rts
.1152					_ECBExit:
.1152	20 fc 10	jsr $10fc			jsr 	ErrorHandler
>1155	45 53 43 41 50 45 00				.text 	"ESCAPE",0
.115c					ExternPrint:
.115c	48		pha				pha
.115d	da		phx				phx
.115e	5a		phy				phy
.115f	29 7f		and #$7f			and 	#$7F
.1161	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.1164	7a		ply				ply
.1165	fa		plx				plx
.1166	68		pla				pla
.1167	60		rts				rts
.1168					ExternColour:
.1168	48		pha				pha
.1169	da		phx				phx
.116a	48		pha				pha
.116b	29 08		and #$08			and 	#8
.116d	0a		asl a				asl 	a
.116e	0a		asl a				asl 	a
.116f	0a		asl a				asl 	a
.1170	0a		asl a				asl 	a
.1171	49 92		eor #$92			eor 	#$92
.1173	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.1176	68		pla				pla
.1177	29 07		and #$07			and 	#7
.1179	aa		tax				tax
.117a	bd 83 11	lda $1183,x			lda 	_ECTable,x
.117d	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.1180	fa		plx				plx
.1181	68		pla				pla
.1182	60		rts				rts
.1183					_ECTable:
>1183	90						.byte 	144
>1184	1c						.byte 	28
>1185	1e						.byte 	30
>1186	9e						.byte 	158
>1187	1f						.byte 	31
>1188	9c						.byte 	156
>1189	9f						.byte 	159
>118a	05						.byte 	5
.118b					ExternInput:
.118b	a9 10		lda #$10			lda 	#(textBuffer & $FF)
.118d	85 14		sta $14				sta 	temp3
.118f	a9 08		lda #$08			lda 	#(textBuffer >> 8)
.1191	85 15		sta $15				sta 	temp3+1
.1193	20 cf ff	jsr $ffcf	_EIRead:jsr 	$FFCF
.1196	c9 0d		cmp #$0d			cmp 	#13
.1198	f0 0c		beq $11a6			beq 	_EIExit
.119a	29 7f		and #$7f			and 	#$7F
.119c	92 14		sta ($14)			sta 	(temp3)
.119e	e6 14		inc $14				inc 	temp3
.11a0	d0 f1		bne $1193			bne 	_EIRead
.11a2	e6 15		inc $15				inc 	temp3+1
.11a4	80 ed		bra $1193			bra 	_EIRead
.11a6	a9 00		lda #$00	_EIExit:lda 	#0
.11a8	92 14		sta ($14)			sta 	(temp3)
.11aa	a9 0d		lda #$0d			lda 	#13
.11ac	20 5c 11	jsr $115c			jsr 	ExternPrint
.11af	60		rts				rts
.11b0					ExternSave:
.11b0	da		phx				phx
.11b1	5a		phy				phy
.11b2	85 12		sta $12				sta 	temp2 						; save start
.11b4	84 13		sty $13				sty 	temp2+1
.11b6	20 18 12	jsr $1218			jsr 	EXGetLength 				; get length of file into A
.11b9	a6 14		ldx $14				ldx 	temp3
.11bb	a4 15		ldy $15				ldy 	temp3+1
.11bd	20 bd ff	jsr $ffbd			jsr 	$FFBD 						; set name
.11c0	a9 01		lda #$01			lda 	#1
.11c2	a2 08		ldx #$08			ldx 	#8	 						; device #8
.11c4	a0 00		ldy #$00			ldy 	#0
.11c6	20 ba ff	jsr $ffba			jsr 	$FFBA 						; set LFS
.11c9	a6 10		ldx $10				ldx 	temp1 						; end address
.11cb	a4 11		ldy $11				ldy 	temp1+1
.11cd	a9 12		lda #$12			lda 	#temp2
.11cf	20 d8 ff	jsr $ffd8			jsr 	$FFD8 						; save
.11d2	b0 03		bcs $11d7			bcs 	_ESSave
.11d4	7a		ply				ply
.11d5	fa		plx				plx
.11d6	60		rts				rts
.11d7					_ESSave:
.11d7	20 fc 10	jsr $10fc			jsr 	ErrorHandler
>11da	53 41 56 45 20 46 41 49				.text 	"SAVE FAILED",0
>11e2	4c 45 44 00
.11e6					ExternLoad:
.11e6	da		phx				phx 								; save XY
.11e7	5a		phy				phy
.11e8	48		pha				pha 								; save target
.11e9	5a		phy				phy
.11ea	20 18 12	jsr $1218			jsr 	EXGetLength 				; get length of file into A
.11ed	a6 14		ldx $14				ldx 	temp3
.11ef	a4 15		ldy $15				ldy 	temp3+1
.11f1	20 bd ff	jsr $ffbd			jsr 	$FFBD 						; set name
.11f4	a9 01		lda #$01			lda 	#1
.11f6	a2 08		ldx #$08			ldx 	#8	 						; device #8
.11f8	a0 00		ldy #$00			ldy 	#0
.11fa	20 ba ff	jsr $ffba			jsr 	$FFBA 						; set LFS
.11fd	7a		ply				ply 								; restore target to YX and call load
.11fe	fa		plx				plx
.11ff	a9 00		lda #$00			lda 	#0 							; load command
.1201	20 d5 ff	jsr $ffd5			jsr 	$FFD5
.1204	b0 03		bcs $1209			bcs 	_ESLoad
.1206	7a		ply				ply
.1207	fa		plx				plx
.1208	60		rts				rts
.1209					_ESLoad:
.1209	20 fc 10	jsr $10fc			jsr 	ErrorHandler
>120c	4c 4f 41 44 20 46 41 49				.text 	"LOAD FAILED",0
>1214	4c 45 44 00
.1218					EXGetLength:
.1218	5a		phy				phy
.1219	a0 ff		ldy #$ff			ldy 	#255
.121b	c8		iny		_EXGL0:	iny
.121c	b1 14		lda ($14),y			lda 	(temp3),y
.121e	d0 fb		bne $121b			bne 	_EXGL0
.1220	98		tya				tya
.1221	7a		ply				ply
.1222	60		rts				rts
.1223					EXPrintString:
.1223	48		pha				pha
.1224	5a		phy				phy
.1225	84 11		sty $11				sty 	temp1+1
.1227	85 10		sta $10				sta 	temp1
.1229	a0 00		ldy #$00			ldy 	#0
.122b					_EXPSLoop:
.122b	b1 10		lda ($10),y			lda 	(temp1),y
.122d	f0 08		beq $1237			beq 	_EXPSExit
.122f	29 7f		and #$7f			and 	#$7F
.1231	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.1234	c8		iny				iny
.1235	80 f4		bra $122b			bra 	_EXPSLoop
.1237					_EXPSExit:
.1237	7a		ply				ply
.1238	68		pla				pla
.1239	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/binary.src

.123a					Add:
.123a	7a		ply				ply
.123b	68		pla				pla
.123c	18		clc				clc
.123d	65 06		adc $06				adc 	TOS
.123f	85 06		sta $06				sta 	TOS
.1241	98		tya				tya
.1242	65 07		adc $07				adc 	TOS+1
.1244	85 07		sta $07				sta 	TOS+1
.1246	4c 00 00	jmp $0000			jmp 	NextCode
.1249					Subtract:
.1249	7a		ply				ply
.124a	68		pla				pla
.124b	38		sec				sec
.124c	e5 06		sbc $06				sbc 	TOS
.124e	85 06		sta $06				sta 	TOS
.1250	98		tya				tya
.1251	e5 07		sbc $07				sbc 	TOS+1
.1253	85 07		sta $07				sta 	TOS+1
.1255	4c 00 00	jmp $0000			jmp 	NextCode
.1258					And:
.1258	68		pla				pla
.1259	25 07		and $07				and 	TOS+1
.125b	85 07		sta $07				sta 	TOS+1
.125d	68		pla				pla
.125e	25 06		and $06				and 	TOS
.1260	85 06		sta $06				sta 	TOS
.1262	4c 00 00	jmp $0000			jmp 	NextCode
.1265					Xor:
.1265	68		pla				pla
.1266	45 07		eor $07				eor 	TOS+1
.1268	85 07		sta $07				sta 	TOS+1
.126a	68		pla				pla
.126b	45 06		eor $06				eor 	TOS
.126d	85 06		sta $06				sta 	TOS
.126f	4c 00 00	jmp $0000			jmp 	NextCode
.1272					LogOr:
.1272	68		pla				pla
.1273	05 07		ora $07				ora 	TOS+1
.1275	85 07		sta $07				sta 	TOS+1
.1277	68		pla				pla
.1278	05 06		ora $06				ora 	TOS
.127a	85 06		sta $06				sta 	TOS
.127c	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/compare.src

.127f					CheckNotEqual:
.127f	38		sec				sec
.1280	80 01		bra $1283			bra 	CECode
.1282					CheckEqual:
.1282	18		clc				clc
.1283					CECode:
.1283	86 10		stx $10				stx 	temp1
.1285	ba		tsx				tsx
.1286	08		php				php
.1287	a5 06		lda $06				lda 	TOS
.1289	5d 02 01	eor $0102,x			eor 	Stack2Low,x
.128c	d0 17		bne $12a5			bne	 	CompareFalse
.128e	a5 07		lda $07				lda 	TOS+1
.1290	5d 01 01	eor $0101,x			eor 	Stack2High,x
.1293	d0 10		bne $12a5			bne 	CompareFalse
.1295					CompareTrue:
.1295	a6 10		ldx $10				ldx 	temp1
.1297	28		plp				plp
.1298	b0 10		bcs $12aa			bcs		CompareFalse2
.129a					CompareTrue2:
.129a	68		pla				pla
.129b	68		pla				pla
.129c	a9 ff		lda #$ff			lda 	#$FF
.129e	85 06		sta $06				sta 	TOS
.12a0	85 07		sta $07				sta 	TOS+1
.12a2	4c 00 00	jmp $0000			jmp 	NextCode
.12a5					CompareFalse:
.12a5	a6 10		ldx $10				ldx 	temp1
.12a7	28		plp				plp
.12a8	b0 f0		bcs $129a			bcs		CompareTrue2
.12aa					CompareFalse2:
.12aa	68		pla				pla
.12ab	68		pla				pla
.12ac	64 06		stz $06				stz 	TOS
.12ae	64 07		stz $07				stz 	TOS+1
.12b0	4c 00 00	jmp $0000			jmp 	NextCode
.12b3					CheckGreaterEq:
.12b3	38		sec				sec
.12b4	80 01		bra $12b7			bra		CLCode
.12b6					CheckLess:
.12b6	18		clc				clc
.12b7	86 10		stx $10		CLCode:	stx 	temp1
.12b9	ba		tsx				tsx
.12ba	08		php				php
.12bb	18		clc				clc
.12bc	a5 06		lda $06				lda 	TOS
.12be	fd 02 01	sbc $0102,x			sbc 	Stack2Low,x
.12c1	a5 07		lda $07				lda 	TOS+1
.12c3	fd 01 01	sbc $0101,x			sbc 	Stack2High,x
.12c6	50 02		bvc $12ca			bvc 	_CLNoFlip
.12c8	49 80		eor #$80			eor 	#$80
.12ca					_CLNoFlip:
.12ca	0a		asl a				asl 	a
.12cb	b0 d8		bcs $12a5			bcs 	CompareFalse
.12cd	80 c6		bra $1295			bra 	CompareTrue
.12cf					CheckLessEq:
.12cf	38		sec				sec
.12d0	80 01		bra $12d3			bra		CGCode
.12d2					CheckGreater:
.12d2	18		clc				clc
.12d3					CGCode:
.12d3	86 10		stx $10				stx 	temp1
.12d5	ba		tsx				tsx
.12d6	08		php				php
.12d7	18		clc				clc
.12d8	bd 02 01	lda $0102,x			lda 	Stack2Low,x
.12db	e5 06		sbc $06				sbc 	TOS
.12dd	bd 01 01	lda $0101,x			lda 	Stack2High,x
.12e0	e5 07		sbc $07				sbc 	TOS+1
.12e2	50 02		bvc $12e6			bvc 	_CGNoFlip
.12e4	49 80		eor #$80			eor 	#$80
.12e6					_CGNoFlip:
.12e6	0a		asl a				asl 	a
.12e7	b0 bc		bcs $12a5			bcs 	CompareFalse
.12e9	80 aa		bra $1295			bra 	CompareTrue
.12eb					Minimum:
.12eb	a9 00		lda #$00			lda 	#0
.12ed	80 02		bra $12f1			bra 	MinMaxCode
.12ef					Maximum:
.12ef	a9 80		lda #$80			lda 	#$80
.12f1					MinMaxCode:
.12f1	85 11		sta $11				sta 	temp1+1
.12f3	86 10		stx $10				stx 	temp1
.12f5	ba		tsx				tsx
.12f6	38		sec				sec
.12f7	a5 06		lda $06				lda 	TOS
.12f9	fd 02 01	sbc $0102,x			sbc 	Stack2Low,x
.12fc	a5 07		lda $07				lda 	TOS+1
.12fe	fd 01 01	sbc $0101,x			sbc 	Stack2High,x
.1301	50 02		bvc $1305			bvc 	_MMNoFlip
.1303	49 80		eor #$80			eor 	#$80
.1305					_MMNoFlip:
.1305	45 11		eor $11				eor 	temp1+1
.1307	30 0a		bmi $1313			bmi 	_MMNoCopy
.1309	bd 02 01	lda $0102,x			lda 	Stack2Low,x
.130c	85 06		sta $06				sta 	TOS
.130e	bd 01 01	lda $0101,x			lda 	Stack2High,x
.1311	85 07		sta $07				sta 	TOS+1
.1313					_MMNoCopy:
.1313	a6 10		ldx $10				ldx 	temp1
.1315	68		pla				pla
.1316	68		pla				pla
.1317	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/divide.src

.131a					Divide16x16:
.131a	86 12		stx $12				stx 	temp2
.131c	ba		tsx				tsx
.131d	20 40 13	jsr $1340			jsr 	IntegerDivide
.1320	68		pla				pla
.1321	85 07		sta $07				sta 	TOS+1
.1323	68		pla				pla
.1324	85 06		sta $06				sta 	TOS
.1326	a6 12		ldx $12				ldx 	temp2
.1328	4c 00 00	jmp $0000			jmp 	NextCode
.132b					Modulus16x16:
.132b	86 12		stx $12				stx 	temp2
.132d	ba		tsx				tsx
.132e	20 40 13	jsr $1340			jsr 	IntegerDivide
.1331	a6 12		ldx $12				ldx 	temp2
.1333	68		pla				pla
.1334	68		pla				pla
.1335	a5 10		lda $10				lda 	temp1
.1337	85 06		sta $06				sta 	TOS
.1339	a5 11		lda $11				lda 	temp1+1
.133b	85 07		sta $07				sta 	TOS+1
.133d	4c 00 00	jmp $0000			jmp 	NextCode
.1340					IntegerDivide:
.1340	a5 06		lda $06				lda 	TOS 				; check for division by zero.
.1342	05 07		ora $07				ora 	TOS+1
.1344	d0 14		bne $135a			bne 	_BFDOkay
.1346	20 fc 10	jsr $10fc			jsr 	ErrorHandler
>1349	44 49 56 49 53 49 4f 4e				.text 	"DIVISION BY ZERO",0
>1351	20 42 59 20 5a 45 52 4f 00
.135a					_BFDOkay:
.135a	64 10		stz $10				stz 	temp1 						; Q/Dividend/Left in +0
.135c	64 11		stz $11				stz 	temp1+1 					; M/Divisor/Right in +2
.135e	64 1a		stz $1a				stz 	SignCount 					; Count of signs.
.1360	20 9b 13	jsr $139b			jsr 	CheckIntegerNegate 			; negate 2nd (and bump sign count)
.1363	20 b5 13	jsr $13b5			jsr 	CheckTOSNegate 				; negate TOS (and bump sign count)
.1366	5a		phy				phy 								; Y is the counter
.1367	a0 10		ldy #$10			ldy 	#16 						; 16 iterations of the loop.
.1369					_BFDLoop:
.1369	1e 02 01	asl $0102,x			asl 	Stack2Low,x 				; shift AQ left.
.136c	3e 01 01	rol $0101,x			rol 	Stack2High,x
.136f	26 10		rol $10				rol 	temp1
.1371	26 11		rol $11				rol 	temp1+1
.1373	38		sec				sec
.1374	a5 10		lda $10				lda 	temp1+0 					; Calculate A-M on stack.
.1376	e5 06		sbc $06				sbc 	TOS
.1378	48		pha				pha
.1379	a5 11		lda $11				lda 	temp1+1
.137b	e5 07		sbc $07				sbc 	TOS+1
.137d	90 0f		bcc $138e			bcc 	_BFDNoAdd
.137f	85 11		sta $11				sta 	temp1+1
.1381	68		pla				pla
.1382	85 10		sta $10				sta 	temp1+0
.1384	bd 02 01	lda $0102,x			lda 	Stack2Low,x 				; set Q bit 1.
.1387	09 01		ora #$01			ora 	#1
.1389	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.138c	80 01		bra $138f			bra 	_BFDNext
.138e					_BFDNoAdd:
.138e	68		pla				pla 								; Throw away the intermediate calculations
.138f					_BFDNext:
.138f	88		dey				dey
.1390	d0 d7		bne $1369			bne 	_BFDLoop
.1392	7a		ply				ply 								; restore Y
.1393	46 1a		lsr $1a				lsr 	SignCount 					; if sign count odd,
.1395	90 03		bcc $139a			bcc 	_BFDUnsigned 				; then the result is signed
.1397	20 a1 13	jsr $13a1			jsr		IntegerNegateAlways 		; negate the result
.139a					_BFDUnsigned:
.139a	60		rts				rts
.139b					CheckIntegerNegate:
.139b	bd 01 01	lda $0101,x			lda 	Stack2High,x 				; is it -ve = MSB set ?
.139e	30 01		bmi $13a1			bmi 	IntegerNegateAlways 		; if so negate it
.13a0	60		rts				rts
.13a1					IntegerNegateAlways:
.13a1	e6 1a		inc $1a				inc 	SignCount 					; bump the count of signs
.13a3	38		sec				sec 								; negate
.13a4	a9 00		lda #$00			lda 	#0
.13a6	fd 02 01	sbc $0102,x			sbc 	Stack2Low,x
.13a9	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.13ac	a9 00		lda #$00			lda 	#0
.13ae	fd 01 01	sbc $0101,x			sbc 	Stack2High,x
.13b1	9d 01 01	sta $0101,x			sta 	Stack2High,x
.13b4	60		rts				rts
.13b5					CheckTOSNegate:
.13b5	a5 07		lda $07				lda 	TOS+1
.13b7	10 0f		bpl $13c8			bpl		CTNNoChange
.13b9	e6 1a		inc $1a				inc 	SignCount
.13bb					TOSNegateAlways:
.13bb	38		sec				sec
.13bc	a9 00		lda #$00			lda 	#0
.13be	e5 06		sbc $06				sbc 	TOS
.13c0	85 06		sta $06				sta 	TOS
.13c2	a9 00		lda #$00			lda 	#0
.13c4	e5 07		sbc $07				sbc 	TOS+1
.13c6	85 07		sta $07				sta 	TOS+1
.13c8					CTNNoChange:
.13c8	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/multiply.src

.13c9					Multiply16x16:
.13c9	86 10		stx $10				stx 	temp1
.13cb	ba		tsx				tsx
.13cc	bd 02 01	lda $0102,x			lda 	Stack2Low,x 				; 2nd value on stack to temp1
.13cf	85 12		sta $12				sta 	temp2
.13d1	bd 01 01	lda $0101,x			lda		Stack2High,x
.13d4	85 13		sta $13				sta 	temp2+1
.13d6	9e 02 01	stz $0102,x			stz 	Stack2Low,x 				; zero 2nd value on stack
.13d9	9e 01 01	stz $0101,x			stz 	Stack2High,x
.13dc					_MultLoop:
.13dc	46 13		lsr $13				lsr 	temp2+1 					; ror temp2 into C
.13de	66 12		ror $12				ror 	temp2
.13e0	90 11		bcc $13f3			bcc 	_MultNoAdd
.13e2	18		clc				clc 								; add 1st to 2nd
.13e3	a5 06		lda $06				lda 	TOS
.13e5	7d 02 01	adc $0102,x			adc 	Stack2Low,x
.13e8	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.13eb	a5 07		lda $07				lda 	TOS+1
.13ed	7d 01 01	adc $0101,x			adc 	Stack2High,x
.13f0	9d 01 01	sta $0101,x			sta 	Stack2High,x
.13f3					_MultNoAdd:
.13f3	06 06		asl $06				asl 	TOS 						; shift 1st left
.13f5	26 07		rol $07				rol 	TOS+1
.13f7	a5 12		lda $12				lda 	temp2	 					; until zero
.13f9	05 13		ora $13				ora 	temp2+1
.13fb	d0 df		bne $13dc			bne 	_MultLoop
.13fd	a6 10		ldx $10				ldx 	temp1 						; restore X load result
.13ff	68		pla				pla
.1400	85 07		sta $07				sta 	TOS+1
.1402	68		pla				pla
.1403	85 06		sta $06				sta 	TOS
.1405	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/unary.src

.1408					Unary1Plus:
.1408	e6 06		inc $06				inc 	TOS
.140a	d0 02		bne $140e			bne 	_U1PSkip
.140c	e6 07		inc $07				inc 	TOS+1
.140e					_U1PSkip:
.140e	4c 00 00	jmp $0000			jmp 	NextCode
.1411					Unary2Plus:
.1411	18		clc				clc
.1412	a5 06		lda $06				lda 	TOS
.1414	69 02		adc #$02			adc 	#2
.1416	85 06		sta $06				sta 	TOS
.1418	90 02		bcc $141c			bcc 	_U1PSkip
.141a	e6 07		inc $07				inc 	TOS+1
.141c					_U1PSkip:
.141c	4c 00 00	jmp $0000			jmp 	NextCode
.141f					Unary1Minus:
.141f	a5 06		lda $06				lda 	TOS
.1421	d0 02		bne $1425			bne 	_U1MSkip
.1423	c6 07		dec $07				dec 	TOS+1
.1425					_U1MSkip:
.1425	c6 06		dec $06				dec 	TOS
.1427	4c 00 00	jmp $0000			jmp 	NextCode
.142a					Unary2Minus:
.142a	38		sec				sec
.142b	a5 06		lda $06				lda 	TOS
.142d	e9 02		sbc #$02			sbc 	#2
.142f	85 06		sta $06				sta 	TOS
.1431	b0 02		bcs $1435			bcs 	_U1PSkip
.1433	c6 07		dec $07				dec 	TOS+1
.1435					_U1PSkip:
.1435	4c 00 00	jmp $0000			jmp 	NextCode
.1438					Absolute:
.1438	a5 07		lda $07				lda 	TOS+1
.143a	30 03		bmi $143f			bmi 	Negate
.143c	4c 00 00	jmp $0000			jmp 	NextCode
.143f					Negate:
.143f	38		sec				sec
.1440	a9 00		lda #$00			lda 	#0
.1442	e5 06		sbc $06				sbc 	TOS
.1444	85 06		sta $06				sta 	TOS
.1446	a9 00		lda #$00			lda 	#0
.1448	e5 07		sbc $07				sbc 	TOS+1
.144a	85 07		sta $07				sta 	TOS+1
.144c	4c 00 00	jmp $0000			jmp 	NextCode
.144f					OneComplement:
.144f	a5 06		lda $06				lda 	TOS
.1451	49 ff		eor #$ff			eor 	#$FF
.1453	85 06		sta $06				sta 	TOS
.1455	a5 07		lda $07				lda 	TOS+1
.1457	49 ff		eor #$ff			eor 	#$FF
.1459	85 07		sta $07				sta 	TOS+1
.145b	4c 00 00	jmp $0000			jmp 	NextCode
.145e					CheckMinus:
.145e	a5 07		lda $07				lda 	TOS+1
.1460	30 07		bmi $1469			bmi 	UnaryTrue
.1462					UnaryFalse:
.1462	64 06		stz $06				stz 	TOS
.1464	64 07		stz $07				stz 	TOS+1
.1466	4c 00 00	jmp $0000			jmp 	NextCode
.1469					UnaryTrue:
.1469	a9 ff		lda #$ff			lda 	#$FF
.146b	85 06		sta $06				sta 	TOS
.146d	85 07		sta $07				sta 	TOS+1
.146f	4c 00 00	jmp $0000			jmp 	NextCode
.1472					CheckZero:
.1472	a5 06		lda $06				lda 	TOS
.1474	05 07		ora $07				ora 	TOS+1
.1476	d0 ea		bne $1462			bne 	UnaryFalse
.1478	80 ef		bra $1469			bra 	UnaryTrue
.147a					SignTOS:
.147a	a5 07		lda $07				lda 	TOS+1
.147c	30 eb		bmi $1469			bmi		UnaryTrue
.147e	05 06		ora $06				ora 	TOS
.1480	f0 e0		beq $1462			beq 	UnaryFalse
.1482	a9 01		lda #$01			lda 	#1
.1484	85 06		sta $06				sta 	TOS
.1486	64 07		stz $07				stz		TOS+1
.1488	4c 00 00	jmp $0000			jmp 	NextCode
.148b					ByteSwap:
.148b	a5 06		lda $06				lda 	TOS
.148d	a4 07		ldy $07				ldy 	TOS+1
.148f	85 07		sta $07				sta 	TOS+1
.1491	84 06		sty $06				sty 	TOS
.1493	4c 00 00	jmp $0000			jmp 	NextCode
.1496					Times16:
.1496	06 06		asl $06				asl 	TOS
.1498	26 07		rol $07				rol 	TOS+1
.149a					Times8:
.149a	06 06		asl $06				asl 	TOS
.149c	26 07		rol $07				rol 	TOS+1
.149e					Times4:
.149e	06 06		asl $06				asl 	TOS
.14a0	26 07		rol $07				rol 	TOS+1
.14a2					Times2:
.14a2	06 06		asl $06				asl 	TOS
.14a4	26 07		rol $07				rol 	TOS+1
.14a6	4c 00 00	jmp $0000			jmp 	NextCode
.14a9					Divide16:
.14a9	46 07		lsr $07				lsr 	TOS+1
.14ab	66 06		ror $06				ror 	TOS
.14ad					Divide8:
.14ad	46 07		lsr $07				lsr 	TOS+1
.14af	66 06		ror $06				ror 	TOS
.14b1					Divide4:
.14b1	46 07		lsr $07				lsr 	TOS+1
.14b3	66 06		ror $06				ror 	TOS
.14b5					Divide2:
.14b5	46 07		lsr $07				lsr 	TOS+1
.14b7	66 06		ror $06				ror 	TOS
.14b9	4c 00 00	jmp $0000			jmp 	NextCode
.14bc					Times256:
.14bc	a5 06		lda $06				lda 	TOS
.14be	85 07		sta $07				sta 	TOS+1
.14c0	64 06		stz $06				stz 	TOS
.14c2	4c 00 00	jmp $0000			jmp 	NextCode
.14c5					Divide256:
.14c5	a5 07		lda $07				lda 	TOS+1
.14c7	85 06		sta $06				sta 	TOS
.14c9	64 07		stz $07				stz 	TOS+1
.14cb	4c 00 00	jmp $0000			jmp 	NextCode
.14ce					RandomNumber:
.14ce	a5 06		lda $06				lda 	TOS
.14d0	48		pha				pha
.14d1	a5 07		lda $07				lda 	TOS+1
.14d3	48		pha				pha
.14d4	a5 1b		lda $1b				lda 	randomSeed
.14d6	05 1c		ora $1c				ora 	randomSeed+1
.14d8	d0 08		bne $14e2			bne 	_RH_NoInit
.14da	a9 7c		lda #$7c			lda 	#$7C
.14dc	85 1b		sta $1b				sta 	randomSeed
.14de	a9 a1		lda #$a1			lda 	#$A1
.14e0	85 1c		sta $1c				sta 	randomSeed+1
.14e2					_RH_NoInit:
.14e2	a5 1b		lda $1b				lda 	randomSeed
.14e4	4a		lsr a		        lsr		a
.14e5	26 1c		rol $1c		        rol 	randomSeed+1
.14e7	90 02		bcc $14eb	        bcc 	_RH_NoEor
.14e9	49 b4		eor #$b4	        eor 	#$B4
.14eb					_RH_NoEor:
.14eb	85 1b		sta $1b		        sta 	randomSeed
.14ed	45 1c		eor $1c		        eor 	randomSeed+1
.14ef	85 07		sta $07		        sta 	TOS+1
.14f1	a5 1b		lda $1b		        lda 	randomSeed
.14f3	85 06		sta $06		        sta 	TOS
.14f5	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/data/literals.src

.14f8					Constant0:
.14f8	a5 06		lda $06				lda 	TOS
.14fa	48		pha				pha
.14fb	a5 07		lda $07				lda 	TOS+1
.14fd	48		pha				pha
.14fe	64 06		stz $06				stz 	TOS
.1500	64 07		stz $07				stz 	TOS+1
.1502	4c 00 00	jmp $0000			jmp 	NextCode
.1505					ConstantMinus1:
.1505	a5 06		lda $06				lda 	TOS
.1507	48		pha				pha
.1508	a5 07		lda $07				lda 	TOS+1
.150a	48		pha				pha
.150b	a9 ff		lda #$ff			lda 	#$FF
.150d	85 06		sta $06				sta 	TOS
.150f	85 07		sta $07				sta 	TOS+1
.1511	4c 00 00	jmp $0000			jmp 	NextCode
.1514					C1:
.1514	a0 01		ldy #$01			ldy 	#1
.1516	80 24		bra $153c			bra 	Const1Byte
.1518					C2:
.1518	a0 02		ldy #$02			ldy 	#2
.151a	80 20		bra $153c			bra 	Const1Byte
.151c					C3:
.151c	a0 03		ldy #$03			ldy 	#3
.151e	80 1c		bra $153c			bra 	Const1Byte
.1520					C4:
.1520	a0 04		ldy #$04			ldy 	#4
.1522	80 18		bra $153c			bra 	Const1Byte
.1524					C5:
.1524	a0 05		ldy #$05			ldy 	#5
.1526	80 14		bra $153c			bra 	Const1Byte
.1528					C8:
.1528	a0 08		ldy #$08			ldy 	#8
.152a	80 10		bra $153c			bra 	Const1Byte
.152c					C10:
.152c	a0 0a		ldy #$0a			ldy 	#10
.152e	80 0c		bra $153c			bra 	Const1Byte
.1530					C15:
.1530	a0 0f		ldy #$0f			ldy 	#15
.1532	80 08		bra $153c			bra 	Const1Byte
.1534					C16:
.1534	a0 10		ldy #$10			ldy 	#16
.1536	80 04		bra $153c			bra 	Const1Byte
.1538					C24:
.1538	a0 18		ldy #$18			ldy 	#24
.153a	80 00		bra $153c			bra 	Const1Byte
.153c					Const1Byte:
.153c	a5 06		lda $06				lda 	TOS
.153e	48		pha				pha
.153f	a5 07		lda $07				lda 	TOS+1
.1541	48		pha				pha
.1542	84 06		sty $06				sty 	TOS
.1544	64 07		stz $07				stz 	TOS+1
.1546	4c 00 00	jmp $0000			jmp 	NextCode
.1549					C32:
.1549	a0 20		ldy #$20			ldy 	#32
.154b	80 ef		bra $153c			bra 	Const1Byte
.154d					C63:
.154d	a0 3f		ldy #$3f			ldy 	#63
.154f	80 eb		bra $153c			bra 	Const1Byte
.1551					C64:
.1551	a0 40		ldy #$40			ldy 	#64
.1553	80 e7		bra $153c			bra 	Const1Byte
.1555					C100:
.1555	a0 64		ldy #$64			ldy 	#100
.1557	80 e3		bra $153c			bra 	Const1Byte
.1559					C127:
.1559	a0 7f		ldy #$7f			ldy 	#127
.155b	80 df		bra $153c			bra 	Const1Byte
.155d					C128:
.155d	a0 80		ldy #$80			ldy 	#128
.155f	80 db		bra $153c			bra 	Const1Byte
.1561					C255:
.1561	a0 ff		ldy #$ff			ldy 	#255
.1563	80 d7		bra $153c			bra 	Const1Byte
.1565					Const2Byte:
.1565	85 06		sta $06				sta 	TOS
.1567	84 07		sty $07				sty 	TOS+1
.1569	4c 00 00	jmp $0000			jmp 	NextCode
.156c					C256:
.156c	a5 06		lda $06				lda 	TOS
.156e	48		pha				pha
.156f	a5 07		lda $07				lda 	TOS+1
.1571	48		pha				pha
.1572	a9 00		lda #$00			lda 	#(256) & $FF
.1574	a0 01		ldy #$01			ldy 	#(256) >> 8
.1576	80 ed		bra $1565			bra 	Const2Byte
.1578					C512:
.1578	a5 06		lda $06				lda 	TOS
.157a	48		pha				pha
.157b	a5 07		lda $07				lda 	TOS+1
.157d	48		pha				pha
.157e	a9 00		lda #$00			lda 	#(512) & $FF
.1580	a0 02		ldy #$02			ldy 	#(512) >> 8
.1582	80 e1		bra $1565			bra 	Const2Byte
.1584					C1024:
.1584	a5 06		lda $06				lda 	TOS
.1586	48		pha				pha
.1587	a5 07		lda $07				lda 	TOS+1
.1589	48		pha				pha
.158a	a9 00		lda #$00			lda 	#(1024) & $FF
.158c	a0 04		ldy #$04			ldy 	#(1024) >> 8
.158e	80 d5		bra $1565			bra 	Const2Byte
.1590					C4096:
.1590	a5 06		lda $06				lda 	TOS
.1592	48		pha				pha
.1593	a5 07		lda $07				lda 	TOS+1
.1595	48		pha				pha
.1596	a9 00		lda #$00			lda 	#(4096) & $FF
.1598	a0 10		ldy #$10			ldy 	#(4096) >> 8
.159a	80 c9		bra $1565			bra 	Const2Byte
.159c					C32767:
.159c	a5 06		lda $06				lda 	TOS
.159e	48		pha				pha
.159f	a5 07		lda $07				lda 	TOS+1
.15a1	48		pha				pha
.15a2	a9 ff		lda #$ff			lda 	#(32767) & $FF
.15a4	a0 7f		ldy #$7f			ldy 	#(32767) >> 8
.15a6	80 bd		bra $1565			bra 	Const2Byte
.15a8					C32768:
.15a8	a5 06		lda $06				lda 	TOS
.15aa	48		pha				pha
.15ab	a5 07		lda $07				lda 	TOS+1
.15ad	48		pha				pha
.15ae	a9 00		lda #$00			lda 	#(32768) & $FF
.15b0	a0 80		ldy #$80			ldy 	#(32768) >> 8
.15b2	80 b1		bra $1565			bra 	Const2Byte

;******  Return to file: kernel.asm


;******  Processing file: words/data/stack.src

.15b4					Drop:
.15b4	68		pla				pla
.15b5	85 07		sta $07				sta 	TOS+1
.15b7	68		pla				pla
.15b8	85 06		sta $06				sta 	TOS
.15ba	4c 00 00	jmp $0000			jmp 	NextCode
.15bd					TestDup:
.15bd	a5 06		lda $06				lda 	TOS
.15bf	05 07		ora $07				ora 	TOS+1
.15c1	d0 03		bne $15c6			bne 	Dup
.15c3	4c 00 00	jmp $0000			jmp 	NextCode
.15c6					Dup:
.15c6	a5 06		lda $06				lda 	TOS
.15c8	48		pha				pha
.15c9	a5 07		lda $07				lda 	TOS+1
.15cb	48		pha				pha
.15cc	4c 00 00	jmp $0000			jmp 	NextCode
.15cf					Swap:
.15cf	86 10		stx $10				stx 	temp1
.15d1	7a		ply				ply
.15d2	fa		plx				plx
.15d3	a5 06		lda $06				lda 	TOS
.15d5	48		pha				pha
.15d6	a5 07		lda $07				lda 	TOS+1
.15d8	48		pha				pha
.15d9	86 06		stx $06				stx 	TOS
.15db	84 07		sty $07				sty 	TOS+1
.15dd	a6 10		ldx $10				ldx 	temp1
.15df	4c 00 00	jmp $0000			jmp 	NextCode
.15e2					Over:
.15e2	a5 06		lda $06				lda 	TOS
.15e4	48		pha				pha
.15e5	a5 07		lda $07				lda 	TOS+1
.15e7	48		pha				pha
.15e8	86 10		stx $10				stx 	temp1
.15ea	ba		tsx				tsx
.15eb	bd 04 01	lda $0104,x			lda 	stack3low,x
.15ee	85 06		sta $06				sta 	TOS
.15f0	bd 03 01	lda $0103,x			lda 	stack3High,x
.15f3	85 07		sta $07				sta 	TOS+1
.15f5	a6 10		ldx $10				ldx 	temp1
.15f7	4c 00 00	jmp $0000			jmp 	NextCode
.15fa					Nip:
.15fa	68		pla				pla
.15fb	68		pla				pla
.15fc	4c 00 00	jmp $0000			jmp 	NextCode
.15ff					Rot:
.15ff	86 10		stx $10				stx 	temp1
.1601	ba		tsx				tsx
.1602	bd 04 01	lda $0104,x			lda 	Stack3Low,x
.1605	a8		tay				tay
.1606	bd 02 01	lda $0102,x			lda 	Stack2Low,x
.1609	9d 04 01	sta $0104,x			sta 	Stack3Low,x
.160c	a5 06		lda $06				lda 	TOS
.160e	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.1611	84 06		sty $06				sty 	TOS
.1613	bd 03 01	lda $0103,x			lda 	Stack3High,x
.1616	a8		tay				tay
.1617	bd 01 01	lda $0101,x			lda 	Stack2High,x
.161a	9d 03 01	sta $0103,x			sta 	Stack3High,x
.161d	a5 07		lda $07				lda 	TOS+1
.161f	9d 01 01	sta $0101,x			sta 	Stack2High,x
.1622	84 07		sty $07				sty 	TOS+1
.1624	a6 10		ldx $10				ldx 	temp1
.1626	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/data/memory.src

.1629					ByteRead:
.1629	b2 06		lda ($06)			lda 	(TOS)
.162b	85 06		sta $06				sta 	TOS
.162d	64 07		stz $07				stz 	TOS+1
.162f	4c 00 00	jmp $0000			jmp 	NextCode
.1632					WordRead:
.1632	a0 01		ldy #$01			ldy 	#1
.1634	b1 06		lda ($06),y			lda 	(TOS),y
.1636	a8		tay				tay
.1637	b2 06		lda ($06)			lda 	(TOS)
.1639	85 06		sta $06				sta 	TOS
.163b	84 07		sty $07				sty 	TOS+1
.163d	4c 00 00	jmp $0000			jmp 	NextCode
.1640					ByteWrite:
.1640	68		pla				pla
.1641	68		pla				pla
.1642	92 06		sta ($06)			sta 	(TOS)
.1644	68		pla				pla
.1645	85 07		sta $07				sta 	TOS+1
.1647	68		pla				pla
.1648	85 06		sta $06				sta 	TOS
.164a	4c 00 00	jmp $0000			jmp 	NextCode
.164d					WordWrite:
.164d	68		pla				pla
.164e	a0 01		ldy #$01			ldy 	#1
.1650	91 06		sta ($06),y			sta 	(TOS),y
.1652	68		pla				pla
.1653	92 06		sta ($06)			sta 	(TOS)
.1655	68		pla				pla
.1656	85 07		sta $07				sta 	TOS+1
.1658	68		pla				pla
.1659	85 06		sta $06				sta 	TOS
.165b	4c 00 00	jmp $0000			jmp 	NextCode
.165e					WordAdd:
.165e	7a		ply				ply
.165f	68		pla				pla
.1660	18		clc				clc
.1661	72 06		adc ($06)			adc 	(TOS)
.1663	92 06		sta ($06)			sta 	(TOS)
.1665	98		tya				tya
.1666	a0 01		ldy #$01			ldy 	#1
.1668	71 06		adc ($06),y			adc 	(TOS),y
.166a	91 06		sta ($06),y			sta 	(TOS),y
.166c	68		pla				pla
.166d	85 07		sta $07				sta 	TOS+1
.166f	68		pla				pla
.1670	85 06		sta $06				sta 	TOS
.1672	4c 00 00	jmp $0000			jmp 	NextCode
.1675					AllocateMemory:
.1675	a5 06		lda $06				lda 	TOS 						; save memory required on stack.
.1677	48		pha				pha
.1678	a5 07		lda $07				lda 	TOS+1
.167a	48		pha				pha
.167b	a5 0e		lda $0e				lda 	nextFreeMem 				; copy free mem address to TOS
.167d	85 06		sta $06				sta 	TOS
.167f	a5 0f		lda $0f				lda 	nextFreeMem+1
.1681	85 07		sta $07				sta 	TOS+1
.1683	7a		ply				ply 								; advance the free ram pointer
.1684	68		pla				pla
.1685	20 8e 1d	jsr $1d8e			jsr 	AdvanceFreeMem
.1688	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/encode/encode.src

.168b					EncodeProgram:
.168b	48		pha				pha 								; save registers.
.168c	da		phx				phx
.168d	5a		phy				phy
.168e	84 09		sty $09				sty 	srcPtr+1					; save source pointer.
.1690	85 08		sta $08				sta		srcPtr
>1692	ff						.byte 	$FF
.1693	64 05		stz $05				stz 	rsp
.1695	a6 05		ldx $05				ldx 	rsp 						; this is the current stack entry type, so $00 means
.1697	9e 40 07	stz $0740,x			stz 	returnStackHigh,x 			; an initial "until" will fail as it's looking for "R" here (repeat)
.169a	20 0c 19	jsr $190c			jsr 	EncodeTrimTrailingSpaces 	; remove trailing spaces.
.169d	a9 03		lda #$03			lda 	#3 							; reset the encode Buffer
.169f	8d 10 09	sta $0910			sta 	encodeBuffer 				; this is also the write ptr/offset
.16a2	9c 11 09	stz $0911			stz 	encodeBuffer+1 				; the line number
.16a5	9c 12 09	stz $0912			stz 	encodeBuffer+2 				; which is initially zero.
.16a8	b2 08		lda ($08)			lda 	(srcPtr) 					; check if first character is digit
.16aa	20 b7 18	jsr $18b7			jsr 	CheckIsDigit
.16ad	90 09		bcc $16b8			bcc 	_EPNoLineNumber 			; if so there is a line number
.16af	20 d9 18	jsr $18d9			jsr 	EncodeGetConstant 			; extract that constant from the source
.16b2	8d 11 09	sta $0911			sta 	encodeBuffer+1 				; that is the line number
.16b5	8c 12 09	sty $0912			sty 	encodeBuffer+2
.16b8					_EPNoLineNumber:
.16b8					EncodeLoop:
.16b8	20 fe 18	jsr $18fe			jsr 	EncSkipSpaces 				; skip over spaces
.16bb	b2 08		lda ($08)			lda 	(srcPtr) 					; reached end ?
.16bd	d0 21		bne $16e0			bne 	_EPNotEnd
.16bf					_EPEndEncode:
.16bf	a9 a7		lda #$a7			lda 	#NextLine & $FF 			; compile $$nextline to mark eol
.16c1	a0 21		ldy #$21			ldy 	#NextLine >> 8
.16c3	20 8f 18	jsr $188f			jsr 	EncodeWriteWord
.16c6	a5 05		lda $05				lda 	rsp 						; is the return stack empty ?
.16c8	d0 04		bne $16ce			bne 	_EPIncomplete
.16ca	7a		ply				ply									; restore and exit.
.16cb	fa		plx				plx
.16cc	68		pla				pla
.16cd	60		rts				rts
.16ce					_EPIncomplete:
.16ce	20 fc 10	jsr $10fc			jsr 	ErrorHandler
>16d1	53 54 52 55 43 54 55 52				.text 	"STRUCTURE OPEN",0
>16d9	45 20 4f 50 45 4e 00
.16e0					_EPNotEnd:
.16e0	b2 08		lda ($08)			lda 	(srcPtr)
.16e2	c9 22		cmp #$22			cmp 	#'"'						; is it a quoted string or comment ?
.16e4	f0 04		beq $16ea			beq 	_EPIsComStr
.16e6	c9 27		cmp #$27			cmp 	#"'"
.16e8	d0 05		bne $16ef			bne 	_EPNotComStr
.16ea					_EPIsComStr:
.16ea	20 dc 17	jsr $17dc			jsr 	EncodeCommentString
.16ed	80 c9		bra $16b8			bra 	EncodeLoop
.16ef					_EPNotComStr:
.16ef	38		sec				sec
.16f0	20 eb 18	jsr $18eb			jsr 	EncSetBit7Word
.16f3	20 33 19	jsr $1933			jsr 	EncodeSearchDictionary		; look it up
.16f6	90 45		bcc $173d			bcc 	_EPNotInDictionary
.16f8	85 10		sta $10				sta 	temp1 						; save dictionary record address
.16fa	84 11		sty $11				sty 	temp1+1
.16fc	a0 01		ldy #$01			ldy 	#1
.16fe	b1 10		lda ($10),y			lda 	(temp1),y 					; check if has an encode bit
.1700	29 20		and #$20			and 	#$20
.1702	d0 12		bne $1716			bne 	_EPEncodeRoutine 			; if so, do special routine.
.1704	a0 02		ldy #$02			ldy 	#2 							; write out the routine address
.1706	b1 10		lda ($10),y			lda 	(temp1),y
.1708	20 99 18	jsr $1899			jsr 	EncodeWriteByte
.170b	c8		iny				iny
.170c	b1 10		lda ($10),y			lda 	(temp1),y
.170e	20 99 18	jsr $1899			jsr 	EncodeWriteByte
.1711	20 c3 18	jsr $18c3			jsr 	EncodeMoveNextWord 			; advance to the next and loop
.1714	80 a2		bra $16b8			bra 	EncodeLoop
.1716					_EPEncodeRoutine:
.1716	a0 01		ldy #$01			ldy 	#1							; get type bit
.1718	b1 10		lda ($10),y			lda 	(temp1),y
.171a	a0 04		ldy #$04			ldy 	#4							; encoder here if no decoder
.171c	29 10		and #$10			and 	#$10 						; but decoder comes first
.171e	f0 02		beq $1722			beq 	_EPENoDecoder
.1720	c8		iny				iny 								; so if it exists, adjust for it.
.1721	c8		iny				iny
.1722					_EPENoDecoder:
.1722	b1 10		lda ($10),y			lda 	(temp1),y 					; copy exec addr to temp2
.1724	85 12		sta $12				sta 	temp2
.1726	c8		iny				iny
.1727	b1 10		lda ($10),y			lda 	(temp1),y
.1729	85 13		sta $13				sta 	temp2+1
.172b	48		pha				pha 								; call routine preserving state
.172c	da		phx				phx
.172d	5a		phy				phy
.172e	20 3a 17	jsr $173a			jsr 	_EPECallTemp2
.1731	7a		ply				ply
.1732	fa		plx				plx
.1733	68		pla				pla
.1734	20 c3 18	jsr $18c3			jsr 	EncodeMoveNextWord 			; advance to the next and loop
.1737	4c b8 16	jmp $16b8			jmp 	EncodeLoop
.173a					_EPECallTemp2:
.173a	6c 12 00	jmp ($0012)			jmp 	(temp2)
.173d					_EPNotInDictionary:
.173d	20 41 18	jsr $1841			jsr 	EncodeSearchUserDefined 	; are there any user defined routines
.1740	90 19		bcc $175b			bcc 	_EPNotDefined
.1742	48		pha				pha
.1743	a9 f3		lda #$f3			lda	 	#CallHandler & $FF 			; write code call handler
.1745	20 99 18	jsr $1899			jsr 	EncodeWriteByte
.1748	a9 1b		lda #$1b			lda	 	#CallHandler >> 8
.174a	20 99 18	jsr $1899			jsr 	EncodeWriteByte
.174d	68		pla				pla 								; write line number
.174e	20 99 18	jsr $1899			jsr 	EncodeWriteByte
.1751	98		tya				tya
.1752	20 99 18	jsr $1899			jsr 	EncodeWriteByte
.1755	20 c3 18	jsr $18c3			jsr 	EncodeMoveNextWord 			; advance to the next and loop
.1758	4c b8 16	jmp $16b8			jmp 	EncodeLoop
.175b					_EPNotDefined:
.175b	b2 08		lda ($08)			lda 	(srcPtr) 					; first character
.175d	c9 3a		cmp #$3a			cmp 	#":"						; is it :<routine> ?
.175f	f0 58		beq $17b9			beq 	_EPDefinition
.1761	c9 3c		cmp #$3c			cmp 	#"<"						; is it <line> which is call syntax
.1763	f0 2e		beq $1793			beq 	_EPCallDirect
.1765	c9 21		cmp #$21			cmp 	#"!"						; check for variable operators
.1767	f0 47		beq $17b0			beq 	_EPVariable
.1769	c9 40		cmp #$40			cmp 	#"@"
.176b	f0 43		beq $17b0			beq 	_EPVariable
.176d	c9 26		cmp #$26			cmp 	#"&"
.176f	f0 3f		beq $17b0			beq 	_EPVariable
.1771	a9 a4		lda #$a4			lda 	#Literal2Byte & $FF 		; write out 2 byte literal
.1773	a0 10		ldy #$10			ldy 	#Literal2Byte >> 8
.1775	20 8f 18	jsr $188f			jsr 	EncodeWriteWord
.1778					_EPOutputConstant:
.1778	20 d9 18	jsr $18d9			jsr 	EncodeGetConstant 			; extract that constant from the source
.177b	90 06		bcc $1783			bcc 	_EPFail 					; if can't find one, that's us done.
.177d	20 8f 18	jsr $188f			jsr 	EncodeWriteWord 			; write out the encoded value.
.1780	4c b8 16	jmp $16b8			jmp 	EncodeLoop 					; and go round again.
.1783					_EPFail:
.1783	20 fc 10	jsr $10fc			jsr 	ErrorHandler
>1786	53 59 4e 54 41 58 20 45				.text 	"SYNTAX ERROR",0
>178e	52 52 4f 52 00
.1793					_EPCallDirect:
.1793	a9 f3		lda #$f3			lda	 	#CallHandler & $FF 			; write code call handler
.1795	a0 1b		ldy #$1b			ldy	 	#CallHandler >> 8
.1797	20 8f 18	jsr $188f			jsr 	EncodeWriteWord
.179a	a9 01		lda #$01			lda 	#1
.179c	20 cf 18	jsr $18cf			jsr 	EncodeAddSrcPtr 			; skip over the <
.179f	a0 ff		ldy #$ff			ldy 	#255 						; scan forward for last character.
.17a1					_EPToLast:
.17a1	c8		iny				iny
.17a2	b1 08		lda ($08),y			lda 	(srcPtr),y
.17a4	10 fb		bpl $17a1			bpl	 	_EPToLast
.17a6	c9 be		cmp #$be			cmp 	#">"+$80 					; must be >
.17a8	d0 d9		bne $1783			bne 	_EPFail
.17aa	a9 20		lda #$20			lda 	#" " 						; strip back to a number, erases last char
.17ac	91 08		sta ($08),y			sta 	(srcPtr),y
.17ae	80 c8		bra $1778			bra 	_EPOutputConstant 			; borrow the number routines extract/compile constant
.17b0					_EPVariable:
.17b0	20 87 19	jsr $1987			jsr 	EncodeVariableReference
.17b3	20 c3 18	jsr $18c3			jsr 	EncodeMoveNextWord 			; advance to the next and loop
.17b6	4c b8 16	jmp $16b8			jmp 	EncodeLoop
.17b9					_EPDefinition:
.17b9	a9 e9		lda #$e9			lda	 	#DefineCode & $FF 			; write code call handler
.17bb	a0 21		ldy #$21			ldy	 	#DefineCode >> 8
.17bd	20 8f 18	jsr $188f			jsr 	EncodeWriteWord
.17c0	ae 10 09	ldx $0910			ldx 	encodeBuffer 				; position
.17c3	a9 01		lda #$01			lda 	#1 							; write default size
.17c5	20 99 18	jsr $1899			jsr 	EncodeWriteByte
.17c8	a0 00		ldy #$00			ldy 	#0 							; copy definition over.
.17ca	c8		iny		_EPCopy:iny
.17cb	b1 08		lda ($08),y			lda 	(srcPtr),y
.17cd	20 99 18	jsr $1899			jsr 	EncodeWriteByte
.17d0	fe 10 09	inc $0910,x			inc 	encodeBuffer,x 				; update length.
.17d3	0a		asl a				asl 	a
.17d4	90 f4		bcc $17ca			bcc 	_EPCopy
.17d6	20 c3 18	jsr $18c3			jsr 	EncodeMoveNextWord 			; advance to the next and loop
.17d9	4c b8 16	jmp $16b8			jmp 	EncodeLoop

;******  Return to file: kernel.asm


;******  Processing file: words/encode/comstr.src

.17dc					EncodeCommentString:
.17dc	b2 08		lda ($08)			lda 	(srcPtr) 					; get first character
.17de	64 10		stz $10				stz 	temp1 						; other terminator = EOL
.17e0	aa		tax				tax 								; save in X
.17e1	a9 be		lda #$be			lda 	#(SkipComment & $FF)		; get the routine to use
.17e3	a0 21		ldy #$21			ldy 	#(SkipComment >> 8)
.17e5	e0 27		cpx #$27			cpx 	#"'"
.17e7	f0 06		beq $17ef			beq 	_ECSGotCmd
.17e9	86 10		stx $10				stx		temp1 						; other terminator = "
.17eb	a9 cc		lda #$cc			lda 	#(LiteralString & $FF)
.17ed	a0 10		ldy #$10			ldy 	#(LiteralString >> 8)
.17ef					_ECSGotCmd:
.17ef	20 8f 18	jsr $188f			jsr 	EncodeWriteWord 			; write word out.
.17f2	a9 01		lda #$01			lda 	#1 							; skip over ' or "
.17f4	20 cf 18	jsr $18cf			jsr 	EncodeAddSrcPtr
.17f7	e0 27		cpx #$27			cpx 	#"'"						; if ' then skip spaces
.17f9	d0 03		bne $17fe			bne 	_ECNoSkipSpaces
.17fb	20 fe 18	jsr $18fe			jsr 	EncSkipSpaces
.17fe					_ECNoSkipSpaces:
.17fe	ae 10 09	ldx $0910			ldx 	encodeBuffer 				; keep offset to buffer in X.
.1801	a9 01		lda #$01			lda 	#1
.1803	20 99 18	jsr $1899			jsr 	EncodeWriteByte 			; write total length, so far 1.
.1806	a0 00		ldy #$00			ldy 	#0 							; for reading the actual text
.1808					_ECSCopyText:
.1808	b1 08		lda ($08),y			lda 	(srcPtr),y 					; get next
.180a	f0 18		beq $1824			beq 	_ECSEndOfLine 				; end of line ?
.180c	c5 10		cmp $10				cmp 	temp1						; is it the other terminator
.180e	f0 09		beq $1819			beq 	_ECSEndOfString 			; if so must be closing quote.
.1810	20 99 18	jsr $1899			jsr 	EncodeWriteByte 			; write the byte out
.1813	fe 10 09	inc $0910,x			inc 	encodeBuffer,x				; increase length
.1816	c8		iny				iny 								; next character
.1817	80 ef		bra $1808			bra 	_ECSCopyText
.1819					_ECSEndOfString:
.1819	c8		iny				iny 								; skip closing quote.
.181a	a9 00		lda #$00			lda 	#0 							; write out ASCIIZ
.181c	20 99 18	jsr $1899			jsr 	EncodeWriteByte
.181f	fe 10 09	inc $0910,x			inc 	encodeBuffer,x 				; fix the length up.
.1822	80 18		bra $183c			bra 	_ECSComplete 				; and just patching up srcPtr to do.
.1824					_ECSEndOfLine:
.1824	a5 10		lda $10				lda 	temp1 						; missing closing quote
.1826	f0 14		beq $183c			beq 	_ECSComplete 				; if we were doing a string.
.1828	20 fc 10	jsr $10fc			jsr 	ErrorHandler
>182b	4e 4f 20 43 4c 4f 53 49				.text 	"NO CLOSING QUOTE",0
>1833	4e 47 20 51 55 4f 54 45 00
.183c					_ECSComplete:
.183c	98		tya				tya									; skip over.
.183d	20 cf 18	jsr $18cf			jsr 	EncodeAddSrcPtr
.1840	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/encode/encdef.src

.1841					EncodeSearchUserDefined:
.1841	38		sec				sec 								; temp1 = srcPtr-6 because the
.1842	a5 08		lda $08				lda 	srcPtr				 		; name is 6 in (offset line# $$call len)
.1844	e9 06		sbc #$06			sbc		#6
.1846	85 10		sta $10				sta 	temp1
.1848	a5 09		lda $09				lda 	srcPtr+1
.184a	e9 00		sbc #$00			sbc 	#0
.184c	85 11		sta $11				sta 	temp1+1
.184e	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.1850	85 12		sta $12				sta 	0+(temp2)
.1852	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.1854	85 13		sta $13				sta 	1+(temp2)
.1856					_ESULoop:
.1856	b2 12		lda ($12)			lda 	(temp2) 					; reached the end (offset 0)
.1858	f0 33		beq $188d			beq 	_ESUFail
.185a	a0 03		ldy #$03			ldy 	#3 							; check it is $$define
.185c	b1 12		lda ($12),y			lda 	(temp2),y
.185e	c9 e9		cmp #$e9			cmp 	#DefineCode & $FF
.1860	d0 1e		bne $1880			bne 	_ESUNext
.1862	c8		iny				iny
.1863	b1 12		lda ($12),y			lda 	(temp2),y
.1865	c9 21		cmp #$21			cmp 	#DefineCode >> 8
.1867	d0 17		bne $1880			bne 	_ESUNext
.1869	c8		iny				iny 								; skip length byte.
.186a					_ESUCompare:
.186a	c8		iny				iny
.186b	b1 12		lda ($12),y			lda 	(temp2),y
.186d	d1 10		cmp ($10),y			cmp 	(temp1),y
.186f	d0 0f		bne $1880			bne 	_ESUNext
.1871	0a		asl a				asl 	a 							; bit 7 set => found it.
.1872	90 f6		bcc $186a			bcc 	_ESUCompare
.1874	a0 01		ldy #$01			ldy 	#1
.1876	b1 12		lda ($12),y			lda 	(temp2),y 					; read in the line number to YA
.1878	aa		tax				tax
.1879	c8		iny				iny
.187a	b1 12		lda ($12),y			lda 	(temp2),y
.187c	a8		tay				tay
.187d	8a		txa				txa
.187e	38		sec				sec 								; return with carry set as found
.187f	60		rts				rts
.1880					_ESUNext:
.1880	18		clc				clc
.1881	a5 12		lda $12				lda 	temp2
.1883	72 12		adc ($12)			adc 	(temp2)
.1885	85 12		sta $12				sta 	temp2
.1887	90 02		bcc $188b			bcc 	_NoCarryAdv
.1889	e6 13		inc $13				inc 	temp2+1
.188b					_NoCarryAdv:
.188b	80 c9		bra $1856			bra 	_ESULoop 					; and loop round
.188d					_ESUFail:
.188d	18		clc				clc
.188e	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/encode/encutils.src

.188f					EncodeWriteWord:
.188f	48		pha				pha
.1890	20 99 18	jsr $1899			jsr 	EncodeWriteByte
.1893	98		tya				tya
.1894	20 99 18	jsr $1899			jsr 	EncodeWriteByte
.1897	68		pla				pla
.1898	60		rts				rts
.1899					EncodeWriteByte:
.1899	da		phx				phx
.189a	ae 10 09	ldx $0910			ldx 	encodeBuffer
.189d	9d 10 09	sta $0910,x			sta 	encodeBuffer,x
.18a0	9e 11 09	stz $0911,x			stz 	encodeBuffer+1,x
.18a3	9e 12 09	stz $0912,x			stz 	encodeBuffer+2,x
.18a6	ee 10 09	inc $0910			inc 	encodeBuffer
.18a9	fa		plx				plx
.18aa	60		rts				rts
.18ab					CheckIsLetter:
.18ab	c9 41		cmp #$41			cmp 	#"A"						; return CS if A..Z
.18ad	90 06		bcc $18b5			bcc 	_CILFail
.18af	c9 5b		cmp #$5b			cmp 	#"Z"+1
.18b1	b0 02		bcs $18b5			bcs 	_CILFail
.18b3	38		sec				sec
.18b4	60		rts				rts
.18b5					_CILFail:
.18b5	18		clc				clc
.18b6	60		rts				rts
.18b7					CheckIsDigit:
.18b7	c9 30		cmp #$30			cmp 	#"0"						; return CS if 0..9
.18b9	90 06		bcc $18c1			bcc 	_CIDFail
.18bb	c9 3a		cmp #$3a			cmp 	#"9"+1
.18bd	b0 02		bcs $18c1			bcs 	_CIDFail
.18bf	38		sec				sec
.18c0	60		rts				rts
.18c1					_CIDFail:
.18c1	18		clc				clc
.18c2	60		rts				rts
.18c3					EncodeMoveNextWord:
.18c3	a0 ff		ldy #$ff			ldy 	#255 						; search forward
.18c5					_EPNWLoop:
.18c5	c8		iny				iny
.18c6	b1 08		lda ($08),y			lda 	(srcPtr),y
.18c8	c9 21		cmp #$21			cmp 	#" "+1						; looking for <= space
.18ca	b0 f9		bcs $18c5			bcs 	_EPNWLoop
.18cc	98		tya				tya
.18cd	80 00		bra $18cf			bra 	EncodeAddSrcPtr
.18cf					EncodeAddSrcPtr:
.18cf	18		clc				clc 								; add offset
.18d0	65 08		adc $08				adc 	srcPtr
.18d2	85 08		sta $08				sta 	srcPtr
.18d4	90 02		bcc $18d8			bcc 	_EASPNoCarry
.18d6	e6 09		inc $09				inc 	srcPtr+1					; carry through
.18d8					_EASPNoCarry:
.18d8	60		rts				rts
.18d9					EncodeGetConstant:
.18d9	a5 08		lda $08				lda 	srcPtr 						; get source
.18db	a4 09		ldy $09				ldy 	srcPtr+1
.18dd	20 12 22	jsr $2212			jsr 	ConvertToInteger 			; call converter
.18e0	90 08		bcc $18ea			bcc 	_EGCExit
.18e2	20 cf 18	jsr $18cf			jsr 	EncodeAddSrcPtr 			; if passed add chars to src ptr
.18e5	a5 14		lda $14				lda 	temp3 						; get result into YA
.18e7	a4 15		ldy $15				ldy 	temp3+1
.18e9	38		sec				sec 								; return CS
.18ea					_EGCExit:
.18ea	60		rts				rts
.18eb					EncSetBit7Word:
.18eb	08		php				php 								; save carry
.18ec	a0 ff		ldy #$ff			ldy 	#255 						; scan forward for space/NULL
.18ee					_ESB7Loop:
.18ee	c8		iny				iny
.18ef	b1 08		lda ($08),y			lda 	(srcPtr),y
.18f1	c9 21		cmp #$21			cmp 	#" "+1 						; while > ' '
.18f3	b0 f9		bcs $18ee			bcs 	_ESB7Loop
.18f5	88		dey				dey									; previous character
.18f6	b1 08		lda ($08),y			lda 	(srcPtr),y 					; read it
.18f8	0a		asl a				asl 	a 							; shift bit 7 out
.18f9	28		plp				plp 								; restore carry
.18fa	6a		ror a				ror 	a 							; shift it in
.18fb	91 08		sta ($08),y			sta 	(srcPtr),y 					; write back and exit
.18fd	60		rts				rts
.18fe					EncSkipSpaces:
.18fe	b2 08		lda ($08)			lda 	(srcPtr) 					; skip over spaces/ reached end
.1900	c9 20		cmp #$20			cmp 	#32
.1902	d0 07		bne $190b			bne 	_ESNotSpace
.1904	a9 01		lda #$01			lda 	#1
.1906	20 cf 18	jsr $18cf			jsr 	EncodeAddSrcPtr
.1909	80 f3		bra $18fe			bra	 	EncSkipSpaces
.190b					_ESNotSpace:
.190b	60		rts				rts
.190c					EncodeTrimTrailingSpaces:
.190c	a0 ff		ldy #$ff			ldy 	#255 						; find EOS
.190e					_ETTFindEnd:
.190e	c8		iny				iny
.190f	b1 08		lda ($08),y			lda 	(srcPtr),y
.1911	d0 fb		bne $190e			bne 	_ETTFindEnd
.1913					_ETTRemoveSpace:
.1913	c0 00		cpy #$00			cpy 	#0 							; start of string
.1915	f0 0d		beq $1924			beq 	_ETTExit
.1917	88		dey				dey 								; previous character 1..32
.1918	b1 08		lda ($08),y			lda 	(srcPtr),y
.191a	c9 21		cmp #$21			cmp 	#32+1
.191c	b0 06		bcs $1924			bcs 	_ETTExit
.191e	a9 00		lda #$00			lda 	#0 							; erase it and go round again
.1920	91 08		sta ($08),y			sta 	(srcPtr),y
.1922	80 ef		bra $1913			bra 	_ETTRemoveSpace
.1924					_ETTExit:
.1924	60		rts				rts
.1925					EncodePushPosMarkerOnStack:
.1925	e6 05		inc $05				inc 	rsp 						; make space on rstack
.1927	a6 05		ldx $05				ldx 	rsp							; access it
.1929	9d 40 07	sta $0740,x			sta 	returnStackHigh,x			; save marker
.192c	ad 10 09	lda $0910			lda 	encodeBuffer 				; save position in encode buffer
.192f	9d 80 07	sta $0780,x			sta 	returnStackX,x
.1932	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/encode/encsearch.src

.1933					EncodeSearchDictionary:
.1933	a9 f6		lda #$f6			lda 	#(Dictionary) & $FF
.1935	85 10		sta $10				sta 	0+(temp1)
.1937	a9 24		lda #$24			lda 	#(Dictionary) >> 8
.1939	85 11		sta $11				sta 	1+(temp1)
.193b					_ESDLoop:
.193b	b2 10		lda ($10)			lda 	(temp1) 					; end of dictionary return with CC.
.193d	18		clc				clc
.193e	f0 46		beq $1986			beq 	_ESDExit
.1940	a0 01		ldy #$01			ldy 	#1 							; get control bits, get offset to name.
.1942	b1 10		lda ($10),y			lda 	(temp1),y
.1944	4a		lsr a				lsr 	a 							; encode/decode bits move to 0,1
.1945	4a		lsr a				lsr 	a
.1946	4a		lsr a				lsr 	a
.1947	4a		lsr a				lsr 	a
.1948	c8		iny				iny 								; Y = 2
.1949	4a		lsr a				lsr 	a
.194a	90 01		bcc $194d			bcc 	_ESDNotDec
.194c	c8		iny				iny
.194d					_ESDNotDec:
.194d	4a		lsr a				lsr 	a
.194e	90 01		bcc $1951			bcc 	_ESDNotInc
.1950	c8		iny				iny
.1951					_ESDNotInc:
.1951	98		tya				tya
.1952	0a		asl a				asl 	a 							; A is now 4,6,8 offset to name.
.1953	a8		tay				tay
.1954	b1 10		lda ($10),y			lda 	(temp1),y 					; quick check of first character
.1956	d2 08		cmp ($08)			cmp 	(srcPtr)
.1958	d0 1f		bne $1979			bne 	_ESDNext 					; do not match, go to next
.195a	98		tya				tya 								; make temp2 point to the name in
.195b	18		clc				clc 								; the dictionary.
.195c	65 10		adc $10				adc 	temp1
.195e	85 12		sta $12				sta 	temp2
.1960	a5 11		lda $11				lda 	temp1+1
.1962	69 00		adc #$00			adc 	#0
.1964	85 13		sta $13				sta 	temp2+1
.1966	a0 ff		ldy #$ff			ldy 	#255 						; now start matching up.
.1968					_ESDCompare:
.1968	c8		iny				iny
.1969	b1 08		lda ($08),y			lda 	(srcPtr),y
.196b	d1 12		cmp ($12),y			cmp 	(temp2),y
.196d	d0 0a		bne $1979			bne 	_ESDNext
.196f	0a		asl a				asl 	a
.1970	90 f6		bcc $1968			bcc 	_ESDCompare
.1972	a5 10		lda $10				lda 	temp1 						; return address in YA and carry set.
.1974	a4 11		ldy $11				ldy 	temp1+1
.1976	38		sec				sec
.1977	80 0d		bra $1986			bra 	_ESDExit
.1979					_ESDNext:
.1979	18		clc				clc
.197a	a5 10		lda $10				lda 	temp1
.197c	72 10		adc ($10)			adc 	(temp1)
.197e	85 10		sta $10				sta 	temp1
.1980	90 b9		bcc $193b			bcc 	_ESDLoop
.1982	e6 11		inc $11				inc 	temp1+1
.1984	80 b5		bra $193b			bra 	_ESDLoop
.1986					_ESDExit:
.1986	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/encode/encvar.src

.1987					EncodeVariableReference:
.1987	b2 08		lda ($08)			lda 	(srcPtr)					; get the type, use it to identify the routine
.1989	a2 4b		ldx #$4b			ldx 	#VarAddressHandler & $FF
.198b	a0 23		ldy #$23			ldy 	#VarAddressHandler >> 8
.198d	c9 26		cmp #$26			cmp 	#"&"
.198f	f0 0c		beq $199d			beq 	_EVFHaveAddress
.1991	a2 68		ldx #$68			ldx 	#VarReadHandler & $FF
.1993	a0 23		ldy #$23			ldy 	#VarReadHandler >> 8
.1995	c9 40		cmp #$40			cmp 	#"@"
.1997	f0 04		beq $199d			beq 	_EVFHaveAddress
.1999	a2 87		ldx #$87			ldx 	#VarWriteHandler & $FF
.199b	a0 23		ldy #$23			ldy 	#VarWriteHandler >> 8
.199d					_EVFHaveAddress:
.199d	8a		txa				txa
.199e	20 8f 18	jsr $188f			jsr 	EncodeWriteWord 			; write it out.
.19a1	a0 01		ldy #$01			ldy 	#1 							; get the first charactere
.19a3	b1 08		lda ($08),y			lda 	(srcPtr),y
.19a5	29 7f		and #$7f			and 	#$7F 						; might be the last.
.19a7	20 ab 18	jsr $18ab			jsr 	CheckIsLetter 				; is it A-Z
.19aa	90 54		bcc $1a00			bcc 	EVFFail
.19ac	29 1f		and #$1f			and 	#31 						; make 1-26
.19ae	85 10		sta $10				sta 	temp1 						; start building the name in temp1
.19b0	64 11		stz $11				stz 	temp1+1
.19b2	38		sec				sec 								; possible char 2
.19b3	20 15 1a	jsr $1a15			jsr 	EncVarAlNum
.19b6	18		clc				clc 								; possible char 3
.19b7	20 15 1a	jsr $1a15			jsr 	EncVarAlNum
.19ba	5a		phy				phy
.19bb	a5 10		lda $10				lda 	temp1 						; write out variable identifier.
.19bd	a4 11		ldy $11				ldy 	temp1+1
.19bf	20 8f 18	jsr $188f			jsr 	EncodeWriteWord
.19c2	7a		ply				ply
.19c3	b1 08		lda ($08),y			lda 	(srcPtr),y 					; more text after ?
.19c5	10 01		bpl $19c8			bpl 	_EVFCheckArray
.19c7	60		rts				rts
.19c8					_EVFCheckArray:
.19c8	c8		iny				iny 								; get the next character
.19c9	b1 08		lda ($08),y			lda 	(srcPtr),y
.19cb	c9 5b		cmp #$5b			cmp 	#"["						; array index ?
.19cd	d0 31		bne $1a00			bne 	EVFFail
.19cf	64 10		stz $10				stz 	temp1 						; zero temp1.
.19d1	c8		iny				iny  								; point to index
.19d2					_EVFGetIndex:
.19d2	06 10		asl $10				asl 	temp1 						; temp1 x 10
.19d4	a5 10		lda $10				lda 	temp1
.19d6	0a		asl a				asl 	a
.19d7	0a		asl a				asl		a
.19d8	65 10		adc $10				adc 	temp1
.19da	85 10		sta $10				sta 	temp1
.19dc	b1 08		lda ($08),y			lda 	(srcPtr),y 					; get the digit
.19de	20 b7 18	jsr $18b7			jsr 	CheckIsDigit
.19e1	90 1d		bcc $1a00			bcc 	EVFFail 					; failed, not digit
.19e3	29 0f		and #$0f			and 	#15
.19e5	18		clc				clc
.19e6	65 10		adc $10				adc 	temp1
.19e8	30 16		bmi $1a00			bmi 	EVFFail 					; failed, bad index.
.19ea	85 10		sta $10				sta 	temp1
.19ec	c8		iny				iny
.19ed	b1 08		lda ($08),y			lda 	(srcPtr),y
.19ef	c9 dd		cmp #$dd			cmp 	#"]"+$80
.19f1	d0 df		bne $19d2			bne 	_EVFGetIndex 				; index now in temp1.
.19f3	a9 a6		lda #$a6			lda 	#IndexHandler & $FF 		; output code
.19f5	a0 23		ldy #$23			ldy 	#IndexHandler >> 8
.19f7	20 8f 18	jsr $188f			jsr 	EncodeWriteWord
.19fa	a5 10		lda $10				lda 	temp1	 					; write index
.19fc	20 99 18	jsr $1899			jsr 	EncodeWriteByte
.19ff	60		rts				rts
.1a00					EVFFail:
.1a00	20 fc 10	jsr $10fc			jsr 	ErrorHandler
>1a03	42 41 44 20 56 41 52 49				.text 	"BAD VARIABLE NAME",0
>1a0b	41 42 4c 45 20 4e 41 4d 45 00
.1a15					EncVarAlNum:
.1a15	b1 08		lda ($08),y			lda 	(srcPtr),y 					; points to the  last char processed.
.1a17	10 01		bpl $1a1a			bpl 	_EVAContinue
.1a19	60		rts				rts
.1a1a					_EVAContinue:
.1a1a	08		php				php 								; CS x 32 ; CC x 32 x 40
.1a1b	c8		iny				iny 								; get the next character, strip bit 7
.1a1c	b1 08		lda ($08),y			lda 	(srcPtr),y
.1a1e	88		dey				dey
.1a1f	29 7f		and #$7f			and 	#$7F
.1a21	20 ab 18	jsr $18ab			jsr 	CheckIsLetter 				; letter ?
.1a24	b0 08		bcs $1a2e			bcs 	_EVACharOkay
.1a26	20 b7 18	jsr $18b7			jsr 	CheckIsDigit				; fail if not digit.
.1a29	90 32		bcc $1a5d			bcc 	_EVAExit
.1a2b	18		clc				clc
.1a2c	69 2b		adc #$2b			adc 	#"Z"+1-"0"					; shift 0 so after Z
.1a2e					_EVACharOkay:
.1a2e	c8		iny				iny 								; char okay advance to it.
.1a2f	38		sec				sec 								; range 1-36
.1a30	e9 40		sbc #$40			sbc 	#64
.1a32	28		plp				plp 								; which multiplier ?
.1a33	90 0f		bcc $1a44			bcc 	_EVATimes32x40
.1a35	85 12		sta $12				sta 	temp2 						; save in temp2 - A x 32
.1a37	64 13		stz $13				stz 	temp2+1
.1a39	a2 05		ldx #$05			ldx 	#5
.1a3b	06 12		asl $12		_EVA32:	asl 	temp2
.1a3d	26 13		rol $13				rol 	temp2+1
.1a3f	ca		dex				dex
.1a40	d0 f9		bne $1a3b			bne 	_EVA32
.1a42	80 0b		bra $1a4f			bra 	_EVAAddVar
.1a44					_EVATimes32x40:
.1a44	85 13		sta $13				sta 	temp2+1						; 32 x 40 = 1280 or $500, so temp2 = A x 256 x 5
.1a46	64 12		stz $12				stz 	temp2
.1a48	0a		asl a				asl 	a
.1a49	0a		asl a				asl 	a
.1a4a	18		clc				clc
.1a4b	65 13		adc $13				adc 	temp2+1
.1a4d	85 13		sta $13				sta 	temp2+1
.1a4f					_EVAAddVar:
.1a4f	18		clc				clc
.1a50	a5 10		lda $10				lda 	temp1
.1a52	65 12		adc $12				adc 	temp2
.1a54	85 10		sta $10				sta 	temp1
.1a56	a5 11		lda $11				lda 	temp1+1
.1a58	65 13		adc $13				adc 	temp2+1
.1a5a	85 11		sta $11				sta 	temp1+1
.1a5c	08		php				php
.1a5d					_EVAExit:
.1a5d	28		plp				plp
.1a5e	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/structures/fornext.src

.1a5f					ForHandler:
.1a5f	e6 05		inc $05				inc 	rsp 						; bump the RSP
.1a61	a4 05		ldy $05				ldy 	rsp 						; get return stack and push TOS/$FF on it.
.1a63	c0 40		cpy #$40			cpy 	#$40 						; overflow
.1a65	f0 18		beq $1a7f			beq 	_FHOverflow
.1a67	a5 07		lda $07				lda 	TOS+1
.1a69	99 40 07	sta $0740,y			sta 	returnStackHigh,y
.1a6c	a5 06		lda $06				lda 	TOS
.1a6e	99 00 07	sta $0700,y			sta 	returnStackLow,y
.1a71	a9 ff		lda #$ff			lda 	#$FF
.1a73	99 80 07	sta $0780,y			sta 	returnStackX,y
.1a76	68		pla				pla
.1a77	85 07		sta $07				sta 	TOS+1
.1a79	68		pla				pla
.1a7a	85 06		sta $06				sta 	TOS
.1a7c	4c 00 00	jmp $0000			jmp 	NextCode
.1a7f					_FHOverflow:
.1a7f	20 fc 10	jsr $10fc			jsr 	ErrorHandler
>1a82	53 54 52 55 43 54 55 52				.text 	"STRUCTURE OVERFLOW",0
>1a8a	45 20 4f 56 45 52 46 4c 4f 57 00
.1a95					ForEncoder:
.1a95	a9 5f		lda #$5f			lda 	#ForHandler & $FF 			; for handler
.1a97	a0 1a		ldy #$1a			ldy 	#ForHandler >> 8
.1a99	20 8f 18	jsr $188f			jsr 	EncodeWriteWord
.1a9c	a9 46		lda #$46			lda 	#"F" 						; for marker
.1a9e	20 25 19	jsr $1925			jsr 	EncodePushPosMarkerOnStack
.1aa1	60		rts				rts
.1aa2					NextHandler:
.1aa2	da		phx				phx
.1aa3	a6 05		ldx $05				ldx 	rsp 						; get current stack ptr
.1aa5	bd 80 07	lda $0780,x			lda 	returnStackX,x 				; check it's a FOR Loop
.1aa8	c9 ff		cmp #$ff			cmp 	#$FF
.1aaa	d0 21		bne $1acd			bne 	NHNoFor
.1aac	bd 00 07	lda $0700,x			lda 	returnStackLow,x 			; decrement the count
.1aaf	d0 03		bne $1ab4			bne 	_NHNoBorrow
.1ab1	de 40 07	dec $0740,x			dec 	returnStackHigh,x
.1ab4					_NHNoBorrow:
.1ab4	de 00 07	dec $0700,x			dec 	returnStackLow,x
.1ab7	bd 00 07	lda $0700,x			lda 	returnStackLow,x 			; have we reached the end ?
.1aba	1d 40 07	ora $0740,x			ora 	returnStackHigh,x
.1abd	fa		plx				plx 								; restore X and re-test
.1abe	09 00		ora #$00			ora 	#0
.1ac0	f0 05		beq $1ac7			beq 	_NHComplete 				; if so then complete, else loop.
.1ac2	e8		inx				inx 								; advance to branch
.1ac3	e8		inx				inx
.1ac4	4c e9 1b	jmp $1be9			jmp 	BranchAlways
.1ac7					_NHComplete:
.1ac7	e8		inx				inx 								; skip over the branch quantity
.1ac8	c6 05		dec $05				dec 	rsp 						; drop the indx
.1aca	4c 00 00	jmp $0000			jmp 	NextCode
.1acd					NHNoFor:
.1acd	20 fc 10	jsr $10fc			jsr 	ErrorHandler
>1ad0	4f 55 54 20 4f 46 20 46				.text 	"OUT OF FOR SCOPE",0
>1ad8	4f 52 20 53 43 4f 50 45 00
.1ae1					NextEncoder:
.1ae1	a9 a2		lda #$a2			lda 	#NextHandler & $FF 			; next code
.1ae3	a0 1a		ldy #$1a			ldy 	#NextHandler >> 8
.1ae5	20 8f 18	jsr $188f			jsr 	EncodeWriteWord
.1ae8	a6 05		ldx $05				ldx 	rsp 						; get stack offset and pop
.1aea	c6 05		dec $05				dec 	rsp
.1aec	bd 40 07	lda $0740,x			lda 	returnStackHigh,x 			; check it is a for
.1aef	c9 46		cmp #$46			cmp 	#"F"
.1af1	d0 07		bne $1afa			bne 	_NENoFor
.1af3	bd 80 07	lda $0780,x			lda 	returnStackX,x 				; write the branch
.1af6	20 99 18	jsr $1899			jsr 	EncodeWriteByte
.1af9	60		rts				rts
.1afa					_NENoFor:
.1afa	20 fc 10	jsr $10fc			jsr 	ErrorHandler
>1afd	4d 49 53 53 49 4e 47 20				.text 	"MISSING FOR",0
>1b05	46 4f 52 00
.1b09					GetIndex:
.1b09	a4 05		ldy $05				ldy 	rsp 						; get current stack ptr
.1b0b	b9 80 07	lda $0780,y			lda 	returnStackX,y 				; check it's a FOR Loop
.1b0e	c9 ff		cmp #$ff			cmp 	#$FF
.1b10	d0 bb		bne $1acd			bne 	NHNoFor
.1b12	a5 06		lda $06				lda 	TOS
.1b14	48		pha				pha
.1b15	a5 07		lda $07				lda 	TOS+1
.1b17	48		pha				pha
.1b18	b9 00 07	lda $0700,y			lda 	returnStackLow,y 			; put counter-1 out
.1b1b	38		sec				sec
.1b1c	e9 01		sbc #$01			sbc 	#1
.1b1e	85 06		sta $06				sta 	TOS
.1b20	b9 40 07	lda $0740,y			lda 	returnStackHigh,y
.1b23	e9 00		sbc #$00			sbc 	#0
.1b25	85 07		sta $07				sta 	TOS+1
.1b27	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/structures/ifelseendif.src

.1b2a					IfHandler:
.1b2a	4c d1 1b	jmp $1bd1			jmp 	BranchIfZero
.1b2d					IfEncoder:
.1b2d	a9 2a		lda #$2a			lda 	#IfHandler & $FF 			; if handler
.1b2f	a0 1b		ldy #$1b			ldy 	#IfHandler >> 8
.1b31	20 8f 18	jsr $188f			jsr 	EncodeWriteWord
.1b34	a9 49		lda #$49			lda 	#"I" 						; if marker
.1b36	20 25 19	jsr $1925			jsr 	EncodePushPosMarkerOnStack
.1b39	a9 00		lda #$00			lda 	#0
.1b3b	20 99 18	jsr $1899			jsr 	EncodeWriteByte 			; dummy write.
.1b3e	60		rts				rts
.1b3f					ElseHandler:
.1b3f	4c e7 1b	jmp $1be7			jmp 	BranchTestSucceedsNoPop
.1b42					ElseEncoder:
.1b42	a9 3f		lda #$3f			lda 	#ElseHandler & $FF 			; else handler
.1b44	a0 1b		ldy #$1b			ldy 	#ElseHandler >> 8
.1b46	20 8f 18	jsr $188f			jsr 	EncodeWriteWord
.1b49	ad 10 09	lda $0910			lda 	encodeBuffer 				; push current position
.1b4c	48		pha				pha
.1b4d	a9 00		lda #$00			lda 	#0 							; zero branch
.1b4f	20 99 18	jsr $1899			jsr 	EncodeWriteByte
.1b52	20 6f 1b	jsr $1b6f			jsr 	IfPatch 					; fix up the branch.
.1b55	a9 49		lda #$49			lda 	#"I" 						; recreate if marker
.1b57	20 25 19	jsr $1925			jsr 	EncodePushPosMarkerOnStack
.1b5a	68		pla				pla 								; address to patch
.1b5b	a6 05		ldx $05				ldx 	rsp
.1b5d	9d 80 07	sta $0780,x			sta 	returnStackX,x 				; and overwrite the target address
.1b60	60		rts				rts
.1b61					EndIfHandler:
.1b61	4c 00 00	jmp $0000			jmp 	NextCode
.1b64					EndIfEncoder:
.1b64	a9 61		lda #$61			lda 	#EndIfHandler & $FF 		; endif handler
.1b66	a0 1b		ldy #$1b			ldy 	#EndIfHandler >> 8
.1b68	20 8f 18	jsr $188f			jsr 	EncodeWriteWord
.1b6b	20 6f 1b	jsr $1b6f			jsr 	IfPatch
.1b6e	60		rts				rts
.1b6f					IfPatch:
.1b6f	a6 05		ldx $05				ldx 	rsp 						; get stack offset and pop
.1b71	c6 05		dec $05				dec 	rsp
.1b73	bd 40 07	lda $0740,x			lda 	returnStackHigh,x 			; check it is an if.
.1b76	c9 49		cmp #$49			cmp 	#"I"
.1b78	d0 0b		bne $1b85			bne 	_NENoIf
.1b7a	bd 80 07	lda $0780,x			lda 	returnStackX,x 				; this is what you patch.
.1b7d	aa		tax				tax
.1b7e	ad 10 09	lda $0910			lda 	encodeBuffer 				; with the current position.
.1b81	9d 10 09	sta $0910,x			sta 	encodeBuffer,x
.1b84	60		rts				rts
.1b85					_NENoIf:
.1b85	20 fc 10	jsr $10fc			jsr 	ErrorHandler
>1b88	4d 49 53 53 49 4e 47 20				.text 	"MISSING IF",0
>1b90	49 46 00

;******  Return to file: kernel.asm


;******  Processing file: words/structures/repeatuntil.src

.1b93					RepeatHandler:
.1b93	4c 00 00	jmp $0000			jmp 	NextCode
.1b96					RepeatEncoder:
.1b96	a9 93		lda #$93			lda 	#RepeatHandler & $FF 		; repeat marker
.1b98	a0 1b		ldy #$1b			ldy 	#RepeatHandler >> 8
.1b9a	20 8f 18	jsr $188f			jsr 	EncodeWriteWord
.1b9d	a9 52		lda #$52			lda 	#"R" 						; repeat marker
.1b9f	20 25 19	jsr $1925			jsr 	EncodePushPosMarkerOnStack
.1ba2	60		rts				rts
.1ba3					UntilHandler:
.1ba3	4c d1 1b	jmp $1bd1			jmp 	BranchIfZero
.1ba6					UntilEncoder:
.1ba6	a9 a3		lda #$a3			lda 	#UntilHandler & $FF 		; until code
.1ba8	a0 1b		ldy #$1b			ldy 	#UntilHandler >> 8
.1baa	20 8f 18	jsr $188f			jsr 	EncodeWriteWord
.1bad	a6 05		ldx $05				ldx 	rsp 						; get stack offset and pop
.1baf	c6 05		dec $05				dec 	rsp
.1bb1	bd 40 07	lda $0740,x			lda 	returnStackHigh,x 			; check it is a repeat
.1bb4	c9 52		cmp #$52			cmp 	#"R"
.1bb6	d0 07		bne $1bbf			bne 	_UENoRepeat
.1bb8	bd 80 07	lda $0780,x			lda 	returnStackX,x 				; write the branch
.1bbb	20 99 18	jsr $1899			jsr 	EncodeWriteByte
.1bbe	60		rts				rts
.1bbf					_UENoRepeat:
.1bbf	20 fc 10	jsr $10fc			jsr 	ErrorHandler
>1bc2	4d 49 53 53 49 4e 47 20				.text 	"MISSING REPEAT",0
>1bca	52 45 50 45 41 54 00

;******  Return to file: kernel.asm


;******  Processing file: words/system/branch.src

.1bd1					BranchIfZero:
.1bd1	a5 06		lda $06				lda 	TOS 						; check TOS = 0
.1bd3	05 07		ora $07				ora 	TOS+1
.1bd5	f0 0a		beq $1be1			beq 	BranchTestSucceeds
.1bd7					BranchTestFails:
.1bd7	68		pla				pla
.1bd8	85 07		sta $07				sta 	TOS+1
.1bda	68		pla				pla
.1bdb	85 06		sta $06				sta 	TOS
.1bdd	e8		inx				inx 								; skip over the relative branch.
.1bde	4c 00 00	jmp $0000			jmp 	NextCode
.1be1					BranchTestSucceeds:
.1be1	68		pla				pla
.1be2	85 07		sta $07				sta 	TOS+1
.1be4	68		pla				pla
.1be5	85 06		sta $06				sta 	TOS
.1be7					BranchTestSucceedsNoPop:
.1be7	e8		inx				inx 								; advance by two, to the offset
.1be8	e8		inx				inx
.1be9					BranchAlways:
.1be9	8a		txa				txa 								; A = Y = position
.1bea	a8		tay				tay 								; (IP),Y now points to the branch target
.1beb	b1 03		lda ($03),y			lda 	(IP),y 						; adjust the position
.1bed	aa		tax				tax 								; position back in this line.
.1bee	ca		dex				dex
.1bef	ca		dex				dex
.1bf0	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/system/callhandler.src

.1bf3					CallHandler:
.1bf3	e8		inx				inx									; bump X to the call address.
.1bf4	e8		inx				inx
.1bf5	e6 05		inc $05				inc 	rsp 						; bump the RSP (first time to zero)
.1bf7	a4 05		ldy $05				ldy 	rsp 						; get return stack and push IP/X on it.
.1bf9	c0 40		cpy #$40			cpy 	#$40 						; overflow
.1bfb	f0 54		beq $1c51			beq 	_CHOverflow
.1bfd	a5 04		lda $04				lda 	IP+1
.1bff	99 40 07	sta $0740,y			sta 	returnStackHigh,y
.1c02	a5 03		lda $03				lda 	IP
.1c04	99 00 07	sta $0700,y			sta 	returnStackLow,y
.1c07	8a		txa				txa
.1c08	99 80 07	sta $0780,y			sta 	returnStackX,y
.1c0b	8a		txa				txa 								; get the line number into temp1.
.1c0c	a8		tay				tay
.1c0d	b1 03		lda ($03),y			lda 	(IP),y
.1c0f	85 10		sta $10				sta 	temp1
.1c11	c8		iny				iny
.1c12	b1 03		lda ($03),y			lda 	(IP),y
.1c14	85 11		sta $11				sta 	temp1+1
.1c16	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.1c18	85 03		sta $03				sta 	0+(IP)
.1c1a	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.1c1c	85 04		sta $04				sta 	1+(IP)
.1c1e	b2 03		lda ($03)			lda 	(IP)						; no program code ?
.1c20	f0 17		beq $1c39			beq 	_CHFail
.1c22	a0 01		ldy #$01			ldy 	#1 							; Y = 1 throughout.
.1c24					_CHSearch:
.1c24	b1 03		lda ($03),y			lda 	(IP),y 						; check LSB of line number
.1c26	c5 10		cmp $10				cmp 	temp1
.1c28	f0 3e		beq $1c68			beq 	_CHFoundLSB
.1c2a					_CHSearchNext:
.1c2a	18		clc				clc
.1c2b	a5 03		lda $03				lda 	IP
.1c2d	72 03		adc ($03)			adc 	(IP)
.1c2f	85 03		sta $03				sta 	IP
.1c31	90 02		bcc $1c35			bcc 	_NoCarryAdv
.1c33	e6 04		inc $04				inc 	IP+1
.1c35					_NoCarryAdv:
.1c35	b2 03		lda ($03)			lda 	(IP)						; check reached the end.
.1c37	d0 eb		bne $1c24			bne 	_CHSearch
.1c39					_CHFail:
.1c39	20 fc 10	jsr $10fc			jsr 	ErrorHandler
>1c3c	43 41 4e 54 20 46 49 4e				.text 	"CANT FIND DEFINITION",0
>1c44	44 20 44 45 46 49 4e 49 54 49 4f 4e 00
.1c51					_CHOverflow:
.1c51	20 fc 10	jsr $10fc			jsr 	ErrorHandler
>1c54	43 41 4c 4c 20 53 54 41				.text 	"CALL STACK OVERFLOW",0
>1c5c	43 4b 20 4f 56 45 52 46 4c 4f 57 00
.1c68					_CHFoundLSB:
.1c68	c8		iny				iny 								; get MSB
.1c69	b1 03		lda ($03),y			lda 	(IP),y
.1c6b	88		dey				dey
.1c6c	c5 11		cmp $11				cmp 	temp1+1 					; matches, if not contineu
.1c6e	d0 ba		bne $1c2a			bne 	_CHSearchNext
.1c70	a0 03		ldy #$03			ldy 	#3	 						; check it begins with $$define
.1c72	b1 03		lda ($03),y			lda 	(IP),y
.1c74	c9 e9		cmp #$e9			cmp 	#DefineCode & $FF
.1c76	d0 c1		bne $1c39			bne 	_CHFail
.1c78	c8		iny				iny
.1c79	b1 03		lda ($03),y			lda 	(IP),y
.1c7b	c9 21		cmp #$21			cmp 	#DefineCode >> 8
.1c7d	d0 ba		bne $1c39			bne 	_CHFail
.1c7f	c8		iny				iny
.1c80	b1 03		lda ($03),y			lda 	(IP),y 						; this is the length of the define name
.1c82	18		clc				clc
.1c83	69 03		adc #$03			adc 	#5-2 						; $$define token, line number, offset - 2 for Next
.1c85	aa		tax				tax
.1c86	4c 00 00	jmp $0000			jmp 	NextCode
.1c89					ReturnHandler:
.1c89	a4 05		ldy $05				ldy 	rsp 						; get rsp
.1c8b	f0 15		beq $1ca2			beq 	_RHUnderflow 				; if -ve underflowed
.1c8d	c6 05		dec $05				dec 	rsp 						; decrement rsp
.1c8f	b9 40 07	lda $0740,y			lda 	returnStackHigh,y 			; restore IP/X
.1c92	85 04		sta $04				sta 	IP+1
.1c94	b9 00 07	lda $0700,y			lda 	returnStackLow,y
.1c97	85 03		sta $03				sta 	IP
.1c99	b9 80 07	lda $0780,y			lda 	returnStackX,y
.1c9c	aa		tax				tax
.1c9d	f0 15		beq $1cb4			beq 	_RHInLoop 					; this means you have done :something for ; next
.1c9f	4c 00 00	jmp $0000			jmp 	NextCode
.1ca2					_RHUnderflow:
.1ca2	20 fc 10	jsr $10fc			jsr 	ErrorHandler
>1ca5	4d 49 53 53 49 4e 47 20				.text 	"MISSING RETURN",0
>1cad	52 45 54 55 52 4e 00
.1cb4					_RHInLoop:
.1cb4	20 fc 10	jsr $10fc			jsr 	ErrorHandler
>1cb7	52 45 54 55 52 4e 20 49				.text 	"RETURN IN LOOP ERROR",0
>1cbf	4e 20 4c 4f 4f 50 20 45 52 52 4f 52 00
.1ccc					CallHandlerDecode:
.1ccc	a9 03		lda #$03			lda 	#CTH_Call					; space
.1cce	20 94 1e	jsr $1e94			jsr 	DecodeWriteBuffer
.1cd1	b1 08		lda ($08),y			lda 	(srcPtr),y 					; get line number into YA
.1cd3	aa		tax				tax
.1cd4	c8		iny				iny
.1cd5	b1 08		lda ($08),y			lda 	(srcPtr),y
.1cd7	a8		tay				tay
.1cd8	8a		txa				txa
.1cd9	20 16 1d	jsr $1d16			jsr 	FindLine 					; try to locate that line.
.1cdc	b0 11		bcs $1cef			bcs 	_CHDFound 					; if found .....
.1cde					_CHDLineOnly:
.1cde	48		pha				pha
.1cdf	a9 3c		lda #$3c			lda 	#"<"
.1ce1	20 94 1e	jsr $1e94			jsr 	DecodeWriteBuffer
.1ce4	68		pla				pla
.1ce5	18		clc				clc 								; output unsigned
.1ce6	20 b6 1e	jsr $1eb6			jsr 	DecodeYAToBuffer
.1ce9	a9 3e		lda #$3e			lda 	#">"
.1ceb	20 94 1e	jsr $1e94			jsr 	DecodeWriteBuffer
.1cee	60		rts				rts
.1cef					_CHDFound:
.1cef	48		pha				pha 								; save YA
.1cf0	5a		phy				phy
.1cf1	a0 03		ldy #$03			ldy 	#3 							; check first is $$define
.1cf3	b1 10		lda ($10),y			lda 	(temp1),y
.1cf5	c9 e9		cmp #$e9			cmp 	#DefineCode & 255
.1cf7	d0 07		bne $1d00			bne 	_CHDNoDefine
.1cf9	c8		iny				iny
.1cfa	b1 10		lda ($10),y			lda 	(temp1),y
.1cfc	c9 21		cmp #$21			cmp 	#DefineCode >> 8
.1cfe	f0 04		beq $1d04			beq 	_CHDFoundDefine
.1d00					_CHDNoDefine:
.1d00	7a		ply				ply									; restore the line number and print it in <>
.1d01	68		pla				pla
.1d02	80 da		bra $1cde			bra 	_CHDLineOnly
.1d04					_CHDFoundDefine:
.1d04	68		pla				pla 								; throw saved line number.
.1d05	68		pla				pla
.1d06	a0 05		ldy #$05			ldy 	#5 							; 3,4 $$define 5 length, name has bit 7 set at end
.1d08					_CHDOutName:
.1d08	c8		iny				iny 								; next
.1d09	b1 10		lda ($10),y			lda 	(temp1),y 					; print char no bit 7
.1d0b	48		pha				pha
.1d0c	29 7f		and #$7f			and 	#$7F
.1d0e	20 94 1e	jsr $1e94			jsr 	DecodeWriteBuffer
.1d11	68		pla				pla
.1d12	0a		asl a				asl 	a 							; bit 7 to carry
.1d13	90 f3		bcc $1d08			bcc 	_CHDOutName
.1d15	60		rts				rts
.1d16					FindLine:
.1d16	48		pha				pha 								; save registers
.1d17	da		phx				phx
.1d18	5a		phy				phy
.1d19	85 12		sta $12				sta 	temp2 						; temp2 = target line#
.1d1b	84 13		sty $13				sty 	temp2+1
.1d1d	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.1d1f	85 10		sta $10				sta 	0+(temp1)
.1d21	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.1d23	85 11		sta $11				sta 	1+(temp1)
.1d25					_FLLoop:
.1d25	b2 10		lda ($10)			lda 	(temp1) 					; found end ?
.1d27	18		clc				clc									; if so exit with CC.
.1d28	f0 1d		beq $1d47			beq 	_FLExit
.1d2a	a0 01		ldy #$01			ldy 	#1 							; check line # match
.1d2c	b1 10		lda ($10),y			lda 	(temp1),y
.1d2e	c5 12		cmp $12				cmp 	temp2
.1d30	d0 08		bne $1d3a			bne 	_FLNext
.1d32	c8		iny				iny
.1d33	b1 10		lda ($10),y			lda 	(temp1),y
.1d35	c5 13		cmp $13				cmp 	temp2+1
.1d37	38		sec				sec 								; if so exit with CS
.1d38	f0 0d		beq $1d47			beq 	_FLExit
.1d3a					_FLNext:
.1d3a	18		clc				clc
.1d3b	a5 10		lda $10				lda 	temp1
.1d3d	72 10		adc ($10)			adc 	(temp1)
.1d3f	85 10		sta $10				sta 	temp1
.1d41	90 02		bcc $1d45			bcc 	_NoCarryAdv
.1d43	e6 11		inc $11				inc 	temp1+1
.1d45					_NoCarryAdv:
.1d45	80 de		bra $1d25			bra 	_FLLoop 					; keep looking.
.1d47					_FLExit:
.1d47	7a		ply				ply
.1d48	fa		plx				plx
.1d49	68		pla				pla
.1d4a	60		rts				rts
.1d4b	18		clc				clc
.1d4c	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/clrnew.src

.1d4d					NewHandler:
.1d4d	9c 00 40	stz $4000			stz 	ProgramMemory 				; Make the first offset zero.
.1d50	20 63 1d	jsr $1d63			jsr 	ClearVariableSpace 			; clear variables, reset pointers
.1d53	4c 00 00	jmp $0000			jmp 	NextCode
.1d56					ClrHandler:
.1d56	86 10		stx $10				stx 	temp1
.1d58	a2 80		ldx #$80			ldx 	#NumberStackBase
.1d5a	9a		txs				txs
.1d5b	a6 10		ldx $10				ldx 	temp1
.1d5d	20 63 1d	jsr $1d63			jsr 	ClearVariableSpace 			; clear variables, reset pointers
.1d60	4c 00 00	jmp $0000			jmp 	NextCode
.1d63					ClearVariableSpace:
.1d63	64 05		stz $05				stz 	rsp
.1d65	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.1d67	85 0e		sta $0e				sta 	0+(nextFreeMem)
.1d69	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.1d6b	85 0f		sta $0f				sta 	1+(nextFreeMem)
.1d6d	a0 1f		ldy #$1f			ldy 	#hashTableSize*2-1 			; erase the hash table (used for variables)
.1d6f					_CVSHashClear:
.1d6f	a9 00		lda #$00			lda 	#0 							; all the first record pointers are $00
.1d71	99 40 06	sta $0640,y			sta 	hashTable,y
.1d74	88		dey				dey
.1d75	10 f8		bpl $1d6f			bpl 	_CVSHashClear
.1d77					_CVSFindEnd:
.1d77	18		clc				clc
.1d78	a5 0e		lda $0e				lda 	nextFreeMem
.1d7a	72 0e		adc ($0e)			adc 	(nextFreeMem)
.1d7c	85 0e		sta $0e				sta 	nextFreeMem
.1d7e	90 02		bcc $1d82			bcc 	_NoCarryAdv
.1d80	e6 0f		inc $0f				inc 	nextFreeMem+1
.1d82					_NoCarryAdv:
.1d82	b2 0e		lda ($0e)			lda 	(nextFreeMem)
.1d84	d0 f1		bne $1d77			bne 	_CVSFindEnd
.1d86	a9 08		lda #$08			lda 	#8 							; this puts a gap in, more for clarity than anything.
.1d88	a0 00		ldy #$00			ldy 	#0
.1d8a	20 8e 1d	jsr $1d8e			jsr 	AdvanceFreeMem				; we need +1 because the previous code leaves the
.1d8d	60		rts				rts 								; free mem pointer pointing to the last zero offset
.1d8e					AdvanceFreeMem:
.1d8e	18		clc				clc
.1d8f	65 0e		adc $0e				adc 	nextFreeMem
.1d91	85 0e		sta $0e				sta 	nextFreeMem
.1d93	98		tya				tya
.1d94	65 0f		adc $0f				adc 	nextFreeMem+1
.1d96	85 0f		sta $0f				sta 	nextFreeMem+1
.1d98	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/debug.src

.1d99					ExitDump:
.1d99	ba		tsx				tsx 								; save Data Stack in temp1
.1d9a	86 10		stx $10				stx 	temp1
.1d9c	4c ff ff	jmp $ffff			jmp 	$FFFF 						; makes the X16-Emulator dump-exit.
.1d9f					BreakCmd:
>1d9f	ff						.byte 	$FF
.1da0	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/system/decode.src

.1da3					DecodeLineIntoBufPtr:
.1da3	48		pha				pha
.1da4	da		phx				phx
.1da5	5a		phy				phy
.1da6	85 08		sta $08				sta 	srcPtr 						; save the source line.
.1da8	84 09		sty $09				sty 	srcPtr+1
.1daa	90 1b		bcc $1dc7			bcc 	_DecodeNoLineNumber
.1dac	a0 01		ldy #$01			ldy 	#1 							; get line # to YA
.1dae	b1 08		lda ($08),y			lda 	(srcPtr),y
.1db0	aa		tax				tax
.1db1	c8		iny				iny
.1db2	b1 08		lda ($08),y			lda 	(srcPtr),y
.1db4	a8		tay				tay
.1db5	8a		txa				txa
.1db6	18		clc				clc
.1db7	20 b6 1e	jsr $1eb6			jsr 	DecodeYAToBuffer 			; convert to string in buffer
.1dba	aa		tax				tax 								; count in X
.1dbb					_DecodeLineSpace:
.1dbb	e0 05		cpx #$05			cpx 	#5
.1dbd	f0 08		beq $1dc7			beq 	_DecodeNoLineNumber
.1dbf	a9 20		lda #$20			lda 	#" " 						; pad to 5 spaces
.1dc1	20 94 1e	jsr $1e94			jsr 	DecodeWriteBuffer
.1dc4	e8		inx				inx
.1dc5	80 f4		bra $1dbb			bra 	_DecodeLineSpace
.1dc7					_DecodeNoLineNumber:
.1dc7	a0 03		ldy #$03			ldy 	#3 							; initial position.
.1dc9					_DecodeLoop:
.1dc9	b1 08		lda ($08),y			lda 	(srcPtr),y 					; copy the current character to temp1
.1dcb	85 10		sta $10				sta 	temp1 						; must be an execution address.
.1dcd	c8		iny				iny
.1dce	b1 08		lda ($08),y			lda 	(srcPtr),y
.1dd0	85 11		sta $11				sta 	temp1+1
.1dd2	c8		iny				iny 								; y points to the byte after it.
.1dd3	a5 10		lda $10				lda 	temp1
.1dd5	c9 a7		cmp #$a7			cmp 	#NextLine & $FF
.1dd7	d0 06		bne $1ddf			bne 	_DecodeNotEOL
.1dd9	a5 11		lda $11				lda 	temp1+1
.1ddb	c9 21		cmp #$21			cmp 	#NextLine >> 8
.1ddd	f0 0b		beq $1dea			beq 	_DecodeEOL
.1ddf					_DecodeNotEOL:
.1ddf	20 f2 1d	jsr $1df2			jsr 	IdentifyCodeWord
.1de2	20 3f 1e	jsr $1e3f			jsr 	DecodeFoundWord
.1de5	20 29 1e	jsr $1e29			jsr 	AdvanceToNext 				; advance to next entry in the line.
.1de8	80 df		bra $1dc9			bra 	_DecodeLoop 				; and go round again
.1dea					_DecodeEOL:
.1dea	a9 00		lda #$00			lda 	#0
.1dec	92 0a		sta ($0a)			sta 	(bufPtr)
.1dee	7a		ply				ply 								; restore registers and exit
.1def	fa		plx				plx
.1df0	68		pla				pla
.1df1	60		rts				rts
.1df2					IdentifyCodeWord:
.1df2	5a		phy				phy 								; save current position on the stack.
.1df3	a9 f6		lda #$f6			lda 	#(Dictionary) & $FF
.1df5	85 0c		sta $0c				sta 	0+(matchPtr)
.1df7	a9 24		lda #$24			lda 	#(Dictionary) >> 8
.1df9	85 0d		sta $0d				sta 	1+(matchPtr)
.1dfb					_DecodeIdentify:
.1dfb	a0 02		ldy #$02			ldy 	#2 							; have we found a match ?
.1dfd	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.1dff	c5 10		cmp $10				cmp 	temp1
.1e01	d0 07		bne $1e0a			bne 	_DecodeIdNext
.1e03	c8		iny				iny
.1e04	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.1e06	c5 11		cmp $11				cmp 	temp1+1
.1e08	f0 1d		beq $1e27			beq 	_DecodeIdFound
.1e0a					_DecodeIdNext:
.1e0a	18		clc				clc
.1e0b	b2 0c		lda ($0c)			lda 	(matchPtr)
.1e0d	f0 0a		beq $1e19			beq 	_DecodeIdIssue
.1e0f	65 0c		adc $0c				adc 	matchPtr
.1e11	85 0c		sta $0c				sta 	matchPtr
.1e13	90 e6		bcc $1dfb			bcc 	_DecodeIdentify
.1e15	e6 0d		inc $0d				inc 	matchPtr+1
.1e17	80 e2		bra $1dfb			bra 	_DecodeIdentify
.1e19					_DecodeIdIssue:
.1e19	20 fc 10	jsr $10fc			jsr 	ErrorHandler
>1e1c	44 45 43 4f 44 45 2f 42				.text 	"DECODE/BUG",0
>1e24	55 47 00
.1e27					_DecodeIdFound:
.1e27	7a		ply				ply 								; restore position.
.1e28	60		rts				rts
.1e29					AdvanceToNext:
.1e29	5a		phy				phy 								; get the parameter count from bits 0-1 of the type byte
.1e2a	a0 01		ldy #$01			ldy 	#1
.1e2c	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.1e2e	29 03		and #$03			and 	#3 							; bits 0-1.
.1e30	7a		ply				ply
.1e31	c9 03		cmp #$03			cmp 	#3 							; is it n-bytes e.g. specified by the next byte
.1e33	d0 02		bne $1e37			bne 	_ATN012
.1e35	b1 08		lda ($08),y			lda 	(srcPtr),y 					; if so, use that byte as the overall length.
.1e37					_ATN012:
.1e37	85 12		sta $12				sta 	temp2 						; now add that to Y
.1e39	98		tya				tya
.1e3a	18		clc				clc
.1e3b	65 12		adc $12				adc 	temp2
.1e3d	a8		tay				tay
.1e3e	60		rts				rts
.1e3f					DecodeFoundWord:
.1e3f	5a		phy				phy 								; save current position
.1e40	84 12		sty $12				sty		temp2 						; put it in temp2 as well.
.1e42	a0 01		ldy #$01			ldy 	#1 							; get the type byte
.1e44	b1 0c		lda ($0c),y			lda 	(matchPtr),y 				; is there a special decoder check (bit 4 set) ?
.1e46	29 10		and #$10			and 	#$10
.1e48	d0 0e		bne $1e58			bne 	_DFWSpecialDecoder
.1e4a	b1 0c		lda ($0c),y			lda 	(matchPtr),y 				; reget it.
.1e4c	30 08		bmi $1e56			bmi 	_DFWExit 					; if hidden word (bit 7 set)
.1e4e	a9 06		lda #$06			lda 	#CTH_Keyword				; output a space to the buffer
.1e50	20 94 1e	jsr $1e94			jsr 	DecodeWriteBuffer
.1e53	20 71 1e	jsr $1e71			jsr 	DecodeCurrentWord 			; expand that.
.1e56					_DFWExit:
.1e56	7a		ply				ply 								; restore current position
.1e57	60		rts				rts
.1e58					_DFWSpecialDecoder:
.1e58	a0 04		ldy #$04			ldy 	#4 							; the decode word address is at offset 4,5
.1e5a	b1 0c		lda ($0c),y			lda 	(matchPtr),y 				; copy this into temp2
.1e5c	85 12		sta $12				sta 	temp2
.1e5e	c8		iny				iny
.1e5f	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.1e61	85 13		sta $13				sta 	temp2+1
.1e63	7a		ply				ply 	 							; restore current position into Y
.1e64	48		pha				pha 								; save registers
.1e65	da		phx				phx
.1e66	5a		phy				phy
.1e67	20 6e 1e	jsr $1e6e			jsr 	_DFWCallDecoder				; call the decoder routine
.1e6a	7a		ply				ply 								; restore registers and exit
.1e6b	fa		plx				plx
.1e6c	68		pla				pla
.1e6d	60		rts				rts
.1e6e					_DFWCallDecoder:
.1e6e	6c 12 00	jmp ($0012)			jmp 	(temp2)
.1e71					DecodeCurrentWord:
.1e71	5a		phy				phy
.1e72	a0 01		ldy #$01			ldy 	#1 							; read type byte
.1e74	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.1e76	a0 04		ldy #$04			ldy 	#4 							; original offset
.1e78	4a		lsr a				lsr 	a 							; encoder/decoder bits in 0-1
.1e79	4a		lsr a				lsr 	a 							; add 2 to Y for each encoder/decoder
.1e7a	4a		lsr a				lsr 	a 							; bit set.
.1e7b	4a		lsr a				lsr 	a
.1e7c	4a		lsr a				lsr 	a 							; decoder bit
.1e7d	90 02		bcc $1e81			bcc 	_DWBNoDec
.1e7f	c8		iny				iny
.1e80	c8		iny				iny
.1e81					_DWBNoDec:
.1e81	4a		lsr a				lsr 	a
.1e82	90 02		bcc $1e86			bcc 	_DWBNoEnc
.1e84	c8		iny				iny
.1e85	c8		iny				iny
.1e86					_DWBNoEnc:
.1e86					_DWBWordOut:
.1e86	b1 0c		lda ($0c),y			lda 	(matchPtr),y 				; output until bit 7 set.
.1e88	48		pha				pha
.1e89	29 7f		and #$7f			and 	#$7F
.1e8b	20 94 1e	jsr $1e94			jsr		DecodeWriteBuffer
.1e8e	c8		iny				iny
.1e8f	68		pla				pla
.1e90	10 f4		bpl $1e86			bpl 	_DWBWordOut
.1e92	7a		ply				ply 								; restore Y and exit
.1e93	60		rts				rts
.1e94					DecodeWriteBuffer:
.1e94	92 0a		sta ($0a)			sta 	(bufPtr)
.1e96	e6 0a		inc $0a				inc 	bufPtr
.1e98	d0 02		bne $1e9c			bne 	_DWBNoCarry
.1e9a	e6 0b		inc $0b				inc 	bufPtr+1
.1e9c					_DWBNoCarry:
.1e9c	60		rts				rts
.1e9d					DecodeOutputData:
.1e9d	48		pha				pha
.1e9e	da		phx				phx
.1e9f	5a		phy				phy
.1ea0	b1 08		lda ($08),y			lda 	(srcPtr),y 					; length + 1
.1ea2	aa		tax				tax
.1ea3					_DODLoop:
.1ea3	ca		dex				dex 								; done it all ?
.1ea4	f0 0c		beq $1eb2			beq		_DODExit
.1ea6	c8		iny				iny 								; output next character
.1ea7	b1 08		lda ($08),y			lda 	(srcPtr),y
.1ea9	29 7f		and #$7f			and 	#$7F
.1eab	f0 f6		beq $1ea3			beq 	_DODLoop 					; don't print NULL
.1ead	20 94 1e	jsr $1e94			jsr 	DecodeWriteBuffer
.1eb0	80 f1		bra $1ea3			bra 	_DODLoop
.1eb2					_DODExit:
.1eb2	7a		ply				ply
.1eb3	fa		plx				plx
.1eb4	68		pla				pla
.1eb5	60		rts				rts
.1eb6					DecodeYAToBuffer:
.1eb6	da		phx				phx
.1eb7	5a		phy				phy
.1eb8	48		pha				pha
.1eb9	a5 0a		lda $0a				lda 	bufPtr 						; copy bufPtr to temp2
.1ebb	85 12		sta $12				sta 	temp2
.1ebd	a5 0b		lda $0b				lda 	bufPtr+1
.1ebf	85 13		sta $13				sta 	temp2+1
.1ec1	68		pla				pla
.1ec2	20 e0 22	jsr $22e0			jsr 	ConvertToStringMain 		; convert YA to string there
.1ec5	aa		tax				tax 								; chars output to X
.1ec6	18		clc				clc
.1ec7	65 0a		adc $0a				adc 	bufPtr 						; add to buffer pointer
.1ec9	85 0a		sta $0a				sta 	bufPtr
.1ecb	90 02		bcc $1ecf			bcc 	_DYABNoCarry
.1ecd	e6 0b		inc $0b				inc 	bufPtr+1
.1ecf					_DYABNoCarry:
.1ecf	8a		txa				txa 								; count in A
.1ed0	7a		ply				ply									; restore and exit.
.1ed1	fa		plx				plx
.1ed2	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/edit.src

.1ed3					EditProgram:
.1ed3	20 50 1f	jsr $1f50			jsr 	EDFindLine					; find line address -> temp1
.1ed6	90 0f		bcc $1ee7			bcc 	_EPNotFound 				; if missing don't delete it.
.1ed8	a5 10		lda $10				lda 	temp1 						; save line address
.1eda	48		pha				pha
.1edb	a5 11		lda $11				lda 	temp1+1
.1edd	48		pha				pha
.1ede	20 f5 1e	jsr $1ef5			jsr 	EDDeleteLine 				; delete the line
.1ee1	68		pla				pla 								; restore line address
.1ee2	85 11		sta $11				sta 	temp1+1
.1ee4	68		pla				pla
.1ee5	85 10		sta $10				sta 	temp1
.1ee7					_EPNotFound:
.1ee7	ad 10 09	lda $0910			lda 	encodeBuffer 				; is there anything in the line.
.1eea	c9 05		cmp #$05			cmp 	#5 							; <offset> <line#> <next line>
.1eec	f0 03		beq $1ef1			beq 	_EPNoInsert
.1eee	20 18 1f	jsr $1f18			jsr 	EDInsertLine 				; insert line back in.
.1ef1					_EPNoInsert:
.1ef1	20 63 1d	jsr $1d63			jsr 	ClearVariableSpace
.1ef4	60		rts				rts
.1ef5					EDDeleteLine:
.1ef5	20 63 1d	jsr $1d63			jsr 	ClearVariableSpace
.1ef8	a0 00		ldy #$00			ldy 	#0 							; this is the offset to copy down.
.1efa	a2 00		ldx #$00			ldx 	#0
.1efc	b1 10		lda ($10),y			lda 	(temp1),y
.1efe	a8		tay				tay 								; put in Y
.1eff					_EDDelLoop:
.1eff	b1 10		lda ($10),y			lda 	(temp1),y 					; get it
.1f01	81 10		sta ($10,x)			sta 	(temp1,x) 					; write it.
.1f03	a5 10		lda $10				lda 	temp1 						; check if pointer has reached the end of
.1f05	c5 0e		cmp $0e				cmp		nextFreeMem 				; low memory. We will have copied down an
.1f07	d0 06		bne $1f0f			bne 	_EDDelNext 					; extra pile of stuff - technically should
.1f09	a5 11		lda $11				lda 	temp1+1 					; check the upper value (e.g. temp1+y)
.1f0b	c5 0f		cmp $0f				cmp 	nextFreeMem+1				; doesn't really matter.
.1f0d	f0 08		beq $1f17			beq		_EDDelExit
.1f0f					_EDDelNext:
.1f0f	e6 10		inc $10				inc 	temp1 						; go to next byte.
.1f11	d0 ec		bne $1eff			bne 	_EDDelLoop
.1f13	e6 11		inc $11				inc 	temp1+1
.1f15	80 e8		bra $1eff			bra 	_EDDelLoop
.1f17					_EDDelExit:
.1f17	60		rts				rts
.1f18					EDInsertLine:
.1f18	20 63 1d	jsr $1d63			jsr 	ClearVariableSpace
.1f1b	a5 0e		lda $0e				lda 	nextFreeMem 				; copy high memory to temp3
.1f1d	85 14		sta $14				sta 	temp3
.1f1f	a5 0f		lda $0f				lda 	nextFreeMem+1
.1f21	85 15		sta $15				sta 	temp3+1
.1f23	ac 10 09	ldy $0910			ldy 	encodeBuffer 				; space to move it to in Y
.1f26	a2 00		ldx #$00			ldx 	#0
.1f28					_EDInsLoop:
.1f28	a1 14		lda ($14,x)			lda 	(temp3,x)					; copy it up
.1f2a	91 14		sta ($14),y			sta 	(temp3),y
.1f2c	a5 14		lda $14				lda 	temp3 						; reached the insert point (temp1)
.1f2e	c5 10		cmp $10				cmp 	temp1
.1f30	d0 06		bne $1f38			bne 	_EDINextShift
.1f32	a5 15		lda $15				lda 	temp3+1
.1f34	c5 11		cmp $11				cmp 	temp1+1
.1f36	f0 0a		beq $1f42			beq 	_EDIShiftOver
.1f38					_EDINextShift:
.1f38	a5 14		lda $14				lda 	temp3 						; decrement the copy pointer.
.1f3a	d0 02		bne $1f3e			bne 	_EDINoBorrow
.1f3c	c6 15		dec $15				dec 	temp3+1
.1f3e					_EDINoBorrow:
.1f3e	c6 14		dec $14				dec 	temp3
.1f40	80 e6		bra $1f28			bra 	_EDInsLoop
.1f42					_EDIShiftOver:
.1f42	a0 00		ldy #$00			ldy 	#0
.1f44					_EDICopyCode:
.1f44	b9 10 09	lda $0910,y			lda 	encodeBuffer,y				; read from the current line
.1f47	91 10		sta ($10),y			sta 	(temp1),y 					; write out
.1f49	c8		iny				iny 								; bump pointers
.1f4a	cc 10 09	cpy $0910			cpy 	encodeBuffer 				; done the whole lot ?
.1f4d	d0 f5		bne $1f44			bne 	_EDICopyCode
.1f4f	60		rts				rts
.1f50					EDFindLine:
.1f50	a9 00		lda #$00			lda 	#(programMemory) & $FF
.1f52	85 10		sta $10				sta 	0+(temp1)
.1f54	a9 40		lda #$40			lda 	#(programMemory) >> 8
.1f56	85 11		sta $11				sta 	1+(temp1)
.1f58					_EDFLLoop:
.1f58	b2 10		lda ($10)			lda 	(temp1) 					; check offset
.1f5a	f0 24		beq $1f80			beq 	_EDFLFail 					; then obviously that's the end ;-) (great comment !)
.1f5c	a0 01		ldy #$01			ldy 	#1							; look at line #
.1f5e	38		sec				sec
.1f5f	ad 11 09	lda $0911			lda 	encodeBuffer+1				; subtract the current from the target
.1f62	f1 10		sbc ($10),y			sbc 	(temp1),y 					; so if searching for 100 and this one is 90,
.1f64	aa		tax				tax	 								; this will return 10.
.1f65	ad 12 09	lda $0912			lda 	encodeBuffer+2
.1f68	c8		iny				iny
.1f69	f1 10		sbc ($10),y			sbc 	(temp1),y
.1f6b	90 13		bcc $1f80			bcc 	_EDFLFail					; if target < current then failed.
.1f6d	d0 04		bne $1f73			bne 	_EDFLNext 					; if non-zero then goto next
.1f6f	e0 00		cpx #$00			cpx 	#0 							; same for the LSB - zero if match found.
.1f71	f0 0f		beq $1f82			beq 	_EDFLFound
.1f73					_EDFLNext:
.1f73	18		clc				clc
.1f74	a5 10		lda $10				lda 	temp1
.1f76	72 10		adc ($10)			adc 	(temp1)
.1f78	85 10		sta $10				sta 	temp1
.1f7a	90 02		bcc $1f7e			bcc 	_NoCarryAdv
.1f7c	e6 11		inc $11				inc 	temp1+1
.1f7e					_NoCarryAdv:
.1f7e	80 d8		bra $1f58			bra 	_EDFLLoop
.1f80					_EDFLFail:
.1f80	18		clc				clc
.1f81	60		rts				rts
.1f82					_EDFLFound:
.1f82	38		sec				sec
.1f83	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/list.src

.1f84					ListCode:
.1f84	64 1e		stz $1e				stz 	ListLowest 					; zero lowest line#
.1f86	64 1f		stz $1f				stz 	ListLowest+1
.1f88	a9 18		lda #$18			lda 	#24 						; show max 24 after lowest line
.1f8a	85 1d		sta $1d				sta 	ListCount
.1f8c	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.1f8e	85 18		sta $18				sta 	0+(listPtr)
.1f90	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.1f92	85 19		sta $19				sta 	1+(listPtr)
.1f94	86 10		stx $10				stx 	temp1						; S->A
.1f96	ba		tsx				tsx
.1f97	8a		txa				txa
.1f98	a6 10		ldx $10				ldx 	temp1
.1f9a	c9 80		cmp #$80			cmp 	#NumberStackBase
.1f9c	f0 0e		beq $1fac			beq 	_LCLoop
.1f9e	a5 06		lda $06				lda 	TOS 						; copy TOS to lowest
.1fa0	85 1e		sta $1e				sta 	ListLowest
.1fa2	a5 07		lda $07				lda 	TOS+1
.1fa4	85 1f		sta $1f				sta 	ListLowest+1
.1fa6	68		pla				pla
.1fa7	85 07		sta $07				sta 	TOS+1
.1fa9	68		pla				pla
.1faa	85 06		sta $06				sta 	TOS
.1fac					_LCLoop:
.1fac	b2 18		lda ($18)			lda 	(listPtr)					; reached end ?
.1fae	f0 4c		beq $1ffc			beq 	_LCExit
.1fb0	a0 01		ldy #$01			ldy 	#1							; >= list lowest
.1fb2	b1 18		lda ($18),y			lda 	(listPtr),y
.1fb4	c5 1e		cmp $1e				cmp 	ListLowest
.1fb6	c8		iny				iny
.1fb7	b1 18		lda ($18),y			lda 	(listPtr),y
.1fb9	e5 1f		sbc $1f				sbc 	ListLowest+1
.1fbb	90 32		bcc $1fef			bcc 	_LCNext
.1fbd	a9 10		lda #$10			lda 	#(textBuffer) & $FF
.1fbf	85 0a		sta $0a				sta 	0+(bufPtr)
.1fc1	a9 08		lda #$08			lda 	#(textBuffer) >> 8
.1fc3	85 0b		sta $0b				sta 	1+(bufPtr)
.1fc5	a5 18		lda $18				lda 	listPtr 					; output the line.
.1fc7	a4 19		ldy $19				ldy 	listPtr+1
.1fc9	38		sec				sec
.1fca	20 a3 1d	jsr $1da3			jsr 	DecodeLineIntoBufPtr
.1fcd	a9 02		lda #$02			lda 	#CTH_LineNo
.1fcf	20 68 11	jsr $1168			jsr 	ExternColour
.1fd2	a0 ff		ldy #$ff			ldy 	#255
.1fd4					_LCLoop2:
.1fd4	c8		iny				iny
.1fd5	b9 10 08	lda $0810,y			lda 	textBuffer,y
.1fd8	f0 0e		beq $1fe8			beq 	_LCEnd
.1fda	c9 20		cmp #$20			cmp 	#32
.1fdc	b0 05		bcs $1fe3			bcs 	_LCPrint
.1fde	20 68 11	jsr $1168			jsr 	ExternColour
.1fe1	a9 20		lda #$20			lda 	#32
.1fe3					_LCPrint:
.1fe3	20 5c 11	jsr $115c			jsr 	ExternPrint
.1fe6	80 ec		bra $1fd4			bra 	_LCLoop2
.1fe8	a9 0d		lda #$0d	_LCEnd:	lda 	#13 						; new line
.1fea	20 5c 11	jsr $115c			jsr 	ExternPrint
.1fed	c6 1d		dec $1d				dec 	ListCount					; done all the lines allowed
.1fef					_LCNext:
.1fef	18		clc				clc
.1ff0	a5 18		lda $18				lda 	listPtr
.1ff2	72 18		adc ($18)			adc 	(listPtr)
.1ff4	85 18		sta $18				sta 	listPtr
.1ff6	90 02		bcc $1ffa			bcc 	_NoCarryAdv
.1ff8	e6 19		inc $19				inc 	listPtr+1
.1ffa					_NoCarryAdv:
.1ffa	80 b0		bra $1fac			bra 	_LCLoop 					; go round again.
.1ffc					_LCExit:
.1ffc	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/system/miscellany.src

.1fff					RunProgram:
.1fff	86 10		stx $10				stx 	temp1
.2001	a2 80		ldx #$80			ldx 	#NumberStackBase
.2003	9a		txs				txs
.2004	a6 10		ldx $10				ldx 	temp1
.2006	20 63 1d	jsr $1d63			jsr 	ClearVariableSpace 			; clear variables etc.
.2009	a2 00		ldx #$00			ldx		#ProgramMemory & $FF		; boot address
.200b	a0 40		ldy #$40			ldy 	#ProgramMemory >>8
.200d	20 93 10	jsr $1093			jsr 	InitialiseCoreCode 			; initialise the NEXT routine at $00
.2010	4c 00 00	jmp $0000			jmp 	NextCode
.2013					Call6502:
.2013	a5 06		lda $06				lda 	TOS 						; copy call address
.2015	85 10		sta $10				sta 	temp1
.2017	a5 07		lda $07				lda 	TOS+1
.2019	85 11		sta $11				sta 	temp1+1
.201b	68		pla				pla
.201c	85 07		sta $07				sta 	TOS+1
.201e	68		pla				pla
.201f	85 06		sta $06				sta 	TOS
.2021	20 27 20	jsr $2027			jsr 	_CallTemp1 					; call it
.2024	4c 00 00	jmp $0000			jmp 	NextCode
.2027					_CallTemp1:
.2027	6c 10 00	jmp ($0010)			jmp 	(temp1)
.202a					AssertCode:
.202a	a5 06		lda $06				lda 	TOS 						; TOS = 0
.202c	05 07		ora $07				ora 	TOS+1
.202e	f0 09		beq $2039			beq 	_ASFail 					; if zero fail
.2030	68		pla				pla
.2031	85 07		sta $07				sta 	TOS+1
.2033	68		pla				pla
.2034	85 06		sta $06				sta 	TOS
.2036	4c 00 00	jmp $0000			jmp 	NextCode
.2039					_ASFail:
.2039	20 fc 10	jsr $10fc			jsr 	ErrorHandler
>203c	41 53 53 45 52 54 00				.text 	"ASSERT",0
.2043					StopCode:
.2043	20 fc 10	jsr $10fc			jsr 	ErrorHandler
>2046	53 54 4f 50 00					.text 	"STOP",0
.204b					EndProgram:
.204b	4c 14 10	jmp $1014			jmp 	WarmStart
.204e					VlistCode:
.204e	a9 f6		lda #$f6			lda 	#(Dictionary) & $FF
.2050	85 10		sta $10				sta 	0+(temp1)
.2052	a9 24		lda #$24			lda 	#(Dictionary) >> 8
.2054	85 11		sta $11				sta 	1+(temp1)
.2056	a0 01		ldy #$01	_VLLoop:ldy 	#1							; type byte
.2058	b1 10		lda ($10),y			lda 	(temp1),y
.205a	a0 04		ldy #$04			ldy 	#4 							; Y = 4
.205c	4a		lsr a				lsr 	a 							; shift bits 4 and 5 to 0,1
.205d	4a		lsr a				lsr 	a
.205e	4a		lsr a				lsr		a
.205f	4a		lsr a				lsr 	a
.2060	4a		lsr a				lsr 	a 							; add those bits in
.2061	90 02		bcc $2065			bcc 	_VLNoDec
.2063	c8		iny				iny
.2064	c8		iny				iny
.2065					_VLNoDec:
.2065	4a		lsr a				lsr 	a
.2066	90 02		bcc $206a			bcc 	_VLNoEnc
.2068	c8		iny				iny
.2069	c8		iny				iny
.206a					_VLNoEnc:
.206a	b1 10		lda ($10),y			lda 	(temp1),y 					; remove $$ words
.206c	c9 24		cmp #$24			cmp 	#"$"
.206e	d0 06		bne $2076			bne 	_VLPrint
.2070	c8		iny				iny
.2071	51 10		eor ($10),y			eor 	(temp1),y
.2073	f0 13		beq $2088			beq 	_VLNext
.2075	88		dey				dey
.2076					_VLPrint:
.2076	b1 10		lda ($10),y			lda 	(temp1),y
.2078	48		pha				pha
.2079	c8		iny				iny
.207a	29 7f		and #$7f			and 	#$7F
.207c	20 5c 11	jsr $115c			jsr 	ExternPrint
.207f	68		pla				pla
.2080	0a		asl a				asl 	a
.2081	90 f3		bcc $2076			bcc 	_VLPrint
.2083	a9 20		lda #$20			lda 	#32
.2085	20 5c 11	jsr $115c			jsr 	ExternPrint
.2088					_VLNext:
.2088	18		clc				clc 								; go to next
.2089	b2 10		lda ($10)			lda 	(temp1)
.208b	65 10		adc $10				adc 	temp1
.208d	85 10		sta $10				sta 	temp1
.208f	90 02		bcc $2093			bcc 	_VLNoCarry
.2091	e6 11		inc $11				inc 	temp1+1
.2093					_VLNoCarry:
.2093	b2 10		lda ($10)			lda 	(temp1)
.2095	d0 bf		bne $2056			bne 	_VLLoop
.2097	a9 0d		lda #$0d			lda 	#13
.2099	20 5c 11	jsr $115c			jsr 	ExternPrint
.209c	4c 00 00	jmp $0000			jmp 	NextCode
.209f					DumpStack:
.209f	a9 5b		lda #$5b			lda		#"["
.20a1	20 5c 11	jsr $115c			jsr 	ExternPrint
.20a4	86 10		stx $10				stx 	temp1 						; X -> A
.20a6	ba		tsx				tsx
.20a7	8a		txa				txa
.20a8	a6 10		ldx $10				ldx 	temp1
.20aa	c9 80		cmp #$80			cmp 	#NumberStackBase 			; out of range, exit
.20ac	f0 2f		beq $20dd			beq 	_DSExit
.20ae	48		pha				pha 								; save it
.20af	a9 07		lda #$07			lda 	#COL_WHITE
.20b1	20 68 11	jsr $1168			jsr 	ExternColour
.20b4	a5 06		lda $06				lda 	TOS 						; print TOS then stack values backwards
.20b6	a4 07		ldy $07				ldy 	TOS+1
.20b8	38		sec				sec 								; print unsigned.
.20b9	20 ba 22	jsr $22ba			jsr 	PrintYA
.20bc	a9 06		lda #$06			lda 	#COL_CYAN
.20be	20 68 11	jsr $1168			jsr 	ExternColour
.20c1	7a		ply				ply 								; restore offset
.20c2					_DSLoop:
.20c2	c0 7e		cpy #$7e			cpy 	#NumberStackBase-2 			; till done whole stack.
.20c4	f0 17		beq $20dd			beq 	_DSExit
.20c6	a9 20		lda #$20			lda 	#" " 						; space
.20c8	20 5c 11	jsr $115c			jsr 	ExternPrint
.20cb	5a		phy				phy 								; save pos
.20cc	b9 01 01	lda $0101,y			lda 	$0101,y 					; read stack item
.20cf	48		pha				pha
.20d0	b9 02 01	lda $0102,y			lda 	$0102,y
.20d3	7a		ply				ply
.20d4	38		sec				sec
.20d5	20 ba 22	jsr $22ba			jsr 	PrintYA 					; print it
.20d8	7a		ply				ply 								; restore and advance pos
.20d9	c8		iny				iny
.20da	c8		iny				iny
.20db	80 e5		bra $20c2			bra 	_DSLoop
.20dd					_DSExit:
.20dd	a9 5d		lda #$5d			lda		#"]"
.20df	20 5c 11	jsr $115c			jsr 	ExternPrint
.20e2	a9 0d		lda #$0d			lda 	#13
.20e4	20 5c 11	jsr $115c			jsr 	ExternPrint
.20e7	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/system/saveload.src

.20ea					System_Save:
.20ea	20 63 1d	jsr $1d63			jsr 	ClearVariableSpace  		; make sure start/end are right
.20ed	20 6c 21	jsr $216c			jsr 	ExtendWithDictionary 		; attach the dictionary addresses.
.20f0	20 18 21	jsr $2118			jsr 	SLGetFileName 				; get filename -> temp3
.20f3	a5 0e		lda $0e				lda 	nextFreeMem 				; end address
.20f5	85 10		sta $10				sta 	temp1
.20f7	a5 0f		lda $0f				lda 	nextFreeMem+1
.20f9	85 11		sta $11				sta 	temp1+1
.20fb	a9 00		lda #$00			lda 	#ProgramMemory & $FF 		; program start to YA
.20fd	a0 40		ldy #$40			ldy 	#ProgramMemory >> 8
.20ff	20 b0 11	jsr $11b0			jsr 	ExternSave
.2102	20 63 1d	jsr $1d63			jsr 	ClearVariableSpace  		; make sure start/end are right
.2105	4c 0d 10	jmp $100d			jmp 	WarmStartBlankStack
.2108					System_Load:
.2108	20 18 21	jsr $2118			jsr 	SLGetFileName 				; get filename -> temp3
.210b	a9 00		lda #$00			lda 	#ProgramMemory & $FF 		; program start to YA
.210d	a0 40		ldy #$40			ldy 	#ProgramMemory >> 8
.210f	20 e6 11	jsr $11e6			jsr 	ExternLoad
.2112	20 63 1d	jsr $1d63			jsr 	ClearVariableSpace 			; reset everything.
.2115	4c 0d 10	jmp $100d			jmp 	WarmStartBlankStack
.2118					SLGetFileName:
.2118	ba		tsx				tsx
.2119	e0 80		cpx #$80			cpx 	#NumberStackBase
.211b	f0 3a		beq $2157			beq 	_SLFNFail
.211d	a9 10		lda #$10			lda 	#textBuffer & $FF 			; f/n in input buffer.
.211f	85 14		sta $14				sta 	temp3
.2121	a9 08		lda #$08			lda 	#textBuffer >> 8
.2123	85 15		sta $15				sta 	temp3+1
.2125	a0 00		ldy #$00			ldy 	#0
.2127	b1 06		lda ($06),y	_SLCopy:lda 	(TOS),y
.2129	91 14		sta ($14),y			sta 	(temp3),y
.212b	c8		iny				iny
.212c	c9 00		cmp #$00			cmp		#0
.212e	d0 f7		bne $2127			bne 	_SLCopy
.2130	88		dey				dey
.2131	a2 03		ldx #$03			ldx 	#3 							; check if it ends in .RPL
.2133					_SLCheckEnd:
.2133	88		dey				dey
.2134	bd 67 21	lda $2167,x			lda 	_SLFNExtension,x
.2137	d1 14		cmp ($14),y			cmp 	(temp3),y
.2139	d0 05		bne $2140			bne 	_SLNoExtension
.213b	ca		dex				dex
.213c	10 f5		bpl $2133			bpl 	_SLCheckEnd
.213e	80 16		bra $2156			bra 	_SLExit
.2140					_SLNoExtension:
.2140	a0 ff		ldy #$ff			ldy 	#255						; add the extension.
.2142					_SLFindend:
.2142	c8		iny				iny
.2143	b9 10 08	lda $0810,y			lda 	textBuffer,y
.2146	d0 fa		bne $2142			bne 	_SLFindend
.2148	a2 00		ldx #$00			ldx 	#0
.214a					_SLAppend:
.214a	bd 67 21	lda $2167,x			lda 	_SLFNExtension,x
.214d	99 10 08	sta $0810,y			sta 	textBuffer,y
.2150	e8		inx				inx
.2151	c8		iny				iny
.2152	c9 00		cmp #$00			cmp 	#0
.2154	d0 f4		bne $214a			bne 	_SLAppend
.2156					_SLExit:
.2156	60		rts				rts
.2157					_SLFNFail:
.2157	20 fc 10	jsr $10fc			jsr 	ErrorHandler
>215a	42 41 44 20 46 49 4c 45				.text 	"BAD FILENAME",0
>2162	4e 41 4d 45 00
.2167					_SLFNExtension:
>2167	2e 52 50 4c 00					.text 	".RPL",0
.216c					ExtendWithDictionary:
.216c	20 95 21	jsr $2195			jsr 	_EWDMarker 					; 8 bytes after the final offset write a marker
.216f	a9 f6		lda #$f6			lda 	#(Dictionary) & $FF
.2171	85 10		sta $10				sta 	0+(temp1)
.2173	a9 24		lda #$24			lda 	#(Dictionary) >> 8
.2175	85 11		sta $11				sta 	1+(temp1)
.2177					_EWDLoop:
.2177	b2 10		lda ($10)			lda 	(temp1)						; end
.2179	f0 1a		beq $2195			beq 	_EWDMarker
.217b	a0 02		ldy #$02			ldy 	#2 							; output the address
.217d	b1 10		lda ($10),y			lda 	(temp1),y
.217f	20 9e 21	jsr $219e			jsr 	_EWDWrite
.2182	c8		iny				iny
.2183	b1 10		lda ($10),y			lda 	(temp1),y
.2185	20 9e 21	jsr $219e			jsr 	_EWDWrite
.2188	18		clc				clc 								; next entry.
.2189	a5 10		lda $10				lda 	temp1
.218b	72 10		adc ($10)			adc 	(temp1)
.218d	85 10		sta $10				sta 	temp1
.218f	90 e6		bcc $2177			bcc 	_EWDLoop
.2191	e6 11		inc $11				inc 	temp1+1
.2193	80 e2		bra $2177			bra 	_EWDLoop
.2195					_EWDMarker:
.2195	a9 ff		lda #$ff			lda 	#$FF
.2197	20 9e 21	jsr $219e			jsr 	_EWDWrite
.219a	20 9e 21	jsr $219e			jsr 	_EWDWrite
.219d	60		rts				rts
.219e					_EWDWrite:
.219e	92 0e		sta ($0e)			sta 	(nextFreeMem)
.21a0	e6 0e		inc $0e				inc 	nextFreeMem
.21a2	d0 02		bne $21a6			bne 	_EWDExit
.21a4	e6 0f		inc $0f				inc 	nextFreeMem+1
.21a6					_EWDExit:
.21a6	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/skipper.src

.21a7					NextLine:
.21a7	18		clc				clc
.21a8	a5 03		lda $03				lda 	IP
.21aa	72 03		adc ($03)			adc 	(IP)
.21ac	85 03		sta $03				sta 	IP
.21ae	90 02		bcc $21b2			bcc 	_NoCarryAdv
.21b0	e6 04		inc $04				inc 	IP+1
.21b2					_NoCarryAdv:
.21b2	b2 03		lda ($03)			lda 	(IP)						; is there any following program ?
.21b4	f0 05		beq $21bb			beq 	_NLGoEnd
.21b6	a2 01		ldx #$01			ldx 	#1 							; start 3 in (-2 for Next)
.21b8	4c 00 00	jmp $0000			jmp 	NextCode
.21bb					_NLGoEnd:
.21bb	4c 14 10	jmp $1014			jmp 	WarmStart
.21be					SkipComment:
.21be	e8		inx				inx									; (IP),X points to the length.
.21bf	e8		inx				inx
.21c0	8a		txa				txa
.21c1	a8		tay				tay 								; put into Y
.21c2	18		clc				clc
.21c3	71 03		adc ($03),y			adc 	(IP),y 						; add the length to X
.21c5	aa		tax				tax 								; put back in X
.21c6	ca		dex				dex
.21c7	ca		dex				dex
.21c8	4c 00 00	jmp $0000			jmp 	NextCode
.21cb					CommentDecoder:
.21cb	a9 06		lda #$06			lda 	#CTH_Keyword
.21cd	20 94 1e	jsr $1e94			jsr 	DecodeWriteBuffer
.21d0	a9 27		lda #$27			lda 	#"'"
.21d2	20 94 1e	jsr $1e94			jsr 	DecodeWriteBuffer
.21d5	b1 08		lda ($08),y			lda 	(srcPtr),y 					; check if there is no data
.21d7	c9 01		cmp #$01			cmp 	#1
.21d9	f0 0d		beq $21e8			beq 	_CDEmpty 					; if so print nothing.
.21db	a9 0b		lda #$0b			lda 	#CTH_Comment
.21dd	20 94 1e	jsr $1e94			jsr 	DecodeWriteBuffer
.21e0	20 9d 1e	jsr $1e9d			jsr 	DecodeOutputData
.21e3	a9 20		lda #$20			lda 	#32
.21e5	20 94 1e	jsr $1e94			jsr 	DecodeWriteBuffer
.21e8					_CDEmpty
.21e8	60		rts				rts
.21e9					DefineCode:
.21e9	20 fc 10	jsr $10fc			jsr 	ErrorHandler
>21ec	52 45 41 43 48 45 44 20				.text 	"REACHED DEFINITION",0
>21f4	44 45 46 49 4e 49 54 49 4f 4e 00
.21ff					DefineDecoder:
.21ff	a9 07		lda #$07			lda 	#CTH_Definition
.2201	20 94 1e	jsr $1e94			jsr 	DecodeWriteBuffer
.2204	a9 3a		lda #$3a			lda 	#":"
.2206	20 94 1e	jsr $1e94			jsr 	DecodeWriteBuffer
.2209	20 9d 1e	jsr $1e9d			jsr 	DecodeOutputData
.220c	a9 20		lda #$20			lda 	#32
.220e	20 94 1e	jsr $1e94			jsr 	DecodeWriteBuffer
.2211	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/toint.src

.2212					ConvertToInteger:
.2212	84 17		sty $17				sty 	temp4+1
.2214	85 16		sta $16				sta 	temp4
.2216	64 14		stz $14				stz 	temp3 						; reset value
.2218	64 15		stz $15				stz 	temp3+1
.221a	64 10		stz $10				stz 	temp1 						; temp1 = 0 (decimal) 255 (hex)
.221c	a0 00		ldy #$00			ldy 	#0 							; look at first character
.221e	b1 16		lda ($16),y			lda 	(temp4),y
.2220	49 2d		eor #$2d			eor 	#"-"						; zero if '-'
.2222	85 11		sta $11				sta 	temp1+1 					; save this in temp1+1
.2224	d0 01		bne $2227			bne 	_CTINotMinus
.2226	c8		iny				iny									; skip -
.2227					_CTINotMinus:
.2227	b1 16		lda ($16),y			lda 	(temp4),y
.2229	c9 24		cmp #$24			cmp		#'$'						; if $ then skip it and set hex flag
.222b	d0 03		bne $2230			bne 	_CTILoop
.222d	c6 10		dec $10				dec 	temp1
.222f	c8		iny				iny
.2230					_CTILoop:
.2230	b1 16		lda ($16),y			lda 	(temp4),y 					; next digit
.2232	29 7f		and #$7f			and 	#$7F 						; drop end of word flag
.2234	38		sec				sec
.2235	e9 30		sbc #$30			sbc 	#'0' 						; put in range '0'+
.2237	90 65		bcc $229e			bcc 	_CTIFail 					; out of range.
.2239	c9 0a		cmp #$0a			cmp 	#10 						; in 0-9 ?
.223b	90 0b		bcc $2248			bcc 	_CTILegal
.223d	c9 11		cmp #$11			cmp 	#'A'-'0'					; between 9 and A ?
.223f	90 5d		bcc $229e			bcc 	_CTIFail
.2241	38		sec				sec
.2242	e9 07		sbc #$07			sbc 	#7 							; hex adjust
.2244	c9 10		cmp #$10			cmp 	#16 						; out of range ?
.2246	b0 56		bcs $229e			bcs 	_CTIFail
.2248					_CTILegal:
.2248	48		pha				pha 								; save digit value.
.2249	06 14		asl $14				asl 	temp3
.224b	26 15		rol $15				rol 	temp3+1
.224d	a5 14		lda $14				lda 	temp3 						; copy x2 into temp2
.224f	85 12		sta $12				sta 	temp2
.2251	a5 15		lda $15				lda 	temp3+1
.2253	85 13		sta $13				sta 	temp2+1
.2255	06 14		asl $14				asl 	temp3
.2257	26 15		rol $15				rol 	temp3+1
.2259	06 14		asl $14				asl 	temp3
.225b	26 15		rol $15				rol 	temp3+1
.225d	24 10		bit $10				bit 	temp1 						; hexadecimal
.225f	10 07		bpl $2268			bpl 	_CTIDecimal
.2261	06 14		asl $14				asl 	temp3
.2263	26 15		rol $15				rol 	temp3+1
.2265	68		pla				pla 								; get digit back
.2266	80 12		bra $227a			bra 	_CTIAddLoop
.2268					_CTIDecimal:
.2268	18		clc				clc 								; x 8 + x 2 = x 10
.2269	a5 14		lda $14				lda 	temp3
.226b	65 12		adc $12				adc 	temp2
.226d	85 14		sta $14				sta 	temp3
.226f	a5 15		lda $15				lda 	temp3+1
.2271	65 13		adc $13				adc 	temp2+1
.2273	85 15		sta $15				sta 	temp3+1
.2275	68		pla				pla 								; check digit 0-9
.2276	c9 0a		cmp #$0a			cmp 	#10
.2278	b0 24		bcs $229e			bcs 	_CTIFail
.227a					_CTIAddLoop:
.227a	18		clc				clc
.227b	65 14		adc $14				adc 	temp3
.227d	85 14		sta $14				sta 	temp3
.227f	90 02		bcc $2283			bcc 	_CTINoCarry
.2281	e6 15		inc $15				inc 	temp3+1
.2283					_CTINoCarry:
.2283	c8		iny				iny
.2284	b1 16		lda ($16),y			lda 	(temp4),y 					; was this the last character
.2286	c9 21		cmp #$21			cmp 	#32+1
.2288	b0 a6		bcs $2230			bcs 	_CTILoop 					; no, go back.
.228a	a5 11		lda $11				lda 	temp1+1 					; was it - ?
.228c	d0 0d		bne $229b			bne 	_CTIOkay
.228e	38		sec				sec
.228f	a9 00		lda #$00			lda 	#0 							; negate temp3.
.2291	e5 14		sbc $14				sbc 	temp3
.2293	85 14		sta $14				sta 	temp3
.2295	a9 00		lda #$00			lda 	#0
.2297	e5 15		sbc $15				sbc 	temp3+1
.2299	85 15		sta $15				sta 	temp3+1
.229b					_CTIOkay:
.229b	98		tya				tya
.229c	38		sec				sec
.229d	60		rts				rts
.229e					_CTIFail:
.229e	18		clc				clc
.229f	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/tostr.src

.22a0					IntToString:
.22a0	a9 10		lda #$10			lda 	#(textBuffer) & $FF
.22a2	85 12		sta $12				sta 	0+(temp2)
.22a4	a9 08		lda #$08			lda 	#(textBuffer) >> 8
.22a6	85 13		sta $13				sta 	1+(temp2)
.22a8	a5 06		lda $06				lda 	TOS 						; value in YA
.22aa	a4 07		ldy $07				ldy 	TOS+1
.22ac	20 dc 22	jsr $22dc			jsr 	ConvertToString
.22af	a9 10		lda #$10			lda 	#(textBuffer) & $FF
.22b1	85 06		sta $06				sta 	0+(TOS)
.22b3	a9 08		lda #$08			lda 	#(textBuffer) >> 8
.22b5	85 07		sta $07				sta 	1+(TOS)
.22b7	4c 00 00	jmp $0000			jmp 	NextCode
.22ba					PrintYA:
.22ba	48		pha				pha
.22bb	da		phx				phx
.22bc	5a		phy				phy
.22bd	48		pha				pha
.22be	a9 10		lda #$10			lda 	#(textBuffer) & $FF
.22c0	85 12		sta $12				sta 	0+(temp2)
.22c2	a9 08		lda #$08			lda 	#(textBuffer) >> 8
.22c4	85 13		sta $13				sta 	1+(temp2)
.22c6	68		pla				pla
.22c7	20 e0 22	jsr $22e0			jsr 	ConvertToStringMain
.22ca	a2 00		ldx #$00			ldx 	#0
.22cc					_PrintYALoop:
.22cc	bd 10 08	lda $0810,x			lda 	textBuffer,x
.22cf	20 5c 11	jsr $115c			jsr 	ExternPrint
.22d2	e8		inx				inx
.22d3	bd 10 08	lda $0810,x			lda 	textBuffer,x
.22d6	d0 f4		bne $22cc			bne 	_PrintYALoop
.22d8	7a		ply				ply
.22d9	fa		plx				plx
.22da	68		pla				pla
.22db	60		rts				rts
.22dc					ConvertToString:
.22dc	38		sec				sec
.22dd	80 01		bra $22e0			bra 	ConvertToStringMain
.22df					ConvertToStringUnsigned:
.22df	18		clc				clc
.22e0					ConvertToStringMain:
.22e0	da		phx				phx									; save XY
.22e1	5a		phy				phy
.22e2	64 1a		stz $1a				stz 	SignCount 					; this is zero suppression
.22e4	85 10		sta $10				sta 	temp1 						; save YA in temp1
.22e6	84 11		sty $11				sty 	temp1+1
.22e8	a0 00		ldy #$00			ldy 	#0 							; index to result.
.22ea	90 16		bcc $2302			bcc 	_CTSUnsigned 				; if carry clear do not adjust for -
.22ec	a5 11		lda $11				lda 	temp1+1 					; is it negative
.22ee	10 12		bpl $2302			bpl 	_CTSUnsigned
.22f0	a9 2d		lda #$2d			lda 	#"-"						; output - sign
.22f2	91 12		sta ($12),y			sta 	(temp2),y
.22f4	c8		iny				iny
.22f5	38		sec				sec 								; negate temp1
.22f6	a9 00		lda #$00			lda 	#0
.22f8	e5 10		sbc $10				sbc 	temp1
.22fa	85 10		sta $10				sta 	temp1
.22fc	a9 00		lda #$00			lda 	#0
.22fe	e5 11		sbc $11				sbc 	temp1+1
.2300	85 11		sta $11				sta 	temp1+1
.2302					_CTSUnsigned:
.2302	a2 00		ldx #$00			ldx 	#0 							; index into subtraction table
.2304					_CTSLoop:
.2304	a9 2f		lda #$2f			lda 	#"0"-1						; set the digit to '0' code.
.2306	91 12		sta ($12),y			sta 	(temp2),y
.2308					_CTSSubLoop:
.2308	b1 12		lda ($12),y			lda 	(temp2),y 					; bump the count
.230a	1a		inc a				inc 	a
.230b	91 12		sta ($12),y			sta 	(temp2),y
.230d	38		sec				sec 								; do subtraction saving interim result
.230e	a5 10		lda $10				lda 	temp1
.2310	fd 43 23	sbc $2343,x			sbc 	_CTSTable,x
.2313	48		pha				pha
.2314	a5 11		lda $11				lda 	temp1+1
.2316	fd 44 23	sbc $2344,x			sbc 	_CTSTable+1,x
.2319	90 07		bcc $2322			bcc 	_CTSCantSubtract 			; end of subtraction.
.231b	85 11		sta $11				sta 	temp1+1 					; save result back
.231d	68		pla				pla
.231e	85 10		sta $10				sta 	temp1
.2320	80 e6		bra $2308			bra 	_CTSSubLoop
.2322					_CTSCantSubtract:
.2322	68		pla				pla 								; throw away interim
.2323	e8		inx				inx 								; next subtractor
.2324	e8		inx				inx
.2325	b1 12		lda ($12),y			lda 	(temp2),y 					; update leading zero
.2327	49 30		eor #$30			eor 	#"0"
.2329	05 1a		ora $1a				ora 	SignCount
.232b	85 1a		sta $1a				sta 	SignCount
.232d	f0 01		beq $2330			beq		_CTSLZ 						; if all zeros so far suppress.
.232f	c8		iny				iny 								; next character
.2330					_CTSLZ:
.2330	e0 08		cpx #$08			cpx 	#_CTSTableEnd-_CTSTable 	; done them all ?
.2332	d0 d0		bne $2304			bne 	_CTSLoop
.2334					_CTSComplete:
.2334	a5 10		lda $10				lda		temp1 						; get remainder 0-9
.2336	09 30		ora #$30			ora 	#48 						; ASCII
.2338	91 12		sta ($12),y			sta 	(temp2),y					; write out
.233a	c8		iny				iny
.233b	a9 00		lda #$00			lda 	#0							; make ASCIIZ
.233d	91 12		sta ($12),y			sta 	(temp2),y
.233f	98		tya				tya 								; size in A
.2340	7a		ply				ply									; pull and exit.
.2341	fa		plx				plx
.2342	60		rts				rts
.2343					_CTSTable:
>2343	10 27 e8 03 64 00 0a 00				.word 	10000,1000,100,10 			; subtractors, this is a simple version.
.234b					_CTSTableEnd:

;******  Return to file: kernel.asm


;******  Processing file: words/system/varhandlers.src

.234b					VarAddressHandler:
.234b	18		clc				clc 								; find variable, error if it doesn't exist.
.234c	20 ee 23	jsr $23ee			jsr 	VariableFind
.234f	20 c8 23	jsr $23c8			jsr 	VariableCheckIndex
.2352	a5 06		lda $06				lda 	TOS
.2354	48		pha				pha
.2355	a5 07		lda $07				lda 	TOS+1
.2357	48		pha				pha
.2358	a5 10		lda $10				lda 	temp1 						; the address is the new value
.235a	85 06		sta $06				sta 	TOS
.235c	a5 11		lda $11				lda		temp1+1
.235e	85 07		sta $07				sta 	TOS+1
.2360	4c 00 00	jmp $0000			jmp 	NextCode
.2363					VarAddrHandlerDecode:
.2363	a9 26		lda #$26			lda 	#"&"
.2365	4c a3 24	jmp $24a3			jmp 	VarHandlerDecode
.2368					VarReadHandler:
.2368	18		clc				clc 								; find variable, error if it doesn't exist.
.2369	20 ee 23	jsr $23ee			jsr 	VariableFind
.236c	20 c8 23	jsr $23c8			jsr 	VariableCheckIndex
.236f	a5 06		lda $06				lda 	TOS
.2371	48		pha				pha
.2372	a5 07		lda $07				lda 	TOS+1
.2374	48		pha				pha
.2375	b2 10		lda ($10)			lda 	(temp1)						; read variable address to TOS
.2377	85 06		sta $06				sta 	TOS
.2379	a0 01		ldy #$01			ldy 	#1
.237b	b1 10		lda ($10),y			lda 	(temp1),y
.237d	85 07		sta $07				sta 	TOS+1
.237f	4c 00 00	jmp $0000			jmp 	NextCode
.2382					VarReadHandlerDecode:
.2382	a9 40		lda #$40			lda 	#"@"
.2384	4c a3 24	jmp $24a3			jmp 	VarHandlerDecode
.2387					VarWriteHandler:
.2387	38		sec				sec 								; find variable, create it if it doesn't exist.
.2388	20 ee 23	jsr $23ee			jsr 	VariableFind
.238b	20 c8 23	jsr $23c8			jsr 	VariableCheckIndex
.238e	a5 06		lda $06				lda 	TOS 						; write TOS to that address.
.2390	92 10		sta ($10)			sta 	(temp1)
.2392	a5 07		lda $07				lda 	TOS+1
.2394	a0 01		ldy #$01			ldy 	#1
.2396	91 10		sta ($10),y			sta 	(temp1),y
.2398	68		pla				pla
.2399	85 07		sta $07				sta 	TOS+1
.239b	68		pla				pla
.239c	85 06		sta $06				sta 	TOS
.239e	4c 00 00	jmp $0000			jmp 	NextCode
.23a1					VarWriteHandlerDecode:
.23a1	a9 21		lda #$21			lda 	#"!"
.23a3	4c a3 24	jmp $24a3			jmp 	VarHandlerDecode
.23a6					IndexHandler:
.23a6	20 fc 10	jsr $10fc			jsr 	ErrorHandler
>23a9	24 24 49 4e 44 45 58 3a				.text 	"$$INDEX:BUG",0
>23b1	42 55 47 00
.23b5					IndexHandlerDecode:
.23b5	a9 5b		lda #$5b			lda 	#"["
.23b7	20 94 1e	jsr $1e94			jsr 	DecodeWriteBuffer
.23ba	b1 08		lda ($08),y			lda 	(srcPtr),y
.23bc	a0 00		ldy #$00			ldy 	#0
.23be	38		sec				sec
.23bf	20 b6 1e	jsr $1eb6			jsr 	DecodeYAToBuffer
.23c2	a9 5d		lda #$5d			lda 	#"]"
.23c4	20 94 1e	jsr $1e94			jsr 	DecodeWriteBuffer
.23c7	60		rts				rts
.23c8					VariableCheckIndex:
.23c8	8a		txa				txa 								; next is $$index ?
.23c9	a8		tay				tay
.23ca	c8		iny				iny
.23cb	c8		iny				iny
.23cc	b1 03		lda ($03),y			lda 	(IP),y
.23ce	c9 a6		cmp #$a6			cmp 	#IndexHandler & $FF
.23d0	d0 1b		bne $23ed			bne 	_VCIExit
.23d2	c8		iny				iny
.23d3	b1 03		lda ($03),y			lda 	(IP),y
.23d5	c9 23		cmp #$23			cmp 	#IndexHandler >> 8
.23d7	d0 14		bne $23ed			bne 	_VCIExit
.23d9	98		tya				tya 								; fix X backup 3 on from where we started
.23da	aa		tax				tax
.23db	c8		iny				iny 								; get the index
.23dc	b1 03		lda ($03),y			lda 	(IP),y
.23de	0a		asl a				asl 	a 							; double it, add to (temp1) -> temp1
.23df	a0 01		ldy #$01			ldy 	#1
.23e1	72 10		adc ($10)			adc 	(temp1) 					; do the indirection e.g. the look up.
.23e3	48		pha				pha
.23e4	b1 10		lda ($10),y			lda 	(temp1),y
.23e6	69 00		adc #$00			adc 	#0
.23e8	85 11		sta $11				sta 	temp1+1
.23ea	68		pla				pla
.23eb	85 10		sta $10				sta 	temp1
.23ed					_VCIExit:
.23ed	60		rts				rts
.23ee					VariableFind:
.23ee	08		php				php 								; save autocreate flag.
.23ef	e8		inx				inx 								; advance to/over the variable name.
.23f0	e8		inx				inx
.23f1	8a		txa				txa 								; put in Y
.23f2	a8		tay				tay
.23f3	b1 03		lda ($03),y			lda 	(IP),y 						; copy name word into temp2
.23f5	85 12		sta $12				sta 	temp2
.23f7	c8		iny				iny
.23f8	b1 03		lda ($03),y			lda 	(IP),y
.23fa	85 13		sta $13				sta 	temp2+1
.23fc	c9 1b		cmp #$1b			cmp 	#27 						; check for A-Z
.23fe	b0 0f		bcs $240f			bcs 	_VFLong
.2400	a5 13		lda $13				lda 	temp2+1
.2402	d0 0b		bne $240f			bne 	_VFLong
.2404	a5 12		lda $12				lda 	temp2						; this is the index
.2406	0a		asl a				asl 	a 							; double it
.2407	85 10		sta $10				sta 	temp1
.2409	a9 06		lda #$06			lda 	#azVariables >> 8			; set the MSB
.240b	85 11		sta $11				sta 	temp1+1
.240d	28		plp				plp 								; throw creation flag, it always exists.
.240e	60		rts				rts
.240f					_VFLong:
.240f	a5 12		lda $12				lda 	temp2 						; built a hash table index into temp3/temp4
.2411	6a		ror a				ror 	a
.2412	6a		ror a				ror 	a
.2413	6a		ror a				ror 	a
.2414	6a		ror a				ror 	a
.2415	45 12		eor $12				eor 	temp2
.2417	45 13		eor $13				eor 	temp2+1
.2419	29 0f		and #$0f			and 	#(hashTableSize-1)			; force into range
.241b	0a		asl a				asl 	a
.241c	69 40		adc #$40			adc 	#hashTable & $FF 			; make an address of the head => temp1/3
.241e	85 10		sta $10				sta 	temp1
.2420	85 14		sta $14				sta 	temp3
.2422	a9 06		lda #$06			lda 	#hashTable >> 8
.2424	85 11		sta $11				sta 	temp1+1
.2426	85 15		sta $15				sta 	temp3+1
.2428					_VFSearch:
.2428	a0 01		ldy #$01			ldy 	#1							; read MSB of first record
.242a	b1 10		lda ($10),y			lda 	(temp1),y
.242c	f0 23		beq $2451			beq 	_VFNotFound 				; is MSB is zero, can't be a variable record
.242e	a8		tay				tay 								; follow the link through.
.242f	b2 10		lda ($10)			lda 	(temp1)
.2431	85 10		sta $10				sta 	temp1
.2433	84 11		sty $11				sty 	temp1+1
.2435	a0 04		ldy #$04			ldy 	#4							; check if the name matches
.2437	b1 10		lda ($10),y			lda 	(temp1),y
.2439	c5 12		cmp $12				cmp 	temp2
.243b	d0 eb		bne $2428			bne 	_VFSearch 					; if it doesn't, follow the next link.
.243d	c8		iny				iny 								; same for 2nd byte of name
.243e	b1 10		lda ($10),y			lda 	(temp1),y
.2440	c5 13		cmp $13				cmp 	temp2+1
.2442	d0 e4		bne $2428			bne 	_VFSearch
.2444	18		clc				clc
.2445	a5 10		lda $10				lda 	temp1 						; make temp1 point to the data at offset 2
.2447	69 02		adc #$02			adc 	#2
.2449	85 10		sta $10				sta 	temp1
.244b	90 02		bcc $244f			bcc 	_VFNoPage1
.244d	e6 11		inc $11				inc 	temp1+1
.244f					_VFNoPage1:
.244f	28		plp				plp 								; don't need to worry about creation flag
.2450	60		rts				rts
.2451					_VFNotFound:
.2451	28		plp				plp 								; was carry set, e.g. create a new record if not found ?
.2452	b0 14		bcs $2468			bcs 	_VFCreate
.2454	20 fc 10	jsr $10fc			jsr 	ErrorHandler
>2457	4e 4f 20 53 55 43 48 20				.text 	"NO SUCH VARIABLE",0
>245f	56 41 52 49 41 42 4c 45 00
.2468					_VFCreate:
.2468	a0 01		ldy #$01			ldy 	#1
.246a	b2 14		lda ($14)			lda 	(temp3) 					; copy the head link to the first 2 bytes
.246c	92 0e		sta ($0e)			sta 	(nextFreeMem)
.246e	b1 14		lda ($14),y			lda 	(temp3),y
.2470	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.2472	c8		iny				iny
.2473	a9 00		lda #$00			lda 	#0	 						; write zero initialised data out.
.2475	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.2477	c8		iny				iny
.2478	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.247a	c8		iny				iny
.247b	a5 12		lda $12				lda 	temp2 						; copy the name out
.247d	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.247f	c8		iny				iny
.2480	a5 13		lda $13				lda 	temp2+1
.2482	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.2484	a0 01		ldy #$01			ldy 	#1
.2486	a5 0e		lda $0e				lda 	nextFreeMem 				; update the head link
.2488	92 14		sta ($14)			sta 	(temp3)
.248a	a5 0f		lda $0f				lda 	nextFreeMem+1
.248c	91 14		sta ($14),y			sta 	(temp3),y
.248e	18		clc				clc
.248f	a5 0e		lda $0e				lda 	nextFreeMem 				; put nextFreeMem+2 in temp1 (data pointer)
.2491	69 02		adc #$02			adc 	#2
.2493	85 10		sta $10				sta 	temp1
.2495	a5 0f		lda $0f				lda 	nextFreeMem+1
.2497	69 00		adc #$00			adc 	#0
.2499	85 11		sta $11				sta 	temp1+1
.249b	a9 06		lda #$06			lda 	#6							; shift freemem pointer up 6
.249d	a0 00		ldy #$00			ldy 	#0
.249f	20 8e 1d	jsr $1d8e			jsr 	AdvanceFreeMem
.24a2	60		rts				rts
.24a3					VarHandlerDecode:
.24a3	48		pha				pha 								; save, leading space
.24a4	a9 07		lda #$07			lda 	#CTH_Variable
.24a6	20 94 1e	jsr $1e94			jsr 	DecodeWriteBuffer
.24a9	68		pla				pla 								; restore and write type
.24aa	20 94 1e	jsr $1e94			jsr 	DecodeWriteBuffer
.24ad	b1 08		lda ($08),y			lda 	(srcPtr),y 					; copy to temp1
.24af	85 10		sta $10				sta 	temp1
.24b1	c8		iny				iny
.24b2	b1 08		lda ($08),y			lda 	(srcPtr),y
.24b4	85 11		sta $11				sta 	temp1+1
.24b6	a5 10		lda $10				lda 	temp1 						; output the first character
.24b8	29 1f		and #$1f			and 	#31
.24ba	20 e5 24	jsr $24e5			jsr 	VHOutVarChar
.24bd	a2 05		ldx #$05			ldx 	#5 							; divide temp1 by 32
.24bf					_VHDShift:
.24bf	46 11		lsr $11				lsr 	temp1+1
.24c1	66 10		ror $10				ror 	temp1
.24c3	ca		dex				dex
.24c4	d0 f9		bne $24bf			bne 	_VHDShift
.24c6	a2 ff		ldx #$ff			ldx 	#255 						; now divide that by 40 by repeated subtraction.
.24c8					_VHDDiv40:
.24c8	e8		inx				inx
.24c9	38		sec				sec
.24ca	a5 10		lda $10				lda 	temp1
.24cc	e9 28		sbc #$28			sbc 	#40
.24ce	a8		tay				tay
.24cf	a5 11		lda $11				lda 	temp1+1
.24d1	e9 00		sbc #$00			sbc 	#0
.24d3	90 06		bcc $24db			bcc 	_VHDivDone
.24d5	85 11		sta $11				sta 	temp1+1
.24d7	84 10		sty $10				sty 	temp1
.24d9	80 ed		bra $24c8			bra 	_VHDDiv40
.24db					_VHDivDone:
.24db	a5 10		lda $10				lda 	temp1 						; remainder
.24dd	20 e5 24	jsr $24e5			jsr 	VHOutVarChar
.24e0	8a		txa				txa
.24e1	20 e5 24	jsr $24e5			jsr 	VHOutVarChar 				; and result.
.24e4	60		rts				rts
.24e5					VHOutVarChar:
.24e5	c9 00		cmp #$00			cmp 	#0
.24e7	f0 0c		beq $24f5			beq 	_VHOExit
.24e9	18		clc				clc
.24ea	69 40		adc #$40			adc 	#64 						; 65-90 A-Z 91-100 0-9
.24ec	c9 5b		cmp #$5b			cmp 	#91 						; convert back ?
.24ee	90 02		bcc $24f2			bcc 	_VHOOut
.24f0	e9 2b		sbc #$2b			sbc 	#91-48 						; adjust to digit
.24f2					_VHOOut:
.24f2	20 94 1e	jsr $1e94			jsr 	DecodeWriteBuffer
.24f5					_VHOExit:
.24f5	60		rts				rts

;******  Return to file: kernel.asm

.24f6					Dictionary:

;******  Processing file: generated/dictionary.inc

>24f6	05					.byte	_end0-*
>24f7	00					.byte	$00
>24f8	4d 16					.word	WordWrite
>24fa	a1					.byte	$a1
.24fb					_end0:
>24fb	10					.byte	_end1-*
>24fc	52					.byte	$52
>24fd	87 23					.word	VarWriteHandler
>24ff	a1 23					.word	VarWriteHandlerDecode
>2501	24 24 21 48 41 4e 44 4c			.byte	$24,$24,$21,$48,$41,$4e,$44,$4c,$45,$d2
>2509	45 d2
.250b					_end1:
>250b	10					.byte	_end2-*
>250c	52					.byte	$52
>250d	4b 23					.word	VarAddressHandler
>250f	63 23					.word	VarAddrHandlerDecode
>2511	24 24 26 48 41 4e 44 4c			.byte	$24,$24,$26,$48,$41,$4e,$44,$4c,$45,$d2
>2519	45 d2
.251b					_end2:
>251b	10					.byte	_end3-*
>251c	52					.byte	$52
>251d	68 23					.word	VarReadHandler
>251f	82 23					.word	VarReadHandlerDecode
>2521	24 24 40 48 41 4e 44 4c			.byte	$24,$24,$40,$48,$41,$4e,$44,$4c,$45,$d2
>2529	45 d2
.252b					_end3:
>252b	0c					.byte	_end4-*
>252c	52					.byte	$52
>252d	f3 1b					.word	CallHandler
>252f	cc 1c					.word	CallHandlerDecode
>2531	24 24 43 41 4c cc			.byte	$24,$24,$43,$41,$4c,$cc
.2537					_end4:
>2537	0f					.byte	_end5-*
>2538	53					.byte	$53
>2539	be 21					.word	SkipComment
>253b	cb 21					.word	CommentDecoder
>253d	24 24 43 4f 4d 4d 45 4e			.byte	$24,$24,$43,$4f,$4d,$4d,$45,$4e,$d4
>2545	d4
.2546					_end5:
>2546	0e					.byte	_end6-*
>2547	53					.byte	$53
>2548	e9 21					.word	DefineCode
>254a	ff 21					.word	DefineDecoder
>254c	24 24 44 45 46 49 4e c5			.byte	$24,$24,$44,$45,$46,$49,$4e,$c5
.2554					_end6:
>2554	0f					.byte	_end7-*
>2555	52					.byte	$52
>2556	a4 10					.word	Literal2Byte
>2558	ba 10					.word	Literal2ByteDecode
>255a	24 24 4c 49 54 45 52 41			.byte	$24,$24,$4c,$49,$54,$45,$52,$41,$cc
>2562	cc
.2563					_end7:
>2563	0e					.byte	_end8-*
>2564	80					.byte	$80
>2565	a7 21					.word	NextLine
>2567	24 24 4e 45 58 54 4c 49			.byte	$24,$24,$4e,$45,$58,$54,$4c,$49,$4e,$c5
>256f	4e c5
.2571					_end8:
>2571	0e					.byte	_end9-*
>2572	53					.byte	$53
>2573	cc 10					.word	LiteralString
>2575	eb 10					.word	LiteralStringDecoder
>2577	24 24 53 54 52 49 4e c7			.byte	$24,$24,$53,$54,$52,$49,$4e,$c7
.257f					_end9:
>257f	05					.byte	_end10-*
>2580	00					.byte	$00
>2581	c9 13					.word	Multiply16x16
>2583	aa					.byte	$aa
.2584					_end10:
>2584	05					.byte	_end11-*
>2585	00					.byte	$00
>2586	3a 12					.word	Add
>2588	ab					.byte	$ab
.2589					_end11:
>2589	06					.byte	_end12-*
>258a	00					.byte	$00
>258b	5e 16					.word	WordAdd
>258d	2b a1					.byte	$2b,$a1
.258f					_end12:
>258f	05					.byte	_end13-*
>2590	00					.byte	$00
>2591	49 12					.word	Subtract
>2593	ad					.byte	$ad
.2594					_end13:
>2594	06					.byte	_end14-*
>2595	00					.byte	$00
>2596	05 15					.word	ConstantMinus1
>2598	2d b1					.byte	$2d,$b1
.259a					_end14:
>259a	06					.byte	_end15-*
>259b	00					.byte	$00
>259c	9f 20					.word	DumpStack
>259e	2e ae					.byte	$2e,$ae
.25a0					_end15:
>25a0	05					.byte	_end16-*
>25a1	00					.byte	$00
>25a2	1a 13					.word	Divide16x16
>25a4	af					.byte	$af
.25a5					_end16:
>25a5	05					.byte	_end17-*
>25a6	00					.byte	$00
>25a7	f8 14					.word	Constant0
>25a9	b0					.byte	$b0
.25aa					_end17:
>25aa	06					.byte	_end18-*
>25ab	00					.byte	$00
>25ac	5e 14					.word	CheckMinus
>25ae	30 bc					.byte	$30,$bc
.25b0					_end18:
>25b0	06					.byte	_end19-*
>25b1	00					.byte	$00
>25b2	72 14					.word	CheckZero
>25b4	30 bd					.byte	$30,$bd
.25b6					_end19:
>25b6	05					.byte	_end20-*
>25b7	00					.byte	$00
>25b8	14 15					.word	C1
>25ba	b1					.byte	$b1
.25bb					_end20:
>25bb	06					.byte	_end21-*
>25bc	00					.byte	$00
>25bd	08 14					.word	Unary1Plus
>25bf	31 ab					.byte	$31,$ab
.25c1					_end21:
>25c1	06					.byte	_end22-*
>25c2	00					.byte	$00
>25c3	1f 14					.word	Unary1Minus
>25c5	31 ad					.byte	$31,$ad
.25c7					_end22:
>25c7	06					.byte	_end23-*
>25c8	00					.byte	$00
>25c9	2c 15					.word	C10
>25cb	31 b0					.byte	$31,$b0
.25cd					_end23:
>25cd	07					.byte	_end24-*
>25ce	00					.byte	$00
>25cf	55 15					.word	C100
>25d1	31 30 b0				.byte	$31,$30,$b0
.25d4					_end24:
>25d4	08					.byte	_end25-*
>25d5	00					.byte	$00
>25d6	84 15					.word	C1024
>25d8	31 30 32 b4				.byte	$31,$30,$32,$b4
.25dc					_end25:
>25dc	07					.byte	_end26-*
>25dd	00					.byte	$00
>25de	59 15					.word	C127
>25e0	31 32 b7				.byte	$31,$32,$b7
.25e3					_end26:
>25e3	07					.byte	_end27-*
>25e4	00					.byte	$00
>25e5	5d 15					.word	C128
>25e7	31 32 b8				.byte	$31,$32,$b8
.25ea					_end27:
>25ea	06					.byte	_end28-*
>25eb	00					.byte	$00
>25ec	30 15					.word	C15
>25ee	31 b5					.byte	$31,$b5
.25f0					_end28:
>25f0	06					.byte	_end29-*
>25f1	00					.byte	$00
>25f2	34 15					.word	C16
>25f4	31 b6					.byte	$31,$b6
.25f6					_end29:
>25f6	07					.byte	_end30-*
>25f7	00					.byte	$00
>25f8	96 14					.word	Times16
>25fa	31 36 aa				.byte	$31,$36,$aa
.25fd					_end30:
>25fd	07					.byte	_end31-*
>25fe	00					.byte	$00
>25ff	a9 14					.word	Divide16
>2601	31 36 af				.byte	$31,$36,$af
.2604					_end31:
>2604	05					.byte	_end32-*
>2605	00					.byte	$00
>2606	18 15					.word	C2
>2608	b2					.byte	$b2
.2609					_end32:
>2609	06					.byte	_end33-*
>260a	00					.byte	$00
>260b	a2 14					.word	Times2
>260d	32 aa					.byte	$32,$aa
.260f					_end33:
>260f	06					.byte	_end34-*
>2610	00					.byte	$00
>2611	11 14					.word	Unary2Plus
>2613	32 ab					.byte	$32,$ab
.2615					_end34:
>2615	06					.byte	_end35-*
>2616	00					.byte	$00
>2617	2a 14					.word	Unary2Minus
>2619	32 ad					.byte	$32,$ad
.261b					_end35:
>261b	06					.byte	_end36-*
>261c	00					.byte	$00
>261d	b5 14					.word	Divide2
>261f	32 af					.byte	$32,$af
.2621					_end36:
>2621	06					.byte	_end37-*
>2622	00					.byte	$00
>2623	38 15					.word	C24
>2625	32 b4					.byte	$32,$b4
.2627					_end37:
>2627	07					.byte	_end38-*
>2628	00					.byte	$00
>2629	61 15					.word	C255
>262b	32 35 b5				.byte	$32,$35,$b5
.262e					_end38:
>262e	07					.byte	_end39-*
>262f	00					.byte	$00
>2630	6c 15					.word	C256
>2632	32 35 b6				.byte	$32,$35,$b6
.2635					_end39:
>2635	08					.byte	_end40-*
>2636	00					.byte	$00
>2637	bc 14					.word	Times256
>2639	32 35 36 aa				.byte	$32,$35,$36,$aa
.263d					_end40:
>263d	08					.byte	_end41-*
>263e	00					.byte	$00
>263f	c5 14					.word	Divide256
>2641	32 35 36 af				.byte	$32,$35,$36,$af
.2645					_end41:
>2645	05					.byte	_end42-*
>2646	00					.byte	$00
>2647	1c 15					.word	C3
>2649	b3					.byte	$b3
.264a					_end42:
>264a	06					.byte	_end43-*
>264b	00					.byte	$00
>264c	49 15					.word	C32
>264e	33 b2					.byte	$33,$b2
.2650					_end43:
>2650	09					.byte	_end44-*
>2651	00					.byte	$00
>2652	9c 15					.word	C32767
>2654	33 32 37 36 b7				.byte	$33,$32,$37,$36,$b7
.2659					_end44:
>2659	09					.byte	_end45-*
>265a	00					.byte	$00
>265b	a8 15					.word	C32768
>265d	33 32 37 36 b8				.byte	$33,$32,$37,$36,$b8
.2662					_end45:
>2662	05					.byte	_end46-*
>2663	00					.byte	$00
>2664	20 15					.word	C4
>2666	b4					.byte	$b4
.2667					_end46:
>2667	06					.byte	_end47-*
>2668	00					.byte	$00
>2669	9e 14					.word	Times4
>266b	34 aa					.byte	$34,$aa
.266d					_end47:
>266d	06					.byte	_end48-*
>266e	00					.byte	$00
>266f	b1 14					.word	Divide4
>2671	34 af					.byte	$34,$af
.2673					_end48:
>2673	08					.byte	_end49-*
>2674	00					.byte	$00
>2675	90 15					.word	C4096
>2677	34 30 39 b6				.byte	$34,$30,$39,$b6
.267b					_end49:
>267b	05					.byte	_end50-*
>267c	00					.byte	$00
>267d	24 15					.word	C5
>267f	b5					.byte	$b5
.2680					_end50:
>2680	07					.byte	_end51-*
>2681	00					.byte	$00
>2682	78 15					.word	C512
>2684	35 31 b2				.byte	$35,$31,$b2
.2687					_end51:
>2687	06					.byte	_end52-*
>2688	00					.byte	$00
>2689	4d 15					.word	C63
>268b	36 b3					.byte	$36,$b3
.268d					_end52:
>268d	06					.byte	_end53-*
>268e	00					.byte	$00
>268f	51 15					.word	C64
>2691	36 b4					.byte	$36,$b4
.2693					_end53:
>2693	05					.byte	_end54-*
>2694	00					.byte	$00
>2695	28 15					.word	C8
>2697	b8					.byte	$b8
.2698					_end54:
>2698	06					.byte	_end55-*
>2699	00					.byte	$00
>269a	9a 14					.word	Times8
>269c	38 aa					.byte	$38,$aa
.269e					_end55:
>269e	06					.byte	_end56-*
>269f	00					.byte	$00
>26a0	ad 14					.word	Divide8
>26a2	38 af					.byte	$38,$af
.26a4					_end56:
>26a4	05					.byte	_end57-*
>26a5	40					.byte	$40
>26a6	89 1c					.word	ReturnHandler
>26a8	bb					.byte	$bb
.26a9					_end57:
>26a9	05					.byte	_end58-*
>26aa	00					.byte	$00
>26ab	b6 12					.word	CheckLess
>26ad	bc					.byte	$bc
.26ae					_end58:
>26ae	06					.byte	_end59-*
>26af	00					.byte	$00
>26b0	cf 12					.word	CheckLessEq
>26b2	3c bd					.byte	$3c,$bd
.26b4					_end59:
>26b4	06					.byte	_end60-*
>26b5	00					.byte	$00
>26b6	7f 12					.word	CheckNotEqual
>26b8	3c be					.byte	$3c,$be
.26ba					_end60:
>26ba	05					.byte	_end61-*
>26bb	00					.byte	$00
>26bc	82 12					.word	CheckEqual
>26be	bd					.byte	$bd
.26bf					_end61:
>26bf	05					.byte	_end62-*
>26c0	00					.byte	$00
>26c1	d2 12					.word	CheckGreater
>26c3	be					.byte	$be
.26c4					_end62:
>26c4	06					.byte	_end63-*
>26c5	00					.byte	$00
>26c6	b3 12					.word	CheckGreaterEq
>26c8	3e bd					.byte	$3e,$bd
.26ca					_end63:
>26ca	08					.byte	_end64-*
>26cb	00					.byte	$00
>26cc	bd 15					.word	TestDup
>26ce	3f 44 55 d0				.byte	$3f,$44,$55,$d0
.26d2					_end64:
>26d2	05					.byte	_end65-*
>26d3	00					.byte	$00
>26d4	32 16					.word	WordRead
>26d6	c0					.byte	$c0
.26d7					_end65:
>26d7	07					.byte	_end66-*
>26d8	00					.byte	$00
>26d9	38 14					.word	Absolute
>26db	41 42 d3				.byte	$41,$42,$d3
.26de					_end66:
>26de	09					.byte	_end67-*
>26df	00					.byte	$00
>26e0	75 16					.word	AllocateMemory
>26e2	41 4c 4c 4f c3				.byte	$41,$4c,$4c,$4f,$c3
.26e7					_end67:
>26e7	07					.byte	_end68-*
>26e8	00					.byte	$00
>26e9	58 12					.word	And
>26eb	41 4e c4				.byte	$41,$4e,$c4
.26ee					_end68:
>26ee	0a					.byte	_end69-*
>26ef	00					.byte	$00
>26f0	2a 20					.word	AssertCode
>26f2	41 53 53 45 52 d4			.byte	$41,$53,$53,$45,$52,$d4
.26f8					_end69:
>26f8	09					.byte	_end70-*
>26f9	00					.byte	$00
>26fa	8b 14					.word	ByteSwap
>26fc	42 53 57 41 d0				.byte	$42,$53,$57,$41,$d0
.2701					_end70:
>2701	06					.byte	_end71-*
>2702	00					.byte	$00
>2703	40 16					.word	ByteWrite
>2705	43 a1					.byte	$43,$a1
.2707					_end71:
>2707	06					.byte	_end72-*
>2708	00					.byte	$00
>2709	29 16					.word	ByteRead
>270b	43 c0					.byte	$43,$c0
.270d					_end72:
>270d	07					.byte	_end73-*
>270e	00					.byte	$00
>270f	56 1d					.word	ClrHandler
>2711	43 4c d2				.byte	$43,$4c,$d2
.2714					_end73:
>2714	08					.byte	_end74-*
>2715	00					.byte	$00
>2716	b4 15					.word	Drop
>2718	44 52 4f d0				.byte	$44,$52,$4f,$d0
.271c					_end74:
>271c	07					.byte	_end75-*
>271d	00					.byte	$00
>271e	c6 15					.word	Dup
>2720	44 55 d0				.byte	$44,$55,$d0
.2723					_end75:
>2723	0a					.byte	_end76-*
>2724	21					.byte	$21
>2725	3f 1b					.word	ElseHandler
>2727	42 1b					.word	ElseEncoder
>2729	45 4c 53 c5				.byte	$45,$4c,$53,$c5
.272d					_end76:
>272d	07					.byte	_end77-*
>272e	00					.byte	$00
>272f	4b 20					.word	EndProgram
>2731	45 4e c4				.byte	$45,$4e,$c4
.2734					_end77:
>2734	0b					.byte	_end78-*
>2735	20					.byte	$20
>2736	61 1b					.word	EndIfHandler
>2738	64 1b					.word	EndIfEncoder
>273a	45 4e 44 49 c6				.byte	$45,$4e,$44,$49,$c6
.273f					_end78:
>273f	09					.byte	_end79-*
>2740	20					.byte	$20
>2741	5f 1a					.word	ForHandler
>2743	95 1a					.word	ForEncoder
>2745	46 4f d2				.byte	$46,$4f,$d2
.2748					_end79:
>2748	08					.byte	_end80-*
>2749	21					.byte	$21
>274a	2a 1b					.word	IfHandler
>274c	2d 1b					.word	IfEncoder
>274e	49 c6					.byte	$49,$c6
.2750					_end80:
>2750	09					.byte	_end81-*
>2751	00					.byte	$00
>2752	09 1b					.word	GetIndex
>2754	49 4e 44 45 d8				.byte	$49,$4e,$44,$45,$d8
.2759					_end81:
>2759	08					.byte	_end82-*
>275a	00					.byte	$00
>275b	84 1f					.word	ListCode
>275d	4c 49 53 d4				.byte	$4c,$49,$53,$d4
.2761					_end82:
>2761	07					.byte	_end83-*
>2762	00					.byte	$00
>2763	ef 12					.word	Maximum
>2765	4d 41 d8				.byte	$4d,$41,$d8
.2768					_end83:
>2768	07					.byte	_end84-*
>2769	00					.byte	$00
>276a	eb 12					.word	Minimum
>276c	4d 49 ce				.byte	$4d,$49,$ce
.276f					_end84:
>276f	07					.byte	_end85-*
>2770	00					.byte	$00
>2771	2b 13					.word	Modulus16x16
>2773	4d 4f c4				.byte	$4d,$4f,$c4
.2776					_end85:
>2776	0a					.byte	_end86-*
>2777	00					.byte	$00
>2778	3f 14					.word	Negate
>277a	4e 45 47 41 54 c5			.byte	$4e,$45,$47,$41,$54,$c5
.2780					_end86:
>2780	07					.byte	_end87-*
>2781	00					.byte	$00
>2782	4d 1d					.word	NewHandler
>2784	4e 45 d7				.byte	$4e,$45,$d7
.2787					_end87:
>2787	0a					.byte	_end88-*
>2788	21					.byte	$21
>2789	a2 1a					.word	NextHandler
>278b	e1 1a					.word	NextEncoder
>278d	4e 45 58 d4				.byte	$4e,$45,$58,$d4
.2791					_end88:
>2791	07					.byte	_end89-*
>2792	00					.byte	$00
>2793	fa 15					.word	Nip
>2795	4e 49 d0				.byte	$4e,$49,$d0
.2798					_end89:
>2798	07					.byte	_end90-*
>2799	00					.byte	$00
>279a	4f 14					.word	OneComplement
>279c	4e 4f d4				.byte	$4e,$4f,$d4
.279f					_end90:
>279f	06					.byte	_end91-*
>27a0	00					.byte	$00
>27a1	72 12					.word	LogOr
>27a3	4f d2					.byte	$4f,$d2
.27a5					_end91:
>27a5	08					.byte	_end92-*
>27a6	00					.byte	$00
>27a7	e2 15					.word	Over
>27a9	4f 56 45 d2				.byte	$4f,$56,$45,$d2
.27ad					_end92:
>27ad	0c					.byte	_end93-*
>27ae	20					.byte	$20
>27af	93 1b					.word	RepeatHandler
>27b1	96 1b					.word	RepeatEncoder
>27b3	52 45 50 45 41 d4			.byte	$52,$45,$50,$45,$41,$d4
.27b9					_end93:
>27b9	07					.byte	_end94-*
>27ba	00					.byte	$00
>27bb	ce 14					.word	RandomNumber
>27bd	52 4e c4				.byte	$52,$4e,$c4
.27c0					_end94:
>27c0	07					.byte	_end95-*
>27c1	00					.byte	$00
>27c2	ff 15					.word	Rot
>27c4	52 4f d4				.byte	$52,$4f,$d4
.27c7					_end95:
>27c7	07					.byte	_end96-*
>27c8	00					.byte	$00
>27c9	ff 1f					.word	RunProgram
>27cb	52 55 ce				.byte	$52,$55,$ce
.27ce					_end96:
>27ce	07					.byte	_end97-*
>27cf	00					.byte	$00
>27d0	7a 14					.word	SignTOS
>27d2	53 47 ce				.byte	$53,$47,$ce
.27d5					_end97:
>27d5	08					.byte	_end98-*
>27d6	00					.byte	$00
>27d7	43 20					.word	StopCode
>27d9	53 54 4f d0				.byte	$53,$54,$4f,$d0
.27dd					_end98:
>27dd	08					.byte	_end99-*
>27de	00					.byte	$00
>27df	cf 15					.word	Swap
>27e1	53 57 41 d0				.byte	$53,$57,$41,$d0
.27e5					_end99:
>27e5	07					.byte	_end100-*
>27e6	00					.byte	$00
>27e7	13 20					.word	Call6502
>27e9	53 59 d3				.byte	$53,$59,$d3
.27ec					_end100:
>27ec	0d					.byte	_end101-*
>27ed	00					.byte	$00
>27ee	a0 22					.word	IntToString
>27f0	54 4f 2e 53 54 52 49 4e			.byte	$54,$4f,$2e,$53,$54,$52,$49,$4e,$c7
>27f8	c7
.27f9					_end101:
>27f9	0b					.byte	_end102-*
>27fa	21					.byte	$21
>27fb	a3 1b					.word	UntilHandler
>27fd	a6 1b					.word	UntilEncoder
>27ff	55 4e 54 49 cc				.byte	$55,$4e,$54,$49,$cc
.2804					_end102:
>2804	09					.byte	_end103-*
>2805	00					.byte	$00
>2806	4e 20					.word	VlistCode
>2808	56 4c 49 53 d4				.byte	$56,$4c,$49,$53,$d4
.280d					_end103:
>280d	0a					.byte	_end104-*
>280e	40					.byte	$40
>280f	9f 1d					.word	BreakCmd
>2811	58 42 52 45 41 cb			.byte	$58,$42,$52,$45,$41,$cb
.2817					_end104:
>2817	09					.byte	_end105-*
>2818	00					.byte	$00
>2819	99 1d					.word	ExitDump
>281b	58 44 55 4d d0				.byte	$58,$44,$55,$4d,$d0
.2820					_end105:
>2820	07					.byte	_end106-*
>2821	00					.byte	$00
>2822	65 12					.word	Xor
>2824	58 4f d2				.byte	$58,$4f,$d2
.2827					_end106:
>2827	08					.byte	_end107-*
>2828	00					.byte	$00
>2829	ea 20					.word	System_Save
>282b	53 41 56 c5				.byte	$53,$41,$56,$c5
.282f					_end107:
>282f	08					.byte	_end108-*
>2830	00					.byte	$00
>2831	08 21					.word	System_Load
>2833	4c 4f 41 c4				.byte	$4c,$4f,$41,$c4
.2837					_end108:
>2837	0d					.byte	_end109-*
>2838	11					.byte	$11
>2839	a6 23					.word	IndexHandler
>283b	b5 23					.word	IndexHandlerDecode
>283d	24 24 49 4e 44 45 d8			.byte	$24,$24,$49,$4e,$44,$45,$d8
.2844					_end109:
>2844	00					.byte	0

;******  Return to file: kernel.asm


;******  Processing file: code/enctest.asm


;******  Return to file: kernel.asm

>3fff	ff						.byte 	$FF
.4000					ProgramMemory:

;******  End of listing
