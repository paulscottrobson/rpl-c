
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -q -c -o kernel_nocode.prg -L kernel.lst -l kernel.lbl kernel.asm
; Wed Jan 08 11:49:25 2020

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: kernel.asm

=$1000					RplBuild = $1000 							; code starts here.

;******  Processing file: data.asm

.0000					Next:
>0000							.fill 	5
=3					IP = Next+3 								; the IP which points to the current instruction
.0005					rsp:
>0005							.byte 	?
.0006					tos:
>0006							.word 	?
.0008					nextFreeMem:
>0008							.word 	?
.000a					temp1:
>000a							.word 	?
.000c					temp2:
>000c							.word 	?
.000e					temp3:
>000e							.word 	?
.0010					temp4:
>0010							.word 	?
.0012					freeMemory:
>0012							.word 	?
.0014					SignCount:
>0014							.byte 	?
=$102					stack2Low = $102							; access other stack members following tsx
=$101					stack2High = $101							; (which requires saving X, not on the stack !)
=$104					stack3Low = $104
=$103					stack3High = $103
=$600					azVariables = $600 							; 26 x 2 variables occupying 52 bytes.
=16					hashTableSize = 16 							; hash tables for variables.
=$640					hashTable = $640 							; hash tables start here.
=$700					returnStack = $700							; return stack (1 page)
=$700					returnStackLow = returnStack
=1856					returnStackHigh = returnStack+$40
=1920					returnStackX = returnStack+$80

;******  Return to file: kernel.asm

.1000	a2 ff		ldx #$ff			ldx 		#$FF 					; reset the stack
.1002	9a		txs				txs
.1003	a2 00		ldx #$00			ldx			#ProgramMemory & $FF	; boot address
.1005	a0 40		ldy #$40			ldy 		#ProgramMemory >>8
.1007	20 10 10	jsr $1010			jsr 		InitialiseCoreCode 		; initialise the NEXT routine at $00
.100a	20 1a 15	jsr $151a			jsr 		ClearVariableSpace 		; clear variables etc.
.100d	4c 00 00	jmp $0000			jmp 		Next

;******  Processing file: core.src

.1010					InitialiseCoreCode:
.1010	a9 e8		lda #$e8			lda 	#$E8 					; Copy INX INX 			4 cycles when run
.1012	85 00		sta $00				sta 	Next
.1014	85 01		sta $01				sta 	Next+1
.1016	a9 7c		lda #$7c			lda 	#$7C 					; Copy JMP ($aaaa,x) 	6 cycles when run
.1018	85 02		sta $02				sta 	Next+2
.101a	86 03		stx $03				stx 	Next+3 					; set the indirect address (IP)
.101c	84 04		sty $04				sty 	Next+4
.101e	a2 01		ldx #$01			ldx 	#1 						; set up to run from provided word.
.1020	60		rts				rts								; (2 INX skip offset and line#)
.1021					Literal2Byte:
.1021	a5 06		lda $06				lda 	TOS
.1023	48		pha				pha
.1024	a5 07		lda $07				lda 	TOS+1
.1026	48		pha				pha
.1027	e8		inx				inx  							; point X to the word
.1028	e8		inx				inx
.1029	8a		txa				txa 							; copy into Y
.102a	a8		tay				tay
.102b	b1 03		lda ($03),y			lda 	(IP),y 					; read it. the LSB
.102d	85 06		sta $06				sta 	TOS
.102f	c8		iny				iny 							; read and push the MSB
.1030	b1 03		lda ($03),y			lda 	(IP),y
.1032	85 07		sta $07				sta 	TOS+1
.1034	4c 00 00	jmp $0000			jmp 	Next
.1037					LiteralString:
.1037	a5 06		lda $06				lda 	TOS
.1039	48		pha				pha
.103a	a5 07		lda $07				lda 	TOS+1
.103c	48		pha				pha
.103d	e8		inx				inx
.103e	e8		inx				inx 							; skip over current word
.103f	8a		txa				txa 							; add to IP + 1 to give string address
.1040	a8		tay				tay 							; put in Y
.1041	38		sec				sec 							; make that TOS
.1042	65 03		adc $03				adc 	IP
.1044	85 06		sta $06				sta 	TOS
.1046	a5 04		lda $04				lda 	IP+1
.1048	69 00		adc #$00			adc 	#0
.104a	85 07		sta $07				sta 	TOS+1
.104c	8a		txa				txa 							; add data length to X
.104d	18		clc				clc
.104e	71 03		adc ($03),y			adc 	(IP),y
.1050	aa		tax				tax
.1051	4c 02 00	jmp $0002			jmp 	Next+2 					; jump without pre-increment

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/binary.src

.1054					Add:
.1054	7a		ply				ply
.1055	68		pla				pla
.1056	18		clc				clc
.1057	65 06		adc $06				adc 	TOS
.1059	85 06		sta $06				sta 	TOS
.105b	98		tya				tya
.105c	65 07		adc $07				adc 	TOS+1
.105e	85 07		sta $07				sta 	TOS+1
.1060	4c 00 00	jmp $0000			jmp 	Next
.1063					Subtract:
.1063	7a		ply				ply
.1064	68		pla				pla
.1065	38		sec				sec
.1066	49 ff		eor #$ff			eor 	#$FF
.1068	65 06		adc $06				adc 	TOS
.106a	85 06		sta $06				sta 	TOS
.106c	98		tya				tya
.106d	49 ff		eor #$ff			eor 	#$FF
.106f	65 07		adc $07				adc 	TOS+1
.1071	85 07		sta $07				sta 	TOS+1
.1073	4c 00 00	jmp $0000			jmp 	Next
.1076					And:
.1076	68		pla				pla
.1077	25 07		and $07				and 	TOS+1
.1079	85 07		sta $07				sta 	TOS+1
.107b	68		pla				pla
.107c	25 06		and $06				and 	TOS
.107e	85 06		sta $06				sta 	TOS
.1080	4c 00 00	jmp $0000			jmp 	Next
.1083					Xor:
.1083	68		pla				pla
.1084	45 07		eor $07				eor 	TOS+1
.1086	85 07		sta $07				sta 	TOS+1
.1088	68		pla				pla
.1089	45 06		eor $06				eor 	TOS
.108b	85 06		sta $06				sta 	TOS
.108d	4c 00 00	jmp $0000			jmp 	Next
.1090					LogOr:
.1090	68		pla				pla
.1091	05 07		ora $07				ora 	TOS+1
.1093	85 07		sta $07				sta 	TOS+1
.1095	68		pla				pla
.1096	05 06		ora $06				ora 	TOS
.1098	85 06		sta $06				sta 	TOS
.109a	4c 00 00	jmp $0000			jmp 	Next

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/compare.src

.109d					CheckEqual:
.109d	86 0a		stx $0a				stx 	temp1
.109f	ba		tsx				tsx
.10a0	a5 06		lda $06				lda 	TOS
.10a2	5d 02 01	eor $0102,x			eor 	Stack2Low,x
.10a5	d0 14		bne $10bb			bne	 	CompareFalse
.10a7	a5 07		lda $07				lda 	TOS+1
.10a9	5d 01 01	eor $0101,x			eor 	Stack2High,x
.10ac	d0 0d		bne $10bb			bne 	CompareFalse
.10ae					CompareTrue:
.10ae	a6 0a		ldx $0a				ldx 	temp1
.10b0	68		pla				pla
.10b1	68		pla				pla
.10b2	a9 ff		lda #$ff			lda 	#$FF
.10b4	85 06		sta $06				sta 	TOS
.10b6	85 07		sta $07				sta 	TOS+1
.10b8	4c 00 00	jmp $0000			jmp 	Next
.10bb					CompareFalse:
.10bb	a6 0a		ldx $0a				ldx 	temp1
.10bd	68		pla				pla
.10be	68		pla				pla
.10bf	64 06		stz $06				stz 	TOS
.10c1	64 07		stz $07				stz 	TOS+1
.10c3	4c 00 00	jmp $0000			jmp 	Next
.10c6					CheckLess:
.10c6	18		clc				clc
.10c7	86 0a		stx $0a				stx 	temp1
.10c9	ba		tsx				tsx
.10ca	a5 06		lda $06				lda 	TOS
.10cc	fd 02 01	sbc $0102,x			sbc 	Stack2Low,x
.10cf	a5 07		lda $07				lda 	TOS+1
.10d1	fd 01 01	sbc $0101,x			sbc 	Stack2High,x
.10d4	50 02		bvc $10d8			bvc 	_CLNoFlip
.10d6	49 80		eor #$80			eor 	#$80
.10d8					_CLNoFlip:
.10d8	0a		asl a				asl 	a
.10d9	b0 e0		bcs $10bb			bcs 	CompareFalse
.10db	80 d1		bra $10ae			bra 	CompareTrue
.10dd					CheckGreater:
.10dd	18		clc				clc
.10de	86 0a		stx $0a				stx 	temp1
.10e0	ba		tsx				tsx
.10e1	bd 02 01	lda $0102,x			lda 	Stack2Low,x
.10e4	e5 06		sbc $06				sbc 	TOS
.10e6	bd 01 01	lda $0101,x			lda 	Stack2High,x
.10e9	e5 07		sbc $07				sbc 	TOS+1
.10eb	50 02		bvc $10ef			bvc 	_CGNoFlip
.10ed	49 80		eor #$80			eor 	#$80
.10ef					_CGNoFlip:
.10ef	0a		asl a				asl 	a
.10f0	b0 c9		bcs $10bb			bcs 	CompareFalse
.10f2	80 ba		bra $10ae			bra 	CompareTrue
.10f4					Minimum:
.10f4	a9 00		lda #$00			lda 	#0
.10f6	80 02		bra $10fa			bra 	MinMaxCode
.10f8					Maximum:
.10f8	a9 80		lda #$80			lda 	#$80
.10fa					MinMaxCode:
.10fa	85 0b		sta $0b				sta 	temp1+1
.10fc	86 0a		stx $0a				stx 	temp1
.10fe	ba		tsx				tsx
.10ff	38		sec				sec
.1100	a5 06		lda $06				lda 	TOS
.1102	fd 02 01	sbc $0102,x			sbc 	Stack2Low,x
.1105	a5 07		lda $07				lda 	TOS+1
.1107	fd 01 01	sbc $0101,x			sbc 	Stack2High,x
.110a	50 02		bvc $110e			bvc 	_MMNoFlip
.110c	49 80		eor #$80			eor 	#$80
.110e					_MMNoFlip:
.110e	45 0b		eor $0b				eor 	temp1+1
.1110	30 0a		bmi $111c			bmi 	_MMNoCopy
.1112	bd 02 01	lda $0102,x			lda 	Stack2Low,x
.1115	85 06		sta $06				sta 	TOS
.1117	bd 01 01	lda $0101,x			lda 	Stack2High,x
.111a	85 07		sta $07				sta 	TOS+1
.111c					_MMNoCopy:
.111c	a6 0a		ldx $0a				ldx 	temp1
.111e	68		pla				pla
.111f	68		pla				pla
.1120	4c 00 00	jmp $0000			jmp 	Next

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/divide.src

.1123					Divide16x16:
.1123	86 0c		stx $0c				stx 	temp2
.1125	ba		tsx				tsx
.1126	20 49 11	jsr $1149			jsr 	IntegerDivide
.1129	68		pla				pla
.112a	85 07		sta $07				sta 	TOS+1
.112c	68		pla				pla
.112d	85 06		sta $06				sta 	TOS
.112f	a6 0c		ldx $0c				ldx 	temp2
.1131	4c 00 00	jmp $0000			jmp 	Next
.1134					Modulus16x16:
.1134	86 0c		stx $0c				stx 	temp2
.1136	ba		tsx				tsx
.1137	20 49 11	jsr $1149			jsr 	IntegerDivide
.113a	a6 0c		ldx $0c				ldx 	temp2
.113c	68		pla				pla
.113d	68		pla				pla
.113e	a5 0a		lda $0a				lda 	temp1
.1140	85 06		sta $06				sta 	TOS
.1142	a5 0b		lda $0b				lda 	temp1+1
.1144	85 07		sta $07				sta 	TOS+1
.1146	4c 00 00	jmp $0000			jmp 	Next
.1149					IntegerDivide:
.1149	a5 06		lda $06				lda 	TOS 				; check for division by zero.
.114b	05 07		ora $07				ora 	TOS+1
.114d	d0 14		bne $1163			bne 	_BFDOkay
.114f	20 80 16	jsr $1680			jsr 	ErrorHandler
>1152	44 49 56 49 53 49 4f 4e				.text 	"DIVISION BY ZERO",0
>115a	20 42 59 20 5a 45 52 4f 00
.1163					_BFDOkay:
.1163	64 0a		stz $0a				stz 	temp1 						; Q/Dividend/Left in +0
.1165	64 0b		stz $0b				stz 	temp1+1 					; M/Divisor/Right in +2
.1167	64 14		stz $14				stz 	SignCount 					; Count of signs.
.1169	20 a4 11	jsr $11a4			jsr 	CheckIntegerNegate 			; negate 2nd (and bump sign count)
.116c	20 be 11	jsr $11be			jsr 	CheckTOSNegate 				; negate TOS (and bump sign count)
.116f	5a		phy				phy 								; Y is the counter
.1170	a0 10		ldy #$10			ldy 	#16 						; 16 iterations of the loop.
.1172					_BFDLoop:
.1172	1e 02 01	asl $0102,x			asl 	Stack2Low,x 				; shift AQ left.
.1175	3e 01 01	rol $0101,x			rol 	Stack2High,x
.1178	26 0a		rol $0a				rol 	temp1
.117a	26 0b		rol $0b				rol 	temp1+1
.117c	38		sec				sec
.117d	a5 0a		lda $0a				lda 	temp1+0 					; Calculate A-M on stack.
.117f	e5 06		sbc $06				sbc 	TOS
.1181	48		pha				pha
.1182	a5 0b		lda $0b				lda 	temp1+1
.1184	e5 07		sbc $07				sbc 	TOS+1
.1186	90 0f		bcc $1197			bcc 	_BFDNoAdd
.1188	85 0b		sta $0b				sta 	temp1+1
.118a	68		pla				pla
.118b	85 0a		sta $0a				sta 	temp1+0
.118d	bd 02 01	lda $0102,x			lda 	Stack2Low,x 				; set Q bit 1.
.1190	09 01		ora #$01			ora 	#1
.1192	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.1195	80 01		bra $1198			bra 	_BFDNext
.1197					_BFDNoAdd:
.1197	68		pla				pla 								; Throw away the intermediate calculations
.1198					_BFDNext:
.1198	88		dey				dey
.1199	d0 d7		bne $1172			bne 	_BFDLoop
.119b	7a		ply				ply 								; restore Y
.119c	46 14		lsr $14				lsr 	SignCount 					; if sign count odd,
.119e	90 03		bcc $11a3			bcc 	_BFDUnsigned 				; then the result is signed
.11a0	20 aa 11	jsr $11aa			jsr		IntegerNegateAlways 		; negate the result
.11a3					_BFDUnsigned:
.11a3	60		rts				rts
.11a4					CheckIntegerNegate:
.11a4	bd 01 01	lda $0101,x			lda 	Stack2High,x 				; is it -ve = MSB set ?
.11a7	30 01		bmi $11aa			bmi 	IntegerNegateAlways 		; if so negate it
.11a9	60		rts				rts
.11aa					IntegerNegateAlways:
.11aa	e6 14		inc $14				inc 	SignCount 					; bump the count of signs
.11ac	38		sec				sec 								; negate
.11ad	a9 00		lda #$00			lda 	#0
.11af	fd 02 01	sbc $0102,x			sbc 	Stack2Low,x
.11b2	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.11b5	a9 00		lda #$00			lda 	#0
.11b7	fd 01 01	sbc $0101,x			sbc 	Stack2High,x
.11ba	9d 01 01	sta $0101,x			sta 	Stack2High,x
.11bd	60		rts				rts
.11be					CheckTOSNegate:
.11be	a5 07		lda $07				lda 	TOS+1
.11c0	10 0f		bpl $11d1			bpl		CTNNoChange
.11c2	e6 14		inc $14				inc 	SignCount
.11c4					TOSNegateAlways:
.11c4	38		sec				sec
.11c5	a9 00		lda #$00			lda 	#0
.11c7	e5 06		sbc $06				sbc 	TOS
.11c9	85 06		sta $06				sta 	TOS
.11cb	a9 00		lda #$00			lda 	#0
.11cd	e5 07		sbc $07				sbc 	TOS+1
.11cf	85 07		sta $07				sta 	TOS+1
.11d1					CTNNoChange:
.11d1	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/multiply.src

.11d2					Multiply16x16:
.11d2	86 0a		stx $0a				stx 	temp1
.11d4	ba		tsx				tsx
.11d5	bd 02 01	lda $0102,x			lda 	Stack2Low,x 				; 2nd value on stack to temp1
.11d8	85 0c		sta $0c				sta 	temp2
.11da	bd 01 01	lda $0101,x			lda		Stack2High,x
.11dd	85 0d		sta $0d				sta 	temp2+1
.11df	9e 02 01	stz $0102,x			stz 	Stack2Low,x 				; zero 2nd value on stack
.11e2	9e 01 01	stz $0101,x			stz 	Stack2High,x
.11e5					_MultLoop:
.11e5	46 0d		lsr $0d				lsr 	temp2+1 					; ror temp2 into C
.11e7	66 0c		ror $0c				ror 	temp2
.11e9	90 11		bcc $11fc			bcc 	_MultNoAdd
.11eb	18		clc				clc 								; add 1st to 2nd
.11ec	a5 06		lda $06				lda 	TOS
.11ee	7d 02 01	adc $0102,x			adc 	Stack2Low,x
.11f1	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.11f4	a5 07		lda $07				lda 	TOS+1
.11f6	7d 01 01	adc $0101,x			adc 	Stack2High,x
.11f9	9d 01 01	sta $0101,x			sta 	Stack2High,x
.11fc					_MultNoAdd:
.11fc	06 06		asl $06				asl 	TOS 						; shift 1st left
.11fe	26 07		rol $07				rol 	TOS+1
.1200	a5 0c		lda $0c				lda 	temp2	 					; until zero
.1202	05 0d		ora $0d				ora 	temp2+1
.1204	d0 df		bne $11e5			bne 	_MultLoop
.1206	a6 0a		ldx $0a				ldx 	temp1 						; restore X load result
.1208	68		pla				pla
.1209	85 07		sta $07				sta 	TOS+1
.120b	68		pla				pla
.120c	85 06		sta $06				sta 	TOS
.120e	4c 00 00	jmp $0000			jmp 	Next

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/unary.src

.1211					Unary1Plus:
.1211	e6 06		inc $06				inc 	TOS
.1213	d0 02		bne $1217			bne 	_U1PSkip
.1215	e6 07		inc $07				inc 	TOS+1
.1217					_U1PSkip:
.1217	4c 00 00	jmp $0000			jmp 	Next
.121a					Unary2Plus:
.121a	18		clc				clc
.121b	a5 06		lda $06				lda 	TOS
.121d	69 02		adc #$02			adc 	#2
.121f	85 06		sta $06				sta 	TOS
.1221	90 02		bcc $1225			bcc 	_U1PSkip
.1223	e6 07		inc $07				inc 	TOS+1
.1225					_U1PSkip:
.1225	4c 00 00	jmp $0000			jmp 	Next
.1228					Unary1Minus:
.1228	a5 06		lda $06				lda 	TOS
.122a	d0 02		bne $122e			bne 	_U1MSkip
.122c	c6 07		dec $07				dec 	TOS+1
.122e					_U1MSkip:
.122e	c6 06		dec $06				dec 	TOS
.1230	4c 00 00	jmp $0000			jmp 	Next
.1233					Unary2Minus:
.1233	38		sec				sec
.1234	a5 06		lda $06				lda 	TOS
.1236	e9 02		sbc #$02			sbc 	#2
.1238	85 06		sta $06				sta 	TOS
.123a	b0 02		bcs $123e			bcs 	_U1PSkip
.123c	c6 07		dec $07				dec 	TOS+1
.123e					_U1PSkip:
.123e	4c 00 00	jmp $0000			jmp 	Next
.1241					Absolute:
.1241	a5 07		lda $07				lda 	TOS+1
.1243	30 03		bmi $1248			bmi 	Negate
.1245	4c 00 00	jmp $0000			jmp 	Next
.1248					Negate:
.1248	38		sec				sec
.1249	a9 00		lda #$00			lda 	#0
.124b	e5 06		sbc $06				sbc 	TOS
.124d	85 06		sta $06				sta 	TOS
.124f	a9 00		lda #$00			lda 	#0
.1251	e5 07		sbc $07				sbc 	TOS+1
.1253	85 07		sta $07				sta 	TOS+1
.1255	4c 00 00	jmp $0000			jmp 	Next
.1258					OneComplement:
.1258	a5 06		lda $06				lda 	TOS
.125a	49 ff		eor #$ff			eor 	#$FF
.125c	85 06		sta $06				sta 	TOS
.125e	a5 07		lda $07				lda 	TOS+1
.1260	49 ff		eor #$ff			eor 	#$FF
.1262	85 07		sta $07				sta 	TOS+1
.1264	4c 00 00	jmp $0000			jmp 	Next
.1267					CheckMinus:
.1267	a5 07		lda $07				lda 	TOS+1
.1269	30 07		bmi $1272			bmi 	UnaryTrue
.126b					UnaryFalse:
.126b	64 06		stz $06				stz 	TOS
.126d	64 07		stz $07				stz 	TOS+1
.126f	4c 00 00	jmp $0000			jmp 	Next
.1272					UnaryTrue:
.1272	a9 ff		lda #$ff			lda 	#$FF
.1274	85 06		sta $06				sta 	TOS
.1276	85 07		sta $07				sta 	TOS+1
.1278	4c 00 00	jmp $0000			jmp 	Next
.127b					CheckZero:
.127b	a5 06		lda $06				lda 	TOS
.127d	05 07		ora $07				ora 	TOS+1
.127f	d0 ea		bne $126b			bne 	UnaryFalse
.1281	80 ef		bra $1272			bra 	UnaryTrue
.1283					ByteSwap:
.1283	a5 06		lda $06				lda 	TOS
.1285	a4 07		ldy $07				ldy 	TOS+1
.1287	85 07		sta $07				sta 	TOS+1
.1289	84 06		sty $06				sty 	TOS
.128b	4c 00 00	jmp $0000			jmp 	Next
.128e					Times16:
.128e	06 06		asl $06				asl 	TOS
.1290	26 07		rol $07				rol 	TOS+1
.1292	06 06		asl $06				asl 	TOS
.1294	26 07		rol $07				rol 	TOS+1
.1296					Times4:
.1296	06 06		asl $06				asl 	TOS
.1298	26 07		rol $07				rol 	TOS+1
.129a					Times2:
.129a	06 06		asl $06				asl 	TOS
.129c	26 07		rol $07				rol 	TOS+1
.129e	4c 00 00	jmp $0000			jmp 	Next
.12a1					Divide2:
.12a1	a5 07		lda $07				lda 	TOS+1
.12a3	0a		asl a				asl 	a
.12a4	66 07		ror $07				ror 	TOS+1
.12a6	66 06		ror $06				ror 	TOS
.12a8	4c 00 00	jmp $0000			jmp 	Next

;******  Return to file: kernel.asm


;******  Processing file: words/data/literals.src

.12ab					Constant0:
.12ab	a5 06		lda $06				lda 	TOS
.12ad	48		pha				pha
.12ae	a5 07		lda $07				lda 	TOS+1
.12b0	48		pha				pha
.12b1	64 06		stz $06				stz 	TOS
.12b3	64 07		stz $07				stz 	TOS+1
.12b5	4c 00 00	jmp $0000			jmp 	Next
.12b8					ConstantMinus1:
.12b8	a5 06		lda $06				lda 	TOS
.12ba	48		pha				pha
.12bb	a5 07		lda $07				lda 	TOS+1
.12bd	48		pha				pha
.12be	a9 ff		lda #$ff			lda 	#$FF
.12c0	85 06		sta $06				sta 	TOS
.12c2	85 07		sta $07				sta 	TOS+1
.12c4	4c 00 00	jmp $0000			jmp 	Next
.12c7					C1:
.12c7	a0 01		ldy #$01			ldy 	#1
.12c9	80 24		bra $12ef			bra 	Const1Byte
.12cb					C2:
.12cb	a0 02		ldy #$02			ldy 	#2
.12cd	80 20		bra $12ef			bra 	Const1Byte
.12cf					C3:
.12cf	a0 03		ldy #$03			ldy 	#3
.12d1	80 1c		bra $12ef			bra 	Const1Byte
.12d3					C4:
.12d3	a0 04		ldy #$04			ldy 	#4
.12d5	80 18		bra $12ef			bra 	Const1Byte
.12d7					C5:
.12d7	a0 05		ldy #$05			ldy 	#5
.12d9	80 14		bra $12ef			bra 	Const1Byte
.12db					C8:
.12db	a0 08		ldy #$08			ldy 	#8
.12dd	80 10		bra $12ef			bra 	Const1Byte
.12df					C10:
.12df	a0 0a		ldy #$0a			ldy 	#10
.12e1	80 0c		bra $12ef			bra 	Const1Byte
.12e3					C15:
.12e3	a0 0f		ldy #$0f			ldy 	#15
.12e5	80 08		bra $12ef			bra 	Const1Byte
.12e7					C16:
.12e7	a0 10		ldy #$10			ldy 	#16
.12e9	80 04		bra $12ef			bra 	Const1Byte
.12eb					C24:
.12eb	a0 18		ldy #$18			ldy 	#24
.12ed	80 00		bra $12ef			bra 	Const1Byte
.12ef					Const1Byte:
.12ef	a5 06		lda $06				lda 	TOS
.12f1	48		pha				pha
.12f2	a5 07		lda $07				lda 	TOS+1
.12f4	48		pha				pha
.12f5	84 06		sty $06				sty 	TOS
.12f7	64 07		stz $07				stz 	TOS+1
.12f9	4c 00 00	jmp $0000			jmp 	Next
.12fc					C32:
.12fc	a0 20		ldy #$20			ldy 	#32
.12fe	80 ef		bra $12ef			bra 	Const1Byte
.1300					C63:
.1300	a0 3f		ldy #$3f			ldy 	#63
.1302	80 eb		bra $12ef			bra 	Const1Byte
.1304					C64:
.1304	a0 40		ldy #$40			ldy 	#64
.1306	80 e7		bra $12ef			bra 	Const1Byte
.1308					C100:
.1308	a0 64		ldy #$64			ldy 	#100
.130a	80 e3		bra $12ef			bra 	Const1Byte
.130c					C127:
.130c	a0 7f		ldy #$7f			ldy 	#127
.130e	80 df		bra $12ef			bra 	Const1Byte
.1310					C128:
.1310	a0 80		ldy #$80			ldy 	#128
.1312	80 db		bra $12ef			bra 	Const1Byte
.1314					C255:
.1314	a0 ff		ldy #$ff			ldy 	#255
.1316	80 d7		bra $12ef			bra 	Const1Byte
.1318					Const2Byte:
.1318	85 06		sta $06				sta 	TOS
.131a	84 07		sty $07				sty 	TOS+1
.131c	4c 00 00	jmp $0000			jmp 	Next
.131f					C256:
.131f	a5 06		lda $06				lda 	TOS
.1321	48		pha				pha
.1322	a5 07		lda $07				lda 	TOS+1
.1324	48		pha				pha
.1325	a9 00		lda #$00			lda 	#(256) & $FF
.1327	a0 01		ldy #$01			ldy 	#(256) >> 8
.1329	80 ed		bra $1318			bra 	Const2Byte
.132b					C512:
.132b	a5 06		lda $06				lda 	TOS
.132d	48		pha				pha
.132e	a5 07		lda $07				lda 	TOS+1
.1330	48		pha				pha
.1331	a9 00		lda #$00			lda 	#(512) & $FF
.1333	a0 02		ldy #$02			ldy 	#(512) >> 8
.1335	80 e1		bra $1318			bra 	Const2Byte
.1337					C1024:
.1337	a5 06		lda $06				lda 	TOS
.1339	48		pha				pha
.133a	a5 07		lda $07				lda 	TOS+1
.133c	48		pha				pha
.133d	a9 00		lda #$00			lda 	#(1024) & $FF
.133f	a0 04		ldy #$04			ldy 	#(1024) >> 8
.1341	80 d5		bra $1318			bra 	Const2Byte
.1343					C4096:
.1343	a5 06		lda $06				lda 	TOS
.1345	48		pha				pha
.1346	a5 07		lda $07				lda 	TOS+1
.1348	48		pha				pha
.1349	a9 00		lda #$00			lda 	#(4096) & $FF
.134b	a0 10		ldy #$10			ldy 	#(4096) >> 8
.134d	80 c9		bra $1318			bra 	Const2Byte
.134f					C32767:
.134f	a5 06		lda $06				lda 	TOS
.1351	48		pha				pha
.1352	a5 07		lda $07				lda 	TOS+1
.1354	48		pha				pha
.1355	a9 ff		lda #$ff			lda 	#(32767) & $FF
.1357	a0 7f		ldy #$7f			ldy 	#(32767) >> 8
.1359	80 bd		bra $1318			bra 	Const2Byte
.135b					C32768:
.135b	a5 06		lda $06				lda 	TOS
.135d	48		pha				pha
.135e	a5 07		lda $07				lda 	TOS+1
.1360	48		pha				pha
.1361	a9 00		lda #$00			lda 	#(32768) & $FF
.1363	a0 80		ldy #$80			ldy 	#(32768) >> 8
.1365	80 b1		bra $1318			bra 	Const2Byte

;******  Return to file: kernel.asm


;******  Processing file: words/data/stack.src

.1367					Drop:
.1367	68		pla				pla
.1368	85 07		sta $07				sta 	TOS+1
.136a	68		pla				pla
.136b	85 06		sta $06				sta 	TOS
.136d	4c 00 00	jmp $0000			jmp 	Next
.1370					TestDup:
.1370	a5 06		lda $06				lda 	TOS
.1372	05 07		ora $07				ora 	TOS+1
.1374	d0 03		bne $1379			bne 	Dup
.1376	4c 00 00	jmp $0000			jmp 	Next
.1379					Dup:
.1379	a5 06		lda $06				lda 	TOS
.137b	48		pha				pha
.137c	a5 07		lda $07				lda 	TOS+1
.137e	48		pha				pha
.137f	4c 00 00	jmp $0000			jmp 	Next
.1382					Swap:
.1382	86 0a		stx $0a				stx 	temp1
.1384	7a		ply				ply
.1385	fa		plx				plx
.1386	a5 06		lda $06				lda 	TOS
.1388	48		pha				pha
.1389	a5 07		lda $07				lda 	TOS+1
.138b	48		pha				pha
.138c	86 06		stx $06				stx 	TOS
.138e	84 07		sty $07				sty 	TOS+1
.1390	a6 0a		ldx $0a				ldx 	temp1
.1392	4c 00 00	jmp $0000			jmp 	Next
.1395					Over:
.1395	a5 06		lda $06				lda 	TOS
.1397	48		pha				pha
.1398	a5 07		lda $07				lda 	TOS+1
.139a	48		pha				pha
.139b	86 0a		stx $0a				stx 	temp1
.139d	ba		tsx				tsx
.139e	bd 04 01	lda $0104,x			lda 	stack3low,x
.13a1	85 06		sta $06				sta 	TOS
.13a3	bd 03 01	lda $0103,x			lda 	stack3High,x
.13a6	85 07		sta $07				sta 	TOS+1
.13a8	a6 0a		ldx $0a				ldx 	temp1
.13aa	4c 00 00	jmp $0000			jmp 	Next
.13ad					Nip:
.13ad	68		pla				pla
.13ae	68		pla				pla
.13af	4c 00 00	jmp $0000			jmp 	Next
.13b2					Rot:
.13b2	86 0a		stx $0a				stx 	temp1
.13b4	ba		tsx				tsx
.13b5	bd 04 01	lda $0104,x			lda 	Stack3Low,x
.13b8	a8		tay				tay
.13b9	bd 02 01	lda $0102,x			lda 	Stack2Low,x
.13bc	9d 04 01	sta $0104,x			sta 	Stack3Low,x
.13bf	a5 06		lda $06				lda 	TOS
.13c1	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.13c4	84 06		sty $06				sty 	TOS
.13c6	bd 03 01	lda $0103,x			lda 	Stack3High,x
.13c9	a8		tay				tay
.13ca	bd 01 01	lda $0101,x			lda 	Stack2High,x
.13cd	9d 03 01	sta $0103,x			sta 	Stack3High,x
.13d0	a5 07		lda $07				lda 	TOS+1
.13d2	9d 01 01	sta $0101,x			sta 	Stack2High,x
.13d5	84 07		sty $07				sty 	TOS+1
.13d7	a6 0a		ldx $0a				ldx 	temp1
.13d9	4c 00 00	jmp $0000			jmp 	Next

;******  Return to file: kernel.asm


;******  Processing file: words/data/memory.src

.13dc					ByteRead:
.13dc	b2 06		lda ($06)			lda 	(TOS)
.13de	85 06		sta $06				sta 	TOS
.13e0	64 07		stz $07				stz 	TOS+1
.13e2	4c 00 00	jmp $0000			jmp 	Next
.13e5					WordRead:
.13e5	a0 01		ldy #$01			ldy 	#1
.13e7	b1 06		lda ($06),y			lda 	(TOS),y
.13e9	a8		tay				tay
.13ea	b2 06		lda ($06)			lda 	(TOS)
.13ec	85 06		sta $06				sta 	TOS
.13ee	84 07		sty $07				sty 	TOS+1
.13f0	4c 00 00	jmp $0000			jmp 	Next
.13f3					ByteWrite:
.13f3	68		pla				pla
.13f4	68		pla				pla
.13f5	92 06		sta ($06)			sta 	(TOS)
.13f7	68		pla				pla
.13f8	85 07		sta $07				sta 	TOS+1
.13fa	68		pla				pla
.13fb	85 06		sta $06				sta 	TOS
.13fd	4c 00 00	jmp $0000			jmp 	Next
.1400					WordWrite:
.1400	68		pla				pla
.1401	a0 01		ldy #$01			ldy 	#1
.1403	91 06		sta ($06),y			sta 	(TOS),y
.1405	68		pla				pla
.1406	92 06		sta ($06)			sta 	(TOS)
.1408	68		pla				pla
.1409	85 07		sta $07				sta 	TOS+1
.140b	68		pla				pla
.140c	85 06		sta $06				sta 	TOS
.140e	4c 00 00	jmp $0000			jmp 	Next
.1411					WordAdd:
.1411	7a		ply				ply
.1412	68		pla				pla
.1413	18		clc				clc
.1414	72 06		adc ($06)			adc 	(TOS)
.1416	92 06		sta ($06)			sta 	(TOS)
.1418	98		tya				tya
.1419	a0 01		ldy #$01			ldy 	#1
.141b	71 06		adc ($06),y			adc 	(TOS),y
.141d	91 06		sta ($06),y			sta 	(TOS),y
.141f	68		pla				pla
.1420	85 07		sta $07				sta 	TOS+1
.1422	68		pla				pla
.1423	85 06		sta $06				sta 	TOS
.1425	4c 00 00	jmp $0000			jmp 	Next

;******  Return to file: kernel.asm


;******  Processing file: words/structures/repeatuntil.src

.1428					RepeatHandler:
.1428	4c 00 00	jmp $0000			jmp 	Next
.142b					UntilHandler:
.142b	4c 2e 14	jmp $142e			jmp 	BranchBackwardsIfZero

;******  Return to file: kernel.asm


;******  Processing file: words/system/branch.src

.142e					BranchBackwardsIfZero:
.142e	a5 06		lda $06				lda 	TOS 						; check TOS = 0
.1430	05 07		ora $07				ora 	TOS+1
.1432	f0 0a		beq $143e			beq 	BranchBackwardsTestSucceeds
.1434					BranchTestFails:
.1434	68		pla				pla
.1435	85 07		sta $07				sta 	TOS+1
.1437	68		pla				pla
.1438	85 06		sta $06				sta 	TOS
.143a	e8		inx				inx 								; skip over the relative branch.
.143b	4c 00 00	jmp $0000			jmp 	Next
.143e					BranchBackwardsTestSucceeds:
.143e	68		pla				pla
.143f	85 07		sta $07				sta 	TOS+1
.1441	68		pla				pla
.1442	85 06		sta $06				sta 	TOS
.1444	e8		inx				inx 								; advance by one, to skip the offset
.1445	8a		txa				txa 								; A = Y = position
.1446	a8		tay				tay
.1447	c8		iny				iny 								; (IP),Y now points to the back branch.
.1448	38		sec				sec
.1449	f1 03		sbc ($03),y			sbc 	(IP),y 						; adjust the position backwards
.144b	aa		tax				tax 								; position back in this line.
.144c	4c 00 00	jmp $0000			jmp 	Next 						; and continue

;******  Return to file: kernel.asm


;******  Processing file: words/system/callhandler.src

.144f					CallHandler:
.144f	e8		inx				inx									; bump X to the call address.
.1450	e8		inx				inx
.1451	e6 05		inc $05				inc 	rsp 						; bump the RSP (first time to zero)
.1453	a4 05		ldy $05				ldy 	rsp 						; get return stack and push IP/X on it.
.1455	c0 40		cpy #$40			cpy 	#$40 						; overflow
.1457	f0 4b		beq $14a4			beq 	_CHOverflow
.1459	a5 04		lda $04				lda 	IP+1
.145b	99 40 07	sta $0740,y			sta 	returnStackHigh,y
.145e	a5 03		lda $03				lda 	IP
.1460	99 00 07	sta $0700,y			sta 	returnStackLow,y
.1463	8a		txa				txa
.1464	99 80 07	sta $0780,y			sta 	returnStackX,y
.1467	8a		txa				txa 								; get the line number into temp1.
.1468	a8		tay				tay
.1469	b1 03		lda ($03),y			lda 	(IP),y
.146b	85 0a		sta $0a				sta 	temp1
.146d	c8		iny				iny
.146e	b1 03		lda ($03),y			lda 	(IP),y
.1470	85 0b		sta $0b				sta 	temp1+1
.1472	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.1474	85 03		sta $03				sta 	0+(IP)
.1476	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.1478	85 04		sta $04				sta 	1+(IP)
.147a	b2 03		lda ($03)			lda 	(IP)						; no program code ?
.147c	f0 17		beq $1495			beq 	_CHFail
.147e	a0 01		ldy #$01			ldy 	#1 							; Y = 1 throughout.
.1480					_CHSearch:
.1480	b1 03		lda ($03),y			lda 	(IP),y 						; check LSB of line number
.1482	c5 0a		cmp $0a				cmp 	temp1
.1484	f0 2d		beq $14b3			beq 	_CHFoundLSB
.1486					_CHSearchNext:
.1486	18		clc				clc
.1487	a5 03		lda $03				lda 	IP
.1489	72 03		adc ($03)			adc 	(IP)
.148b	85 03		sta $03				sta 	IP
.148d	90 02		bcc $1491			bcc 	_NoCarryAdv
.148f	e6 04		inc $04				inc 	IP+1
.1491					_NoCarryAdv:
.1491	b2 03		lda ($03)			lda 	(IP)						; check reached the end.
.1493	d0 eb		bne $1480			bne 	_CHSearch
.1495					_CHFail:
.1495	20 80 16	jsr $1680			jsr 	ErrorHandler
>1498	44 45 46 49 4e 49 54 49				.text 	"DEFINITION?",0
>14a0	4f 4e 3f 00
.14a4					_CHOverflow:
.14a4	20 80 16	jsr $1680			jsr 	ErrorHandler
>14a7	53 54 41 43 4b 44 45 50				.text 	"STACKDEPTH?",0
>14af	54 48 3f 00
.14b3					_CHFoundLSB:
.14b3	c8		iny				iny 								; get MSB
.14b4	b1 03		lda ($03),y			lda 	(IP),y
.14b6	88		dey				dey
.14b7	c5 0b		cmp $0b				cmp 	temp1+1 					; matches, if not contineu
.14b9	d0 cb		bne $1486			bne 	_CHSearchNext
.14bb	a0 03		ldy #$03			ldy 	#3	 						; check it begins with $$define
.14bd	b1 03		lda ($03),y			lda 	(IP),y
.14bf	c9 2a		cmp #$2a			cmp 	#DefineCode & $FF
.14c1	d0 d2		bne $1495			bne 	_CHFail
.14c3	c8		iny				iny
.14c4	b1 03		lda ($03),y			lda 	(IP),y
.14c6	c9 16		cmp #$16			cmp 	#DefineCode >> 8
.14c8	d0 cb		bne $1495			bne 	_CHFail
.14ca	c8		iny				iny
.14cb	b1 03		lda ($03),y			lda 	(IP),y 						; this is the length of the define name
.14cd	18		clc				clc
.14ce	69 05		adc #$05			adc 	#5 							; $$define token, line number, offset
.14d0	aa		tax				tax
.14d1	4c 02 00	jmp $0002			jmp 	Next+2 						; and execute
.14d4					ReturnHandler:
.14d4	a4 05		ldy $05				ldy 	rsp 						; get rsp
.14d6	30 15		bmi $14ed			bmi 	_RHUnderflow 				; if -ve underflowed
.14d8	c6 05		dec $05				dec 	rsp 						; decrement rsp
.14da	b9 40 07	lda $0740,y			lda 	returnStackHigh,y 			; restore IP/X
.14dd	85 04		sta $04				sta 	IP+1
.14df	b9 00 07	lda $0700,y			lda 	returnStackLow,y
.14e2	85 03		sta $03				sta 	IP
.14e4	b9 80 07	lda $0780,y			lda 	returnStackX,y
.14e7	aa		tax				tax
.14e8	f0 0e		beq $14f8			beq 	_RHInLoop 					; this means you have done :something for ; next
.14ea	4c 00 00	jmp $0000			jmp 	Next
.14ed					_RHUnderflow:
.14ed	20 80 16	jsr $1680			jsr 	ErrorHandler
>14f0	52 45 54 55 52 4e 3f 00				.text 	"RETURN?",0
.14f8					_RHInLoop:
.14f8	20 80 16	jsr $1680			jsr 	ErrorHandler
>14fb	52 45 54 55 52 4e 20 49				.text 	"RETURN IN LOOP?",0
>1503	4e 20 4c 4f 4f 50 3f 00

;******  Return to file: kernel.asm


;******  Processing file: words/system/clrnew.src

.150b					NewHandler:
.150b	9c 00 40	stz $4000			stz 	ProgramMemory 				; Make the first offset zero.
.150e	20 1a 15	jsr $151a			jsr 	ClearVariableSpace 			; clear variables, reset pointers
.1511	4c 00 00	jmp $0000			jmp 	Next
.1514					ClrHandler:
.1514	20 1a 15	jsr $151a			jsr 	ClearVariableSpace 			; clear variables, reset pointers
.1517	4c 00 00	jmp $0000			jmp 	Next
.151a					ClearVariableSpace:
.151a	a9 ff		lda #$ff			lda 	#$FF 						; empty return stack
.151c	85 05		sta $05				sta 	rsp
.151e	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.1520	85 08		sta $08				sta 	0+(nextFreeMem)
.1522	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.1524	85 09		sta $09				sta 	1+(nextFreeMem)
.1526	a0 1f		ldy #$1f			ldy 	#hashTableSize*2-1 			; erase the hash table (used for variables)
.1528					_CVSHashClear:
.1528	a9 00		lda #$00			lda 	#0 							; all the first record pointers are $00
.152a	99 40 06	sta $0640,y			sta 	hashTable,y
.152d	88		dey				dey
.152e	10 f8		bpl $1528			bpl 	_CVSHashClear
.1530					_CVSFindEnd:
.1530	18		clc				clc
.1531	a5 08		lda $08				lda 	nextFreeMem
.1533	72 08		adc ($08)			adc 	(nextFreeMem)
.1535	85 08		sta $08				sta 	nextFreeMem
.1537	90 02		bcc $153b			bcc 	_NoCarryAdv
.1539	e6 09		inc $09				inc 	nextFreeMem+1
.153b					_NoCarryAdv:
.153b	b2 08		lda ($08)			lda 	(nextFreeMem)
.153d	d0 f1		bne $1530			bne 	_CVSFindEnd
.153f	a9 08		lda #$08			lda 	#8 							; this puts a gap in, more for clarity than anything.
.1541	a0 00		ldy #$00			ldy 	#0
.1543	20 47 15	jsr $1547			jsr 	AdvanceFreeMem				; we need +1 because the previous code leaves the
.1546	60		rts				rts 								; free mem pointer pointing to the last zero offset
.1547					AdvanceFreeMem:
.1547	18		clc				clc
.1548	65 08		adc $08				adc 	nextFreeMem
.154a	85 08		sta $08				sta 	nextFreeMem
.154c	98		tya				tya
.154d	65 09		adc $09				adc 	nextFreeMem+1
.154f	85 09		sta $09				sta 	nextFreeMem+1
.1551	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/debug.src

.1552					ExitDump:
.1552	ba		tsx				tsx 								; save Data Stack in temp1
.1553	86 0a		stx $0a				stx 	temp1
.1555	4c ff ff	jmp $ffff			jmp 	$FFFF 						; makes the X16-Emulator dump-exit.
.1558					BreakCmd:
>1558	ff						.byte 	$FF
.1559	4c 00 00	jmp $0000			jmp 	Next

;******  Return to file: kernel.asm


;******  Processing file: words/system/miscellany.src

.155c					Call6502:
.155c	a5 06		lda $06				lda 	TOS 						; copy call address
.155e	85 0a		sta $0a				sta 	temp1
.1560	a5 07		lda $07				lda 	TOS+1
.1562	85 0b		sta $0b				sta 	temp1+1
.1564	68		pla				pla
.1565	85 07		sta $07				sta 	TOS+1
.1567	68		pla				pla
.1568	85 06		sta $06				sta 	TOS
.156a	20 70 15	jsr $1570			jsr 	_CallTemp1 					; call it
.156d	4c 00 00	jmp $0000			jmp 	Next
.1570					_CallTemp1:
.1570	6c 0a 00	jmp ($000a)			jmp 	(temp1)
.1573					AssertCode:
.1573	a5 06		lda $06				lda 	TOS 						; TOS = 0
.1575	05 07		ora $07				ora 	TOS+1
.1577	f0 09		beq $1582			beq 	_ASFail 					; if zero fail
.1579	68		pla				pla
.157a	85 07		sta $07				sta 	TOS+1
.157c	68		pla				pla
.157d	85 06		sta $06				sta 	TOS
.157f	4c 00 00	jmp $0000			jmp 	Next
.1582					_ASFail:
.1582	20 80 16	jsr $1680			jsr 	ErrorHandler
>1585	41 53 53 45 52 54 00				.text 	"ASSERT",0
.158c					StopCode:
.158c	20 80 16	jsr $1680			jsr 	ErrorHandler
>158f	53 54 4f 50 00					.text 	"STOP",0
.1594					EndProgram:
.1594	4c 7d 16	jmp $167d			jmp 	WarmStart

;******  Return to file: kernel.asm


;******  Processing file: words/system/number.src

.1597					ConvertToInteger:
.1597	64 0e		stz $0e				stz 	temp3 						; reset value
.1599	64 0f		stz $0f				stz 	temp3+1
.159b	64 0a		stz $0a				stz 	temp1 						; temp1 = 0 (decimal) 255 (hex)
.159d	a0 00		ldy #$00			ldy 	#0 							; look at first character
.159f	b1 06		lda ($06),y			lda 	(TOS),y
.15a1	c9 24		cmp #$24			cmp		#'$'						; if $ then skip it and set hex flag
.15a3	d0 03		bne $15a8			bne 	_CTILoop
.15a5	c6 0a		dec $0a				dec 	temp1
.15a7	c8		iny				iny
.15a8					_CTILoop:
.15a8	b1 06		lda ($06),y			lda 	(TOS),y 					; next digit
.15aa	29 7f		and #$7f			and 	#$7F 						; drop end of word flag
.15ac	38		sec				sec
.15ad	e9 30		sbc #$30			sbc 	#'0' 						; put in range '0'+
.15af	90 55		bcc $1606			bcc 	_CTIFail 					; out of range.
.15b1	c9 0a		cmp #$0a			cmp 	#10 						; in 0-9 ?
.15b3	90 0b		bcc $15c0			bcc 	_CTILegal
.15b5	c9 11		cmp #$11			cmp 	#'A'-'0'					; between 9 and A ?
.15b7	90 4d		bcc $1606			bcc 	_CTIFail
.15b9	38		sec				sec
.15ba	e9 07		sbc #$07			sbc 	#7 							; hex adjust
.15bc	c9 10		cmp #$10			cmp 	#16 						; out of range ?
.15be	b0 46		bcs $1606			bcs 	_CTIFail
.15c0					_CTILegal:
.15c0	85 0b		sta $0b				sta 	temp1+1 					; save digit value.
.15c2	06 0e		asl $0e				asl 	temp3
.15c4	26 0f		rol $0f				rol 	temp3+1
.15c6	a5 0e		lda $0e				lda 	temp3 						; copy x2 into temp2
.15c8	85 0c		sta $0c				sta 	temp2
.15ca	a5 0f		lda $0f				lda 	temp3+1
.15cc	85 0d		sta $0d				sta 	temp2+1
.15ce	06 0e		asl $0e				asl 	temp3
.15d0	26 0f		rol $0f				rol 	temp3+1
.15d2	06 0e		asl $0e				asl 	temp3
.15d4	26 0f		rol $0f				rol 	temp3+1
.15d6	24 0a		bit $0a				bit 	temp1 						; hexadecimal
.15d8	10 06		bpl $15e0			bpl 	_CTIDecimal
.15da	06 0e		asl $0e				asl 	temp3
.15dc	26 0f		rol $0f				rol 	temp3+1
.15de	80 13		bra $15f3			bra 	_CTIAddLoop
.15e0					_CTIDecimal:
.15e0	18		clc				clc 								; x 8 + x 2 = x 10
.15e1	a5 0e		lda $0e				lda 	temp3
.15e3	65 0c		adc $0c				adc 	temp2
.15e5	85 0e		sta $0e				sta 	temp3
.15e7	a5 0f		lda $0f				lda 	temp3+1
.15e9	65 0d		adc $0d				adc 	temp2+1
.15eb	85 0f		sta $0f				sta 	temp3+1
.15ed	a5 0b		lda $0b				lda 	temp1+1 					; check digit 0-9
.15ef	c9 0a		cmp #$0a			cmp 	#10
.15f1	b0 13		bcs $1606			bcs 	_CTIFail
.15f3					_CTIAddLoop:
.15f3	18		clc				clc
.15f4	a5 0e		lda $0e				lda 	temp3
.15f6	65 0b		adc $0b				adc 	temp1+1
.15f8	85 0e		sta $0e				sta 	temp3
.15fa	90 02		bcc $15fe			bcc 	_CTINoCarry
.15fc	e6 0f		inc $0f				inc 	temp3+1
.15fe					_CTINoCarry:
.15fe	b1 06		lda ($06),y			lda 	(TOS),y 					; was this the last character
.1600	c8		iny				iny
.1601	0a		asl a				asl 	a
.1602	90 a4		bcc $15a8			bcc 	_CTILoop 					; no, go back.
.1604					_CTIOkay:
.1604	38		sec				sec
.1605	60		rts				rts
.1606					_CTIFail:
.1606	18		clc				clc
.1607	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/skipper.src

.1608					NextLine:
.1608	18		clc				clc
.1609	a5 03		lda $03				lda 	IP
.160b	72 03		adc ($03)			adc 	(IP)
.160d	85 03		sta $03				sta 	IP
.160f	90 02		bcc $1613			bcc 	_NoCarryAdv
.1611	e6 04		inc $04				inc 	IP+1
.1613					_NoCarryAdv:
.1613	b2 03		lda ($03)			lda 	(IP)						; is there any following program ?
.1615	f0 05		beq $161c			beq 	_NLGoEnd
.1617	a2 03		ldx #$03			ldx 	#3 							; start 3 in
.1619	4c 02 00	jmp $0002			jmp 	Next+2 						; avoid the first two INXs
.161c					_NLGoEnd:
.161c	4c 7d 16	jmp $167d			jmp 	WarmStart
.161f					SkipComment:
.161f	e8		inx				inx									; (IP),X points to the length.
.1620	e8		inx				inx
.1621	8a		txa				txa
.1622	a8		tay				tay 								; put into Y
.1623	18		clc				clc
.1624	71 03		adc ($03),y			adc 	(IP),y 						; add the length to X
.1626	aa		tax				tax 								; put back in X
.1627	4c 02 00	jmp $0002			jmp 	Next+2 						; continue skipping the pre-increment.
.162a					DefineCode:
.162a	20 80 16	jsr $1680			jsr 	ErrorHandler
>162d	44 45 46 49 4e 49 54 49				.text 	"DEFINITION?",0
>1635	4f 4e 3f 00

;******  Return to file: kernel.asm


;******  Processing file: words/system/varhandlers.src

.1639					VarAddressHandler:
.1639	18		clc				clc 								; find variable, error if it doesn't exist.
.163a	20 7c 16	jsr $167c			jsr 	VariableFind
.163d	a5 06		lda $06				lda 	TOS
.163f	48		pha				pha
.1640	a5 07		lda $07				lda 	TOS+1
.1642	48		pha				pha
.1643	a5 0a		lda $0a				lda 	temp1 						; the address is the new value
.1645	85 06		sta $06				sta 	TOS
.1647	a5 0b		lda $0b				lda		temp1+1
.1649	85 07		sta $07				sta 	TOS+1
.164b	4c 00 00	jmp $0000			jmp 	Next
.164e					VarReadHandler:
.164e	18		clc				clc 								; find variable, error if it doesn't exist.
.164f	20 7c 16	jsr $167c			jsr 	VariableFind
.1652	a5 06		lda $06				lda 	TOS
.1654	48		pha				pha
.1655	a5 07		lda $07				lda 	TOS+1
.1657	48		pha				pha
.1658	b2 0a		lda ($0a)			lda 	(temp1)						; read variable address to TOS
.165a	85 06		sta $06				sta 	TOS
.165c	a0 01		ldy #$01			ldy 	#1
.165e	b1 0a		lda ($0a),y			lda 	(temp1),y
.1660	85 07		sta $07				sta 	TOS+1
.1662	4c 00 00	jmp $0000			jmp 	Next
.1665					VarWriteHandler:
.1665	38		sec				sec 								; find variable, create it if it doesn't exist.
.1666	20 7c 16	jsr $167c			jsr 	VariableFind
.1669	a5 06		lda $06				lda 	TOS 						; write TOS to that address.
.166b	92 0a		sta ($0a)			sta 	(temp1)
.166d	a5 07		lda $07				lda 	TOS+1
.166f	a0 01		ldy #$01			ldy 	#1
.1671	91 0a		sta ($0a),y			sta 	(temp1),y
.1673	68		pla				pla
.1674	85 07		sta $07				sta 	TOS+1
.1676	68		pla				pla
.1677	85 06		sta $06				sta 	TOS
.1679	4c 00 00	jmp $0000			jmp 	Next
.167c					VariableFind:
>167c	ff						.byte 	$FF

;******  Return to file: kernel.asm

.167d					WarmStart:
>167d	ff						.byte 	$FF
.167e	a2 00		ldx #$00			ldx 	#$00
.1680					ErrorHandler:
>1680	ff						.byte 	$FF
.1681	a2 5e		ldx #$5e			ldx 	#$5E
.1683					Dictionary:

;******  Processing file: generated/dictionary.inc

>1683	05					.byte	_end1-*
>1684	00					.byte	$00
>1685	00 14					.word	WordWrite
>1687	a1					.byte	$a1
.1688					_end1:
>1688	0e					.byte	_end2-*
>1689	42					.byte	$42
>168a	65 16					.word	VarWriteHandler
>168c	24 24 21 48 41 4e 44 4c			.byte	$24,$24,$21,$48,$41,$4e,$44,$4c,$45,$d2
>1694	45 d2
.1696					_end2:
>1696	0e					.byte	_end3-*
>1697	42					.byte	$42
>1698	39 16					.word	VarAddressHandler
>169a	24 24 26 48 41 4e 44 4c			.byte	$24,$24,$26,$48,$41,$4e,$44,$4c,$45,$d2
>16a2	45 d2
.16a4					_end3:
>16a4	0e					.byte	_end4-*
>16a5	42					.byte	$42
>16a6	4e 16					.word	VarReadHandler
>16a8	24 24 40 48 41 4e 44 4c			.byte	$24,$24,$40,$48,$41,$4e,$44,$4c,$45,$d2
>16b0	45 d2
.16b2					_end4:
>16b2	0a					.byte	_end5-*
>16b3	42					.byte	$42
>16b4	4f 14					.word	CallHandler
>16b6	24 24 43 41 4c cc			.byte	$24,$24,$43,$41,$4c,$cc
.16bc					_end5:
>16bc	0d					.byte	_end6-*
>16bd	43					.byte	$43
>16be	1f 16					.word	SkipComment
>16c0	24 24 43 4f 4d 4d 45 4e			.byte	$24,$24,$43,$4f,$4d,$4d,$45,$4e,$d4
>16c8	d4
.16c9					_end6:
>16c9	0c					.byte	_end7-*
>16ca	43					.byte	$43
>16cb	2a 16					.word	DefineCode
>16cd	24 24 44 45 46 49 4e c5			.byte	$24,$24,$44,$45,$46,$49,$4e,$c5
.16d5					_end7:
>16d5	0d					.byte	_end8-*
>16d6	42					.byte	$42
>16d7	21 10					.word	Literal2Byte
>16d9	24 24 4c 49 54 45 52 41			.byte	$24,$24,$4c,$49,$54,$45,$52,$41,$cc
>16e1	cc
.16e2					_end8:
>16e2	0e					.byte	_end9-*
>16e3	80					.byte	$80
>16e4	08 16					.word	NextLine
>16e6	24 24 4e 45 58 54 4c 49			.byte	$24,$24,$4e,$45,$58,$54,$4c,$49,$4e,$c5
>16ee	4e c5
.16f0					_end9:
>16f0	0c					.byte	_end10-*
>16f1	43					.byte	$43
>16f2	37 10					.word	LiteralString
>16f4	24 24 53 54 52 49 4e c7			.byte	$24,$24,$53,$54,$52,$49,$4e,$c7
.16fc					_end10:
>16fc	05					.byte	_end11-*
>16fd	00					.byte	$00
>16fe	d2 11					.word	Multiply16x16
>1700	aa					.byte	$aa
.1701					_end11:
>1701	05					.byte	_end12-*
>1702	00					.byte	$00
>1703	54 10					.word	Add
>1705	ab					.byte	$ab
.1706					_end12:
>1706	06					.byte	_end13-*
>1707	00					.byte	$00
>1708	11 14					.word	WordAdd
>170a	2b a1					.byte	$2b,$a1
.170c					_end13:
>170c	05					.byte	_end14-*
>170d	00					.byte	$00
>170e	63 10					.word	Subtract
>1710	ad					.byte	$ad
.1711					_end14:
>1711	06					.byte	_end15-*
>1712	00					.byte	$00
>1713	b8 12					.word	ConstantMinus1
>1715	2d b1					.byte	$2d,$b1
.1717					_end15:
>1717	05					.byte	_end16-*
>1718	00					.byte	$00
>1719	23 11					.word	Divide16x16
>171b	af					.byte	$af
.171c					_end16:
>171c	05					.byte	_end17-*
>171d	00					.byte	$00
>171e	ab 12					.word	Constant0
>1720	b0					.byte	$b0
.1721					_end17:
>1721	06					.byte	_end18-*
>1722	00					.byte	$00
>1723	67 12					.word	CheckMinus
>1725	30 bc					.byte	$30,$bc
.1727					_end18:
>1727	06					.byte	_end19-*
>1728	00					.byte	$00
>1729	7b 12					.word	CheckZero
>172b	30 bd					.byte	$30,$bd
.172d					_end19:
>172d	05					.byte	_end20-*
>172e	00					.byte	$00
>172f	c7 12					.word	C1
>1731	b1					.byte	$b1
.1732					_end20:
>1732	06					.byte	_end21-*
>1733	00					.byte	$00
>1734	11 12					.word	Unary1Plus
>1736	31 ab					.byte	$31,$ab
.1738					_end21:
>1738	06					.byte	_end22-*
>1739	00					.byte	$00
>173a	28 12					.word	Unary1Minus
>173c	31 ad					.byte	$31,$ad
.173e					_end22:
>173e	06					.byte	_end23-*
>173f	00					.byte	$00
>1740	df 12					.word	C10
>1742	31 b0					.byte	$31,$b0
.1744					_end23:
>1744	07					.byte	_end24-*
>1745	00					.byte	$00
>1746	08 13					.word	C100
>1748	31 30 b0				.byte	$31,$30,$b0
.174b					_end24:
>174b	08					.byte	_end25-*
>174c	00					.byte	$00
>174d	37 13					.word	C1024
>174f	31 30 32 b4				.byte	$31,$30,$32,$b4
.1753					_end25:
>1753	07					.byte	_end26-*
>1754	00					.byte	$00
>1755	0c 13					.word	C127
>1757	31 32 b7				.byte	$31,$32,$b7
.175a					_end26:
>175a	07					.byte	_end27-*
>175b	00					.byte	$00
>175c	10 13					.word	C128
>175e	31 32 b8				.byte	$31,$32,$b8
.1761					_end27:
>1761	06					.byte	_end28-*
>1762	00					.byte	$00
>1763	e3 12					.word	C15
>1765	31 b5					.byte	$31,$b5
.1767					_end28:
>1767	06					.byte	_end29-*
>1768	00					.byte	$00
>1769	e7 12					.word	C16
>176b	31 b6					.byte	$31,$b6
.176d					_end29:
>176d	07					.byte	_end30-*
>176e	00					.byte	$00
>176f	8e 12					.word	Times16
>1771	31 36 aa				.byte	$31,$36,$aa
.1774					_end30:
>1774	05					.byte	_end31-*
>1775	00					.byte	$00
>1776	cb 12					.word	C2
>1778	b2					.byte	$b2
.1779					_end31:
>1779	06					.byte	_end32-*
>177a	00					.byte	$00
>177b	9a 12					.word	Times2
>177d	32 aa					.byte	$32,$aa
.177f					_end32:
>177f	06					.byte	_end33-*
>1780	00					.byte	$00
>1781	1a 12					.word	Unary2Plus
>1783	32 ab					.byte	$32,$ab
.1785					_end33:
>1785	06					.byte	_end34-*
>1786	00					.byte	$00
>1787	33 12					.word	Unary2Minus
>1789	32 ad					.byte	$32,$ad
.178b					_end34:
>178b	06					.byte	_end35-*
>178c	00					.byte	$00
>178d	a1 12					.word	Divide2
>178f	32 af					.byte	$32,$af
.1791					_end35:
>1791	06					.byte	_end36-*
>1792	00					.byte	$00
>1793	eb 12					.word	C24
>1795	32 b4					.byte	$32,$b4
.1797					_end36:
>1797	07					.byte	_end37-*
>1798	00					.byte	$00
>1799	14 13					.word	C255
>179b	32 35 b5				.byte	$32,$35,$b5
.179e					_end37:
>179e	07					.byte	_end38-*
>179f	00					.byte	$00
>17a0	1f 13					.word	C256
>17a2	32 35 b6				.byte	$32,$35,$b6
.17a5					_end38:
>17a5	05					.byte	_end39-*
>17a6	00					.byte	$00
>17a7	cf 12					.word	C3
>17a9	b3					.byte	$b3
.17aa					_end39:
>17aa	06					.byte	_end40-*
>17ab	00					.byte	$00
>17ac	fc 12					.word	C32
>17ae	33 b2					.byte	$33,$b2
.17b0					_end40:
>17b0	09					.byte	_end41-*
>17b1	00					.byte	$00
>17b2	4f 13					.word	C32767
>17b4	33 32 37 36 b7				.byte	$33,$32,$37,$36,$b7
.17b9					_end41:
>17b9	09					.byte	_end42-*
>17ba	00					.byte	$00
>17bb	5b 13					.word	C32768
>17bd	33 32 37 36 b8				.byte	$33,$32,$37,$36,$b8
.17c2					_end42:
>17c2	05					.byte	_end43-*
>17c3	00					.byte	$00
>17c4	d3 12					.word	C4
>17c6	b4					.byte	$b4
.17c7					_end43:
>17c7	06					.byte	_end44-*
>17c8	00					.byte	$00
>17c9	96 12					.word	Times4
>17cb	34 aa					.byte	$34,$aa
.17cd					_end44:
>17cd	08					.byte	_end45-*
>17ce	00					.byte	$00
>17cf	43 13					.word	C4096
>17d1	34 30 39 b6				.byte	$34,$30,$39,$b6
.17d5					_end45:
>17d5	05					.byte	_end46-*
>17d6	00					.byte	$00
>17d7	d7 12					.word	C5
>17d9	b5					.byte	$b5
.17da					_end46:
>17da	07					.byte	_end47-*
>17db	00					.byte	$00
>17dc	2b 13					.word	C512
>17de	35 31 b2				.byte	$35,$31,$b2
.17e1					_end47:
>17e1	06					.byte	_end48-*
>17e2	00					.byte	$00
>17e3	00 13					.word	C63
>17e5	36 b3					.byte	$36,$b3
.17e7					_end48:
>17e7	06					.byte	_end49-*
>17e8	00					.byte	$00
>17e9	04 13					.word	C64
>17eb	36 b4					.byte	$36,$b4
.17ed					_end49:
>17ed	05					.byte	_end50-*
>17ee	00					.byte	$00
>17ef	db 12					.word	C8
>17f1	b8					.byte	$b8
.17f2					_end50:
>17f2	05					.byte	_end51-*
>17f3	40					.byte	$40
>17f4	d4 14					.word	ReturnHandler
>17f6	bb					.byte	$bb
.17f7					_end51:
>17f7	05					.byte	_end52-*
>17f8	00					.byte	$00
>17f9	c6 10					.word	CheckLess
>17fb	bc					.byte	$bc
.17fc					_end52:
>17fc	05					.byte	_end53-*
>17fd	00					.byte	$00
>17fe	9d 10					.word	CheckEqual
>1800	bd					.byte	$bd
.1801					_end53:
>1801	05					.byte	_end54-*
>1802	00					.byte	$00
>1803	dd 10					.word	CheckGreater
>1805	be					.byte	$be
.1806					_end54:
>1806	08					.byte	_end55-*
>1807	00					.byte	$00
>1808	70 13					.word	TestDup
>180a	3f 44 55 d0				.byte	$3f,$44,$55,$d0
.180e					_end55:
>180e	05					.byte	_end56-*
>180f	00					.byte	$00
>1810	e5 13					.word	WordRead
>1812	c0					.byte	$c0
.1813					_end56:
>1813	07					.byte	_end57-*
>1814	00					.byte	$00
>1815	41 12					.word	Absolute
>1817	41 42 d3				.byte	$41,$42,$d3
.181a					_end57:
>181a	07					.byte	_end58-*
>181b	00					.byte	$00
>181c	76 10					.word	And
>181e	41 4e c4				.byte	$41,$4e,$c4
.1821					_end58:
>1821	0a					.byte	_end59-*
>1822	00					.byte	$00
>1823	73 15					.word	AssertCode
>1825	41 53 53 45 52 d4			.byte	$41,$53,$53,$45,$52,$d4
.182b					_end59:
>182b	09					.byte	_end60-*
>182c	00					.byte	$00
>182d	83 12					.word	ByteSwap
>182f	42 53 57 41 d0				.byte	$42,$53,$57,$41,$d0
.1834					_end60:
>1834	06					.byte	_end61-*
>1835	00					.byte	$00
>1836	f3 13					.word	ByteWrite
>1838	43 a1					.byte	$43,$a1
.183a					_end61:
>183a	06					.byte	_end62-*
>183b	00					.byte	$00
>183c	dc 13					.word	ByteRead
>183e	43 c0					.byte	$43,$c0
.1840					_end62:
>1840	07					.byte	_end63-*
>1841	00					.byte	$00
>1842	14 15					.word	ClrHandler
>1844	43 4c d2				.byte	$43,$4c,$d2
.1847					_end63:
>1847	08					.byte	_end64-*
>1848	00					.byte	$00
>1849	67 13					.word	Drop
>184b	44 52 4f d0				.byte	$44,$52,$4f,$d0
.184f					_end64:
>184f	07					.byte	_end65-*
>1850	00					.byte	$00
>1851	79 13					.word	Dup
>1853	44 55 d0				.byte	$44,$55,$d0
.1856					_end65:
>1856	07					.byte	_end66-*
>1857	00					.byte	$00
>1858	94 15					.word	EndProgram
>185a	45 4e c4				.byte	$45,$4e,$c4
.185d					_end66:
>185d	07					.byte	_end67-*
>185e	00					.byte	$00
>185f	f8 10					.word	Maximum
>1861	4d 41 d8				.byte	$4d,$41,$d8
.1864					_end67:
>1864	07					.byte	_end68-*
>1865	00					.byte	$00
>1866	f4 10					.word	Minimum
>1868	4d 49 ce				.byte	$4d,$49,$ce
.186b					_end68:
>186b	07					.byte	_end69-*
>186c	00					.byte	$00
>186d	34 11					.word	Modulus16x16
>186f	4d 4f c4				.byte	$4d,$4f,$c4
.1872					_end69:
>1872	0a					.byte	_end70-*
>1873	00					.byte	$00
>1874	48 12					.word	Negate
>1876	4e 45 47 41 54 c5			.byte	$4e,$45,$47,$41,$54,$c5
.187c					_end70:
>187c	07					.byte	_end71-*
>187d	00					.byte	$00
>187e	0b 15					.word	NewHandler
>1880	4e 45 d7				.byte	$4e,$45,$d7
.1883					_end71:
>1883	07					.byte	_end72-*
>1884	00					.byte	$00
>1885	ad 13					.word	Nip
>1887	4e 49 d0				.byte	$4e,$49,$d0
.188a					_end72:
>188a	07					.byte	_end73-*
>188b	00					.byte	$00
>188c	58 12					.word	OneComplement
>188e	4e 4f d4				.byte	$4e,$4f,$d4
.1891					_end73:
>1891	06					.byte	_end74-*
>1892	00					.byte	$00
>1893	90 10					.word	LogOr
>1895	4f d2					.byte	$4f,$d2
.1897					_end74:
>1897	08					.byte	_end75-*
>1898	00					.byte	$00
>1899	95 13					.word	Over
>189b	4f 56 45 d2				.byte	$4f,$56,$45,$d2
.189f					_end75:
>189f	0a					.byte	_end76-*
>18a0	00					.byte	$00
>18a1	28 14					.word	RepeatHandler
>18a3	52 45 50 45 41 d4			.byte	$52,$45,$50,$45,$41,$d4
.18a9					_end76:
>18a9	07					.byte	_end77-*
>18aa	00					.byte	$00
>18ab	b2 13					.word	Rot
>18ad	52 4f d4				.byte	$52,$4f,$d4
.18b0					_end77:
>18b0	08					.byte	_end78-*
>18b1	00					.byte	$00
>18b2	8c 15					.word	StopCode
>18b4	53 54 4f d0				.byte	$53,$54,$4f,$d0
.18b8					_end78:
>18b8	08					.byte	_end79-*
>18b9	00					.byte	$00
>18ba	82 13					.word	Swap
>18bc	53 57 41 d0				.byte	$53,$57,$41,$d0
.18c0					_end79:
>18c0	07					.byte	_end80-*
>18c1	00					.byte	$00
>18c2	5c 15					.word	Call6502
>18c4	53 59 d3				.byte	$53,$59,$d3
.18c7					_end80:
>18c7	09					.byte	_end81-*
>18c8	01					.byte	$01
>18c9	2b 14					.word	UntilHandler
>18cb	55 4e 54 49 cc				.byte	$55,$4e,$54,$49,$cc
.18d0					_end81:
>18d0	0a					.byte	_end82-*
>18d1	40					.byte	$40
>18d2	58 15					.word	BreakCmd
>18d4	58 42 52 45 41 cb			.byte	$58,$42,$52,$45,$41,$cb
.18da					_end82:
>18da	09					.byte	_end83-*
>18db	00					.byte	$00
>18dc	52 15					.word	ExitDump
>18de	58 44 55 4d d0				.byte	$58,$44,$55,$4d,$d0
.18e3					_end83:
>18e3	07					.byte	_end84-*
>18e4	00					.byte	$00
>18e5	83 10					.word	Xor
>18e7	58 4f d2				.byte	$58,$4f,$d2
.18ea					_end84:
>18ea	00					.byte	0

;******  Return to file: kernel.asm

>3fff	ff						.byte 	$FF
.4000					ProgramMemory:

;******  End of listing
