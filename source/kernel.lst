
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -q -D encode=0 -c -o kernel_nocode.prg -L kernel.lst -l kernel.lbl kernel.asm
; Mon Jan 13 12:41:25 2020

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=0					encode=0

;******  Processing input file: kernel.asm

=$1000					RplBuild = $1000 							; code starts here.

;******  Processing file: data.asm

.0000					NextCode:
>0000							.fill 	5
=3					IP = NextCode+3 							; the IP which points to the current instruction
.0005					rsp:
>0005							.byte 	?
.0006					tos:
>0006							.word 	?
.0008					srcPtr:
>0008							.word 	?
.000a					bufPtr:
>000a							.word 	?
.000c					matchPtr:
>000c							.word 	?
.000e					nextFreeMem:
>000e							.word 	?
.0010					temp1:
>0010							.word 	?
.0012					temp2:
>0012							.word 	?
.0014					temp3:
>0014							.word 	?
.0016					temp4:
>0016							.word 	?
.0018					listPtr:
>0018							.word 	?
.001a					SignCount:
>001a							.byte 	?
.001b					RandomSeed:
>001b							.word 	?
.001d					ListCount:
>001d							.byte 	?
.001e					ListLowest:
>001e							.word 	?
=$102					stack2Low = $102							; access other stack members following tsx
=$101					stack2High = $101							; (which requires saving X, not on the stack !)
=$104					stack3Low = $104
=$103					stack3High = $103
=$600					azVariables = $600 							; 26 x 2 variables occupying 52 bytes * PAGE BOUNDARY *
=16					hashTableSize = 16 							; hash tables for variables.
=$640					hashTable = $640 							; hash tables start here * ALL ON ONE PAGE *
=$810					textBuffer = $810 							; buffer for text.
=$700					returnStack = $700							; return stack (1 page)
=$700					returnStackLow = returnStack
=1856					returnStackHigh = returnStack+$40
=1920					returnStackX = returnStack+$80
=$80					NumberStackBase = $80 						; number stack down from here.
=$910					encodeBuffer = $910 						; buffer for encoded program
=0					COL_BLACK = 0
=1					COL_RED = 1
=2					COL_GREEN = 2
=3					COL_YELLOW = 3
=4					COL_BLUE = 4
=5					COL_MAGENTA = 5
=6					COL_CYAN = 6
=7					COL_WHITE = 7
=8					COL_RVS = 8
=2					CTH_LineNo = COL_Green
=6					CTH_Keyword = COL_Cyan
=11					CTH_Comment = COL_Yellow+COL_Rvs
=7					CTH_Definition = COL_White
=5					CTH_String = COL_Magenta
=3					CTH_Call = COL_Yellow

;******  Return to file: kernel.asm

.1000	a2 ff		ldx #$ff			ldx 	#$FF 						; reset the stack
.1002	9a		txs				txs
.1003	20 de 10	jsr $10de			jsr 	ExternInitialise
.1006	a9 23		lda #$23			lda 	#BootMsg & $FF
.1008	a0 10		ldy #$10			ldy 	#BootMsg >> 8
.100a	20 ce 11	jsr $11ce			jsr 	EXPrintString
.100d					WarmStartBlankStack:
.100d	a2 80		ldx #$80			ldx 	#NumberStackBase
.100f	9a		txs				txs
.1010					WarmStart:
.1010	a9 03		lda #$03			lda 	#COL_Yellow
.1012	20 15 11	jsr $1115			jsr 	ExternColour
.1015	20 38 11	jsr $1138			jsr 	ExternInput
.1018	a9 06		lda #$06			lda 	#COL_Cyan
.101a	20 15 11	jsr $1115			jsr 	ExternColour
.101d	4c 50 1d	jmp $1d50			jmp 	RunProgram
.1020					ErrorHandler:
>1020	ff						.byte 	$FF
.1021	a2 5e		ldx #$5e			ldx 	#$5E
.1023					BootMsg:
>1023	2a 2a 2a 20 52 50 4c 2f				.text 	"*** RPL/C INTERPRETER ***",13,13
>102b	43 20 49 4e 54 45 52 50 52 45 54 45 52 20 2a 2a
>103b	2a 0d 0d
>103e	57 52 49 54 54 45 4e 20				.text	"WRITTEN BY PAUL ROBSON 2020",13,13
>1046	42 59 20 50 41 55 4c 20 52 4f 42 53 4f 4e 20 32
>1056	30 32 30 0d 0d
>105b	42 55 49 4c 44 3a 20				.text 	"BUILD: "

;******  Processing file: generated/timestamp.inc

>1062	5b 32 30 2d 30 31 2d 31			.text	"[20-01-13 12:41]"
>106a	33 20 31 32 3a 34 31 5d

;******  Return to file: kernel.asm

>1072	0d 0d 00					.byte 	13,13,0

;******  Processing file: core.src

.1075					InitialiseCoreCode:
.1075	a9 e8		lda #$e8			lda 	#$E8 					; Copy INX INX 			4 cycles when run
.1077	85 00		sta $00				sta 	NextCode
.1079	85 01		sta $01				sta 	NextCode+1
.107b	a9 7c		lda #$7c			lda 	#$7C 					; Copy JMP ($aaaa,x) 	6 cycles when run
.107d	85 02		sta $02				sta 	NextCode+2
.107f	86 03		stx $03				stx 	NextCode+3 				; set the indirect address (IP)
.1081	84 04		sty $04				sty 	NextCode+4
.1083	a2 01		ldx #$01			ldx 	#1 						; set up to run from provided word.
.1085	60		rts				rts								; (2 INX skip offset and line#)
.1086					Literal2Byte:
.1086	a5 06		lda $06				lda 	TOS
.1088	48		pha				pha
.1089	a5 07		lda $07				lda 	TOS+1
.108b	48		pha				pha
.108c	e8		inx				inx  							; point X to the word
.108d	e8		inx				inx
.108e	8a		txa				txa 							; copy into Y
.108f	a8		tay				tay
.1090	b1 03		lda ($03),y			lda 	(IP),y 					; read it. the LSB
.1092	85 06		sta $06				sta 	TOS
.1094	c8		iny				iny 							; read and push the MSB
.1095	b1 03		lda ($03),y			lda 	(IP),y
.1097	85 07		sta $07				sta 	TOS+1
.1099	4c 00 00	jmp $0000			jmp 	NextCode
.109c					Literal2ByteDecode:
.109c	a9 06		lda #$06			lda 	#CTH_Keyword
.109e	20 94 1c	jsr $1c94			jsr 	DecodeWriteBuffer
.10a1	b1 08		lda ($08),y			lda 	(srcPtr),y
.10a3	aa		tax				tax
.10a4	c8		iny				iny
.10a5	b1 08		lda ($08),y			lda 	(srcPtr),y
.10a7	a8		tay				tay
.10a8	8a		txa				txa
.10a9	38		sec				sec 							; output signed
.10aa	20 b6 1c	jsr $1cb6			jsr 	DecodeYAToBuffer
.10ad	60		rts				rts
.10ae					LiteralString:
.10ae	a5 06		lda $06				lda 	TOS
.10b0	48		pha				pha
.10b1	a5 07		lda $07				lda 	TOS+1
.10b3	48		pha				pha
.10b4	e8		inx				inx
.10b5	e8		inx				inx 							; skip over current word
.10b6	8a		txa				txa 							; add to IP + 1 to give string address
.10b7	a8		tay				tay 							; put in Y
.10b8	38		sec				sec 							; make that TOS
.10b9	65 03		adc $03				adc 	IP
.10bb	85 06		sta $06				sta 	TOS
.10bd	a5 04		lda $04				lda 	IP+1
.10bf	69 00		adc #$00			adc 	#0
.10c1	85 07		sta $07				sta 	TOS+1
.10c3	8a		txa				txa 							; add data length to X
.10c4	18		clc				clc
.10c5	71 03		adc ($03),y			adc 	(IP),y
.10c7	aa		tax				tax
.10c8	ca		dex				dex
.10c9	ca		dex				dex
.10ca	4c 00 00	jmp $0000			jmp 	NextCode
.10cd					LiteralStringDecoder:
.10cd	a9 05		lda #$05			lda 	#CTH_String
.10cf	20 94 1c	jsr $1c94			jsr 	DecodeWriteBuffer
.10d2	a9 22		lda #$22			lda 	#'"'
.10d4	20 94 1c	jsr $1c94			jsr 	DecodeWriteBuffer
.10d7	20 9d 1c	jsr $1c9d			jsr 	DecodeOutputData
.10da	20 94 1c	jsr $1c94			jsr 	DecodeWriteBuffer
.10dd	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: extern.asm

.10de					ExternInitialise:
.10de	a9 90		lda #$90			lda 	#144 						; set colour
.10e0	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.10e3	a9 01		lda #$01			lda 	#$01
.10e5	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.10e8	a9 0e		lda #$0e			lda 	#14							; lower case
.10ea	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.10ed	a9 93		lda #$93			lda 	#147 						; clear screen
.10ef	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.10f2	a9 07		lda #$07			lda 	#COL_WHITE 					; white text.
.10f4	4c 15 11	jmp $1115			jmp 	ExternColour
.10f7					ExternCheckBreak:
.10f7	da		phx				phx 								; make sure we keep XY
.10f8	5a		phy				phy
.10f9	20 e1 ff	jsr $ffe1			jsr 	$FFE1						; STOP check on CBM KERNAL
.10fc	f0 03		beq $1101			beq		_ECBExit 					; stopped
.10fe	7a		ply				ply 								; restore and exit.
.10ff	fa		plx				plx
.1100	60		rts				rts
.1101					_ECBExit:
.1101	20 20 10	jsr $1020			jsr 	ErrorHandler
>1104	45 53 43 41 50 45 00				.text 	"ESCAPE",0
.110b					ExternPrint:
.110b	48		pha				pha
.110c	da		phx				phx
.110d	5a		phy				phy
.110e	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.1111	7a		ply				ply
.1112	fa		plx				plx
.1113	68		pla				pla
.1114	60		rts				rts
.1115					ExternColour:
.1115	48		pha				pha
.1116	da		phx				phx
.1117	48		pha				pha
.1118	29 08		and #$08			and 	#8
.111a	0a		asl a				asl 	a
.111b	0a		asl a				asl 	a
.111c	0a		asl a				asl 	a
.111d	0a		asl a				asl 	a
.111e	49 92		eor #$92			eor 	#$92
.1120	20 0b 11	jsr $110b			jsr 	ExternPrint
.1123	68		pla				pla
.1124	29 07		and #$07			and 	#7
.1126	aa		tax				tax
.1127	bd 30 11	lda $1130,x			lda 	_ECTable,x
.112a	20 0b 11	jsr $110b			jsr 	ExternPrint
.112d	fa		plx				plx
.112e	68		pla				pla
.112f	60		rts				rts
.1130					_ECTable:
>1130	90						.byte 	144
>1131	1c						.byte 	28
>1132	1e						.byte 	30
>1133	9e						.byte 	158
>1134	1f						.byte 	31
>1135	9c						.byte 	156
>1136	9f						.byte 	159
>1137	05						.byte 	5
.1138					ExternInput:
.1138	a9 10		lda #$10			lda 	#(textBuffer & $FF)
.113a	85 14		sta $14				sta 	temp3
.113c	a9 08		lda #$08			lda 	#(textBuffer >> 8)
.113e	85 15		sta $15				sta 	temp3+1
.1140	20 cf ff	jsr $ffcf	_EIRead:jsr 	$FFCF
.1143	29 7f		and #$7f			and 	#$7F
.1145	c9 0d		cmp #$0d			cmp 	#13
.1147	f0 0a		beq $1153			beq 	_EIExit
.1149	92 14		sta ($14)			sta 	(temp3)
.114b	e6 14		inc $14				inc 	temp3
.114d	d0 f1		bne $1140			bne 	_EIRead
.114f	e6 15		inc $15				inc 	temp3+1
.1151	80 ed		bra $1140			bra 	_EIRead
.1153	a9 00		lda #$00	_EIExit:lda 	#0
.1155	92 14		sta ($14)			sta 	(temp3)
.1157	a9 0d		lda #$0d			lda 	#13
.1159	20 0b 11	jsr $110b			jsr 	ExternPrint
.115c	60		rts				rts
.115d					ExternSave:
.115d	da		phx				phx
.115e	5a		phy				phy
.115f	85 12		sta $12				sta 	temp2 						; save start
.1161	84 13		sty $13				sty 	temp2+1
.1163	20 c5 11	jsr $11c5			jsr 	EXGetLength 				; get length of file into A
.1166	a6 14		ldx $14				ldx 	temp3
.1168	a4 15		ldy $15				ldy 	temp3+1
.116a	20 bd ff	jsr $ffbd			jsr 	$FFBD 						; set name
.116d	a9 01		lda #$01			lda 	#1
.116f	a2 08		ldx #$08			ldx 	#8	 						; device #8
.1171	a0 00		ldy #$00			ldy 	#0
.1173	20 ba ff	jsr $ffba			jsr 	$FFBA 						; set LFS
.1176	a6 10		ldx $10				ldx 	temp1 						; end address
.1178	a4 11		ldy $11				ldy 	temp1+1
.117a	a9 12		lda #$12			lda 	#temp2
.117c	20 d8 ff	jsr $ffd8			jsr 	$FFD8 						; save
.117f	b0 03		bcs $1184			bcs 	_ESSave
.1181	7a		ply				ply
.1182	fa		plx				plx
.1183	60		rts				rts
.1184					_ESSave:
.1184	20 20 10	jsr $1020			jsr 	ErrorHandler
>1187	53 41 56 45 20 46 41 49				.text 	"SAVE FAILED",0
>118f	4c 45 44 00
.1193					ExternLoad:
.1193	da		phx				phx 								; save XY
.1194	5a		phy				phy
.1195	48		pha				pha 								; save target
.1196	5a		phy				phy
.1197	20 c5 11	jsr $11c5			jsr 	EXGetLength 				; get length of file into A
.119a	a6 14		ldx $14				ldx 	temp3
.119c	a4 15		ldy $15				ldy 	temp3+1
.119e	20 bd ff	jsr $ffbd			jsr 	$FFBD 						; set name
.11a1	a9 01		lda #$01			lda 	#1
.11a3	a2 08		ldx #$08			ldx 	#8	 						; device #8
.11a5	a0 00		ldy #$00			ldy 	#0
.11a7	20 ba ff	jsr $ffba			jsr 	$FFBA 						; set LFS
.11aa	7a		ply				ply 								; restore target to YX and call load
.11ab	fa		plx				plx
.11ac	a9 00		lda #$00			lda 	#0 							; load command
.11ae	20 d5 ff	jsr $ffd5			jsr 	$FFD5
.11b1	b0 03		bcs $11b6			bcs 	_ESLoad
.11b3	7a		ply				ply
.11b4	fa		plx				plx
.11b5	60		rts				rts
.11b6					_ESLoad:
.11b6	20 20 10	jsr $1020			jsr 	ErrorHandler
>11b9	4c 4f 41 44 20 46 41 49				.text 	"LOAD FAILED",0
>11c1	4c 45 44 00
.11c5					EXGetLength:
.11c5	b2 14		lda ($14)			lda 	(temp3) 					; get name length
.11c7	e6 14		inc $14				inc 	temp3 						; bump ptr past it
.11c9	d0 02		bne $11cd			bne 	_EXGLExit
.11cb	e6 15		inc $15				inc 	temp3+1
.11cd					_EXGLExit:
.11cd	60		rts				rts
.11ce					EXPrintString:
.11ce	48		pha				pha
.11cf	5a		phy				phy
.11d0	84 11		sty $11				sty 	temp1+1
.11d2	85 10		sta $10				sta 	temp1
.11d4	a0 00		ldy #$00			ldy 	#0
.11d6					_EXPSLoop:
.11d6	b1 10		lda ($10),y			lda 	(temp1),y
.11d8	f0 08		beq $11e2			beq 	_EXPSExit
.11da	29 7f		and #$7f			and 	#$7F
.11dc	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.11df	c8		iny				iny
.11e0	80 f4		bra $11d6			bra 	_EXPSLoop
.11e2					_EXPSExit:
.11e2	7a		ply				ply
.11e3	68		pla				pla
.11e4	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/binary.src

.11e5					Add:
.11e5	7a		ply				ply
.11e6	68		pla				pla
.11e7	18		clc				clc
.11e8	65 06		adc $06				adc 	TOS
.11ea	85 06		sta $06				sta 	TOS
.11ec	98		tya				tya
.11ed	65 07		adc $07				adc 	TOS+1
.11ef	85 07		sta $07				sta 	TOS+1
.11f1	4c 00 00	jmp $0000			jmp 	NextCode
.11f4					Subtract:
.11f4	7a		ply				ply
.11f5	68		pla				pla
.11f6	38		sec				sec
.11f7	49 ff		eor #$ff			eor 	#$FF
.11f9	65 06		adc $06				adc 	TOS
.11fb	85 06		sta $06				sta 	TOS
.11fd	98		tya				tya
.11fe	49 ff		eor #$ff			eor 	#$FF
.1200	65 07		adc $07				adc 	TOS+1
.1202	85 07		sta $07				sta 	TOS+1
.1204	4c 00 00	jmp $0000			jmp 	NextCode
.1207					And:
.1207	68		pla				pla
.1208	25 07		and $07				and 	TOS+1
.120a	85 07		sta $07				sta 	TOS+1
.120c	68		pla				pla
.120d	25 06		and $06				and 	TOS
.120f	85 06		sta $06				sta 	TOS
.1211	4c 00 00	jmp $0000			jmp 	NextCode
.1214					Xor:
.1214	68		pla				pla
.1215	45 07		eor $07				eor 	TOS+1
.1217	85 07		sta $07				sta 	TOS+1
.1219	68		pla				pla
.121a	45 06		eor $06				eor 	TOS
.121c	85 06		sta $06				sta 	TOS
.121e	4c 00 00	jmp $0000			jmp 	NextCode
.1221					LogOr:
.1221	68		pla				pla
.1222	05 07		ora $07				ora 	TOS+1
.1224	85 07		sta $07				sta 	TOS+1
.1226	68		pla				pla
.1227	05 06		ora $06				ora 	TOS
.1229	85 06		sta $06				sta 	TOS
.122b	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/compare.src

.122e					CheckNotEqual:
.122e	38		sec				sec
.122f	80 01		bra $1232			bra 	CECode
.1231					CheckEqual:
.1231	18		clc				clc
.1232					CECode:
.1232	86 10		stx $10				stx 	temp1
.1234	ba		tsx				tsx
.1235	08		php				php
.1236	a5 06		lda $06				lda 	TOS
.1238	5d 02 01	eor $0102,x			eor 	Stack2Low,x
.123b	d0 17		bne $1254			bne	 	CompareFalse
.123d	a5 07		lda $07				lda 	TOS+1
.123f	5d 01 01	eor $0101,x			eor 	Stack2High,x
.1242	d0 10		bne $1254			bne 	CompareFalse
.1244					CompareTrue:
.1244	a6 10		ldx $10				ldx 	temp1
.1246	28		plp				plp
.1247	b0 10		bcs $1259			bcs		CompareFalse2
.1249					CompareTrue2:
.1249	68		pla				pla
.124a	68		pla				pla
.124b	a9 ff		lda #$ff			lda 	#$FF
.124d	85 06		sta $06				sta 	TOS
.124f	85 07		sta $07				sta 	TOS+1
.1251	4c 00 00	jmp $0000			jmp 	NextCode
.1254					CompareFalse:
.1254	a6 10		ldx $10				ldx 	temp1
.1256	28		plp				plp
.1257	b0 f0		bcs $1249			bcs		CompareTrue2
.1259					CompareFalse2:
.1259	68		pla				pla
.125a	68		pla				pla
.125b	64 06		stz $06				stz 	TOS
.125d	64 07		stz $07				stz 	TOS+1
.125f	4c 00 00	jmp $0000			jmp 	NextCode
.1262					CheckGreaterEq:
.1262	38		sec				sec
.1263	80 01		bra $1266			bra		CLCode
.1265					CheckLess:
.1265	18		clc				clc
.1266	86 10		stx $10		CLCode:	stx 	temp1
.1268	ba		tsx				tsx
.1269	08		php				php
.126a	18		clc				clc
.126b	a5 06		lda $06				lda 	TOS
.126d	fd 02 01	sbc $0102,x			sbc 	Stack2Low,x
.1270	a5 07		lda $07				lda 	TOS+1
.1272	fd 01 01	sbc $0101,x			sbc 	Stack2High,x
.1275	50 02		bvc $1279			bvc 	_CLNoFlip
.1277	49 80		eor #$80			eor 	#$80
.1279					_CLNoFlip:
.1279	0a		asl a				asl 	a
.127a	b0 d8		bcs $1254			bcs 	CompareFalse
.127c	80 c6		bra $1244			bra 	CompareTrue
.127e					CheckLessEq:
.127e	38		sec				sec
.127f	80 01		bra $1282			bra		CGCode
.1281					CheckGreater:
.1281	18		clc				clc
.1282					CGCode:
.1282	86 10		stx $10				stx 	temp1
.1284	ba		tsx				tsx
.1285	08		php				php
.1286	18		clc				clc
.1287	bd 02 01	lda $0102,x			lda 	Stack2Low,x
.128a	e5 06		sbc $06				sbc 	TOS
.128c	bd 01 01	lda $0101,x			lda 	Stack2High,x
.128f	e5 07		sbc $07				sbc 	TOS+1
.1291	50 02		bvc $1295			bvc 	_CGNoFlip
.1293	49 80		eor #$80			eor 	#$80
.1295					_CGNoFlip:
.1295	0a		asl a				asl 	a
.1296	b0 bc		bcs $1254			bcs 	CompareFalse
.1298	80 aa		bra $1244			bra 	CompareTrue
.129a					Minimum:
.129a	a9 00		lda #$00			lda 	#0
.129c	80 02		bra $12a0			bra 	MinMaxCode
.129e					Maximum:
.129e	a9 80		lda #$80			lda 	#$80
.12a0					MinMaxCode:
.12a0	85 11		sta $11				sta 	temp1+1
.12a2	86 10		stx $10				stx 	temp1
.12a4	ba		tsx				tsx
.12a5	38		sec				sec
.12a6	a5 06		lda $06				lda 	TOS
.12a8	fd 02 01	sbc $0102,x			sbc 	Stack2Low,x
.12ab	a5 07		lda $07				lda 	TOS+1
.12ad	fd 01 01	sbc $0101,x			sbc 	Stack2High,x
.12b0	50 02		bvc $12b4			bvc 	_MMNoFlip
.12b2	49 80		eor #$80			eor 	#$80
.12b4					_MMNoFlip:
.12b4	45 11		eor $11				eor 	temp1+1
.12b6	30 0a		bmi $12c2			bmi 	_MMNoCopy
.12b8	bd 02 01	lda $0102,x			lda 	Stack2Low,x
.12bb	85 06		sta $06				sta 	TOS
.12bd	bd 01 01	lda $0101,x			lda 	Stack2High,x
.12c0	85 07		sta $07				sta 	TOS+1
.12c2					_MMNoCopy:
.12c2	a6 10		ldx $10				ldx 	temp1
.12c4	68		pla				pla
.12c5	68		pla				pla
.12c6	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/divide.src

.12c9					Divide16x16:
.12c9	86 12		stx $12				stx 	temp2
.12cb	ba		tsx				tsx
.12cc	20 ef 12	jsr $12ef			jsr 	IntegerDivide
.12cf	68		pla				pla
.12d0	85 07		sta $07				sta 	TOS+1
.12d2	68		pla				pla
.12d3	85 06		sta $06				sta 	TOS
.12d5	a6 12		ldx $12				ldx 	temp2
.12d7	4c 00 00	jmp $0000			jmp 	NextCode
.12da					Modulus16x16:
.12da	86 12		stx $12				stx 	temp2
.12dc	ba		tsx				tsx
.12dd	20 ef 12	jsr $12ef			jsr 	IntegerDivide
.12e0	a6 12		ldx $12				ldx 	temp2
.12e2	68		pla				pla
.12e3	68		pla				pla
.12e4	a5 10		lda $10				lda 	temp1
.12e6	85 06		sta $06				sta 	TOS
.12e8	a5 11		lda $11				lda 	temp1+1
.12ea	85 07		sta $07				sta 	TOS+1
.12ec	4c 00 00	jmp $0000			jmp 	NextCode
.12ef					IntegerDivide:
.12ef	a5 06		lda $06				lda 	TOS 				; check for division by zero.
.12f1	05 07		ora $07				ora 	TOS+1
.12f3	d0 14		bne $1309			bne 	_BFDOkay
.12f5	20 20 10	jsr $1020			jsr 	ErrorHandler
>12f8	44 49 56 49 53 49 4f 4e				.text 	"DIVISION BY ZERO",0
>1300	20 42 59 20 5a 45 52 4f 00
.1309					_BFDOkay:
.1309	64 10		stz $10				stz 	temp1 						; Q/Dividend/Left in +0
.130b	64 11		stz $11				stz 	temp1+1 					; M/Divisor/Right in +2
.130d	64 1a		stz $1a				stz 	SignCount 					; Count of signs.
.130f	20 4a 13	jsr $134a			jsr 	CheckIntegerNegate 			; negate 2nd (and bump sign count)
.1312	20 64 13	jsr $1364			jsr 	CheckTOSNegate 				; negate TOS (and bump sign count)
.1315	5a		phy				phy 								; Y is the counter
.1316	a0 10		ldy #$10			ldy 	#16 						; 16 iterations of the loop.
.1318					_BFDLoop:
.1318	1e 02 01	asl $0102,x			asl 	Stack2Low,x 				; shift AQ left.
.131b	3e 01 01	rol $0101,x			rol 	Stack2High,x
.131e	26 10		rol $10				rol 	temp1
.1320	26 11		rol $11				rol 	temp1+1
.1322	38		sec				sec
.1323	a5 10		lda $10				lda 	temp1+0 					; Calculate A-M on stack.
.1325	e5 06		sbc $06				sbc 	TOS
.1327	48		pha				pha
.1328	a5 11		lda $11				lda 	temp1+1
.132a	e5 07		sbc $07				sbc 	TOS+1
.132c	90 0f		bcc $133d			bcc 	_BFDNoAdd
.132e	85 11		sta $11				sta 	temp1+1
.1330	68		pla				pla
.1331	85 10		sta $10				sta 	temp1+0
.1333	bd 02 01	lda $0102,x			lda 	Stack2Low,x 				; set Q bit 1.
.1336	09 01		ora #$01			ora 	#1
.1338	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.133b	80 01		bra $133e			bra 	_BFDNext
.133d					_BFDNoAdd:
.133d	68		pla				pla 								; Throw away the intermediate calculations
.133e					_BFDNext:
.133e	88		dey				dey
.133f	d0 d7		bne $1318			bne 	_BFDLoop
.1341	7a		ply				ply 								; restore Y
.1342	46 1a		lsr $1a				lsr 	SignCount 					; if sign count odd,
.1344	90 03		bcc $1349			bcc 	_BFDUnsigned 				; then the result is signed
.1346	20 50 13	jsr $1350			jsr		IntegerNegateAlways 		; negate the result
.1349					_BFDUnsigned:
.1349	60		rts				rts
.134a					CheckIntegerNegate:
.134a	bd 01 01	lda $0101,x			lda 	Stack2High,x 				; is it -ve = MSB set ?
.134d	30 01		bmi $1350			bmi 	IntegerNegateAlways 		; if so negate it
.134f	60		rts				rts
.1350					IntegerNegateAlways:
.1350	e6 1a		inc $1a				inc 	SignCount 					; bump the count of signs
.1352	38		sec				sec 								; negate
.1353	a9 00		lda #$00			lda 	#0
.1355	fd 02 01	sbc $0102,x			sbc 	Stack2Low,x
.1358	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.135b	a9 00		lda #$00			lda 	#0
.135d	fd 01 01	sbc $0101,x			sbc 	Stack2High,x
.1360	9d 01 01	sta $0101,x			sta 	Stack2High,x
.1363	60		rts				rts
.1364					CheckTOSNegate:
.1364	a5 07		lda $07				lda 	TOS+1
.1366	10 0f		bpl $1377			bpl		CTNNoChange
.1368	e6 1a		inc $1a				inc 	SignCount
.136a					TOSNegateAlways:
.136a	38		sec				sec
.136b	a9 00		lda #$00			lda 	#0
.136d	e5 06		sbc $06				sbc 	TOS
.136f	85 06		sta $06				sta 	TOS
.1371	a9 00		lda #$00			lda 	#0
.1373	e5 07		sbc $07				sbc 	TOS+1
.1375	85 07		sta $07				sta 	TOS+1
.1377					CTNNoChange:
.1377	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/multiply.src

.1378					Multiply16x16:
.1378	86 10		stx $10				stx 	temp1
.137a	ba		tsx				tsx
.137b	bd 02 01	lda $0102,x			lda 	Stack2Low,x 				; 2nd value on stack to temp1
.137e	85 12		sta $12				sta 	temp2
.1380	bd 01 01	lda $0101,x			lda		Stack2High,x
.1383	85 13		sta $13				sta 	temp2+1
.1385	9e 02 01	stz $0102,x			stz 	Stack2Low,x 				; zero 2nd value on stack
.1388	9e 01 01	stz $0101,x			stz 	Stack2High,x
.138b					_MultLoop:
.138b	46 13		lsr $13				lsr 	temp2+1 					; ror temp2 into C
.138d	66 12		ror $12				ror 	temp2
.138f	90 11		bcc $13a2			bcc 	_MultNoAdd
.1391	18		clc				clc 								; add 1st to 2nd
.1392	a5 06		lda $06				lda 	TOS
.1394	7d 02 01	adc $0102,x			adc 	Stack2Low,x
.1397	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.139a	a5 07		lda $07				lda 	TOS+1
.139c	7d 01 01	adc $0101,x			adc 	Stack2High,x
.139f	9d 01 01	sta $0101,x			sta 	Stack2High,x
.13a2					_MultNoAdd:
.13a2	06 06		asl $06				asl 	TOS 						; shift 1st left
.13a4	26 07		rol $07				rol 	TOS+1
.13a6	a5 12		lda $12				lda 	temp2	 					; until zero
.13a8	05 13		ora $13				ora 	temp2+1
.13aa	d0 df		bne $138b			bne 	_MultLoop
.13ac	a6 10		ldx $10				ldx 	temp1 						; restore X load result
.13ae	68		pla				pla
.13af	85 07		sta $07				sta 	TOS+1
.13b1	68		pla				pla
.13b2	85 06		sta $06				sta 	TOS
.13b4	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/unary.src

.13b7					Unary1Plus:
.13b7	e6 06		inc $06				inc 	TOS
.13b9	d0 02		bne $13bd			bne 	_U1PSkip
.13bb	e6 07		inc $07				inc 	TOS+1
.13bd					_U1PSkip:
.13bd	4c 00 00	jmp $0000			jmp 	NextCode
.13c0					Unary2Plus:
.13c0	18		clc				clc
.13c1	a5 06		lda $06				lda 	TOS
.13c3	69 02		adc #$02			adc 	#2
.13c5	85 06		sta $06				sta 	TOS
.13c7	90 02		bcc $13cb			bcc 	_U1PSkip
.13c9	e6 07		inc $07				inc 	TOS+1
.13cb					_U1PSkip:
.13cb	4c 00 00	jmp $0000			jmp 	NextCode
.13ce					Unary1Minus:
.13ce	a5 06		lda $06				lda 	TOS
.13d0	d0 02		bne $13d4			bne 	_U1MSkip
.13d2	c6 07		dec $07				dec 	TOS+1
.13d4					_U1MSkip:
.13d4	c6 06		dec $06				dec 	TOS
.13d6	4c 00 00	jmp $0000			jmp 	NextCode
.13d9					Unary2Minus:
.13d9	38		sec				sec
.13da	a5 06		lda $06				lda 	TOS
.13dc	e9 02		sbc #$02			sbc 	#2
.13de	85 06		sta $06				sta 	TOS
.13e0	b0 02		bcs $13e4			bcs 	_U1PSkip
.13e2	c6 07		dec $07				dec 	TOS+1
.13e4					_U1PSkip:
.13e4	4c 00 00	jmp $0000			jmp 	NextCode
.13e7					Absolute:
.13e7	a5 07		lda $07				lda 	TOS+1
.13e9	30 03		bmi $13ee			bmi 	Negate
.13eb	4c 00 00	jmp $0000			jmp 	NextCode
.13ee					Negate:
.13ee	38		sec				sec
.13ef	a9 00		lda #$00			lda 	#0
.13f1	e5 06		sbc $06				sbc 	TOS
.13f3	85 06		sta $06				sta 	TOS
.13f5	a9 00		lda #$00			lda 	#0
.13f7	e5 07		sbc $07				sbc 	TOS+1
.13f9	85 07		sta $07				sta 	TOS+1
.13fb	4c 00 00	jmp $0000			jmp 	NextCode
.13fe					OneComplement:
.13fe	a5 06		lda $06				lda 	TOS
.1400	49 ff		eor #$ff			eor 	#$FF
.1402	85 06		sta $06				sta 	TOS
.1404	a5 07		lda $07				lda 	TOS+1
.1406	49 ff		eor #$ff			eor 	#$FF
.1408	85 07		sta $07				sta 	TOS+1
.140a	4c 00 00	jmp $0000			jmp 	NextCode
.140d					CheckMinus:
.140d	a5 07		lda $07				lda 	TOS+1
.140f	30 07		bmi $1418			bmi 	UnaryTrue
.1411					UnaryFalse:
.1411	64 06		stz $06				stz 	TOS
.1413	64 07		stz $07				stz 	TOS+1
.1415	4c 00 00	jmp $0000			jmp 	NextCode
.1418					UnaryTrue:
.1418	a9 ff		lda #$ff			lda 	#$FF
.141a	85 06		sta $06				sta 	TOS
.141c	85 07		sta $07				sta 	TOS+1
.141e	4c 00 00	jmp $0000			jmp 	NextCode
.1421					CheckZero:
.1421	a5 06		lda $06				lda 	TOS
.1423	05 07		ora $07				ora 	TOS+1
.1425	d0 ea		bne $1411			bne 	UnaryFalse
.1427	80 ef		bra $1418			bra 	UnaryTrue
.1429					SignTOS:
.1429	a5 07		lda $07				lda 	TOS+1
.142b	30 eb		bmi $1418			bmi		UnaryTrue
.142d	05 06		ora $06				ora 	TOS
.142f	f0 e0		beq $1411			beq 	UnaryFalse
.1431	a9 01		lda #$01			lda 	#1
.1433	85 06		sta $06				sta 	TOS
.1435	64 07		stz $07				stz		TOS+1
.1437	4c 00 00	jmp $0000			jmp 	NextCode
.143a					ByteSwap:
.143a	a5 06		lda $06				lda 	TOS
.143c	a4 07		ldy $07				ldy 	TOS+1
.143e	85 07		sta $07				sta 	TOS+1
.1440	84 06		sty $06				sty 	TOS
.1442	4c 00 00	jmp $0000			jmp 	NextCode
.1445					Times16:
.1445	06 06		asl $06				asl 	TOS
.1447	26 07		rol $07				rol 	TOS+1
.1449					Times8:
.1449	06 06		asl $06				asl 	TOS
.144b	26 07		rol $07				rol 	TOS+1
.144d					Times4:
.144d	06 06		asl $06				asl 	TOS
.144f	26 07		rol $07				rol 	TOS+1
.1451					Times2:
.1451	06 06		asl $06				asl 	TOS
.1453	26 07		rol $07				rol 	TOS+1
.1455	4c 00 00	jmp $0000			jmp 	NextCode
.1458					Divide16:
.1458	46 07		lsr $07				lsr 	TOS+1
.145a	66 06		ror $06				ror 	TOS
.145c					Divide8:
.145c	46 07		lsr $07				lsr 	TOS+1
.145e	66 06		ror $06				ror 	TOS
.1460					Divide4:
.1460	46 07		lsr $07				lsr 	TOS+1
.1462	66 06		ror $06				ror 	TOS
.1464					Divide2:
.1464	46 07		lsr $07				lsr 	TOS+1
.1466	66 06		ror $06				ror 	TOS
.1468	4c 00 00	jmp $0000			jmp 	NextCode
.146b					Times256:
.146b	a5 06		lda $06				lda 	TOS
.146d	85 07		sta $07				sta 	TOS+1
.146f	64 06		stz $06				stz 	TOS
.1471	4c 00 00	jmp $0000			jmp 	NextCode
.1474					Divide256:
.1474	a5 07		lda $07				lda 	TOS+1
.1476	85 06		sta $06				sta 	TOS
.1478	64 07		stz $07				stz 	TOS+1
.147a	4c 00 00	jmp $0000			jmp 	NextCode
.147d					RandomNumber:
.147d	a5 06		lda $06				lda 	TOS
.147f	48		pha				pha
.1480	a5 07		lda $07				lda 	TOS+1
.1482	48		pha				pha
.1483	a5 1b		lda $1b				lda 	randomSeed
.1485	05 1c		ora $1c				ora 	randomSeed+1
.1487	d0 08		bne $1491			bne 	_RH_NoInit
.1489	a9 7c		lda #$7c			lda 	#$7C
.148b	85 1b		sta $1b				sta 	randomSeed
.148d	a9 a1		lda #$a1			lda 	#$A1
.148f	85 1c		sta $1c				sta 	randomSeed+1
.1491					_RH_NoInit:
.1491	a5 1b		lda $1b				lda 	randomSeed
.1493	4a		lsr a		        lsr		a
.1494	26 1c		rol $1c		        rol 	randomSeed+1
.1496	90 02		bcc $149a	        bcc 	_RH_NoEor
.1498	49 b4		eor #$b4	        eor 	#$B4
.149a					_RH_NoEor:
.149a	85 1b		sta $1b		        sta 	randomSeed
.149c	45 1c		eor $1c		        eor 	randomSeed+1
.149e	85 07		sta $07		        sta 	TOS+1
.14a0	a5 1b		lda $1b		        lda 	randomSeed
.14a2	85 06		sta $06		        sta 	TOS
.14a4	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/data/literals.src

.14a7					Constant0:
.14a7	a5 06		lda $06				lda 	TOS
.14a9	48		pha				pha
.14aa	a5 07		lda $07				lda 	TOS+1
.14ac	48		pha				pha
.14ad	64 06		stz $06				stz 	TOS
.14af	64 07		stz $07				stz 	TOS+1
.14b1	4c 00 00	jmp $0000			jmp 	NextCode
.14b4					ConstantMinus1:
.14b4	a5 06		lda $06				lda 	TOS
.14b6	48		pha				pha
.14b7	a5 07		lda $07				lda 	TOS+1
.14b9	48		pha				pha
.14ba	a9 ff		lda #$ff			lda 	#$FF
.14bc	85 06		sta $06				sta 	TOS
.14be	85 07		sta $07				sta 	TOS+1
.14c0	4c 00 00	jmp $0000			jmp 	NextCode
.14c3					C1:
.14c3	a0 01		ldy #$01			ldy 	#1
.14c5	80 24		bra $14eb			bra 	Const1Byte
.14c7					C2:
.14c7	a0 02		ldy #$02			ldy 	#2
.14c9	80 20		bra $14eb			bra 	Const1Byte
.14cb					C3:
.14cb	a0 03		ldy #$03			ldy 	#3
.14cd	80 1c		bra $14eb			bra 	Const1Byte
.14cf					C4:
.14cf	a0 04		ldy #$04			ldy 	#4
.14d1	80 18		bra $14eb			bra 	Const1Byte
.14d3					C5:
.14d3	a0 05		ldy #$05			ldy 	#5
.14d5	80 14		bra $14eb			bra 	Const1Byte
.14d7					C8:
.14d7	a0 08		ldy #$08			ldy 	#8
.14d9	80 10		bra $14eb			bra 	Const1Byte
.14db					C10:
.14db	a0 0a		ldy #$0a			ldy 	#10
.14dd	80 0c		bra $14eb			bra 	Const1Byte
.14df					C15:
.14df	a0 0f		ldy #$0f			ldy 	#15
.14e1	80 08		bra $14eb			bra 	Const1Byte
.14e3					C16:
.14e3	a0 10		ldy #$10			ldy 	#16
.14e5	80 04		bra $14eb			bra 	Const1Byte
.14e7					C24:
.14e7	a0 18		ldy #$18			ldy 	#24
.14e9	80 00		bra $14eb			bra 	Const1Byte
.14eb					Const1Byte:
.14eb	a5 06		lda $06				lda 	TOS
.14ed	48		pha				pha
.14ee	a5 07		lda $07				lda 	TOS+1
.14f0	48		pha				pha
.14f1	84 06		sty $06				sty 	TOS
.14f3	64 07		stz $07				stz 	TOS+1
.14f5	4c 00 00	jmp $0000			jmp 	NextCode
.14f8					C32:
.14f8	a0 20		ldy #$20			ldy 	#32
.14fa	80 ef		bra $14eb			bra 	Const1Byte
.14fc					C63:
.14fc	a0 3f		ldy #$3f			ldy 	#63
.14fe	80 eb		bra $14eb			bra 	Const1Byte
.1500					C64:
.1500	a0 40		ldy #$40			ldy 	#64
.1502	80 e7		bra $14eb			bra 	Const1Byte
.1504					C100:
.1504	a0 64		ldy #$64			ldy 	#100
.1506	80 e3		bra $14eb			bra 	Const1Byte
.1508					C127:
.1508	a0 7f		ldy #$7f			ldy 	#127
.150a	80 df		bra $14eb			bra 	Const1Byte
.150c					C128:
.150c	a0 80		ldy #$80			ldy 	#128
.150e	80 db		bra $14eb			bra 	Const1Byte
.1510					C255:
.1510	a0 ff		ldy #$ff			ldy 	#255
.1512	80 d7		bra $14eb			bra 	Const1Byte
.1514					Const2Byte:
.1514	85 06		sta $06				sta 	TOS
.1516	84 07		sty $07				sty 	TOS+1
.1518	4c 00 00	jmp $0000			jmp 	NextCode
.151b					C256:
.151b	a5 06		lda $06				lda 	TOS
.151d	48		pha				pha
.151e	a5 07		lda $07				lda 	TOS+1
.1520	48		pha				pha
.1521	a9 00		lda #$00			lda 	#(256) & $FF
.1523	a0 01		ldy #$01			ldy 	#(256) >> 8
.1525	80 ed		bra $1514			bra 	Const2Byte
.1527					C512:
.1527	a5 06		lda $06				lda 	TOS
.1529	48		pha				pha
.152a	a5 07		lda $07				lda 	TOS+1
.152c	48		pha				pha
.152d	a9 00		lda #$00			lda 	#(512) & $FF
.152f	a0 02		ldy #$02			ldy 	#(512) >> 8
.1531	80 e1		bra $1514			bra 	Const2Byte
.1533					C1024:
.1533	a5 06		lda $06				lda 	TOS
.1535	48		pha				pha
.1536	a5 07		lda $07				lda 	TOS+1
.1538	48		pha				pha
.1539	a9 00		lda #$00			lda 	#(1024) & $FF
.153b	a0 04		ldy #$04			ldy 	#(1024) >> 8
.153d	80 d5		bra $1514			bra 	Const2Byte
.153f					C4096:
.153f	a5 06		lda $06				lda 	TOS
.1541	48		pha				pha
.1542	a5 07		lda $07				lda 	TOS+1
.1544	48		pha				pha
.1545	a9 00		lda #$00			lda 	#(4096) & $FF
.1547	a0 10		ldy #$10			ldy 	#(4096) >> 8
.1549	80 c9		bra $1514			bra 	Const2Byte
.154b					C32767:
.154b	a5 06		lda $06				lda 	TOS
.154d	48		pha				pha
.154e	a5 07		lda $07				lda 	TOS+1
.1550	48		pha				pha
.1551	a9 ff		lda #$ff			lda 	#(32767) & $FF
.1553	a0 7f		ldy #$7f			ldy 	#(32767) >> 8
.1555	80 bd		bra $1514			bra 	Const2Byte
.1557					C32768:
.1557	a5 06		lda $06				lda 	TOS
.1559	48		pha				pha
.155a	a5 07		lda $07				lda 	TOS+1
.155c	48		pha				pha
.155d	a9 00		lda #$00			lda 	#(32768) & $FF
.155f	a0 80		ldy #$80			ldy 	#(32768) >> 8
.1561	80 b1		bra $1514			bra 	Const2Byte

;******  Return to file: kernel.asm


;******  Processing file: words/data/stack.src

.1563					Drop:
.1563	68		pla				pla
.1564	85 07		sta $07				sta 	TOS+1
.1566	68		pla				pla
.1567	85 06		sta $06				sta 	TOS
.1569	4c 00 00	jmp $0000			jmp 	NextCode
.156c					TestDup:
.156c	a5 06		lda $06				lda 	TOS
.156e	05 07		ora $07				ora 	TOS+1
.1570	d0 03		bne $1575			bne 	Dup
.1572	4c 00 00	jmp $0000			jmp 	NextCode
.1575					Dup:
.1575	a5 06		lda $06				lda 	TOS
.1577	48		pha				pha
.1578	a5 07		lda $07				lda 	TOS+1
.157a	48		pha				pha
.157b	4c 00 00	jmp $0000			jmp 	NextCode
.157e					Swap:
.157e	86 10		stx $10				stx 	temp1
.1580	7a		ply				ply
.1581	fa		plx				plx
.1582	a5 06		lda $06				lda 	TOS
.1584	48		pha				pha
.1585	a5 07		lda $07				lda 	TOS+1
.1587	48		pha				pha
.1588	86 06		stx $06				stx 	TOS
.158a	84 07		sty $07				sty 	TOS+1
.158c	a6 10		ldx $10				ldx 	temp1
.158e	4c 00 00	jmp $0000			jmp 	NextCode
.1591					Over:
.1591	a5 06		lda $06				lda 	TOS
.1593	48		pha				pha
.1594	a5 07		lda $07				lda 	TOS+1
.1596	48		pha				pha
.1597	86 10		stx $10				stx 	temp1
.1599	ba		tsx				tsx
.159a	bd 04 01	lda $0104,x			lda 	stack3low,x
.159d	85 06		sta $06				sta 	TOS
.159f	bd 03 01	lda $0103,x			lda 	stack3High,x
.15a2	85 07		sta $07				sta 	TOS+1
.15a4	a6 10		ldx $10				ldx 	temp1
.15a6	4c 00 00	jmp $0000			jmp 	NextCode
.15a9					Nip:
.15a9	68		pla				pla
.15aa	68		pla				pla
.15ab	4c 00 00	jmp $0000			jmp 	NextCode
.15ae					Rot:
.15ae	86 10		stx $10				stx 	temp1
.15b0	ba		tsx				tsx
.15b1	bd 04 01	lda $0104,x			lda 	Stack3Low,x
.15b4	a8		tay				tay
.15b5	bd 02 01	lda $0102,x			lda 	Stack2Low,x
.15b8	9d 04 01	sta $0104,x			sta 	Stack3Low,x
.15bb	a5 06		lda $06				lda 	TOS
.15bd	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.15c0	84 06		sty $06				sty 	TOS
.15c2	bd 03 01	lda $0103,x			lda 	Stack3High,x
.15c5	a8		tay				tay
.15c6	bd 01 01	lda $0101,x			lda 	Stack2High,x
.15c9	9d 03 01	sta $0103,x			sta 	Stack3High,x
.15cc	a5 07		lda $07				lda 	TOS+1
.15ce	9d 01 01	sta $0101,x			sta 	Stack2High,x
.15d1	84 07		sty $07				sty 	TOS+1
.15d3	a6 10		ldx $10				ldx 	temp1
.15d5	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/data/memory.src

.15d8					ByteRead:
.15d8	b2 06		lda ($06)			lda 	(TOS)
.15da	85 06		sta $06				sta 	TOS
.15dc	64 07		stz $07				stz 	TOS+1
.15de	4c 00 00	jmp $0000			jmp 	NextCode
.15e1					WordRead:
.15e1	a0 01		ldy #$01			ldy 	#1
.15e3	b1 06		lda ($06),y			lda 	(TOS),y
.15e5	a8		tay				tay
.15e6	b2 06		lda ($06)			lda 	(TOS)
.15e8	85 06		sta $06				sta 	TOS
.15ea	84 07		sty $07				sty 	TOS+1
.15ec	4c 00 00	jmp $0000			jmp 	NextCode
.15ef					ByteWrite:
.15ef	68		pla				pla
.15f0	68		pla				pla
.15f1	92 06		sta ($06)			sta 	(TOS)
.15f3	68		pla				pla
.15f4	85 07		sta $07				sta 	TOS+1
.15f6	68		pla				pla
.15f7	85 06		sta $06				sta 	TOS
.15f9	4c 00 00	jmp $0000			jmp 	NextCode
.15fc					WordWrite:
.15fc	68		pla				pla
.15fd	a0 01		ldy #$01			ldy 	#1
.15ff	91 06		sta ($06),y			sta 	(TOS),y
.1601	68		pla				pla
.1602	92 06		sta ($06)			sta 	(TOS)
.1604	68		pla				pla
.1605	85 07		sta $07				sta 	TOS+1
.1607	68		pla				pla
.1608	85 06		sta $06				sta 	TOS
.160a	4c 00 00	jmp $0000			jmp 	NextCode
.160d					WordAdd:
.160d	7a		ply				ply
.160e	68		pla				pla
.160f	18		clc				clc
.1610	72 06		adc ($06)			adc 	(TOS)
.1612	92 06		sta ($06)			sta 	(TOS)
.1614	98		tya				tya
.1615	a0 01		ldy #$01			ldy 	#1
.1617	71 06		adc ($06),y			adc 	(TOS),y
.1619	91 06		sta ($06),y			sta 	(TOS),y
.161b	68		pla				pla
.161c	85 07		sta $07				sta 	TOS+1
.161e	68		pla				pla
.161f	85 06		sta $06				sta 	TOS
.1621	4c 00 00	jmp $0000			jmp 	NextCode
.1624					AllocateMemory:
.1624	a5 06		lda $06				lda 	TOS 						; save memory required on stack.
.1626	48		pha				pha
.1627	a5 07		lda $07				lda 	TOS+1
.1629	48		pha				pha
.162a	a5 0e		lda $0e				lda 	nextFreeMem 				; copy free mem address to TOS
.162c	85 06		sta $06				sta 	TOS
.162e	a5 0f		lda $0f				lda 	nextFreeMem+1
.1630	85 07		sta $07				sta 	TOS+1
.1632	7a		ply				ply 								; advance the free ram pointer
.1633	68		pla				pla
.1634	20 91 1b	jsr $1b91			jsr 	AdvanceFreeMem
.1637	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/encode/encode.src

.163a					EncodeProgram:
.163a	48		pha				pha 								; save registers.
.163b	da		phx				phx
.163c	5a		phy				phy
.163d	84 09		sty $09				sty 	srcPtr+1					; save source pointer.
.163f	85 08		sta $08				sta		srcPtr
.1641	20 63 18	jsr $1863			jsr 	EncodeTrimTrailingSpaces 	; remove trailing spaces.
.1644	a9 03		lda #$03			lda 	#3 							; reset the encode Buffer
.1646	8d 10 09	sta $0910			sta 	encodeBuffer 				; this is also the write ptr/offset
.1649	9c 11 09	stz $0911			stz 	encodeBuffer+1 				; the line number
.164c	9c 12 09	stz $0912			stz 	encodeBuffer+2 				; which is initially zero.
.164f	b2 08		lda ($08)			lda 	(srcPtr) 					; check if first character is digit
.1651	20 0e 18	jsr $180e			jsr 	CheckIsDigit
.1654	90 09		bcc $165f			bcc 	_EPNoLineNumber 			; if so there is a line number
.1656	20 30 18	jsr $1830			jsr 	EncodeGetConstant 			; extract that constant from the source
.1659	8d 11 09	sta $0911			sta 	encodeBuffer+1 				; that is the line number
.165c	8c 12 09	sty $0912			sty 	encodeBuffer+2
.165f					_EPNoLineNumber:
.165f					EncodeLoop:
.165f	20 55 18	jsr $1855			jsr 	EncSkipSpaces 				; skip over spaces
.1662	b2 08		lda ($08)			lda 	(srcPtr) 					; reached end ?
.1664	d0 0b		bne $1671			bne 	_EPNotEnd
.1666					_EPEndEncode:
.1666	a9 7a		lda #$7a			lda 	#NextLine & $FF 			; compile $$nextline to mark eol
.1668	a0 1e		ldy #$1e			ldy 	#NextLine >> 8
.166a	20 e9 17	jsr $17e9			jsr 	EncodeWriteWord
.166d	7a		ply				ply									; restore and exit.
.166e	fa		plx				plx
.166f	68		pla				pla
.1670	60		rts				rts
.1671					_EPNotEnd:
.1671	b2 08		lda ($08)			lda 	(srcPtr)
.1673	c9 22		cmp #$22			cmp 	#'"'						; is it a quoted string or comment ?
.1675	f0 04		beq $167b			beq 	_EPIsComStr
.1677	c9 27		cmp #$27			cmp 	#"'"
.1679	d0 05		bne $1680			bne 	_EPNotComStr
.167b					_EPIsComStr:
.167b	20 40 17	jsr $1740			jsr 	EncodeCommentString
.167e	80 df		bra $165f			bra 	EncodeLoop
.1680					_EPNotComStr:
.1680	38		sec				sec
.1681	20 42 18	jsr $1842			jsr 	EncSetBit7Word
.1684	20 7c 18	jsr $187c			jsr 	EncodeSearchDictionary		; look it up
.1687	90 44		bcc $16cd			bcc 	_EPNotInDictionary
.1689	85 10		sta $10				sta 	temp1 						; save dictionary record address
.168b	84 11		sty $11				sty 	temp1+1
.168d	a0 01		ldy #$01			ldy 	#1
.168f	b1 10		lda ($10),y			lda 	(temp1),y 					; check if has an encode bit
.1691	29 20		and #$20			and 	#$20
.1693	d0 12		bne $16a7			bne 	_EPEncodeRoutine 			; if so, do special routine.
.1695	a0 02		ldy #$02			ldy 	#2 							; write out the routine address
.1697	b1 10		lda ($10),y			lda 	(temp1),y
.1699	20 f3 17	jsr $17f3			jsr 	EncodeWriteByte
.169c	c8		iny				iny
.169d	b1 10		lda ($10),y			lda 	(temp1),y
.169f	20 f3 17	jsr $17f3			jsr 	EncodeWriteByte
.16a2	20 1a 18	jsr $181a			jsr 	EncodeMoveNextWord 			; advance to the next and loop
.16a5	80 b8		bra $165f			bra 	EncodeLoop
.16a7					_EPEncodeRoutine:
.16a7	a0 01		ldy #$01			ldy 	#1							; get type bit
.16a9	b1 10		lda ($10),y			lda 	(temp1),y
.16ab	a0 04		ldy #$04			ldy 	#4							; encoder here if no decoder
.16ad	29 10		and #$10			and 	#$10 						; but decoder comes first
.16af	f0 02		beq $16b3			beq 	_EPENoDecoder
.16b1	c8		iny				iny 								; so if it exists, adjust for it.
.16b2	c8		iny				iny
.16b3					_EPENoDecoder:
.16b3	b1 10		lda ($10),y			lda 	(temp1),y 					; copy exec addr to temp2
.16b5	85 12		sta $12				sta 	temp2
.16b7	c8		iny				iny
.16b8	b1 10		lda ($10),y			lda 	(temp1),y
.16ba	85 13		sta $13				sta 	temp2+1
.16bc	48		pha				pha 								; call routine preserving state
.16bd	da		phx				phx
.16be	5a		phy				phy
.16bf	20 ca 16	jsr $16ca			jsr 	_EPECallTemp2
.16c2	7a		ply				ply
.16c3	fa		plx				plx
.16c4	68		pla				pla
.16c5	20 1a 18	jsr $181a			jsr 	EncodeMoveNextWord 			; advance to the next and loop
.16c8	80 95		bra $165f			bra 	EncodeLoop
.16ca					_EPECallTemp2:
.16ca	6c 12 00	jmp ($0012)			jmp 	(temp2)
.16cd					_EPNotInDictionary:
.16cd	20 9b 17	jsr $179b			jsr 	EncodeSearchUserDefined 	; are there any user defined routines
.16d0	90 19		bcc $16eb			bcc 	_EPNotDefined
.16d2	48		pha				pha
.16d3	a9 18		lda #$18			lda	 	#CallHandler & $FF 			; write code call handler
.16d5	20 f3 17	jsr $17f3			jsr 	EncodeWriteByte
.16d8	a9 1a		lda #$1a			lda	 	#CallHandler >> 8
.16da	20 f3 17	jsr $17f3			jsr 	EncodeWriteByte
.16dd	68		pla				pla 								; write line number
.16de	20 f3 17	jsr $17f3			jsr 	EncodeWriteByte
.16e1	98		tya				tya
.16e2	20 f3 17	jsr $17f3			jsr 	EncodeWriteByte
.16e5	20 1a 18	jsr $181a			jsr 	EncodeMoveNextWord 			; advance to the next and loop
.16e8	4c 5f 16	jmp $165f			jmp 	EncodeLoop
.16eb					_EPNotDefined:
.16eb	b2 08		lda ($08)			lda 	(srcPtr) 					; first character
.16ed	c9 3c		cmp #$3c			cmp 	#"<"						; is it <line> which is call syntax
.16ef	f0 29		beq $171a			beq 	_EPCallDirect
.16f1	c9 21		cmp #$21			cmp 	#"!"						; check for variable operators
.16f3	f0 42		beq $1737			beq 	_EPVariable
.16f5	c9 40		cmp #$40			cmp 	#"@"
.16f7	f0 3e		beq $1737			beq 	_EPVariable
.16f9	c9 26		cmp #$26			cmp 	#"&"
.16fb	f0 3a		beq $1737			beq 	_EPVariable
.16fd	a9 86		lda #$86			lda 	#Literal2Byte & $FF 		; write out 2 byte literal
.16ff	a0 10		ldy #$10			ldy 	#Literal2Byte >> 8
.1701	20 e9 17	jsr $17e9			jsr 	EncodeWriteWord
.1704					_EPOutputConstant:
.1704	20 30 18	jsr $1830			jsr 	EncodeGetConstant 			; extract that constant from the source
.1707	90 06		bcc $170f			bcc 	_EPFail 					; if can't find one, that's us done.
.1709	20 e9 17	jsr $17e9			jsr 	EncodeWriteWord 			; write out the encoded value.
.170c	4c 5f 16	jmp $165f			jmp 	EncodeLoop 					; and go round again.
.170f					_EPFail:
.170f	20 20 10	jsr $1020			jsr 	ErrorHandler
>1712	53 59 4e 54 41 58 3f 00				.text 	"SYNTAX?",0
.171a					_EPCallDirect:
.171a	a9 18		lda #$18			lda	 	#CallHandler & $FF 			; write code call handler
.171c	a0 1a		ldy #$1a			ldy	 	#CallHandler >> 8
.171e	20 e9 17	jsr $17e9			jsr 	EncodeWriteWord
.1721	a9 01		lda #$01			lda 	#1
.1723	20 26 18	jsr $1826			jsr 	EncodeAddSrcPtr 			; skip over the <
.1726	a0 ff		ldy #$ff			ldy 	#255 						; scan forward for last character.
.1728					_EPToLast:
.1728	c8		iny				iny
.1729	b1 08		lda ($08),y			lda 	(srcPtr),y
.172b	10 fb		bpl $1728			bpl	 	_EPToLast
.172d	c9 be		cmp #$be			cmp 	#">"+$80 					; must be >
.172f	d0 de		bne $170f			bne 	_EPFail
.1731	a9 20		lda #$20			lda 	#" " 						; strip back to a number, erases last char
.1733	91 08		sta ($08),y			sta 	(srcPtr),y
.1735	80 cd		bra $1704			bra 	_EPOutputConstant 			; borrow the number routines extract/compile constant
.1737					_EPVariable:
.1737	20 d0 18	jsr $18d0			jsr 	EncodeVariableReference
.173a	20 1a 18	jsr $181a			jsr 	EncodeMoveNextWord 			; advance to the next and loop
.173d	4c 5f 16	jmp $165f			jmp 	EncodeLoop

;******  Return to file: kernel.asm


;******  Processing file: words/encode/comstr.src

.1740					EncodeCommentString:
.1740	b2 08		lda ($08)			lda 	(srcPtr) 					; get first character
.1742	64 10		stz $10				stz 	temp1 						; other terminator = EOL
.1744	aa		tax				tax 								; save in X
.1745	a9 91		lda #$91			lda 	#(SkipComment & $FF)		; get the routine to use
.1747	a0 1e		ldy #$1e			ldy 	#(SkipComment >> 8)
.1749	e0 27		cpx #$27			cpx 	#"'"
.174b	f0 06		beq $1753			beq 	_ECSGotCmd
.174d	86 10		stx $10				stx		temp1 						; other terminator = "
.174f	a9 ae		lda #$ae			lda 	#(LiteralString & $FF)
.1751	a0 10		ldy #$10			ldy 	#(LiteralString >> 8)
.1753					_ECSGotCmd:
.1753	20 e9 17	jsr $17e9			jsr 	EncodeWriteWord 			; write word out.
.1756	a9 01		lda #$01			lda 	#1 							; skip over ' or "
.1758	20 26 18	jsr $1826			jsr 	EncodeAddSrcPtr
.175b	e0 27		cpx #$27			cpx 	#"'"						; if ' then skip spaces
.175d	d0 03		bne $1762			bne 	_ECNoSkipSpaces
.175f	20 55 18	jsr $1855			jsr 	EncSkipSpaces
.1762					_ECNoSkipSpaces:
.1762	ae 10 09	ldx $0910			ldx 	encodeBuffer 				; keep offset to buffer in X.
.1765	a9 01		lda #$01			lda 	#1
.1767	20 f3 17	jsr $17f3			jsr 	EncodeWriteByte 			; write total length, so far 1.
.176a	a0 00		ldy #$00			ldy 	#0 							; for reading the actual text
.176c					_ECSCopyText:
.176c	b1 08		lda ($08),y			lda 	(srcPtr),y 					; get next
.176e	f0 18		beq $1788			beq 	_ECSEndOfLine 				; end of line ?
.1770	c5 10		cmp $10				cmp 	temp1						; is it the other terminator
.1772	f0 09		beq $177d			beq 	_ECSEndOfString 			; if so must be closing quote.
.1774	20 f3 17	jsr $17f3			jsr 	EncodeWriteByte 			; write the byte out
.1777	fe 10 09	inc $0910,x			inc 	encodeBuffer,x				; increase length
.177a	c8		iny				iny 								; next character
.177b	80 ef		bra $176c			bra 	_ECSCopyText
.177d					_ECSEndOfString:
.177d	c8		iny				iny 								; skip closing quote.
.177e	a9 00		lda #$00			lda 	#0 							; write out ASCIIZ
.1780	20 f3 17	jsr $17f3			jsr 	EncodeWriteByte
.1783	fe 10 09	inc $0910,x			inc 	encodeBuffer,x 				; fix the length up.
.1786	80 0e		bra $1796			bra 	_ECSComplete 				; and just patching up srcPtr to do.
.1788					_ECSEndOfLine:
.1788	a5 10		lda $10				lda 	temp1 						; missing closing quote
.178a	f0 0a		beq $1796			beq 	_ECSComplete 				; if we were doing a string.
.178c	20 20 10	jsr $1020			jsr 	ErrorHandler
>178f	51 55 4f 54 45 3f 00				.text 	"QUOTE?",0
.1796					_ECSComplete:
.1796	98		tya				tya									; skip over.
.1797	20 26 18	jsr $1826			jsr 	EncodeAddSrcPtr
.179a	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/encode/encdef.src

.179b					EncodeSearchUserDefined:
.179b	38		sec				sec 								; temp1 = srcPtr-6 because the
.179c	a5 08		lda $08				lda 	srcPtr				 		; name is 6 in (offset line# $$call len)
.179e	e9 06		sbc #$06			sbc		#6
.17a0	85 10		sta $10				sta 	temp1
.17a2	a5 09		lda $09				lda 	srcPtr+1
.17a4	e9 00		sbc #$00			sbc 	#0
.17a6	85 11		sta $11				sta 	temp1+1
.17a8	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.17aa	85 12		sta $12				sta 	0+(temp2)
.17ac	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.17ae	85 13		sta $13				sta 	1+(temp2)
.17b0					_ESULoop:
.17b0	b2 12		lda ($12)			lda 	(temp2) 					; reached the end (offset 0)
.17b2	f0 33		beq $17e7			beq 	_ESUFail
.17b4	a0 03		ldy #$03			ldy 	#3 							; check it is $$define
.17b6	b1 12		lda ($12),y			lda 	(temp2),y
.17b8	c9 b6		cmp #$b6			cmp 	#DefineCode & $FF
.17ba	d0 1e		bne $17da			bne 	_ESUNext
.17bc	c8		iny				iny
.17bd	b1 12		lda ($12),y			lda 	(temp2),y
.17bf	c9 1e		cmp #$1e			cmp 	#DefineCode >> 8
.17c1	d0 17		bne $17da			bne 	_ESUNext
.17c3	c8		iny				iny 								; skip length byte.
.17c4					_ESUCompare:
.17c4	c8		iny				iny
.17c5	b1 12		lda ($12),y			lda 	(temp2),y
.17c7	d1 10		cmp ($10),y			cmp 	(temp1),y
.17c9	d0 0f		bne $17da			bne 	_ESUNext
.17cb	0a		asl a				asl 	a 							; bit 7 set => found it.
.17cc	90 f6		bcc $17c4			bcc 	_ESUCompare
.17ce	a0 01		ldy #$01			ldy 	#1
.17d0	b1 12		lda ($12),y			lda 	(temp2),y 					; read in the line number to YA
.17d2	aa		tax				tax
.17d3	c8		iny				iny
.17d4	b1 12		lda ($12),y			lda 	(temp2),y
.17d6	a8		tay				tay
.17d7	8a		txa				txa
.17d8	38		sec				sec 								; return with carry set as found
.17d9	60		rts				rts
.17da					_ESUNext:
.17da	18		clc				clc
.17db	a5 12		lda $12				lda 	temp2
.17dd	72 12		adc ($12)			adc 	(temp2)
.17df	85 12		sta $12				sta 	temp2
.17e1	90 02		bcc $17e5			bcc 	_NoCarryAdv
.17e3	e6 13		inc $13				inc 	temp2+1
.17e5					_NoCarryAdv:
.17e5	80 c9		bra $17b0			bra 	_ESULoop 					; and loop round
.17e7					_ESUFail:
.17e7	18		clc				clc
.17e8	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/encode/encutils.src

.17e9					EncodeWriteWord:
.17e9	48		pha				pha
.17ea	20 f3 17	jsr $17f3			jsr 	EncodeWriteByte
.17ed	98		tya				tya
.17ee	20 f3 17	jsr $17f3			jsr 	EncodeWriteByte
.17f1	68		pla				pla
.17f2	60		rts				rts
.17f3					EncodeWriteByte:
.17f3	da		phx				phx
.17f4	ae 10 09	ldx $0910			ldx 	encodeBuffer
.17f7	9d 10 09	sta $0910,x			sta 	encodeBuffer,x
.17fa	9e 11 09	stz $0911,x			stz 	encodeBuffer+1,x
.17fd	ee 10 09	inc $0910			inc 	encodeBuffer
.1800	fa		plx				plx
.1801	60		rts				rts
.1802					CheckIsLetter:
.1802	c9 41		cmp #$41			cmp 	#"A"						; return CS if A..Z
.1804	90 06		bcc $180c			bcc 	_CILFail
.1806	c9 5b		cmp #$5b			cmp 	#"Z"+1
.1808	b0 02		bcs $180c			bcs 	_CILFail
.180a	38		sec				sec
.180b	60		rts				rts
.180c					_CILFail:
.180c	18		clc				clc
.180d	60		rts				rts
.180e					CheckIsDigit:
.180e	c9 30		cmp #$30			cmp 	#"0"						; return CS if 0..9
.1810	90 06		bcc $1818			bcc 	_CIDFail
.1812	c9 3a		cmp #$3a			cmp 	#"9"+1
.1814	b0 02		bcs $1818			bcs 	_CIDFail
.1816	38		sec				sec
.1817	60		rts				rts
.1818					_CIDFail:
.1818	18		clc				clc
.1819	60		rts				rts
.181a					EncodeMoveNextWord:
.181a	a0 ff		ldy #$ff			ldy 	#255 						; search forward
.181c					_EPNWLoop:
.181c	c8		iny				iny
.181d	b1 08		lda ($08),y			lda 	(srcPtr),y
.181f	c9 21		cmp #$21			cmp 	#" "+1						; looking for <= space
.1821	b0 f9		bcs $181c			bcs 	_EPNWLoop
.1823	98		tya				tya
.1824	80 00		bra $1826			bra 	EncodeAddSrcPtr
.1826					EncodeAddSrcPtr:
.1826	18		clc				clc 								; add offset
.1827	65 08		adc $08				adc 	srcPtr
.1829	85 08		sta $08				sta 	srcPtr
.182b	90 02		bcc $182f			bcc 	_EASPNoCarry
.182d	e6 09		inc $09				inc 	srcPtr+1					; carry through
.182f					_EASPNoCarry:
.182f	60		rts				rts
.1830					EncodeGetConstant:
.1830	a5 08		lda $08				lda 	srcPtr 						; get source
.1832	a4 09		ldy $09				ldy 	srcPtr+1
.1834	20 ec 1d	jsr $1dec			jsr 	ConvertToInteger 			; call converter
.1837	90 08		bcc $1841			bcc 	_EGCExit
.1839	20 26 18	jsr $1826			jsr 	EncodeAddSrcPtr 			; if passed add chars to src ptr
.183c	a5 14		lda $14				lda 	temp3 						; get result into YA
.183e	a4 15		ldy $15				ldy 	temp3+1
.1840	38		sec				sec 								; return CS
.1841					_EGCExit:
.1841	60		rts				rts
.1842					EncSetBit7Word:
.1842	08		php				php 								; save carry
.1843	a0 ff		ldy #$ff			ldy 	#255 						; scan forward for space/NULL
.1845					_ESB7Loop:
.1845	c8		iny				iny
.1846	b1 08		lda ($08),y			lda 	(srcPtr),y
.1848	c9 21		cmp #$21			cmp 	#" "+1 						; while > ' '
.184a	b0 f9		bcs $1845			bcs 	_ESB7Loop
.184c	88		dey				dey									; previous character
.184d	b1 08		lda ($08),y			lda 	(srcPtr),y 					; read it
.184f	0a		asl a				asl 	a 							; shift bit 7 out
.1850	28		plp				plp 								; restore carry
.1851	6a		ror a				ror 	a 							; shift it in
.1852	91 08		sta ($08),y			sta 	(srcPtr),y 					; write back and exit
.1854	60		rts				rts
.1855					EncSkipSpaces:
.1855	b2 08		lda ($08)			lda 	(srcPtr) 					; skip over spaces/ reached end
.1857	c9 20		cmp #$20			cmp 	#32
.1859	d0 07		bne $1862			bne 	_ESNotSpace
.185b	a9 01		lda #$01			lda 	#1
.185d	20 26 18	jsr $1826			jsr 	EncodeAddSrcPtr
.1860	80 f3		bra $1855			bra	 	EncSkipSpaces
.1862					_ESNotSpace:
.1862	60		rts				rts
.1863					EncodeTrimTrailingSpaces:
.1863	a0 ff		ldy #$ff			ldy 	#255 						; find EOS
.1865					_ETTFindEnd:
.1865	c8		iny				iny
.1866	b1 08		lda ($08),y			lda 	(srcPtr),y
.1868	d0 fb		bne $1865			bne 	_ETTFindEnd
.186a					_ETTRemoveSpace:
.186a	c0 00		cpy #$00			cpy 	#0 							; start of string
.186c	f0 0d		beq $187b			beq 	_ETTExit
.186e	88		dey				dey 								; previous character 1..32
.186f	b1 08		lda ($08),y			lda 	(srcPtr),y
.1871	c9 21		cmp #$21			cmp 	#32+1
.1873	b0 06		bcs $187b			bcs 	_ETTExit
.1875	a9 00		lda #$00			lda 	#0 							; erase it and go round again
.1877	91 08		sta ($08),y			sta 	(srcPtr),y
.1879	80 ef		bra $186a			bra 	_ETTRemoveSpace
.187b					_ETTExit:
.187b	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/encode/encsearch.src

.187c					EncodeSearchDictionary:
.187c	a9 b4		lda #$b4			lda 	#(Dictionary) & $FF
.187e	85 10		sta $10				sta 	0+(temp1)
.1880	a9 20		lda #$20			lda 	#(Dictionary) >> 8
.1882	85 11		sta $11				sta 	1+(temp1)
.1884					_ESDLoop:
.1884	b2 10		lda ($10)			lda 	(temp1) 					; end of dictionary return with CC.
.1886	18		clc				clc
.1887	f0 46		beq $18cf			beq 	_ESDExit
.1889	a0 01		ldy #$01			ldy 	#1 							; get control bits, get offset to name.
.188b	b1 10		lda ($10),y			lda 	(temp1),y
.188d	4a		lsr a				lsr 	a 							; encode/decode bits move to 0,1
.188e	4a		lsr a				lsr 	a
.188f	4a		lsr a				lsr 	a
.1890	4a		lsr a				lsr 	a
.1891	c8		iny				iny 								; Y = 2
.1892	4a		lsr a				lsr 	a
.1893	90 01		bcc $1896			bcc 	_ESDNotDec
.1895	c8		iny				iny
.1896					_ESDNotDec:
.1896	4a		lsr a				lsr 	a
.1897	90 01		bcc $189a			bcc 	_ESDNotInc
.1899	c8		iny				iny
.189a					_ESDNotInc:
.189a	98		tya				tya
.189b	0a		asl a				asl 	a 							; A is now 4,6,8 offset to name.
.189c	a8		tay				tay
.189d	b1 10		lda ($10),y			lda 	(temp1),y 					; quick check of first character
.189f	d2 08		cmp ($08)			cmp 	(srcPtr)
.18a1	d0 1f		bne $18c2			bne 	_ESDNext 					; do not match, go to next
.18a3	98		tya				tya 								; make temp2 point to the name in
.18a4	18		clc				clc 								; the dictionary.
.18a5	65 10		adc $10				adc 	temp1
.18a7	85 12		sta $12				sta 	temp2
.18a9	a5 11		lda $11				lda 	temp1+1
.18ab	69 00		adc #$00			adc 	#0
.18ad	85 13		sta $13				sta 	temp2+1
.18af	a0 ff		ldy #$ff			ldy 	#255 						; now start matching up.
.18b1					_ESDCompare:
.18b1	c8		iny				iny
.18b2	b1 08		lda ($08),y			lda 	(srcPtr),y
.18b4	d1 12		cmp ($12),y			cmp 	(temp2),y
.18b6	d0 0a		bne $18c2			bne 	_ESDNext
.18b8	0a		asl a				asl 	a
.18b9	90 f6		bcc $18b1			bcc 	_ESDCompare
.18bb	a5 10		lda $10				lda 	temp1 						; return address in YA and carry set.
.18bd	a4 11		ldy $11				ldy 	temp1+1
.18bf	38		sec				sec
.18c0	80 0d		bra $18cf			bra 	_ESDExit
.18c2					_ESDNext:
.18c2	18		clc				clc
.18c3	a5 10		lda $10				lda 	temp1
.18c5	72 10		adc ($10)			adc 	(temp1)
.18c7	85 10		sta $10				sta 	temp1
.18c9	90 b9		bcc $1884			bcc 	_ESDLoop
.18cb	e6 11		inc $11				inc 	temp1+1
.18cd	80 b5		bra $1884			bra 	_ESDLoop
.18cf					_ESDExit:
.18cf	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/encode/encvar.src

.18d0					EncodeVariableReference:
.18d0	b2 08		lda ($08)			lda 	(srcPtr)					; get the type, use it to identify the routine
.18d2	a2 61		ldx #$61			ldx 	#VarAddressHandler & $FF
.18d4	a0 1f		ldy #$1f			ldy 	#VarAddressHandler >> 8
.18d6	c9 26		cmp #$26			cmp 	#"&"
.18d8	f0 0c		beq $18e6			beq 	_EVFHaveAddress
.18da	a2 7b		ldx #$7b			ldx 	#VarReadHandler & $FF
.18dc	a0 1f		ldy #$1f			ldy 	#VarReadHandler >> 8
.18de	c9 40		cmp #$40			cmp 	#"@"
.18e0	f0 04		beq $18e6			beq 	_EVFHaveAddress
.18e2	a2 97		ldx #$97			ldx 	#VarWriteHandler & $FF
.18e4	a0 1f		ldy #$1f			ldy 	#VarWriteHandler >> 8
.18e6					_EVFHaveAddress:
.18e6	8a		txa				txa
.18e7	20 e9 17	jsr $17e9			jsr 	EncodeWriteWord 			; write it out.
.18ea	a0 01		ldy #$01			ldy 	#1 							; get the first charactere
.18ec	b1 08		lda ($08),y			lda 	(srcPtr),y
.18ee	29 7f		and #$7f			and 	#$7F 						; might be the last.
.18f0	20 02 18	jsr $1802			jsr 	CheckIsLetter 				; is it A-Z
.18f3	90 1a		bcc $190f			bcc 	EVFFail
.18f5	29 1f		and #$1f			and 	#31 						; make 1-26
.18f7	85 10		sta $10				sta 	temp1 						; start building the name in temp1
.18f9	64 11		stz $11				stz 	temp1+1
.18fb	38		sec				sec 								; possible char 2
.18fc	20 1c 19	jsr $191c			jsr 	EncVarAlNum
.18ff	18		clc				clc 								; possible char 3
.1900	20 1c 19	jsr $191c			jsr 	EncVarAlNum
.1903	b1 08		lda ($08),y			lda 	(srcPtr),y 					; more text after ?
.1905	10 08		bpl $190f			bpl 	EVFFail
.1907	a5 10		lda $10				lda 	temp1 						; write out variable identifier.
.1909	a4 11		ldy $11				ldy 	temp1+1
.190b	20 e9 17	jsr $17e9			jsr 	EncodeWriteWord
.190e	60		rts				rts
.190f					EVFFail:
.190f	20 20 10	jsr $1020			jsr 	ErrorHandler
>1912	56 41 52 49 41 42 4c 45				.text 	"VARIABLE?",0
>191a	3f 00
.191c					EncVarAlNum:
.191c	b1 08		lda ($08),y			lda 	(srcPtr),y 					; points to the  last char processed.
.191e	10 01		bpl $1921			bpl 	_EVAContinue
.1920	60		rts				rts
.1921					_EVAContinue:
.1921	08		php				php 								; CS x 32 ; CC x 32 x 40
.1922	c8		iny				iny 								; get the next character, strip bit 7
.1923	b1 08		lda ($08),y			lda 	(srcPtr),y
.1925	29 7f		and #$7f			and 	#$7F
.1927	20 02 18	jsr $1802			jsr 	CheckIsLetter 				; letter ?
.192a	b0 08		bcs $1934			bcs 	_EVACharOkay
.192c	20 0e 18	jsr $180e			jsr 	CheckIsDigit				; fail if not digit.
.192f	90 de		bcc $190f			bcc 	EVFFail
.1931	18		clc				clc
.1932	69 2b		adc #$2b			adc 	#"Z"+1-"0"					; shift 0 so after Z
.1934					_EVACharOkay:
.1934	38		sec				sec 								; range 1-36
.1935	e9 40		sbc #$40			sbc 	#64
.1937	28		plp				plp 								; which multiplier ?
.1938	90 0f		bcc $1949			bcc 	_EVATimes32x40
.193a	85 12		sta $12				sta 	temp2 						; save in temp2 - A x 32
.193c	64 13		stz $13				stz 	temp2+1
.193e	a2 05		ldx #$05			ldx 	#5
.1940	06 12		asl $12		_EVA32:	asl 	temp2
.1942	26 13		rol $13				rol 	temp2+1
.1944	ca		dex				dex
.1945	d0 f9		bne $1940			bne 	_EVA32
.1947	80 0b		bra $1954			bra 	_EVAAddVar
.1949					_EVATimes32x40:
.1949	85 13		sta $13				sta 	temp2+1						; 32 x 40 = 1280 or $500, so temp2 = A x 256 x 5
.194b	64 12		stz $12				stz 	temp2
.194d	0a		asl a				asl 	a
.194e	0a		asl a				asl 	a
.194f	18		clc				clc
.1950	65 13		adc $13				adc 	temp2+1
.1952	85 13		sta $13				sta 	temp2+1
.1954					_EVAAddVar:
.1954	18		clc				clc
.1955	a5 10		lda $10				lda 	temp1
.1957	65 12		adc $12				adc 	temp2
.1959	85 10		sta $10				sta 	temp1
.195b	a5 11		lda $11				lda 	temp1+1
.195d	65 13		adc $13				adc 	temp2+1
.195f	85 11		sta $11				sta 	temp1+1
.1961	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/structures/fornext.src

.1962					ForHandler:
.1962	e6 05		inc $05				inc 	rsp 						; bump the RSP
.1964	a4 05		ldy $05				ldy 	rsp 						; get return stack and push TOS/$FF on it.
.1966	c0 40		cpy #$40			cpy 	#$40 						; overflow
.1968	f0 18		beq $1982			beq 	_FHOverflow
.196a	a5 07		lda $07				lda 	TOS+1
.196c	99 40 07	sta $0740,y			sta 	returnStackHigh,y
.196f	a5 06		lda $06				lda 	TOS
.1971	99 00 07	sta $0700,y			sta 	returnStackLow,y
.1974	a9 ff		lda #$ff			lda 	#$FF
.1976	99 80 07	sta $0780,y			sta 	returnStackX,y
.1979	68		pla				pla
.197a	85 07		sta $07				sta 	TOS+1
.197c	68		pla				pla
.197d	85 06		sta $06				sta 	TOS
.197f	4c 00 00	jmp $0000			jmp 	NextCode
.1982					_FHOverflow:
.1982	20 20 10	jsr $1020			jsr 	ErrorHandler
>1985	46 4f 52 20 53 54 41 43				.text 	"FOR STACK?",0
>198d	4b 3f 00
.1990					NextHandler:
.1990	da		phx				phx
.1991	a6 05		ldx $05				ldx 	rsp 						; get current stack ptr
.1993	bd 80 07	lda $0780,x			lda 	returnStackX,x 				; check it's a FOR Loop
.1996	c9 ff		cmp #$ff			cmp 	#$FF
.1998	d0 21		bne $19bb			bne 	NHNoFor
.199a	bd 00 07	lda $0700,x			lda 	returnStackLow,x 			; decrement the count
.199d	d0 03		bne $19a2			bne 	_NHNoBorrow
.199f	de 40 07	dec $0740,x			dec 	returnStackHigh,x
.19a2					_NHNoBorrow:
.19a2	de 00 07	dec $0700,x			dec 	returnStackLow,x
.19a5	bd 00 07	lda $0700,x			lda 	returnStackLow,x 			; have we reached the end ?
.19a8	1d 40 07	ora $0740,x			ora 	returnStackHigh,x
.19ab	fa		plx				plx 								; restore X and re-test
.19ac	09 00		ora #$00			ora 	#0
.19ae	f0 05		beq $19b5			beq 	_NHComplete 				; if so then complete, else loop.
.19b0	e8		inx				inx 								; advance to branch
.19b1	e8		inx				inx
.19b2	4c 0e 1a	jmp $1a0e			jmp 	BranchAlways
.19b5					_NHComplete:
.19b5	e8		inx				inx 								; skip over the branch quantity
.19b6	c6 05		dec $05				dec 	rsp 						; drop the indx
.19b8	4c 00 00	jmp $0000			jmp 	NextCode
.19bb					NHNoFor:
.19bb	20 20 10	jsr $1020			jsr 	ErrorHandler
>19be	4e 4f 20 46 4f 52 3f 00				.text 	"NO FOR?",0
.19c6					GetIndex:
.19c6	a4 05		ldy $05				ldy 	rsp 						; get current stack ptr
.19c8	b9 80 07	lda $0780,y			lda 	returnStackX,y 				; check it's a FOR Loop
.19cb	c9 ff		cmp #$ff			cmp 	#$FF
.19cd	d0 ec		bne $19bb			bne 	NHNoFor
.19cf	a5 06		lda $06				lda 	TOS
.19d1	48		pha				pha
.19d2	a5 07		lda $07				lda 	TOS+1
.19d4	48		pha				pha
.19d5	b9 00 07	lda $0700,y			lda 	returnStackLow,y 			; put counter-1 out
.19d8	38		sec				sec
.19d9	e9 01		sbc #$01			sbc 	#1
.19db	85 06		sta $06				sta 	TOS
.19dd	b9 40 07	lda $0740,y			lda 	returnStackHigh,y
.19e0	e9 00		sbc #$00			sbc 	#0
.19e2	85 07		sta $07				sta 	TOS+1
.19e4	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/structures/ifelseendif.src

.19e7					IfHandler:
.19e7	4c f6 19	jmp $19f6			jmp 	BranchIfZero
.19ea					ElseHandler:
.19ea	4c 0c 1a	jmp $1a0c			jmp 	BranchTestSucceedsNoPop
.19ed					EndIfHandler:
.19ed	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/structures/repeatuntil.src

.19f0					RepeatHandler:
.19f0	4c 00 00	jmp $0000			jmp 	NextCode
.19f3					UntilHandler:
.19f3	4c f6 19	jmp $19f6			jmp 	BranchIfZero

;******  Return to file: kernel.asm


;******  Processing file: words/system/branch.src

.19f6					BranchIfZero:
.19f6	a5 06		lda $06				lda 	TOS 						; check TOS = 0
.19f8	05 07		ora $07				ora 	TOS+1
.19fa	f0 0a		beq $1a06			beq 	BranchTestSucceeds
.19fc					BranchTestFails:
.19fc	68		pla				pla
.19fd	85 07		sta $07				sta 	TOS+1
.19ff	68		pla				pla
.1a00	85 06		sta $06				sta 	TOS
.1a02	e8		inx				inx 								; skip over the relative branch.
.1a03	4c 00 00	jmp $0000			jmp 	NextCode
.1a06					BranchTestSucceeds:
.1a06	68		pla				pla
.1a07	85 07		sta $07				sta 	TOS+1
.1a09	68		pla				pla
.1a0a	85 06		sta $06				sta 	TOS
.1a0c					BranchTestSucceedsNoPop:
.1a0c	e8		inx				inx 								; advance by two, to the offset
.1a0d	e8		inx				inx
.1a0e					BranchAlways:
.1a0e	8a		txa				txa 								; A = Y = position
.1a0f	a8		tay				tay 								; (IP),Y now points to the branch target
.1a10	b1 03		lda ($03),y			lda 	(IP),y 						; adjust the position
.1a12	aa		tax				tax 								; position back in this line.
.1a13	ca		dex				dex
.1a14	ca		dex				dex
.1a15	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/system/callhandler.src

.1a18					CallHandler:
.1a18	e8		inx				inx									; bump X to the call address.
.1a19	e8		inx				inx
.1a1a	e6 05		inc $05				inc 	rsp 						; bump the RSP (first time to zero)
.1a1c	a4 05		ldy $05				ldy 	rsp 						; get return stack and push IP/X on it.
.1a1e	c0 40		cpy #$40			cpy 	#$40 						; overflow
.1a20	f0 4b		beq $1a6d			beq 	_CHOverflow
.1a22	a5 04		lda $04				lda 	IP+1
.1a24	99 40 07	sta $0740,y			sta 	returnStackHigh,y
.1a27	a5 03		lda $03				lda 	IP
.1a29	99 00 07	sta $0700,y			sta 	returnStackLow,y
.1a2c	8a		txa				txa
.1a2d	99 80 07	sta $0780,y			sta 	returnStackX,y
.1a30	8a		txa				txa 								; get the line number into temp1.
.1a31	a8		tay				tay
.1a32	b1 03		lda ($03),y			lda 	(IP),y
.1a34	85 10		sta $10				sta 	temp1
.1a36	c8		iny				iny
.1a37	b1 03		lda ($03),y			lda 	(IP),y
.1a39	85 11		sta $11				sta 	temp1+1
.1a3b	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.1a3d	85 03		sta $03				sta 	0+(IP)
.1a3f	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.1a41	85 04		sta $04				sta 	1+(IP)
.1a43	b2 03		lda ($03)			lda 	(IP)						; no program code ?
.1a45	f0 17		beq $1a5e			beq 	_CHFail
.1a47	a0 01		ldy #$01			ldy 	#1 							; Y = 1 throughout.
.1a49					_CHSearch:
.1a49	b1 03		lda ($03),y			lda 	(IP),y 						; check LSB of line number
.1a4b	c5 10		cmp $10				cmp 	temp1
.1a4d	f0 2d		beq $1a7c			beq 	_CHFoundLSB
.1a4f					_CHSearchNext:
.1a4f	18		clc				clc
.1a50	a5 03		lda $03				lda 	IP
.1a52	72 03		adc ($03)			adc 	(IP)
.1a54	85 03		sta $03				sta 	IP
.1a56	90 02		bcc $1a5a			bcc 	_NoCarryAdv
.1a58	e6 04		inc $04				inc 	IP+1
.1a5a					_NoCarryAdv:
.1a5a	b2 03		lda ($03)			lda 	(IP)						; check reached the end.
.1a5c	d0 eb		bne $1a49			bne 	_CHSearch
.1a5e					_CHFail:
.1a5e	20 20 10	jsr $1020			jsr 	ErrorHandler
>1a61	44 45 46 49 4e 49 54 49				.text 	"DEFINITION?",0
>1a69	4f 4e 3f 00
.1a6d					_CHOverflow:
.1a6d	20 20 10	jsr $1020			jsr 	ErrorHandler
>1a70	53 54 41 43 4b 44 45 50				.text 	"STACKDEPTH?",0
>1a78	54 48 3f 00
.1a7c					_CHFoundLSB:
.1a7c	c8		iny				iny 								; get MSB
.1a7d	b1 03		lda ($03),y			lda 	(IP),y
.1a7f	88		dey				dey
.1a80	c5 11		cmp $11				cmp 	temp1+1 					; matches, if not contineu
.1a82	d0 cb		bne $1a4f			bne 	_CHSearchNext
.1a84	a0 03		ldy #$03			ldy 	#3	 						; check it begins with $$define
.1a86	b1 03		lda ($03),y			lda 	(IP),y
.1a88	c9 b6		cmp #$b6			cmp 	#DefineCode & $FF
.1a8a	d0 d2		bne $1a5e			bne 	_CHFail
.1a8c	c8		iny				iny
.1a8d	b1 03		lda ($03),y			lda 	(IP),y
.1a8f	c9 1e		cmp #$1e			cmp 	#DefineCode >> 8
.1a91	d0 cb		bne $1a5e			bne 	_CHFail
.1a93	c8		iny				iny
.1a94	b1 03		lda ($03),y			lda 	(IP),y 						; this is the length of the define name
.1a96	18		clc				clc
.1a97	69 03		adc #$03			adc 	#5-2 						; $$define token, line number, offset - 2 for Next
.1a99	aa		tax				tax
.1a9a	4c 00 00	jmp $0000			jmp 	NextCode
.1a9d					ReturnHandler:
.1a9d	a4 05		ldy $05				ldy 	rsp 						; get rsp
.1a9f	30 15		bmi $1ab6			bmi 	_RHUnderflow 				; if -ve underflowed
.1aa1	c6 05		dec $05				dec 	rsp 						; decrement rsp
.1aa3	b9 40 07	lda $0740,y			lda 	returnStackHigh,y 			; restore IP/X
.1aa6	85 04		sta $04				sta 	IP+1
.1aa8	b9 00 07	lda $0700,y			lda 	returnStackLow,y
.1aab	85 03		sta $03				sta 	IP
.1aad	b9 80 07	lda $0780,y			lda 	returnStackX,y
.1ab0	aa		tax				tax
.1ab1	f0 0e		beq $1ac1			beq 	_RHInLoop 					; this means you have done :something for ; next
.1ab3	4c 00 00	jmp $0000			jmp 	NextCode
.1ab6					_RHUnderflow:
.1ab6	20 20 10	jsr $1020			jsr 	ErrorHandler
>1ab9	52 45 54 55 52 4e 3f 00				.text 	"RETURN?",0
.1ac1					_RHInLoop:
.1ac1	20 20 10	jsr $1020			jsr 	ErrorHandler
>1ac4	52 45 54 55 52 4e 20 49				.text 	"RETURN IN LOOP?",0
>1acc	4e 20 4c 4f 4f 50 3f 00
.1ad4					CallHandlerDecode:
.1ad4	a9 03		lda #$03			lda 	#CTH_Call					; space
.1ad6	20 94 1c	jsr $1c94			jsr 	DecodeWriteBuffer
.1ad9	b1 08		lda ($08),y			lda 	(srcPtr),y 					; get line number into YA
.1adb	aa		tax				tax
.1adc	c8		iny				iny
.1add	b1 08		lda ($08),y			lda 	(srcPtr),y
.1adf	a8		tay				tay
.1ae0	8a		txa				txa
.1ae1	20 1e 1b	jsr $1b1e			jsr 	FindLine 					; try to locate that line.
.1ae4	b0 11		bcs $1af7			bcs 	_CHDFound 					; if found .....
.1ae6					_CHDLineOnly:
.1ae6	48		pha				pha
.1ae7	a9 3c		lda #$3c			lda 	#"<"
.1ae9	20 94 1c	jsr $1c94			jsr 	DecodeWriteBuffer
.1aec	68		pla				pla
.1aed	18		clc				clc 								; output unsigned
.1aee	20 b6 1c	jsr $1cb6			jsr 	DecodeYAToBuffer
.1af1	a9 3e		lda #$3e			lda 	#">"
.1af3	20 94 1c	jsr $1c94			jsr 	DecodeWriteBuffer
.1af6	60		rts				rts
.1af7					_CHDFound:
.1af7	48		pha				pha 								; save YA
.1af8	5a		phy				phy
.1af9	a0 03		ldy #$03			ldy 	#3 							; check first is $$define
.1afb	b1 10		lda ($10),y			lda 	(temp1),y
.1afd	c9 b6		cmp #$b6			cmp 	#DefineCode & 255
.1aff	d0 07		bne $1b08			bne 	_CHDNoDefine
.1b01	c8		iny				iny
.1b02	b1 10		lda ($10),y			lda 	(temp1),y
.1b04	c9 1e		cmp #$1e			cmp 	#DefineCode >> 8
.1b06	f0 04		beq $1b0c			beq 	_CHDFoundDefine
.1b08					_CHDNoDefine:
.1b08	7a		ply				ply									; restore the line number and print it in <>
.1b09	68		pla				pla
.1b0a	80 da		bra $1ae6			bra 	_CHDLineOnly
.1b0c					_CHDFoundDefine:
.1b0c	68		pla				pla 								; throw saved line number.
.1b0d	68		pla				pla
.1b0e	a0 05		ldy #$05			ldy 	#5 							; 3,4 $$define 5 length, name has bit 7 set at end
.1b10					_CHDOutName:
.1b10	c8		iny				iny 								; next
.1b11	b1 10		lda ($10),y			lda 	(temp1),y 					; print char no bit 7
.1b13	48		pha				pha
.1b14	29 7f		and #$7f			and 	#$7F
.1b16	20 94 1c	jsr $1c94			jsr 	DecodeWriteBuffer
.1b19	68		pla				pla
.1b1a	0a		asl a				asl 	a 							; bit 7 to carry
.1b1b	90 f3		bcc $1b10			bcc 	_CHDOutName
.1b1d	60		rts				rts
.1b1e					FindLine:
.1b1e	48		pha				pha 								; save registers
.1b1f	da		phx				phx
.1b20	5a		phy				phy
.1b21	85 12		sta $12				sta 	temp2 						; temp2 = target line#
.1b23	84 13		sty $13				sty 	temp2+1
.1b25	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.1b27	85 10		sta $10				sta 	0+(temp1)
.1b29	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.1b2b	85 11		sta $11				sta 	1+(temp1)
.1b2d					_FLLoop:
.1b2d	b2 10		lda ($10)			lda 	(temp1) 					; found end ?
.1b2f	18		clc				clc									; if so exit with CC.
.1b30	f0 1d		beq $1b4f			beq 	_FLExit
.1b32	a0 01		ldy #$01			ldy 	#1 							; check line # match
.1b34	b1 10		lda ($10),y			lda 	(temp1),y
.1b36	c5 12		cmp $12				cmp 	temp2
.1b38	d0 08		bne $1b42			bne 	_FLNext
.1b3a	c8		iny				iny
.1b3b	b1 10		lda ($10),y			lda 	(temp1),y
.1b3d	c5 13		cmp $13				cmp 	temp2+1
.1b3f	38		sec				sec 								; if so exit with CS
.1b40	f0 0d		beq $1b4f			beq 	_FLExit
.1b42					_FLNext:
.1b42	18		clc				clc
.1b43	a5 10		lda $10				lda 	temp1
.1b45	72 10		adc ($10)			adc 	(temp1)
.1b47	85 10		sta $10				sta 	temp1
.1b49	90 02		bcc $1b4d			bcc 	_NoCarryAdv
.1b4b	e6 11		inc $11				inc 	temp1+1
.1b4d					_NoCarryAdv:
.1b4d	80 de		bra $1b2d			bra 	_FLLoop 					; keep looking.
.1b4f					_FLExit:
.1b4f	7a		ply				ply
.1b50	fa		plx				plx
.1b51	68		pla				pla
.1b52	60		rts				rts
.1b53	18		clc				clc
.1b54	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/clrnew.src

.1b55					NewHandler:
.1b55	9c 00 40	stz $4000			stz 	ProgramMemory 				; Make the first offset zero.
.1b58	20 64 1b	jsr $1b64			jsr 	ClearVariableSpace 			; clear variables, reset pointers
.1b5b	4c 00 00	jmp $0000			jmp 	NextCode
.1b5e					ClrHandler:
.1b5e	20 64 1b	jsr $1b64			jsr 	ClearVariableSpace 			; clear variables, reset pointers
.1b61	4c 00 00	jmp $0000			jmp 	NextCode
.1b64					ClearVariableSpace:
.1b64	a9 ff		lda #$ff			lda 	#$FF 						; empty return stack
.1b66	85 05		sta $05				sta 	rsp
.1b68	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.1b6a	85 0e		sta $0e				sta 	0+(nextFreeMem)
.1b6c	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.1b6e	85 0f		sta $0f				sta 	1+(nextFreeMem)
.1b70	a0 1f		ldy #$1f			ldy 	#hashTableSize*2-1 			; erase the hash table (used for variables)
.1b72					_CVSHashClear:
.1b72	a9 00		lda #$00			lda 	#0 							; all the first record pointers are $00
.1b74	99 40 06	sta $0640,y			sta 	hashTable,y
.1b77	88		dey				dey
.1b78	10 f8		bpl $1b72			bpl 	_CVSHashClear
.1b7a					_CVSFindEnd:
.1b7a	18		clc				clc
.1b7b	a5 0e		lda $0e				lda 	nextFreeMem
.1b7d	72 0e		adc ($0e)			adc 	(nextFreeMem)
.1b7f	85 0e		sta $0e				sta 	nextFreeMem
.1b81	90 02		bcc $1b85			bcc 	_NoCarryAdv
.1b83	e6 0f		inc $0f				inc 	nextFreeMem+1
.1b85					_NoCarryAdv:
.1b85	b2 0e		lda ($0e)			lda 	(nextFreeMem)
.1b87	d0 f1		bne $1b7a			bne 	_CVSFindEnd
.1b89	a9 08		lda #$08			lda 	#8 							; this puts a gap in, more for clarity than anything.
.1b8b	a0 00		ldy #$00			ldy 	#0
.1b8d	20 91 1b	jsr $1b91			jsr 	AdvanceFreeMem				; we need +1 because the previous code leaves the
.1b90	60		rts				rts 								; free mem pointer pointing to the last zero offset
.1b91					AdvanceFreeMem:
.1b91	18		clc				clc
.1b92	65 0e		adc $0e				adc 	nextFreeMem
.1b94	85 0e		sta $0e				sta 	nextFreeMem
.1b96	98		tya				tya
.1b97	65 0f		adc $0f				adc 	nextFreeMem+1
.1b99	85 0f		sta $0f				sta 	nextFreeMem+1
.1b9b	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/debug.src

.1b9c					ExitDump:
.1b9c	ba		tsx				tsx 								; save Data Stack in temp1
.1b9d	86 10		stx $10				stx 	temp1
.1b9f	4c ff ff	jmp $ffff			jmp 	$FFFF 						; makes the X16-Emulator dump-exit.
.1ba2					BreakCmd:
>1ba2	ff						.byte 	$FF
.1ba3	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/system/decode.src

.1ba6					DecodeLineIntoBufPtr:
.1ba6	48		pha				pha
.1ba7	da		phx				phx
.1ba8	5a		phy				phy
.1ba9	85 08		sta $08				sta 	srcPtr 						; save the source line.
.1bab	84 09		sty $09				sty 	srcPtr+1
.1bad	90 1b		bcc $1bca			bcc 	_DecodeNoLineNumber
.1baf	a0 01		ldy #$01			ldy 	#1 							; get line # to YA
.1bb1	b1 08		lda ($08),y			lda 	(srcPtr),y
.1bb3	aa		tax				tax
.1bb4	c8		iny				iny
.1bb5	b1 08		lda ($08),y			lda 	(srcPtr),y
.1bb7	a8		tay				tay
.1bb8	8a		txa				txa
.1bb9	18		clc				clc
.1bba	20 b6 1c	jsr $1cb6			jsr 	DecodeYAToBuffer 			; convert to string in buffer
.1bbd	aa		tax				tax 								; count in X
.1bbe					_DecodeLineSpace:
.1bbe	e0 05		cpx #$05			cpx 	#5
.1bc0	f0 08		beq $1bca			beq 	_DecodeNoLineNumber
.1bc2	a9 20		lda #$20			lda 	#" " 						; pad to 5 spaces
.1bc4	20 94 1c	jsr $1c94			jsr 	DecodeWriteBuffer
.1bc7	e8		inx				inx
.1bc8	80 f4		bra $1bbe			bra 	_DecodeLineSpace
.1bca					_DecodeNoLineNumber:
.1bca	a0 03		ldy #$03			ldy 	#3 							; initial position.
.1bcc					_DecodeLoop:
.1bcc	b1 08		lda ($08),y			lda 	(srcPtr),y 					; copy the current character to temp1
.1bce	85 10		sta $10				sta 	temp1 						; must be an execution address.
.1bd0	c8		iny				iny
.1bd1	b1 08		lda ($08),y			lda 	(srcPtr),y
.1bd3	85 11		sta $11				sta 	temp1+1
.1bd5	c8		iny				iny 								; y points to the byte after it.
.1bd6	a5 10		lda $10				lda 	temp1
.1bd8	c9 7a		cmp #$7a			cmp 	#NextLine & $FF
.1bda	d0 06		bne $1be2			bne 	_DecodeNotEOL
.1bdc	a5 11		lda $11				lda 	temp1+1
.1bde	c9 1e		cmp #$1e			cmp 	#NextLine >> 8
.1be0	f0 0b		beq $1bed			beq 	_DecodeEOL
.1be2					_DecodeNotEOL:
.1be2	20 f5 1b	jsr $1bf5			jsr 	IdentifyCodeWord
.1be5	20 3f 1c	jsr $1c3f			jsr 	DecodeFoundWord
.1be8	20 29 1c	jsr $1c29			jsr 	AdvanceToNext 				; advance to next entry in the line.
.1beb	80 df		bra $1bcc			bra 	_DecodeLoop 				; and go round again
.1bed					_DecodeEOL:
.1bed	a9 00		lda #$00			lda 	#0
.1bef	92 0a		sta ($0a)			sta 	(bufPtr)
.1bf1	7a		ply				ply 								; restore registers and exit
.1bf2	fa		plx				plx
.1bf3	68		pla				pla
.1bf4	60		rts				rts
.1bf5					IdentifyCodeWord:
.1bf5	5a		phy				phy 								; save current position on the stack.
.1bf6	a9 b4		lda #$b4			lda 	#(Dictionary) & $FF
.1bf8	85 0c		sta $0c				sta 	0+(matchPtr)
.1bfa	a9 20		lda #$20			lda 	#(Dictionary) >> 8
.1bfc	85 0d		sta $0d				sta 	1+(matchPtr)
.1bfe					_DecodeIdentify:
.1bfe	a0 02		ldy #$02			ldy 	#2 							; have we found a match ?
.1c00	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.1c02	c5 10		cmp $10				cmp 	temp1
.1c04	d0 07		bne $1c0d			bne 	_DecodeIdNext
.1c06	c8		iny				iny
.1c07	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.1c09	c5 11		cmp $11				cmp 	temp1+1
.1c0b	f0 1a		beq $1c27			beq 	_DecodeIdFound
.1c0d					_DecodeIdNext:
.1c0d	18		clc				clc
.1c0e	b2 0c		lda ($0c)			lda 	(matchPtr)
.1c10	f0 0a		beq $1c1c			beq 	_DecodeIdIssue
.1c12	65 0c		adc $0c				adc 	matchPtr
.1c14	85 0c		sta $0c				sta 	matchPtr
.1c16	90 e6		bcc $1bfe			bcc 	_DecodeIdentify
.1c18	e6 0d		inc $0d				inc 	matchPtr+1
.1c1a	80 e2		bra $1bfe			bra 	_DecodeIdentify
.1c1c					_DecodeIdIssue:
.1c1c	20 20 10	jsr $1020			jsr 	ErrorHandler
>1c1f	44 45 43 4f 44 45 3f 00				.text 	"DECODE?",0
.1c27					_DecodeIdFound:
.1c27	7a		ply				ply 								; restore position.
.1c28	60		rts				rts
.1c29					AdvanceToNext:
.1c29	5a		phy				phy 								; get the parameter count from bits 0-1 of the type byte
.1c2a	a0 01		ldy #$01			ldy 	#1
.1c2c	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.1c2e	29 03		and #$03			and 	#3 							; bits 0-1.
.1c30	7a		ply				ply
.1c31	c9 03		cmp #$03			cmp 	#3 							; is it n-bytes e.g. specified by the next byte
.1c33	d0 02		bne $1c37			bne 	_ATN012
.1c35	b1 08		lda ($08),y			lda 	(srcPtr),y 					; if so, use that byte as the overall length.
.1c37					_ATN012:
.1c37	85 12		sta $12				sta 	temp2 						; now add that to Y
.1c39	98		tya				tya
.1c3a	18		clc				clc
.1c3b	65 12		adc $12				adc 	temp2
.1c3d	a8		tay				tay
.1c3e	60		rts				rts
.1c3f					DecodeFoundWord:
.1c3f	5a		phy				phy 								; save current position
.1c40	84 12		sty $12				sty		temp2 						; put it in temp2 as well.
.1c42	a0 01		ldy #$01			ldy 	#1 							; get the type byte
.1c44	b1 0c		lda ($0c),y			lda 	(matchPtr),y 				; is there a special decoder check (bit 4 set) ?
.1c46	29 10		and #$10			and 	#$10
.1c48	d0 0e		bne $1c58			bne 	_DFWSpecialDecoder
.1c4a	b1 0c		lda ($0c),y			lda 	(matchPtr),y 				; reget it.
.1c4c	30 08		bmi $1c56			bmi 	_DFWExit 					; if hidden word (bit 7 set)
.1c4e	a9 06		lda #$06			lda 	#CTH_Keyword				; output a space to the buffer
.1c50	20 94 1c	jsr $1c94			jsr 	DecodeWriteBuffer
.1c53	20 71 1c	jsr $1c71			jsr 	DecodeCurrentWord 			; expand that.
.1c56					_DFWExit:
.1c56	7a		ply				ply 								; restore current position
.1c57	60		rts				rts
.1c58					_DFWSpecialDecoder:
.1c58	a0 04		ldy #$04			ldy 	#4 							; the decode word address is at offset 4,5
.1c5a	b1 0c		lda ($0c),y			lda 	(matchPtr),y 				; copy this into temp2
.1c5c	85 12		sta $12				sta 	temp2
.1c5e	c8		iny				iny
.1c5f	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.1c61	85 13		sta $13				sta 	temp2+1
.1c63	7a		ply				ply 	 							; restore current position into Y
.1c64	48		pha				pha 								; save registers
.1c65	da		phx				phx
.1c66	5a		phy				phy
.1c67	20 6e 1c	jsr $1c6e			jsr 	_DFWCallDecoder				; call the decoder routine
.1c6a	7a		ply				ply 								; restore registers and exit
.1c6b	fa		plx				plx
.1c6c	68		pla				pla
.1c6d	60		rts				rts
.1c6e					_DFWCallDecoder:
.1c6e	6c 12 00	jmp ($0012)			jmp 	(temp2)
.1c71					DecodeCurrentWord:
.1c71	5a		phy				phy
.1c72	a0 01		ldy #$01			ldy 	#1 							; read type byte
.1c74	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.1c76	a0 04		ldy #$04			ldy 	#4 							; original offset
.1c78	4a		lsr a				lsr 	a 							; encoder/decoder bits in 0-1
.1c79	4a		lsr a				lsr 	a 							; add 2 to Y for each encoder/decoder
.1c7a	4a		lsr a				lsr 	a 							; bit set.
.1c7b	4a		lsr a				lsr 	a
.1c7c	4a		lsr a				lsr 	a 							; decoder bit
.1c7d	90 02		bcc $1c81			bcc 	_DWBNoDec
.1c7f	c8		iny				iny
.1c80	c8		iny				iny
.1c81					_DWBNoDec:
.1c81	4a		lsr a				lsr 	a
.1c82	90 02		bcc $1c86			bcc 	_DWBNoEnc
.1c84	c8		iny				iny
.1c85	c8		iny				iny
.1c86					_DWBNoEnc:
.1c86					_DWBWordOut:
.1c86	b1 0c		lda ($0c),y			lda 	(matchPtr),y 				; output until bit 7 set.
.1c88	48		pha				pha
.1c89	29 7f		and #$7f			and 	#$7F
.1c8b	20 94 1c	jsr $1c94			jsr		DecodeWriteBuffer
.1c8e	c8		iny				iny
.1c8f	68		pla				pla
.1c90	10 f4		bpl $1c86			bpl 	_DWBWordOut
.1c92	7a		ply				ply 								; restore Y and exit
.1c93	60		rts				rts
.1c94					DecodeWriteBuffer:
.1c94	92 0a		sta ($0a)			sta 	(bufPtr)
.1c96	e6 0a		inc $0a				inc 	bufPtr
.1c98	d0 02		bne $1c9c			bne 	_DWBNoCarry
.1c9a	e6 0b		inc $0b				inc 	bufPtr+1
.1c9c					_DWBNoCarry:
.1c9c	60		rts				rts
.1c9d					DecodeOutputData:
.1c9d	48		pha				pha
.1c9e	da		phx				phx
.1c9f	5a		phy				phy
.1ca0	b1 08		lda ($08),y			lda 	(srcPtr),y 					; length + 1
.1ca2	aa		tax				tax
.1ca3					_DODLoop:
.1ca3	ca		dex				dex 								; done it all ?
.1ca4	f0 0c		beq $1cb2			beq		_DODExit
.1ca6	c8		iny				iny 								; output next character
.1ca7	b1 08		lda ($08),y			lda 	(srcPtr),y
.1ca9	29 7f		and #$7f			and 	#$7F
.1cab	f0 f6		beq $1ca3			beq 	_DODLoop 					; don't print NULL
.1cad	20 94 1c	jsr $1c94			jsr 	DecodeWriteBuffer
.1cb0	80 f1		bra $1ca3			bra 	_DODLoop
.1cb2					_DODExit:
.1cb2	7a		ply				ply
.1cb3	fa		plx				plx
.1cb4	68		pla				pla
.1cb5	60		rts				rts
.1cb6					DecodeYAToBuffer:
.1cb6	da		phx				phx
.1cb7	5a		phy				phy
.1cb8	48		pha				pha
.1cb9	a5 0a		lda $0a				lda 	bufPtr 						; copy bufPtr to temp2
.1cbb	85 12		sta $12				sta 	temp2
.1cbd	a5 0b		lda $0b				lda 	bufPtr+1
.1cbf	85 13		sta $13				sta 	temp2+1
.1cc1	68		pla				pla
.1cc2	20 f6 1e	jsr $1ef6			jsr 	ConvertToStringMain 		; convert YA to string there
.1cc5	aa		tax				tax 								; chars output to X
.1cc6	18		clc				clc
.1cc7	65 0a		adc $0a				adc 	bufPtr 						; add to buffer pointer
.1cc9	85 0a		sta $0a				sta 	bufPtr
.1ccb	90 02		bcc $1ccf			bcc 	_DYABNoCarry
.1ccd	e6 0b		inc $0b				inc 	bufPtr+1
.1ccf					_DYABNoCarry:
.1ccf	8a		txa				txa 								; count in A
.1cd0	7a		ply				ply									; restore and exit.
.1cd1	fa		plx				plx
.1cd2	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/list.src

.1cd3					ListCode:
.1cd3	64 1e		stz $1e				stz 	ListLowest 					; zero lowest line#
.1cd5	64 1f		stz $1f				stz 	ListLowest+1
.1cd7	a9 14		lda #$14			lda 	#20 						; show max 20 after lowest line
.1cd9	85 1d		sta $1d				sta 	ListCount
.1cdb	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.1cdd	85 18		sta $18				sta 	0+(listPtr)
.1cdf	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.1ce1	85 19		sta $19				sta 	1+(listPtr)
.1ce3	86 10		stx $10				stx 	temp1						; S->A
.1ce5	ba		tsx				tsx
.1ce6	8a		txa				txa
.1ce7	a6 10		ldx $10				ldx 	temp1
.1ce9	c9 80		cmp #$80			cmp 	#NumberStackBase
.1ceb	f0 0e		beq $1cfb			beq 	_LCLoop
.1ced	a5 06		lda $06				lda 	TOS 						; copy TOS to lowest
.1cef	85 1e		sta $1e				sta 	ListLowest
.1cf1	a5 07		lda $07				lda 	TOS+1
.1cf3	85 1f		sta $1f				sta 	ListLowest+1
.1cf5	68		pla				pla
.1cf6	85 07		sta $07				sta 	TOS+1
.1cf8	68		pla				pla
.1cf9	85 06		sta $06				sta 	TOS
.1cfb					_LCLoop:
.1cfb	b2 18		lda ($18)			lda 	(listPtr)					; reached end ?
.1cfd	f0 4e		beq $1d4d			beq 	_LCExit
.1cff	a0 01		ldy #$01			ldy 	#1							; >= list lowest
.1d01	b1 18		lda ($18),y			lda 	(listPtr),y
.1d03	c5 1e		cmp $1e				cmp 	ListLowest
.1d05	c8		iny				iny
.1d06	b1 18		lda ($18),y			lda 	(listPtr),y
.1d08	e5 1f		sbc $1f				sbc 	ListLowest+1
.1d0a	90 34		bcc $1d40			bcc 	_LCNext
.1d0c	a9 10		lda #$10			lda 	#(textBuffer) & $FF
.1d0e	85 0a		sta $0a				sta 	0+(bufPtr)
.1d10	a9 08		lda #$08			lda 	#(textBuffer) >> 8
.1d12	85 0b		sta $0b				sta 	1+(bufPtr)
.1d14	a5 18		lda $18				lda 	listPtr 					; output the line.
.1d16	a4 19		ldy $19				ldy 	listPtr+1
.1d18	38		sec				sec
.1d19	20 a6 1b	jsr $1ba6			jsr 	DecodeLineIntoBufPtr
.1d1c	a9 02		lda #$02			lda 	#CTH_LineNo
.1d1e	20 15 11	jsr $1115			jsr 	ExternColour
.1d21	a0 ff		ldy #$ff			ldy 	#255
.1d23					_LCLoop2:
.1d23	c8		iny				iny
.1d24	b9 10 08	lda $0810,y			lda 	textBuffer,y
.1d27	f0 0e		beq $1d37			beq 	_LCEnd
.1d29	c9 20		cmp #$20			cmp 	#32
.1d2b	b0 05		bcs $1d32			bcs 	_LCPrint
.1d2d	20 15 11	jsr $1115			jsr 	ExternColour
.1d30	a9 20		lda #$20			lda 	#32
.1d32					_LCPrint:
.1d32	20 0b 11	jsr $110b			jsr 	ExternPrint
.1d35	80 ec		bra $1d23			bra 	_LCLoop2
.1d37	a9 0d		lda #$0d	_LCEnd:	lda 	#13 						; new line
.1d39	20 0b 11	jsr $110b			jsr 	ExternPrint
.1d3c	c6 1d		dec $1d				dec 	ListCount					; done all the lines allowed
.1d3e	f0 0d		beq $1d4d			beq 	_LCExit
.1d40					_LCNext:
.1d40	18		clc				clc
.1d41	a5 18		lda $18				lda 	listPtr
.1d43	72 18		adc ($18)			adc 	(listPtr)
.1d45	85 18		sta $18				sta 	listPtr
.1d47	90 02		bcc $1d4b			bcc 	_NoCarryAdv
.1d49	e6 19		inc $19				inc 	listPtr+1
.1d4b					_NoCarryAdv:
.1d4b	80 ae		bra $1cfb			bra 	_LCLoop 					; go round again.
.1d4d					_LCExit:
.1d4d	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/system/miscellany.src

.1d50					RunProgram:
.1d50	a2 80		ldx #$80			ldx 	#NumberStackBase
.1d52	9a		txs				txs
.1d53	20 64 1b	jsr $1b64			jsr 	ClearVariableSpace 			; clear variables etc.
.1d56	a2 00		ldx #$00			ldx		#ProgramMemory & $FF		; boot address
.1d58	a0 40		ldy #$40			ldy 	#ProgramMemory >>8
.1d5a	20 75 10	jsr $1075			jsr 	InitialiseCoreCode 			; initialise the NEXT routine at $00
.1d5d	4c 00 00	jmp $0000			jmp 	NextCode
.1d60					Call6502:
.1d60	a5 06		lda $06				lda 	TOS 						; copy call address
.1d62	85 10		sta $10				sta 	temp1
.1d64	a5 07		lda $07				lda 	TOS+1
.1d66	85 11		sta $11				sta 	temp1+1
.1d68	68		pla				pla
.1d69	85 07		sta $07				sta 	TOS+1
.1d6b	68		pla				pla
.1d6c	85 06		sta $06				sta 	TOS
.1d6e	20 74 1d	jsr $1d74			jsr 	_CallTemp1 					; call it
.1d71	4c 00 00	jmp $0000			jmp 	NextCode
.1d74					_CallTemp1:
.1d74	6c 10 00	jmp ($0010)			jmp 	(temp1)
.1d77					AssertCode:
.1d77	a5 06		lda $06				lda 	TOS 						; TOS = 0
.1d79	05 07		ora $07				ora 	TOS+1
.1d7b	f0 09		beq $1d86			beq 	_ASFail 					; if zero fail
.1d7d	68		pla				pla
.1d7e	85 07		sta $07				sta 	TOS+1
.1d80	68		pla				pla
.1d81	85 06		sta $06				sta 	TOS
.1d83	4c 00 00	jmp $0000			jmp 	NextCode
.1d86					_ASFail:
.1d86	20 20 10	jsr $1020			jsr 	ErrorHandler
>1d89	41 53 53 45 52 54 00				.text 	"ASSERT",0
.1d90					StopCode:
.1d90	20 20 10	jsr $1020			jsr 	ErrorHandler
>1d93	53 54 4f 50 00					.text 	"STOP",0
.1d98					EndProgram:
.1d98	4c 10 10	jmp $1010			jmp 	WarmStart
.1d9b					VlistCode:
.1d9b	a9 b4		lda #$b4			lda 	#(Dictionary) & $FF
.1d9d	85 10		sta $10				sta 	0+(temp1)
.1d9f	a9 20		lda #$20			lda 	#(Dictionary) >> 8
.1da1	85 11		sta $11				sta 	1+(temp1)
.1da3	a0 01		ldy #$01	_VLLoop:ldy 	#1							; type byte
.1da5	b1 10		lda ($10),y			lda 	(temp1),y
.1da7	a0 04		ldy #$04			ldy 	#4 							; Y = 4
.1da9	4a		lsr a				lsr 	a 							; shift bits 4 and 5 to 0,1
.1daa	4a		lsr a				lsr 	a
.1dab	4a		lsr a				lsr		a
.1dac	4a		lsr a				lsr 	a
.1dad	4a		lsr a				lsr 	a 							; add those bits in
.1dae	90 02		bcc $1db2			bcc 	_VLNoDec
.1db0	c8		iny				iny
.1db1	c8		iny				iny
.1db2					_VLNoDec:
.1db2	4a		lsr a				lsr 	a
.1db3	90 02		bcc $1db7			bcc 	_VLNoEnc
.1db5	c8		iny				iny
.1db6	c8		iny				iny
.1db7					_VLNoEnc:
.1db7	b1 10		lda ($10),y			lda 	(temp1),y 					; remove $$ words
.1db9	c9 24		cmp #$24			cmp 	#"$"
.1dbb	d0 06		bne $1dc3			bne 	_VLPrint
.1dbd	c8		iny				iny
.1dbe	51 10		eor ($10),y			eor 	(temp1),y
.1dc0	f0 13		beq $1dd5			beq 	_VLNext
.1dc2	88		dey				dey
.1dc3					_VLPrint:
.1dc3	b1 10		lda ($10),y			lda 	(temp1),y
.1dc5	48		pha				pha
.1dc6	c8		iny				iny
.1dc7	29 7f		and #$7f			and 	#$7F
.1dc9	20 0b 11	jsr $110b			jsr 	ExternPrint
.1dcc	68		pla				pla
.1dcd	0a		asl a				asl 	a
.1dce	90 f3		bcc $1dc3			bcc 	_VLPrint
.1dd0	a9 20		lda #$20			lda 	#32
.1dd2	20 0b 11	jsr $110b			jsr 	ExternPrint
.1dd5					_VLNext:
.1dd5	18		clc				clc 								; go to next
.1dd6	b2 10		lda ($10)			lda 	(temp1)
.1dd8	65 10		adc $10				adc 	temp1
.1dda	85 10		sta $10				sta 	temp1
.1ddc	90 02		bcc $1de0			bcc 	_VLNoCarry
.1dde	e6 11		inc $11				inc 	temp1+1
.1de0					_VLNoCarry:
.1de0	b2 10		lda ($10)			lda 	(temp1)
.1de2	d0 bf		bne $1da3			bne 	_VLLoop
.1de4	a9 0d		lda #$0d			lda 	#13
.1de6	20 0b 11	jsr $110b			jsr 	ExternPrint
.1de9	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/system/toint.src

.1dec					ConvertToInteger:
.1dec	84 17		sty $17				sty 	temp4+1
.1dee	85 16		sta $16				sta 	temp4
.1df0	64 14		stz $14				stz 	temp3 						; reset value
.1df2	64 15		stz $15				stz 	temp3+1
.1df4	64 10		stz $10				stz 	temp1 						; temp1 = 0 (decimal) 255 (hex)
.1df6	a0 00		ldy #$00			ldy 	#0 							; look at first character
.1df8	b1 16		lda ($16),y			lda 	(temp4),y
.1dfa	49 2d		eor #$2d			eor 	#"-"						; zero if '-'
.1dfc	85 11		sta $11				sta 	temp1+1 					; save this in temp1+1
.1dfe	d0 01		bne $1e01			bne 	_CTINotMinus
.1e00	c8		iny				iny									; skip -
.1e01					_CTINotMinus:
.1e01	b1 16		lda ($16),y			lda 	(temp4),y
.1e03	c9 24		cmp #$24			cmp		#'$'						; if $ then skip it and set hex flag
.1e05	d0 03		bne $1e0a			bne 	_CTILoop
.1e07	c6 10		dec $10				dec 	temp1
.1e09	c8		iny				iny
.1e0a					_CTILoop:
.1e0a	b1 16		lda ($16),y			lda 	(temp4),y 					; next digit
.1e0c	29 7f		and #$7f			and 	#$7F 						; drop end of word flag
.1e0e	38		sec				sec
.1e0f	e9 30		sbc #$30			sbc 	#'0' 						; put in range '0'+
.1e11	90 65		bcc $1e78			bcc 	_CTIFail 					; out of range.
.1e13	c9 0a		cmp #$0a			cmp 	#10 						; in 0-9 ?
.1e15	90 0b		bcc $1e22			bcc 	_CTILegal
.1e17	c9 11		cmp #$11			cmp 	#'A'-'0'					; between 9 and A ?
.1e19	90 5d		bcc $1e78			bcc 	_CTIFail
.1e1b	38		sec				sec
.1e1c	e9 07		sbc #$07			sbc 	#7 							; hex adjust
.1e1e	c9 10		cmp #$10			cmp 	#16 						; out of range ?
.1e20	b0 56		bcs $1e78			bcs 	_CTIFail
.1e22					_CTILegal:
.1e22	48		pha				pha 								; save digit value.
.1e23	06 14		asl $14				asl 	temp3
.1e25	26 15		rol $15				rol 	temp3+1
.1e27	a5 14		lda $14				lda 	temp3 						; copy x2 into temp2
.1e29	85 12		sta $12				sta 	temp2
.1e2b	a5 15		lda $15				lda 	temp3+1
.1e2d	85 13		sta $13				sta 	temp2+1
.1e2f	06 14		asl $14				asl 	temp3
.1e31	26 15		rol $15				rol 	temp3+1
.1e33	06 14		asl $14				asl 	temp3
.1e35	26 15		rol $15				rol 	temp3+1
.1e37	24 10		bit $10				bit 	temp1 						; hexadecimal
.1e39	10 07		bpl $1e42			bpl 	_CTIDecimal
.1e3b	06 14		asl $14				asl 	temp3
.1e3d	26 15		rol $15				rol 	temp3+1
.1e3f	68		pla				pla 								; get digit back
.1e40	80 12		bra $1e54			bra 	_CTIAddLoop
.1e42					_CTIDecimal:
.1e42	18		clc				clc 								; x 8 + x 2 = x 10
.1e43	a5 14		lda $14				lda 	temp3
.1e45	65 12		adc $12				adc 	temp2
.1e47	85 14		sta $14				sta 	temp3
.1e49	a5 15		lda $15				lda 	temp3+1
.1e4b	65 13		adc $13				adc 	temp2+1
.1e4d	85 15		sta $15				sta 	temp3+1
.1e4f	68		pla				pla 								; check digit 0-9
.1e50	c9 0a		cmp #$0a			cmp 	#10
.1e52	b0 24		bcs $1e78			bcs 	_CTIFail
.1e54					_CTIAddLoop:
.1e54	18		clc				clc
.1e55	65 14		adc $14				adc 	temp3
.1e57	85 14		sta $14				sta 	temp3
.1e59	90 02		bcc $1e5d			bcc 	_CTINoCarry
.1e5b	e6 15		inc $15				inc 	temp3+1
.1e5d					_CTINoCarry:
.1e5d	c8		iny				iny
.1e5e	b1 16		lda ($16),y			lda 	(temp4),y 					; was this the last character
.1e60	c9 21		cmp #$21			cmp 	#32+1
.1e62	b0 a6		bcs $1e0a			bcs 	_CTILoop 					; no, go back.
.1e64	a5 11		lda $11				lda 	temp1+1 					; was it - ?
.1e66	d0 0d		bne $1e75			bne 	_CTIOkay
.1e68	38		sec				sec
.1e69	a9 00		lda #$00			lda 	#0 							; negate temp3.
.1e6b	e5 14		sbc $14				sbc 	temp3
.1e6d	85 14		sta $14				sta 	temp3
.1e6f	a9 00		lda #$00			lda 	#0
.1e71	e5 15		sbc $15				sbc 	temp3+1
.1e73	85 15		sta $15				sta 	temp3+1
.1e75					_CTIOkay:
.1e75	98		tya				tya
.1e76	38		sec				sec
.1e77	60		rts				rts
.1e78					_CTIFail:
.1e78	18		clc				clc
.1e79	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/skipper.src

.1e7a					NextLine:
.1e7a	18		clc				clc
.1e7b	a5 03		lda $03				lda 	IP
.1e7d	72 03		adc ($03)			adc 	(IP)
.1e7f	85 03		sta $03				sta 	IP
.1e81	90 02		bcc $1e85			bcc 	_NoCarryAdv
.1e83	e6 04		inc $04				inc 	IP+1
.1e85					_NoCarryAdv:
.1e85	b2 03		lda ($03)			lda 	(IP)						; is there any following program ?
.1e87	f0 05		beq $1e8e			beq 	_NLGoEnd
.1e89	a2 01		ldx #$01			ldx 	#1 							; start 3 in (-2 for Next)
.1e8b	4c 00 00	jmp $0000			jmp 	NextCode
.1e8e					_NLGoEnd:
.1e8e	4c 10 10	jmp $1010			jmp 	WarmStart
.1e91					SkipComment:
.1e91	e8		inx				inx									; (IP),X points to the length.
.1e92	e8		inx				inx
.1e93	8a		txa				txa
.1e94	a8		tay				tay 								; put into Y
.1e95	18		clc				clc
.1e96	71 03		adc ($03),y			adc 	(IP),y 						; add the length to X
.1e98	aa		tax				tax 								; put back in X
.1e99	ca		dex				dex
.1e9a	ca		dex				dex
.1e9b	4c 00 00	jmp $0000			jmp 	NextCode
.1e9e					CommentDecoder:
.1e9e	a9 06		lda #$06			lda 	#CTH_Keyword
.1ea0	20 94 1c	jsr $1c94			jsr 	DecodeWriteBuffer
.1ea3	a9 27		lda #$27			lda 	#"'"
.1ea5	20 94 1c	jsr $1c94			jsr 	DecodeWriteBuffer
.1ea8	a9 0b		lda #$0b			lda 	#CTH_Comment
.1eaa	20 94 1c	jsr $1c94			jsr 	DecodeWriteBuffer
.1ead	20 9d 1c	jsr $1c9d			jsr 	DecodeOutputData
.1eb0	a9 20		lda #$20			lda 	#32
.1eb2	20 94 1c	jsr $1c94			jsr 	DecodeWriteBuffer
.1eb5	60		rts				rts
.1eb6					DefineCode:
.1eb6	20 20 10	jsr $1020			jsr 	ErrorHandler
>1eb9	44 45 46 49 4e 49 54 49				.text 	"DEFINITION?",0
>1ec1	4f 4e 3f 00
.1ec5					DefineDecoder:
.1ec5	a9 07		lda #$07			lda 	#CTH_Definition
.1ec7	20 94 1c	jsr $1c94			jsr 	DecodeWriteBuffer
.1eca	a9 3a		lda #$3a			lda 	#":"
.1ecc	20 94 1c	jsr $1c94			jsr 	DecodeWriteBuffer
.1ecf	20 9d 1c	jsr $1c9d			jsr 	DecodeOutputData
.1ed2	a9 20		lda #$20			lda 	#32
.1ed4	20 94 1c	jsr $1c94			jsr 	DecodeWriteBuffer
.1ed7	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/tostr.src

.1ed8					IntToString:
.1ed8	a9 10		lda #$10			lda 	#(textBuffer) & $FF
.1eda	85 12		sta $12				sta 	0+(temp2)
.1edc	a9 08		lda #$08			lda 	#(textBuffer) >> 8
.1ede	85 13		sta $13				sta 	1+(temp2)
.1ee0	a5 06		lda $06				lda 	TOS 						; value in YA
.1ee2	a4 07		ldy $07				ldy 	TOS+1
.1ee4	20 f2 1e	jsr $1ef2			jsr 	ConvertToString
.1ee7	a9 10		lda #$10			lda 	#(textBuffer) & $FF
.1ee9	85 06		sta $06				sta 	0+(TOS)
.1eeb	a9 08		lda #$08			lda 	#(textBuffer) >> 8
.1eed	85 07		sta $07				sta 	1+(TOS)
.1eef	4c 00 00	jmp $0000			jmp 	NextCode
.1ef2					ConvertToString:
.1ef2	38		sec				sec
.1ef3	80 01		bra $1ef6			bra 	ConvertToStringMain
.1ef5					ConvertToStringUnsigned:
.1ef5	18		clc				clc
.1ef6					ConvertToStringMain:
.1ef6	da		phx				phx									; save XY
.1ef7	5a		phy				phy
.1ef8	64 1a		stz $1a				stz 	SignCount 					; this is zero suppression
.1efa	85 10		sta $10				sta 	temp1 						; save YA in temp1
.1efc	84 11		sty $11				sty 	temp1+1
.1efe	a0 00		ldy #$00			ldy 	#0 							; index to result.
.1f00	90 16		bcc $1f18			bcc 	_CTSUnsigned 				; if carry clear do not adjust for -
.1f02	a5 11		lda $11				lda 	temp1+1 					; is it negative
.1f04	10 12		bpl $1f18			bpl 	_CTSUnsigned
.1f06	a9 2d		lda #$2d			lda 	#"-"						; output - sign
.1f08	91 12		sta ($12),y			sta 	(temp2),y
.1f0a	c8		iny				iny
.1f0b	38		sec				sec 								; negate temp1
.1f0c	a9 00		lda #$00			lda 	#0
.1f0e	e5 10		sbc $10				sbc 	temp1
.1f10	85 10		sta $10				sta 	temp1
.1f12	a9 00		lda #$00			lda 	#0
.1f14	e5 11		sbc $11				sbc 	temp1+1
.1f16	85 11		sta $11				sta 	temp1+1
.1f18					_CTSUnsigned:
.1f18	a2 00		ldx #$00			ldx 	#0 							; index into subtraction table
.1f1a					_CTSLoop:
.1f1a	a9 2f		lda #$2f			lda 	#"0"-1						; set the digit to '0' code.
.1f1c	91 12		sta ($12),y			sta 	(temp2),y
.1f1e					_CTSSubLoop:
.1f1e	b1 12		lda ($12),y			lda 	(temp2),y 					; bump the count
.1f20	1a		inc a				inc 	a
.1f21	91 12		sta ($12),y			sta 	(temp2),y
.1f23	38		sec				sec 								; do subtraction saving interim result
.1f24	a5 10		lda $10				lda 	temp1
.1f26	fd 59 1f	sbc $1f59,x			sbc 	_CTSTable,x
.1f29	48		pha				pha
.1f2a	a5 11		lda $11				lda 	temp1+1
.1f2c	fd 5a 1f	sbc $1f5a,x			sbc 	_CTSTable+1,x
.1f2f	90 07		bcc $1f38			bcc 	_CTSCantSubtract 			; end of subtraction.
.1f31	85 11		sta $11				sta 	temp1+1 					; save result back
.1f33	68		pla				pla
.1f34	85 10		sta $10				sta 	temp1
.1f36	80 e6		bra $1f1e			bra 	_CTSSubLoop
.1f38					_CTSCantSubtract:
.1f38	68		pla				pla 								; throw away interim
.1f39	e8		inx				inx 								; next subtractor
.1f3a	e8		inx				inx
.1f3b	b1 12		lda ($12),y			lda 	(temp2),y 					; update leading zero
.1f3d	49 30		eor #$30			eor 	#"0"
.1f3f	05 1a		ora $1a				ora 	SignCount
.1f41	85 1a		sta $1a				sta 	SignCount
.1f43	f0 01		beq $1f46			beq		_CTSLZ 						; if all zeros so far suppress.
.1f45	c8		iny				iny 								; next character
.1f46					_CTSLZ:
.1f46	e0 08		cpx #$08			cpx 	#_CTSTableEnd-_CTSTable 	; done them all ?
.1f48	d0 d0		bne $1f1a			bne 	_CTSLoop
.1f4a					_CTSComplete:
.1f4a	a5 10		lda $10				lda		temp1 						; get remainder 0-9
.1f4c	09 30		ora #$30			ora 	#48 						; ASCII
.1f4e	91 12		sta ($12),y			sta 	(temp2),y					; write out
.1f50	c8		iny				iny
.1f51	a9 00		lda #$00			lda 	#0							; make ASCIIZ
.1f53	91 12		sta ($12),y			sta 	(temp2),y
.1f55	98		tya				tya 								; size in A
.1f56	7a		ply				ply									; pull and exit.
.1f57	fa		plx				plx
.1f58	60		rts				rts
.1f59					_CTSTable:
>1f59	10 27 e8 03 64 00 0a 00				.word 	10000,1000,100,10 			; subtractors, this is a simple version.
.1f61					_CTSTableEnd:

;******  Return to file: kernel.asm


;******  Processing file: words/system/varhandlers.src

.1f61					VarAddressHandler:
.1f61	18		clc				clc 								; find variable, error if it doesn't exist.
.1f62	20 b3 1f	jsr $1fb3			jsr 	VariableFind
.1f65	a5 06		lda $06				lda 	TOS
.1f67	48		pha				pha
.1f68	a5 07		lda $07				lda 	TOS+1
.1f6a	48		pha				pha
.1f6b	a5 10		lda $10				lda 	temp1 						; the address is the new value
.1f6d	85 06		sta $06				sta 	TOS
.1f6f	a5 11		lda $11				lda		temp1+1
.1f71	85 07		sta $07				sta 	TOS+1
.1f73	4c 00 00	jmp $0000			jmp 	NextCode
.1f76					VarAddrHandlerDecode:
.1f76	a9 26		lda #$26			lda 	#"&"
.1f78	4c 61 20	jmp $2061			jmp 	VarHandlerDecode
.1f7b					VarReadHandler:
.1f7b	18		clc				clc 								; find variable, error if it doesn't exist.
.1f7c	20 b3 1f	jsr $1fb3			jsr 	VariableFind
.1f7f	a5 06		lda $06				lda 	TOS
.1f81	48		pha				pha
.1f82	a5 07		lda $07				lda 	TOS+1
.1f84	48		pha				pha
.1f85	b2 10		lda ($10)			lda 	(temp1)						; read variable address to TOS
.1f87	85 06		sta $06				sta 	TOS
.1f89	a0 01		ldy #$01			ldy 	#1
.1f8b	b1 10		lda ($10),y			lda 	(temp1),y
.1f8d	85 07		sta $07				sta 	TOS+1
.1f8f	4c 00 00	jmp $0000			jmp 	NextCode
.1f92					VarReadHandlerDecode:
.1f92	a9 40		lda #$40			lda 	#"@"
.1f94	4c 61 20	jmp $2061			jmp 	VarHandlerDecode
.1f97					VarWriteHandler:
.1f97	38		sec				sec 								; find variable, create it if it doesn't exist.
.1f98	20 b3 1f	jsr $1fb3			jsr 	VariableFind
.1f9b	a5 06		lda $06				lda 	TOS 						; write TOS to that address.
.1f9d	92 10		sta ($10)			sta 	(temp1)
.1f9f	a5 07		lda $07				lda 	TOS+1
.1fa1	a0 01		ldy #$01			ldy 	#1
.1fa3	91 10		sta ($10),y			sta 	(temp1),y
.1fa5	68		pla				pla
.1fa6	85 07		sta $07				sta 	TOS+1
.1fa8	68		pla				pla
.1fa9	85 06		sta $06				sta 	TOS
.1fab	4c 00 00	jmp $0000			jmp 	NextCode
.1fae					VarWriteHandlerDecode:
.1fae	a9 21		lda #$21			lda 	#"!"
.1fb0	4c 61 20	jmp $2061			jmp 	VarHandlerDecode
.1fb3					VariableFind:
.1fb3	08		php				php 								; save autocreate flag.
.1fb4	e8		inx				inx 								; advance to/over the variable name.
.1fb5	e8		inx				inx
.1fb6	8a		txa				txa 								; put in Y
.1fb7	a8		tay				tay
.1fb8	b1 03		lda ($03),y			lda 	(IP),y 						; copy name word into temp2
.1fba	85 12		sta $12				sta 	temp2
.1fbc	c8		iny				iny
.1fbd	b1 03		lda ($03),y			lda 	(IP),y
.1fbf	85 13		sta $13				sta 	temp2+1
.1fc1	c9 1b		cmp #$1b			cmp 	#27 						; check for A-Z
.1fc3	b0 0f		bcs $1fd4			bcs 	_VFLong
.1fc5	a5 13		lda $13				lda 	temp2+1
.1fc7	d0 0b		bne $1fd4			bne 	_VFLong
.1fc9	a5 12		lda $12				lda 	temp2						; this is the index
.1fcb	0a		asl a				asl 	a 							; double it
.1fcc	85 10		sta $10				sta 	temp1
.1fce	a9 06		lda #$06			lda 	#azVariables >> 8			; set the MSB
.1fd0	85 11		sta $11				sta 	temp1+1
.1fd2	28		plp				plp 								; throw creation flag, it always exists.
.1fd3	60		rts				rts
.1fd4					_VFLong:
.1fd4	a5 12		lda $12				lda 	temp2 						; built a hash table index into temp3/temp4
.1fd6	6a		ror a				ror 	a
.1fd7	6a		ror a				ror 	a
.1fd8	6a		ror a				ror 	a
.1fd9	6a		ror a				ror 	a
.1fda	45 12		eor $12				eor 	temp2
.1fdc	45 13		eor $13				eor 	temp2+1
.1fde	29 0f		and #$0f			and 	#(hashTableSize-1)			; force into range
.1fe0	0a		asl a				asl 	a
.1fe1	69 40		adc #$40			adc 	#hashTable & $FF 			; make an address of the head => temp1/3
.1fe3	85 10		sta $10				sta 	temp1
.1fe5	85 14		sta $14				sta 	temp3
.1fe7	a9 06		lda #$06			lda 	#hashTable >> 8
.1fe9	85 11		sta $11				sta 	temp1+1
.1feb	85 15		sta $15				sta 	temp3+1
.1fed					_VFSearch:
.1fed	a0 01		ldy #$01			ldy 	#1							; read MSB of first record
.1fef	b1 10		lda ($10),y			lda 	(temp1),y
.1ff1	f0 23		beq $2016			beq 	_VFNotFound 				; is MSB is zero, can't be a variable record
.1ff3	a8		tay				tay 								; follow the link through.
.1ff4	b2 10		lda ($10)			lda 	(temp1)
.1ff6	85 10		sta $10				sta 	temp1
.1ff8	84 11		sty $11				sty 	temp1+1
.1ffa	a0 04		ldy #$04			ldy 	#4							; check if the name matches
.1ffc	b1 10		lda ($10),y			lda 	(temp1),y
.1ffe	c5 12		cmp $12				cmp 	temp2
.2000	d0 eb		bne $1fed			bne 	_VFSearch 					; if it doesn't, follow the next link.
.2002	c8		iny				iny 								; same for 2nd byte of name
.2003	b1 10		lda ($10),y			lda 	(temp1),y
.2005	c5 13		cmp $13				cmp 	temp2+1
.2007	d0 e4		bne $1fed			bne 	_VFSearch
.2009	18		clc				clc
.200a	a5 10		lda $10				lda 	temp1 						; make temp1 point to the data at offset 2
.200c	69 02		adc #$02			adc 	#2
.200e	85 10		sta $10				sta 	temp1
.2010	90 02		bcc $2014			bcc 	_VFNoPage1
.2012	e6 11		inc $11				inc 	temp1+1
.2014					_VFNoPage1:
.2014	28		plp				plp 								; don't need to worry about creation flag
.2015	60		rts				rts
.2016					_VFNotFound:
.2016	28		plp				plp 								; was carry set, e.g. create a new record if not found ?
.2017	b0 0d		bcs $2026			bcs 	_VFCreate
.2019	20 20 10	jsr $1020			jsr 	ErrorHandler
>201c	56 41 52 49 41 42 4c 45				.text 	"VARIABLE?",0
>2024	3f 00
.2026					_VFCreate:
.2026	a0 01		ldy #$01			ldy 	#1
.2028	b2 14		lda ($14)			lda 	(temp3) 					; copy the head link to the first 2 bytes
.202a	92 0e		sta ($0e)			sta 	(nextFreeMem)
.202c	b1 14		lda ($14),y			lda 	(temp3),y
.202e	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.2030	c8		iny				iny
.2031	a9 00		lda #$00			lda 	#0	 						; write zero initialised data out.
.2033	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.2035	c8		iny				iny
.2036	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.2038	c8		iny				iny
.2039	a5 12		lda $12				lda 	temp2 						; copy the name out
.203b	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.203d	c8		iny				iny
.203e	a5 13		lda $13				lda 	temp2+1
.2040	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.2042	a0 01		ldy #$01			ldy 	#1
.2044	a5 0e		lda $0e				lda 	nextFreeMem 				; update the head link
.2046	92 14		sta ($14)			sta 	(temp3)
.2048	a5 0f		lda $0f				lda 	nextFreeMem+1
.204a	91 14		sta ($14),y			sta 	(temp3),y
.204c	18		clc				clc
.204d	a5 0e		lda $0e				lda 	nextFreeMem 				; put nextFreeMem+2 in temp1 (data pointer)
.204f	69 02		adc #$02			adc 	#2
.2051	85 10		sta $10				sta 	temp1
.2053	a5 0f		lda $0f				lda 	nextFreeMem+1
.2055	69 00		adc #$00			adc 	#0
.2057	85 11		sta $11				sta 	temp1+1
.2059	a9 06		lda #$06			lda 	#6							; shift freemem pointer up 6
.205b	a0 00		ldy #$00			ldy 	#0
.205d	20 91 1b	jsr $1b91			jsr 	AdvanceFreeMem
.2060	60		rts				rts
.2061					VarHandlerDecode:
.2061	48		pha				pha 								; save, leading space
.2062	a9 20		lda #$20			lda 	#" "
.2064	20 94 1c	jsr $1c94			jsr 	DecodeWriteBuffer
.2067	68		pla				pla 								; restore and write type
.2068	20 94 1c	jsr $1c94			jsr 	DecodeWriteBuffer
.206b	b1 08		lda ($08),y			lda 	(srcPtr),y 					; copy to temp1
.206d	85 10		sta $10				sta 	temp1
.206f	c8		iny				iny
.2070	b1 08		lda ($08),y			lda 	(srcPtr),y
.2072	85 11		sta $11				sta 	temp1+1
.2074	a5 10		lda $10				lda 	temp1 						; output the first character
.2076	29 1f		and #$1f			and 	#31
.2078	20 a3 20	jsr $20a3			jsr 	VHOutVarChar
.207b	a2 05		ldx #$05			ldx 	#5 							; divide temp1 by 32
.207d					_VHDShift:
.207d	46 11		lsr $11				lsr 	temp1+1
.207f	66 10		ror $10				ror 	temp1
.2081	ca		dex				dex
.2082	d0 f9		bne $207d			bne 	_VHDShift
.2084	a2 ff		ldx #$ff			ldx 	#255 						; now divide that by 40 by repeated subtraction.
.2086					_VHDDiv40:
.2086	e8		inx				inx
.2087	38		sec				sec
.2088	a5 10		lda $10				lda 	temp1
.208a	e9 28		sbc #$28			sbc 	#40
.208c	a8		tay				tay
.208d	a5 11		lda $11				lda 	temp1+1
.208f	e9 00		sbc #$00			sbc 	#0
.2091	90 06		bcc $2099			bcc 	_VHDivDone
.2093	85 11		sta $11				sta 	temp1+1
.2095	84 10		sty $10				sty 	temp1
.2097	80 ed		bra $2086			bra 	_VHDDiv40
.2099					_VHDivDone:
.2099	a5 10		lda $10				lda 	temp1 						; remainder
.209b	20 a3 20	jsr $20a3			jsr 	VHOutVarChar
.209e	8a		txa				txa
.209f	20 a3 20	jsr $20a3			jsr 	VHOutVarChar 				; and result.
.20a2	60		rts				rts
.20a3					VHOutVarChar:
.20a3	c9 00		cmp #$00			cmp 	#0
.20a5	f0 0c		beq $20b3			beq 	_VHOExit
.20a7	18		clc				clc
.20a8	69 40		adc #$40			adc 	#64 						; 65-90 A-Z 91-100 0-9
.20aa	c9 5b		cmp #$5b			cmp 	#91 						; convert back ?
.20ac	90 02		bcc $20b0			bcc 	_VHOOut
.20ae	e9 2b		sbc #$2b			sbc 	#91-48 						; adjust to digit
.20b0					_VHOOut:
.20b0	20 94 1c	jsr $1c94			jsr 	DecodeWriteBuffer
.20b3					_VHOExit:
.20b3	60		rts				rts

;******  Return to file: kernel.asm

.20b4					Dictionary:

;******  Processing file: generated/dictionary.inc

>20b4	05					.byte	_end1-*
>20b5	00					.byte	$00
>20b6	fc 15					.word	WordWrite
>20b8	a1					.byte	$a1
.20b9					_end1:
>20b9	10					.byte	_end2-*
>20ba	52					.byte	$52
>20bb	97 1f					.word	VarWriteHandler
>20bd	ae 1f					.word	VarWriteHandlerDecode
>20bf	24 24 21 48 41 4e 44 4c			.byte	$24,$24,$21,$48,$41,$4e,$44,$4c,$45,$d2
>20c7	45 d2
.20c9					_end2:
>20c9	10					.byte	_end3-*
>20ca	52					.byte	$52
>20cb	61 1f					.word	VarAddressHandler
>20cd	76 1f					.word	VarAddrHandlerDecode
>20cf	24 24 26 48 41 4e 44 4c			.byte	$24,$24,$26,$48,$41,$4e,$44,$4c,$45,$d2
>20d7	45 d2
.20d9					_end3:
>20d9	10					.byte	_end4-*
>20da	52					.byte	$52
>20db	7b 1f					.word	VarReadHandler
>20dd	92 1f					.word	VarReadHandlerDecode
>20df	24 24 40 48 41 4e 44 4c			.byte	$24,$24,$40,$48,$41,$4e,$44,$4c,$45,$d2
>20e7	45 d2
.20e9					_end4:
>20e9	0c					.byte	_end5-*
>20ea	52					.byte	$52
>20eb	18 1a					.word	CallHandler
>20ed	d4 1a					.word	CallHandlerDecode
>20ef	24 24 43 41 4c cc			.byte	$24,$24,$43,$41,$4c,$cc
.20f5					_end5:
>20f5	0f					.byte	_end6-*
>20f6	53					.byte	$53
>20f7	91 1e					.word	SkipComment
>20f9	9e 1e					.word	CommentDecoder
>20fb	24 24 43 4f 4d 4d 45 4e			.byte	$24,$24,$43,$4f,$4d,$4d,$45,$4e,$d4
>2103	d4
.2104					_end6:
>2104	0e					.byte	_end7-*
>2105	53					.byte	$53
>2106	b6 1e					.word	DefineCode
>2108	c5 1e					.word	DefineDecoder
>210a	24 24 44 45 46 49 4e c5			.byte	$24,$24,$44,$45,$46,$49,$4e,$c5
.2112					_end7:
>2112	0f					.byte	_end8-*
>2113	52					.byte	$52
>2114	86 10					.word	Literal2Byte
>2116	9c 10					.word	Literal2ByteDecode
>2118	24 24 4c 49 54 45 52 41			.byte	$24,$24,$4c,$49,$54,$45,$52,$41,$cc
>2120	cc
.2121					_end8:
>2121	0e					.byte	_end9-*
>2122	80					.byte	$80
>2123	7a 1e					.word	NextLine
>2125	24 24 4e 45 58 54 4c 49			.byte	$24,$24,$4e,$45,$58,$54,$4c,$49,$4e,$c5
>212d	4e c5
.212f					_end9:
>212f	0e					.byte	_end10-*
>2130	53					.byte	$53
>2131	ae 10					.word	LiteralString
>2133	cd 10					.word	LiteralStringDecoder
>2135	24 24 53 54 52 49 4e c7			.byte	$24,$24,$53,$54,$52,$49,$4e,$c7
.213d					_end10:
>213d	05					.byte	_end11-*
>213e	00					.byte	$00
>213f	78 13					.word	Multiply16x16
>2141	aa					.byte	$aa
.2142					_end11:
>2142	05					.byte	_end12-*
>2143	00					.byte	$00
>2144	e5 11					.word	Add
>2146	ab					.byte	$ab
.2147					_end12:
>2147	06					.byte	_end13-*
>2148	00					.byte	$00
>2149	0d 16					.word	WordAdd
>214b	2b a1					.byte	$2b,$a1
.214d					_end13:
>214d	05					.byte	_end14-*
>214e	00					.byte	$00
>214f	f4 11					.word	Subtract
>2151	ad					.byte	$ad
.2152					_end14:
>2152	06					.byte	_end15-*
>2153	00					.byte	$00
>2154	b4 14					.word	ConstantMinus1
>2156	2d b1					.byte	$2d,$b1
.2158					_end15:
>2158	05					.byte	_end16-*
>2159	00					.byte	$00
>215a	c9 12					.word	Divide16x16
>215c	af					.byte	$af
.215d					_end16:
>215d	05					.byte	_end17-*
>215e	00					.byte	$00
>215f	a7 14					.word	Constant0
>2161	b0					.byte	$b0
.2162					_end17:
>2162	06					.byte	_end18-*
>2163	00					.byte	$00
>2164	0d 14					.word	CheckMinus
>2166	30 bc					.byte	$30,$bc
.2168					_end18:
>2168	06					.byte	_end19-*
>2169	00					.byte	$00
>216a	21 14					.word	CheckZero
>216c	30 bd					.byte	$30,$bd
.216e					_end19:
>216e	05					.byte	_end20-*
>216f	00					.byte	$00
>2170	c3 14					.word	C1
>2172	b1					.byte	$b1
.2173					_end20:
>2173	06					.byte	_end21-*
>2174	00					.byte	$00
>2175	b7 13					.word	Unary1Plus
>2177	31 ab					.byte	$31,$ab
.2179					_end21:
>2179	06					.byte	_end22-*
>217a	00					.byte	$00
>217b	ce 13					.word	Unary1Minus
>217d	31 ad					.byte	$31,$ad
.217f					_end22:
>217f	06					.byte	_end23-*
>2180	00					.byte	$00
>2181	db 14					.word	C10
>2183	31 b0					.byte	$31,$b0
.2185					_end23:
>2185	07					.byte	_end24-*
>2186	00					.byte	$00
>2187	04 15					.word	C100
>2189	31 30 b0				.byte	$31,$30,$b0
.218c					_end24:
>218c	08					.byte	_end25-*
>218d	00					.byte	$00
>218e	33 15					.word	C1024
>2190	31 30 32 b4				.byte	$31,$30,$32,$b4
.2194					_end25:
>2194	07					.byte	_end26-*
>2195	00					.byte	$00
>2196	08 15					.word	C127
>2198	31 32 b7				.byte	$31,$32,$b7
.219b					_end26:
>219b	07					.byte	_end27-*
>219c	00					.byte	$00
>219d	0c 15					.word	C128
>219f	31 32 b8				.byte	$31,$32,$b8
.21a2					_end27:
>21a2	06					.byte	_end28-*
>21a3	00					.byte	$00
>21a4	df 14					.word	C15
>21a6	31 b5					.byte	$31,$b5
.21a8					_end28:
>21a8	06					.byte	_end29-*
>21a9	00					.byte	$00
>21aa	e3 14					.word	C16
>21ac	31 b6					.byte	$31,$b6
.21ae					_end29:
>21ae	07					.byte	_end30-*
>21af	00					.byte	$00
>21b0	45 14					.word	Times16
>21b2	31 36 aa				.byte	$31,$36,$aa
.21b5					_end30:
>21b5	07					.byte	_end31-*
>21b6	00					.byte	$00
>21b7	58 14					.word	Divide16
>21b9	31 36 af				.byte	$31,$36,$af
.21bc					_end31:
>21bc	05					.byte	_end32-*
>21bd	00					.byte	$00
>21be	c7 14					.word	C2
>21c0	b2					.byte	$b2
.21c1					_end32:
>21c1	06					.byte	_end33-*
>21c2	00					.byte	$00
>21c3	51 14					.word	Times2
>21c5	32 aa					.byte	$32,$aa
.21c7					_end33:
>21c7	06					.byte	_end34-*
>21c8	00					.byte	$00
>21c9	c0 13					.word	Unary2Plus
>21cb	32 ab					.byte	$32,$ab
.21cd					_end34:
>21cd	06					.byte	_end35-*
>21ce	00					.byte	$00
>21cf	d9 13					.word	Unary2Minus
>21d1	32 ad					.byte	$32,$ad
.21d3					_end35:
>21d3	06					.byte	_end36-*
>21d4	00					.byte	$00
>21d5	64 14					.word	Divide2
>21d7	32 af					.byte	$32,$af
.21d9					_end36:
>21d9	06					.byte	_end37-*
>21da	00					.byte	$00
>21db	e7 14					.word	C24
>21dd	32 b4					.byte	$32,$b4
.21df					_end37:
>21df	07					.byte	_end38-*
>21e0	00					.byte	$00
>21e1	10 15					.word	C255
>21e3	32 35 b5				.byte	$32,$35,$b5
.21e6					_end38:
>21e6	07					.byte	_end39-*
>21e7	00					.byte	$00
>21e8	1b 15					.word	C256
>21ea	32 35 b6				.byte	$32,$35,$b6
.21ed					_end39:
>21ed	08					.byte	_end40-*
>21ee	00					.byte	$00
>21ef	6b 14					.word	Times256
>21f1	32 35 36 aa				.byte	$32,$35,$36,$aa
.21f5					_end40:
>21f5	08					.byte	_end41-*
>21f6	00					.byte	$00
>21f7	74 14					.word	Divide256
>21f9	32 35 36 af				.byte	$32,$35,$36,$af
.21fd					_end41:
>21fd	05					.byte	_end42-*
>21fe	00					.byte	$00
>21ff	cb 14					.word	C3
>2201	b3					.byte	$b3
.2202					_end42:
>2202	06					.byte	_end43-*
>2203	00					.byte	$00
>2204	f8 14					.word	C32
>2206	33 b2					.byte	$33,$b2
.2208					_end43:
>2208	09					.byte	_end44-*
>2209	00					.byte	$00
>220a	4b 15					.word	C32767
>220c	33 32 37 36 b7				.byte	$33,$32,$37,$36,$b7
.2211					_end44:
>2211	09					.byte	_end45-*
>2212	00					.byte	$00
>2213	57 15					.word	C32768
>2215	33 32 37 36 b8				.byte	$33,$32,$37,$36,$b8
.221a					_end45:
>221a	05					.byte	_end46-*
>221b	00					.byte	$00
>221c	cf 14					.word	C4
>221e	b4					.byte	$b4
.221f					_end46:
>221f	06					.byte	_end47-*
>2220	00					.byte	$00
>2221	4d 14					.word	Times4
>2223	34 aa					.byte	$34,$aa
.2225					_end47:
>2225	06					.byte	_end48-*
>2226	00					.byte	$00
>2227	60 14					.word	Divide4
>2229	34 af					.byte	$34,$af
.222b					_end48:
>222b	08					.byte	_end49-*
>222c	00					.byte	$00
>222d	3f 15					.word	C4096
>222f	34 30 39 b6				.byte	$34,$30,$39,$b6
.2233					_end49:
>2233	05					.byte	_end50-*
>2234	00					.byte	$00
>2235	d3 14					.word	C5
>2237	b5					.byte	$b5
.2238					_end50:
>2238	07					.byte	_end51-*
>2239	00					.byte	$00
>223a	27 15					.word	C512
>223c	35 31 b2				.byte	$35,$31,$b2
.223f					_end51:
>223f	06					.byte	_end52-*
>2240	00					.byte	$00
>2241	fc 14					.word	C63
>2243	36 b3					.byte	$36,$b3
.2245					_end52:
>2245	06					.byte	_end53-*
>2246	00					.byte	$00
>2247	00 15					.word	C64
>2249	36 b4					.byte	$36,$b4
.224b					_end53:
>224b	05					.byte	_end54-*
>224c	00					.byte	$00
>224d	d7 14					.word	C8
>224f	b8					.byte	$b8
.2250					_end54:
>2250	06					.byte	_end55-*
>2251	00					.byte	$00
>2252	49 14					.word	Times8
>2254	38 aa					.byte	$38,$aa
.2256					_end55:
>2256	06					.byte	_end56-*
>2257	00					.byte	$00
>2258	5c 14					.word	Divide8
>225a	38 af					.byte	$38,$af
.225c					_end56:
>225c	05					.byte	_end57-*
>225d	40					.byte	$40
>225e	9d 1a					.word	ReturnHandler
>2260	bb					.byte	$bb
.2261					_end57:
>2261	05					.byte	_end58-*
>2262	00					.byte	$00
>2263	65 12					.word	CheckLess
>2265	bc					.byte	$bc
.2266					_end58:
>2266	06					.byte	_end59-*
>2267	00					.byte	$00
>2268	7e 12					.word	CheckLessEq
>226a	3c bd					.byte	$3c,$bd
.226c					_end59:
>226c	06					.byte	_end60-*
>226d	00					.byte	$00
>226e	2e 12					.word	CheckNotEqual
>2270	3c be					.byte	$3c,$be
.2272					_end60:
>2272	05					.byte	_end61-*
>2273	00					.byte	$00
>2274	31 12					.word	CheckEqual
>2276	bd					.byte	$bd
.2277					_end61:
>2277	05					.byte	_end62-*
>2278	00					.byte	$00
>2279	81 12					.word	CheckGreater
>227b	be					.byte	$be
.227c					_end62:
>227c	06					.byte	_end63-*
>227d	00					.byte	$00
>227e	62 12					.word	CheckGreaterEq
>2280	3e bd					.byte	$3e,$bd
.2282					_end63:
>2282	08					.byte	_end64-*
>2283	00					.byte	$00
>2284	6c 15					.word	TestDup
>2286	3f 44 55 d0				.byte	$3f,$44,$55,$d0
.228a					_end64:
>228a	05					.byte	_end65-*
>228b	00					.byte	$00
>228c	e1 15					.word	WordRead
>228e	c0					.byte	$c0
.228f					_end65:
>228f	07					.byte	_end66-*
>2290	00					.byte	$00
>2291	e7 13					.word	Absolute
>2293	41 42 d3				.byte	$41,$42,$d3
.2296					_end66:
>2296	09					.byte	_end67-*
>2297	00					.byte	$00
>2298	24 16					.word	AllocateMemory
>229a	41 4c 4c 4f c3				.byte	$41,$4c,$4c,$4f,$c3
.229f					_end67:
>229f	07					.byte	_end68-*
>22a0	00					.byte	$00
>22a1	07 12					.word	And
>22a3	41 4e c4				.byte	$41,$4e,$c4
.22a6					_end68:
>22a6	0a					.byte	_end69-*
>22a7	00					.byte	$00
>22a8	77 1d					.word	AssertCode
>22aa	41 53 53 45 52 d4			.byte	$41,$53,$53,$45,$52,$d4
.22b0					_end69:
>22b0	09					.byte	_end70-*
>22b1	00					.byte	$00
>22b2	3a 14					.word	ByteSwap
>22b4	42 53 57 41 d0				.byte	$42,$53,$57,$41,$d0
.22b9					_end70:
>22b9	06					.byte	_end71-*
>22ba	00					.byte	$00
>22bb	ef 15					.word	ByteWrite
>22bd	43 a1					.byte	$43,$a1
.22bf					_end71:
>22bf	06					.byte	_end72-*
>22c0	00					.byte	$00
>22c1	d8 15					.word	ByteRead
>22c3	43 c0					.byte	$43,$c0
.22c5					_end72:
>22c5	07					.byte	_end73-*
>22c6	00					.byte	$00
>22c7	5e 1b					.word	ClrHandler
>22c9	43 4c d2				.byte	$43,$4c,$d2
.22cc					_end73:
>22cc	08					.byte	_end74-*
>22cd	00					.byte	$00
>22ce	63 15					.word	Drop
>22d0	44 52 4f d0				.byte	$44,$52,$4f,$d0
.22d4					_end74:
>22d4	07					.byte	_end75-*
>22d5	00					.byte	$00
>22d6	75 15					.word	Dup
>22d8	44 55 d0				.byte	$44,$55,$d0
.22db					_end75:
>22db	08					.byte	_end76-*
>22dc	01					.byte	$01
>22dd	ea 19					.word	ElseHandler
>22df	45 4c 53 c5				.byte	$45,$4c,$53,$c5
.22e3					_end76:
>22e3	07					.byte	_end77-*
>22e4	00					.byte	$00
>22e5	98 1d					.word	EndProgram
>22e7	45 4e c4				.byte	$45,$4e,$c4
.22ea					_end77:
>22ea	09					.byte	_end78-*
>22eb	00					.byte	$00
>22ec	ed 19					.word	EndIfHandler
>22ee	45 4e 44 49 c6				.byte	$45,$4e,$44,$49,$c6
.22f3					_end78:
>22f3	07					.byte	_end79-*
>22f4	00					.byte	$00
>22f5	62 19					.word	ForHandler
>22f7	46 4f d2				.byte	$46,$4f,$d2
.22fa					_end79:
>22fa	06					.byte	_end80-*
>22fb	01					.byte	$01
>22fc	e7 19					.word	IfHandler
>22fe	49 c6					.byte	$49,$c6
.2300					_end80:
>2300	09					.byte	_end81-*
>2301	00					.byte	$00
>2302	c6 19					.word	GetIndex
>2304	49 4e 44 45 d8				.byte	$49,$4e,$44,$45,$d8
.2309					_end81:
>2309	08					.byte	_end82-*
>230a	00					.byte	$00
>230b	d3 1c					.word	ListCode
>230d	4c 49 53 d4				.byte	$4c,$49,$53,$d4
.2311					_end82:
>2311	07					.byte	_end83-*
>2312	00					.byte	$00
>2313	9e 12					.word	Maximum
>2315	4d 41 d8				.byte	$4d,$41,$d8
.2318					_end83:
>2318	07					.byte	_end84-*
>2319	00					.byte	$00
>231a	9a 12					.word	Minimum
>231c	4d 49 ce				.byte	$4d,$49,$ce
.231f					_end84:
>231f	07					.byte	_end85-*
>2320	00					.byte	$00
>2321	da 12					.word	Modulus16x16
>2323	4d 4f c4				.byte	$4d,$4f,$c4
.2326					_end85:
>2326	0a					.byte	_end86-*
>2327	00					.byte	$00
>2328	ee 13					.word	Negate
>232a	4e 45 47 41 54 c5			.byte	$4e,$45,$47,$41,$54,$c5
.2330					_end86:
>2330	07					.byte	_end87-*
>2331	00					.byte	$00
>2332	55 1b					.word	NewHandler
>2334	4e 45 d7				.byte	$4e,$45,$d7
.2337					_end87:
>2337	08					.byte	_end88-*
>2338	01					.byte	$01
>2339	90 19					.word	NextHandler
>233b	4e 45 58 d4				.byte	$4e,$45,$58,$d4
.233f					_end88:
>233f	07					.byte	_end89-*
>2340	00					.byte	$00
>2341	a9 15					.word	Nip
>2343	4e 49 d0				.byte	$4e,$49,$d0
.2346					_end89:
>2346	07					.byte	_end90-*
>2347	00					.byte	$00
>2348	fe 13					.word	OneComplement
>234a	4e 4f d4				.byte	$4e,$4f,$d4
.234d					_end90:
>234d	06					.byte	_end91-*
>234e	00					.byte	$00
>234f	21 12					.word	LogOr
>2351	4f d2					.byte	$4f,$d2
.2353					_end91:
>2353	08					.byte	_end92-*
>2354	00					.byte	$00
>2355	91 15					.word	Over
>2357	4f 56 45 d2				.byte	$4f,$56,$45,$d2
.235b					_end92:
>235b	0a					.byte	_end93-*
>235c	00					.byte	$00
>235d	f0 19					.word	RepeatHandler
>235f	52 45 50 45 41 d4			.byte	$52,$45,$50,$45,$41,$d4
.2365					_end93:
>2365	07					.byte	_end94-*
>2366	00					.byte	$00
>2367	7d 14					.word	RandomNumber
>2369	52 4e c4				.byte	$52,$4e,$c4
.236c					_end94:
>236c	07					.byte	_end95-*
>236d	00					.byte	$00
>236e	ae 15					.word	Rot
>2370	52 4f d4				.byte	$52,$4f,$d4
.2373					_end95:
>2373	07					.byte	_end96-*
>2374	00					.byte	$00
>2375	50 1d					.word	RunProgram
>2377	52 55 ce				.byte	$52,$55,$ce
.237a					_end96:
>237a	07					.byte	_end97-*
>237b	00					.byte	$00
>237c	29 14					.word	SignTOS
>237e	53 47 ce				.byte	$53,$47,$ce
.2381					_end97:
>2381	08					.byte	_end98-*
>2382	00					.byte	$00
>2383	90 1d					.word	StopCode
>2385	53 54 4f d0				.byte	$53,$54,$4f,$d0
.2389					_end98:
>2389	08					.byte	_end99-*
>238a	00					.byte	$00
>238b	7e 15					.word	Swap
>238d	53 57 41 d0				.byte	$53,$57,$41,$d0
.2391					_end99:
>2391	07					.byte	_end100-*
>2392	00					.byte	$00
>2393	60 1d					.word	Call6502
>2395	53 59 d3				.byte	$53,$59,$d3
.2398					_end100:
>2398	0d					.byte	_end101-*
>2399	00					.byte	$00
>239a	d8 1e					.word	IntToString
>239c	54 4f 2e 53 54 52 49 4e			.byte	$54,$4f,$2e,$53,$54,$52,$49,$4e,$c7
>23a4	c7
.23a5					_end101:
>23a5	09					.byte	_end102-*
>23a6	01					.byte	$01
>23a7	f3 19					.word	UntilHandler
>23a9	55 4e 54 49 cc				.byte	$55,$4e,$54,$49,$cc
.23ae					_end102:
>23ae	09					.byte	_end103-*
>23af	00					.byte	$00
>23b0	9b 1d					.word	VlistCode
>23b2	56 4c 49 53 d4				.byte	$56,$4c,$49,$53,$d4
.23b7					_end103:
>23b7	0a					.byte	_end104-*
>23b8	40					.byte	$40
>23b9	a2 1b					.word	BreakCmd
>23bb	58 42 52 45 41 cb			.byte	$58,$42,$52,$45,$41,$cb
.23c1					_end104:
>23c1	09					.byte	_end105-*
>23c2	00					.byte	$00
>23c3	9c 1b					.word	ExitDump
>23c5	58 44 55 4d d0				.byte	$58,$44,$55,$4d,$d0
.23ca					_end105:
>23ca	07					.byte	_end106-*
>23cb	00					.byte	$00
>23cc	14 12					.word	Xor
>23ce	58 4f d2				.byte	$58,$4f,$d2
.23d1					_end106:
>23d1	00					.byte	0

;******  Return to file: kernel.asm

>3fff	ff						.byte 	$FF
.4000					ProgramMemory:

;******  End of listing
