
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -q -D encode=0 -c -o kernel_nocode.prg -L kernel.lst -l kernel.lbl kernel.asm
; Mon Jan 13 14:12:22 2020

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=0					encode=0

;******  Processing input file: kernel.asm

=$1000					RplBuild = $1000 							; code starts here.

;******  Processing file: data.asm

.0000					NextCode:
>0000							.fill 	5
=3					IP = NextCode+3 							; the IP which points to the current instruction
.0005					rsp:
>0005							.byte 	?
.0006					tos:
>0006							.word 	?
.0008					srcPtr:
>0008							.word 	?
.000a					bufPtr:
>000a							.word 	?
.000c					matchPtr:
>000c							.word 	?
.000e					nextFreeMem:
>000e							.word 	?
.0010					temp1:
>0010							.word 	?
.0012					temp2:
>0012							.word 	?
.0014					temp3:
>0014							.word 	?
.0016					temp4:
>0016							.word 	?
.0018					listPtr:
>0018							.word 	?
.001a					SignCount:
>001a							.byte 	?
.001b					RandomSeed:
>001b							.word 	?
.001d					ListCount:
>001d							.byte 	?
.001e					ListLowest:
>001e							.word 	?
=$102					stack2Low = $102							; access other stack members following tsx
=$101					stack2High = $101							; (which requires saving X, not on the stack !)
=$104					stack3Low = $104
=$103					stack3High = $103
=$600					azVariables = $600 							; 26 x 2 variables occupying 52 bytes * PAGE BOUNDARY *
=16					hashTableSize = 16 							; hash tables for variables.
=$640					hashTable = $640 							; hash tables start here * ALL ON ONE PAGE *
=$810					textBuffer = $810 							; buffer for text.
=$700					returnStack = $700							; return stack (1 page)
=$700					returnStackLow = returnStack
=1856					returnStackHigh = returnStack+$40
=1920					returnStackX = returnStack+$80
=$80					NumberStackBase = $80 						; number stack down from here.
=$910					encodeBuffer = $910 						; buffer for encoded program
=0					COL_BLACK = 0
=1					COL_RED = 1
=2					COL_GREEN = 2
=3					COL_YELLOW = 3
=4					COL_BLUE = 4
=5					COL_MAGENTA = 5
=6					COL_CYAN = 6
=7					COL_WHITE = 7
=8					COL_RVS = 8
=2					CTH_LineNo = COL_Green
=6					CTH_Keyword = COL_Cyan
=11					CTH_Comment = COL_Yellow+COL_Rvs
=7					CTH_Definition = COL_White
=5					CTH_String = COL_Magenta
=3					CTH_Call = COL_Yellow

;******  Return to file: kernel.asm

.1000	a2 ff		ldx #$ff			ldx 	#$FF 						; reset the stack
.1002	9a		txs				txs
.1003	20 fd 10	jsr $10fd			jsr 	ExternInitialise
.1006	a9 42		lda #$42			lda 	#BootMsg & $FF
.1008	a0 10		ldy #$10			ldy 	#BootMsg >> 8
.100a	20 ed 11	jsr $11ed			jsr 	EXPrintString
.100d					WarmStartBlankStack:
.100d	86 10		stx $10				stx 	temp1
.100f	a2 80		ldx #$80			ldx 	#NumberStackBase
.1011	9a		txs				txs
.1012	a6 10		ldx $10				ldx 	temp1
.1014					WarmStart:
.1014	a9 03		lda #$03			lda 	#COL_Yellow
.1016	20 34 11	jsr $1134			jsr 	ExternColour
.1019	20 57 11	jsr $1157			jsr 	ExternInput
.101c	a9 06		lda #$06			lda 	#COL_Cyan
.101e	20 34 11	jsr $1134			jsr 	ExternColour
.1021	a9 10		lda #$10			lda 	#textBuffer & $FF
.1023	a0 08		ldy #$08			ldy 	#textBuffer >> 8
.1025	20 59 16	jsr $1659			jsr 	EncodeProgram
.1028	ad 11 09	lda $0911			lda 	encodeBuffer+1 				; has a line number been entered ?
.102b	0d 12 09	ora $0912			ora 	encodeBuffer+2
.102e	d0 0e		bne $103e			bne 	LineEditor 					; if so, do the line editing code.
.1030	a9 ff		lda #$ff			lda 	#$FF
.1032	85 05		sta $05				sta 	rsp
.1034	a2 10		ldx #$10			ldx 	#encodeBuffer & $FF 		; run what is in the encode buffer.
.1036	a0 09		ldy #$09			ldy 	#encodeBuffer >> 8
.1038	20 94 10	jsr $1094			jsr 	InitialiseCoreCode 			; initialise the NEXT routine at $00
.103b	4c 00 00	jmp $0000			jmp 	NextCode
.103e					LineEditor:
>103e	ff						.byte 	$FF
.103f					ErrorHandler:
>103f	ff						.byte 	$FF
.1040	a2 5e		ldx #$5e			ldx 	#$5E
.1042					BootMsg:
>1042	2a 2a 2a 20 52 50 4c 2f				.text 	"*** RPL/C INTERPRETER ***",13,13
>104a	43 20 49 4e 54 45 52 50 52 45 54 45 52 20 2a 2a
>105a	2a 0d 0d
>105d	57 52 49 54 54 45 4e 20				.text	"WRITTEN BY PAUL ROBSON 2020",13,13
>1065	42 59 20 50 41 55 4c 20 52 4f 42 53 4f 4e 20 32
>1075	30 32 30 0d 0d
>107a	42 55 49 4c 44 3a 20				.text 	"BUILD: "

;******  Processing file: generated/timestamp.inc

>1081	5b 32 30 2d 30 31 2d 31			.text	"[20-01-13 14:12]"
>1089	33 20 31 34 3a 31 32 5d

;******  Return to file: kernel.asm

>1091	0d 0d 00					.byte 	13,13,0

;******  Processing file: core.src

.1094					InitialiseCoreCode:
.1094	a9 e8		lda #$e8			lda 	#$E8 					; Copy INX INX 			4 cycles when run
.1096	85 00		sta $00				sta 	NextCode
.1098	85 01		sta $01				sta 	NextCode+1
.109a	a9 7c		lda #$7c			lda 	#$7C 					; Copy JMP ($aaaa,x) 	6 cycles when run
.109c	85 02		sta $02				sta 	NextCode+2
.109e	86 03		stx $03				stx 	NextCode+3 				; set the indirect address (IP)
.10a0	84 04		sty $04				sty 	NextCode+4
.10a2	a2 01		ldx #$01			ldx 	#1 						; set up to run from provided word.
.10a4	60		rts				rts								; (2 INX skip offset and line#)
.10a5					Literal2Byte:
.10a5	a5 06		lda $06				lda 	TOS
.10a7	48		pha				pha
.10a8	a5 07		lda $07				lda 	TOS+1
.10aa	48		pha				pha
.10ab	e8		inx				inx  							; point X to the word
.10ac	e8		inx				inx
.10ad	8a		txa				txa 							; copy into Y
.10ae	a8		tay				tay
.10af	b1 03		lda ($03),y			lda 	(IP),y 					; read it. the LSB
.10b1	85 06		sta $06				sta 	TOS
.10b3	c8		iny				iny 							; read and push the MSB
.10b4	b1 03		lda ($03),y			lda 	(IP),y
.10b6	85 07		sta $07				sta 	TOS+1
.10b8	4c 00 00	jmp $0000			jmp 	NextCode
.10bb					Literal2ByteDecode:
.10bb	a9 06		lda #$06			lda 	#CTH_Keyword
.10bd	20 bd 1c	jsr $1cbd			jsr 	DecodeWriteBuffer
.10c0	b1 08		lda ($08),y			lda 	(srcPtr),y
.10c2	aa		tax				tax
.10c3	c8		iny				iny
.10c4	b1 08		lda ($08),y			lda 	(srcPtr),y
.10c6	a8		tay				tay
.10c7	8a		txa				txa
.10c8	38		sec				sec 							; output signed
.10c9	20 df 1c	jsr $1cdf			jsr 	DecodeYAToBuffer
.10cc	60		rts				rts
.10cd					LiteralString:
.10cd	a5 06		lda $06				lda 	TOS
.10cf	48		pha				pha
.10d0	a5 07		lda $07				lda 	TOS+1
.10d2	48		pha				pha
.10d3	e8		inx				inx
.10d4	e8		inx				inx 							; skip over current word
.10d5	8a		txa				txa 							; add to IP + 1 to give string address
.10d6	a8		tay				tay 							; put in Y
.10d7	38		sec				sec 							; make that TOS
.10d8	65 03		adc $03				adc 	IP
.10da	85 06		sta $06				sta 	TOS
.10dc	a5 04		lda $04				lda 	IP+1
.10de	69 00		adc #$00			adc 	#0
.10e0	85 07		sta $07				sta 	TOS+1
.10e2	8a		txa				txa 							; add data length to X
.10e3	18		clc				clc
.10e4	71 03		adc ($03),y			adc 	(IP),y
.10e6	aa		tax				tax
.10e7	ca		dex				dex
.10e8	ca		dex				dex
.10e9	4c 00 00	jmp $0000			jmp 	NextCode
.10ec					LiteralStringDecoder:
.10ec	a9 05		lda #$05			lda 	#CTH_String
.10ee	20 bd 1c	jsr $1cbd			jsr 	DecodeWriteBuffer
.10f1	a9 22		lda #$22			lda 	#'"'
.10f3	20 bd 1c	jsr $1cbd			jsr 	DecodeWriteBuffer
.10f6	20 c6 1c	jsr $1cc6			jsr 	DecodeOutputData
.10f9	20 bd 1c	jsr $1cbd			jsr 	DecodeWriteBuffer
.10fc	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: extern.asm

.10fd					ExternInitialise:
.10fd	a9 90		lda #$90			lda 	#144 						; set colour
.10ff	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.1102	a9 01		lda #$01			lda 	#$01
.1104	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.1107	a9 0e		lda #$0e			lda 	#14							; lower case
.1109	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.110c	a9 93		lda #$93			lda 	#147 						; clear screen
.110e	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.1111	a9 07		lda #$07			lda 	#COL_WHITE 					; white text.
.1113	4c 34 11	jmp $1134			jmp 	ExternColour
.1116					ExternCheckBreak:
.1116	da		phx				phx 								; make sure we keep XY
.1117	5a		phy				phy
.1118	20 e1 ff	jsr $ffe1			jsr 	$FFE1						; STOP check on CBM KERNAL
.111b	f0 03		beq $1120			beq		_ECBExit 					; stopped
.111d	7a		ply				ply 								; restore and exit.
.111e	fa		plx				plx
.111f	60		rts				rts
.1120					_ECBExit:
.1120	20 3f 10	jsr $103f			jsr 	ErrorHandler
>1123	45 53 43 41 50 45 00				.text 	"ESCAPE",0
.112a					ExternPrint:
.112a	48		pha				pha
.112b	da		phx				phx
.112c	5a		phy				phy
.112d	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.1130	7a		ply				ply
.1131	fa		plx				plx
.1132	68		pla				pla
.1133	60		rts				rts
.1134					ExternColour:
.1134	48		pha				pha
.1135	da		phx				phx
.1136	48		pha				pha
.1137	29 08		and #$08			and 	#8
.1139	0a		asl a				asl 	a
.113a	0a		asl a				asl 	a
.113b	0a		asl a				asl 	a
.113c	0a		asl a				asl 	a
.113d	49 92		eor #$92			eor 	#$92
.113f	20 2a 11	jsr $112a			jsr 	ExternPrint
.1142	68		pla				pla
.1143	29 07		and #$07			and 	#7
.1145	aa		tax				tax
.1146	bd 4f 11	lda $114f,x			lda 	_ECTable,x
.1149	20 2a 11	jsr $112a			jsr 	ExternPrint
.114c	fa		plx				plx
.114d	68		pla				pla
.114e	60		rts				rts
.114f					_ECTable:
>114f	90						.byte 	144
>1150	1c						.byte 	28
>1151	1e						.byte 	30
>1152	9e						.byte 	158
>1153	1f						.byte 	31
>1154	9c						.byte 	156
>1155	9f						.byte 	159
>1156	05						.byte 	5
.1157					ExternInput:
.1157	a9 10		lda #$10			lda 	#(textBuffer & $FF)
.1159	85 14		sta $14				sta 	temp3
.115b	a9 08		lda #$08			lda 	#(textBuffer >> 8)
.115d	85 15		sta $15				sta 	temp3+1
.115f	20 cf ff	jsr $ffcf	_EIRead:jsr 	$FFCF
.1162	29 7f		and #$7f			and 	#$7F
.1164	c9 0d		cmp #$0d			cmp 	#13
.1166	f0 0a		beq $1172			beq 	_EIExit
.1168	92 14		sta ($14)			sta 	(temp3)
.116a	e6 14		inc $14				inc 	temp3
.116c	d0 f1		bne $115f			bne 	_EIRead
.116e	e6 15		inc $15				inc 	temp3+1
.1170	80 ed		bra $115f			bra 	_EIRead
.1172	a9 00		lda #$00	_EIExit:lda 	#0
.1174	92 14		sta ($14)			sta 	(temp3)
.1176	a9 0d		lda #$0d			lda 	#13
.1178	20 2a 11	jsr $112a			jsr 	ExternPrint
.117b	60		rts				rts
.117c					ExternSave:
.117c	da		phx				phx
.117d	5a		phy				phy
.117e	85 12		sta $12				sta 	temp2 						; save start
.1180	84 13		sty $13				sty 	temp2+1
.1182	20 e4 11	jsr $11e4			jsr 	EXGetLength 				; get length of file into A
.1185	a6 14		ldx $14				ldx 	temp3
.1187	a4 15		ldy $15				ldy 	temp3+1
.1189	20 bd ff	jsr $ffbd			jsr 	$FFBD 						; set name
.118c	a9 01		lda #$01			lda 	#1
.118e	a2 08		ldx #$08			ldx 	#8	 						; device #8
.1190	a0 00		ldy #$00			ldy 	#0
.1192	20 ba ff	jsr $ffba			jsr 	$FFBA 						; set LFS
.1195	a6 10		ldx $10				ldx 	temp1 						; end address
.1197	a4 11		ldy $11				ldy 	temp1+1
.1199	a9 12		lda #$12			lda 	#temp2
.119b	20 d8 ff	jsr $ffd8			jsr 	$FFD8 						; save
.119e	b0 03		bcs $11a3			bcs 	_ESSave
.11a0	7a		ply				ply
.11a1	fa		plx				plx
.11a2	60		rts				rts
.11a3					_ESSave:
.11a3	20 3f 10	jsr $103f			jsr 	ErrorHandler
>11a6	53 41 56 45 20 46 41 49				.text 	"SAVE FAILED",0
>11ae	4c 45 44 00
.11b2					ExternLoad:
.11b2	da		phx				phx 								; save XY
.11b3	5a		phy				phy
.11b4	48		pha				pha 								; save target
.11b5	5a		phy				phy
.11b6	20 e4 11	jsr $11e4			jsr 	EXGetLength 				; get length of file into A
.11b9	a6 14		ldx $14				ldx 	temp3
.11bb	a4 15		ldy $15				ldy 	temp3+1
.11bd	20 bd ff	jsr $ffbd			jsr 	$FFBD 						; set name
.11c0	a9 01		lda #$01			lda 	#1
.11c2	a2 08		ldx #$08			ldx 	#8	 						; device #8
.11c4	a0 00		ldy #$00			ldy 	#0
.11c6	20 ba ff	jsr $ffba			jsr 	$FFBA 						; set LFS
.11c9	7a		ply				ply 								; restore target to YX and call load
.11ca	fa		plx				plx
.11cb	a9 00		lda #$00			lda 	#0 							; load command
.11cd	20 d5 ff	jsr $ffd5			jsr 	$FFD5
.11d0	b0 03		bcs $11d5			bcs 	_ESLoad
.11d2	7a		ply				ply
.11d3	fa		plx				plx
.11d4	60		rts				rts
.11d5					_ESLoad:
.11d5	20 3f 10	jsr $103f			jsr 	ErrorHandler
>11d8	4c 4f 41 44 20 46 41 49				.text 	"LOAD FAILED",0
>11e0	4c 45 44 00
.11e4					EXGetLength:
.11e4	b2 14		lda ($14)			lda 	(temp3) 					; get name length
.11e6	e6 14		inc $14				inc 	temp3 						; bump ptr past it
.11e8	d0 02		bne $11ec			bne 	_EXGLExit
.11ea	e6 15		inc $15				inc 	temp3+1
.11ec					_EXGLExit:
.11ec	60		rts				rts
.11ed					EXPrintString:
.11ed	48		pha				pha
.11ee	5a		phy				phy
.11ef	84 11		sty $11				sty 	temp1+1
.11f1	85 10		sta $10				sta 	temp1
.11f3	a0 00		ldy #$00			ldy 	#0
.11f5					_EXPSLoop:
.11f5	b1 10		lda ($10),y			lda 	(temp1),y
.11f7	f0 08		beq $1201			beq 	_EXPSExit
.11f9	29 7f		and #$7f			and 	#$7F
.11fb	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.11fe	c8		iny				iny
.11ff	80 f4		bra $11f5			bra 	_EXPSLoop
.1201					_EXPSExit:
.1201	7a		ply				ply
.1202	68		pla				pla
.1203	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/binary.src

.1204					Add:
.1204	7a		ply				ply
.1205	68		pla				pla
.1206	18		clc				clc
.1207	65 06		adc $06				adc 	TOS
.1209	85 06		sta $06				sta 	TOS
.120b	98		tya				tya
.120c	65 07		adc $07				adc 	TOS+1
.120e	85 07		sta $07				sta 	TOS+1
.1210	4c 00 00	jmp $0000			jmp 	NextCode
.1213					Subtract:
.1213	7a		ply				ply
.1214	68		pla				pla
.1215	38		sec				sec
.1216	49 ff		eor #$ff			eor 	#$FF
.1218	65 06		adc $06				adc 	TOS
.121a	85 06		sta $06				sta 	TOS
.121c	98		tya				tya
.121d	49 ff		eor #$ff			eor 	#$FF
.121f	65 07		adc $07				adc 	TOS+1
.1221	85 07		sta $07				sta 	TOS+1
.1223	4c 00 00	jmp $0000			jmp 	NextCode
.1226					And:
.1226	68		pla				pla
.1227	25 07		and $07				and 	TOS+1
.1229	85 07		sta $07				sta 	TOS+1
.122b	68		pla				pla
.122c	25 06		and $06				and 	TOS
.122e	85 06		sta $06				sta 	TOS
.1230	4c 00 00	jmp $0000			jmp 	NextCode
.1233					Xor:
.1233	68		pla				pla
.1234	45 07		eor $07				eor 	TOS+1
.1236	85 07		sta $07				sta 	TOS+1
.1238	68		pla				pla
.1239	45 06		eor $06				eor 	TOS
.123b	85 06		sta $06				sta 	TOS
.123d	4c 00 00	jmp $0000			jmp 	NextCode
.1240					LogOr:
.1240	68		pla				pla
.1241	05 07		ora $07				ora 	TOS+1
.1243	85 07		sta $07				sta 	TOS+1
.1245	68		pla				pla
.1246	05 06		ora $06				ora 	TOS
.1248	85 06		sta $06				sta 	TOS
.124a	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/compare.src

.124d					CheckNotEqual:
.124d	38		sec				sec
.124e	80 01		bra $1251			bra 	CECode
.1250					CheckEqual:
.1250	18		clc				clc
.1251					CECode:
.1251	86 10		stx $10				stx 	temp1
.1253	ba		tsx				tsx
.1254	08		php				php
.1255	a5 06		lda $06				lda 	TOS
.1257	5d 02 01	eor $0102,x			eor 	Stack2Low,x
.125a	d0 17		bne $1273			bne	 	CompareFalse
.125c	a5 07		lda $07				lda 	TOS+1
.125e	5d 01 01	eor $0101,x			eor 	Stack2High,x
.1261	d0 10		bne $1273			bne 	CompareFalse
.1263					CompareTrue:
.1263	a6 10		ldx $10				ldx 	temp1
.1265	28		plp				plp
.1266	b0 10		bcs $1278			bcs		CompareFalse2
.1268					CompareTrue2:
.1268	68		pla				pla
.1269	68		pla				pla
.126a	a9 ff		lda #$ff			lda 	#$FF
.126c	85 06		sta $06				sta 	TOS
.126e	85 07		sta $07				sta 	TOS+1
.1270	4c 00 00	jmp $0000			jmp 	NextCode
.1273					CompareFalse:
.1273	a6 10		ldx $10				ldx 	temp1
.1275	28		plp				plp
.1276	b0 f0		bcs $1268			bcs		CompareTrue2
.1278					CompareFalse2:
.1278	68		pla				pla
.1279	68		pla				pla
.127a	64 06		stz $06				stz 	TOS
.127c	64 07		stz $07				stz 	TOS+1
.127e	4c 00 00	jmp $0000			jmp 	NextCode
.1281					CheckGreaterEq:
.1281	38		sec				sec
.1282	80 01		bra $1285			bra		CLCode
.1284					CheckLess:
.1284	18		clc				clc
.1285	86 10		stx $10		CLCode:	stx 	temp1
.1287	ba		tsx				tsx
.1288	08		php				php
.1289	18		clc				clc
.128a	a5 06		lda $06				lda 	TOS
.128c	fd 02 01	sbc $0102,x			sbc 	Stack2Low,x
.128f	a5 07		lda $07				lda 	TOS+1
.1291	fd 01 01	sbc $0101,x			sbc 	Stack2High,x
.1294	50 02		bvc $1298			bvc 	_CLNoFlip
.1296	49 80		eor #$80			eor 	#$80
.1298					_CLNoFlip:
.1298	0a		asl a				asl 	a
.1299	b0 d8		bcs $1273			bcs 	CompareFalse
.129b	80 c6		bra $1263			bra 	CompareTrue
.129d					CheckLessEq:
.129d	38		sec				sec
.129e	80 01		bra $12a1			bra		CGCode
.12a0					CheckGreater:
.12a0	18		clc				clc
.12a1					CGCode:
.12a1	86 10		stx $10				stx 	temp1
.12a3	ba		tsx				tsx
.12a4	08		php				php
.12a5	18		clc				clc
.12a6	bd 02 01	lda $0102,x			lda 	Stack2Low,x
.12a9	e5 06		sbc $06				sbc 	TOS
.12ab	bd 01 01	lda $0101,x			lda 	Stack2High,x
.12ae	e5 07		sbc $07				sbc 	TOS+1
.12b0	50 02		bvc $12b4			bvc 	_CGNoFlip
.12b2	49 80		eor #$80			eor 	#$80
.12b4					_CGNoFlip:
.12b4	0a		asl a				asl 	a
.12b5	b0 bc		bcs $1273			bcs 	CompareFalse
.12b7	80 aa		bra $1263			bra 	CompareTrue
.12b9					Minimum:
.12b9	a9 00		lda #$00			lda 	#0
.12bb	80 02		bra $12bf			bra 	MinMaxCode
.12bd					Maximum:
.12bd	a9 80		lda #$80			lda 	#$80
.12bf					MinMaxCode:
.12bf	85 11		sta $11				sta 	temp1+1
.12c1	86 10		stx $10				stx 	temp1
.12c3	ba		tsx				tsx
.12c4	38		sec				sec
.12c5	a5 06		lda $06				lda 	TOS
.12c7	fd 02 01	sbc $0102,x			sbc 	Stack2Low,x
.12ca	a5 07		lda $07				lda 	TOS+1
.12cc	fd 01 01	sbc $0101,x			sbc 	Stack2High,x
.12cf	50 02		bvc $12d3			bvc 	_MMNoFlip
.12d1	49 80		eor #$80			eor 	#$80
.12d3					_MMNoFlip:
.12d3	45 11		eor $11				eor 	temp1+1
.12d5	30 0a		bmi $12e1			bmi 	_MMNoCopy
.12d7	bd 02 01	lda $0102,x			lda 	Stack2Low,x
.12da	85 06		sta $06				sta 	TOS
.12dc	bd 01 01	lda $0101,x			lda 	Stack2High,x
.12df	85 07		sta $07				sta 	TOS+1
.12e1					_MMNoCopy:
.12e1	a6 10		ldx $10				ldx 	temp1
.12e3	68		pla				pla
.12e4	68		pla				pla
.12e5	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/divide.src

.12e8					Divide16x16:
.12e8	86 12		stx $12				stx 	temp2
.12ea	ba		tsx				tsx
.12eb	20 0e 13	jsr $130e			jsr 	IntegerDivide
.12ee	68		pla				pla
.12ef	85 07		sta $07				sta 	TOS+1
.12f1	68		pla				pla
.12f2	85 06		sta $06				sta 	TOS
.12f4	a6 12		ldx $12				ldx 	temp2
.12f6	4c 00 00	jmp $0000			jmp 	NextCode
.12f9					Modulus16x16:
.12f9	86 12		stx $12				stx 	temp2
.12fb	ba		tsx				tsx
.12fc	20 0e 13	jsr $130e			jsr 	IntegerDivide
.12ff	a6 12		ldx $12				ldx 	temp2
.1301	68		pla				pla
.1302	68		pla				pla
.1303	a5 10		lda $10				lda 	temp1
.1305	85 06		sta $06				sta 	TOS
.1307	a5 11		lda $11				lda 	temp1+1
.1309	85 07		sta $07				sta 	TOS+1
.130b	4c 00 00	jmp $0000			jmp 	NextCode
.130e					IntegerDivide:
.130e	a5 06		lda $06				lda 	TOS 				; check for division by zero.
.1310	05 07		ora $07				ora 	TOS+1
.1312	d0 14		bne $1328			bne 	_BFDOkay
.1314	20 3f 10	jsr $103f			jsr 	ErrorHandler
>1317	44 49 56 49 53 49 4f 4e				.text 	"DIVISION BY ZERO",0
>131f	20 42 59 20 5a 45 52 4f 00
.1328					_BFDOkay:
.1328	64 10		stz $10				stz 	temp1 						; Q/Dividend/Left in +0
.132a	64 11		stz $11				stz 	temp1+1 					; M/Divisor/Right in +2
.132c	64 1a		stz $1a				stz 	SignCount 					; Count of signs.
.132e	20 69 13	jsr $1369			jsr 	CheckIntegerNegate 			; negate 2nd (and bump sign count)
.1331	20 83 13	jsr $1383			jsr 	CheckTOSNegate 				; negate TOS (and bump sign count)
.1334	5a		phy				phy 								; Y is the counter
.1335	a0 10		ldy #$10			ldy 	#16 						; 16 iterations of the loop.
.1337					_BFDLoop:
.1337	1e 02 01	asl $0102,x			asl 	Stack2Low,x 				; shift AQ left.
.133a	3e 01 01	rol $0101,x			rol 	Stack2High,x
.133d	26 10		rol $10				rol 	temp1
.133f	26 11		rol $11				rol 	temp1+1
.1341	38		sec				sec
.1342	a5 10		lda $10				lda 	temp1+0 					; Calculate A-M on stack.
.1344	e5 06		sbc $06				sbc 	TOS
.1346	48		pha				pha
.1347	a5 11		lda $11				lda 	temp1+1
.1349	e5 07		sbc $07				sbc 	TOS+1
.134b	90 0f		bcc $135c			bcc 	_BFDNoAdd
.134d	85 11		sta $11				sta 	temp1+1
.134f	68		pla				pla
.1350	85 10		sta $10				sta 	temp1+0
.1352	bd 02 01	lda $0102,x			lda 	Stack2Low,x 				; set Q bit 1.
.1355	09 01		ora #$01			ora 	#1
.1357	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.135a	80 01		bra $135d			bra 	_BFDNext
.135c					_BFDNoAdd:
.135c	68		pla				pla 								; Throw away the intermediate calculations
.135d					_BFDNext:
.135d	88		dey				dey
.135e	d0 d7		bne $1337			bne 	_BFDLoop
.1360	7a		ply				ply 								; restore Y
.1361	46 1a		lsr $1a				lsr 	SignCount 					; if sign count odd,
.1363	90 03		bcc $1368			bcc 	_BFDUnsigned 				; then the result is signed
.1365	20 6f 13	jsr $136f			jsr		IntegerNegateAlways 		; negate the result
.1368					_BFDUnsigned:
.1368	60		rts				rts
.1369					CheckIntegerNegate:
.1369	bd 01 01	lda $0101,x			lda 	Stack2High,x 				; is it -ve = MSB set ?
.136c	30 01		bmi $136f			bmi 	IntegerNegateAlways 		; if so negate it
.136e	60		rts				rts
.136f					IntegerNegateAlways:
.136f	e6 1a		inc $1a				inc 	SignCount 					; bump the count of signs
.1371	38		sec				sec 								; negate
.1372	a9 00		lda #$00			lda 	#0
.1374	fd 02 01	sbc $0102,x			sbc 	Stack2Low,x
.1377	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.137a	a9 00		lda #$00			lda 	#0
.137c	fd 01 01	sbc $0101,x			sbc 	Stack2High,x
.137f	9d 01 01	sta $0101,x			sta 	Stack2High,x
.1382	60		rts				rts
.1383					CheckTOSNegate:
.1383	a5 07		lda $07				lda 	TOS+1
.1385	10 0f		bpl $1396			bpl		CTNNoChange
.1387	e6 1a		inc $1a				inc 	SignCount
.1389					TOSNegateAlways:
.1389	38		sec				sec
.138a	a9 00		lda #$00			lda 	#0
.138c	e5 06		sbc $06				sbc 	TOS
.138e	85 06		sta $06				sta 	TOS
.1390	a9 00		lda #$00			lda 	#0
.1392	e5 07		sbc $07				sbc 	TOS+1
.1394	85 07		sta $07				sta 	TOS+1
.1396					CTNNoChange:
.1396	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/multiply.src

.1397					Multiply16x16:
.1397	86 10		stx $10				stx 	temp1
.1399	ba		tsx				tsx
.139a	bd 02 01	lda $0102,x			lda 	Stack2Low,x 				; 2nd value on stack to temp1
.139d	85 12		sta $12				sta 	temp2
.139f	bd 01 01	lda $0101,x			lda		Stack2High,x
.13a2	85 13		sta $13				sta 	temp2+1
.13a4	9e 02 01	stz $0102,x			stz 	Stack2Low,x 				; zero 2nd value on stack
.13a7	9e 01 01	stz $0101,x			stz 	Stack2High,x
.13aa					_MultLoop:
.13aa	46 13		lsr $13				lsr 	temp2+1 					; ror temp2 into C
.13ac	66 12		ror $12				ror 	temp2
.13ae	90 11		bcc $13c1			bcc 	_MultNoAdd
.13b0	18		clc				clc 								; add 1st to 2nd
.13b1	a5 06		lda $06				lda 	TOS
.13b3	7d 02 01	adc $0102,x			adc 	Stack2Low,x
.13b6	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.13b9	a5 07		lda $07				lda 	TOS+1
.13bb	7d 01 01	adc $0101,x			adc 	Stack2High,x
.13be	9d 01 01	sta $0101,x			sta 	Stack2High,x
.13c1					_MultNoAdd:
.13c1	06 06		asl $06				asl 	TOS 						; shift 1st left
.13c3	26 07		rol $07				rol 	TOS+1
.13c5	a5 12		lda $12				lda 	temp2	 					; until zero
.13c7	05 13		ora $13				ora 	temp2+1
.13c9	d0 df		bne $13aa			bne 	_MultLoop
.13cb	a6 10		ldx $10				ldx 	temp1 						; restore X load result
.13cd	68		pla				pla
.13ce	85 07		sta $07				sta 	TOS+1
.13d0	68		pla				pla
.13d1	85 06		sta $06				sta 	TOS
.13d3	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/unary.src

.13d6					Unary1Plus:
.13d6	e6 06		inc $06				inc 	TOS
.13d8	d0 02		bne $13dc			bne 	_U1PSkip
.13da	e6 07		inc $07				inc 	TOS+1
.13dc					_U1PSkip:
.13dc	4c 00 00	jmp $0000			jmp 	NextCode
.13df					Unary2Plus:
.13df	18		clc				clc
.13e0	a5 06		lda $06				lda 	TOS
.13e2	69 02		adc #$02			adc 	#2
.13e4	85 06		sta $06				sta 	TOS
.13e6	90 02		bcc $13ea			bcc 	_U1PSkip
.13e8	e6 07		inc $07				inc 	TOS+1
.13ea					_U1PSkip:
.13ea	4c 00 00	jmp $0000			jmp 	NextCode
.13ed					Unary1Minus:
.13ed	a5 06		lda $06				lda 	TOS
.13ef	d0 02		bne $13f3			bne 	_U1MSkip
.13f1	c6 07		dec $07				dec 	TOS+1
.13f3					_U1MSkip:
.13f3	c6 06		dec $06				dec 	TOS
.13f5	4c 00 00	jmp $0000			jmp 	NextCode
.13f8					Unary2Minus:
.13f8	38		sec				sec
.13f9	a5 06		lda $06				lda 	TOS
.13fb	e9 02		sbc #$02			sbc 	#2
.13fd	85 06		sta $06				sta 	TOS
.13ff	b0 02		bcs $1403			bcs 	_U1PSkip
.1401	c6 07		dec $07				dec 	TOS+1
.1403					_U1PSkip:
.1403	4c 00 00	jmp $0000			jmp 	NextCode
.1406					Absolute:
.1406	a5 07		lda $07				lda 	TOS+1
.1408	30 03		bmi $140d			bmi 	Negate
.140a	4c 00 00	jmp $0000			jmp 	NextCode
.140d					Negate:
.140d	38		sec				sec
.140e	a9 00		lda #$00			lda 	#0
.1410	e5 06		sbc $06				sbc 	TOS
.1412	85 06		sta $06				sta 	TOS
.1414	a9 00		lda #$00			lda 	#0
.1416	e5 07		sbc $07				sbc 	TOS+1
.1418	85 07		sta $07				sta 	TOS+1
.141a	4c 00 00	jmp $0000			jmp 	NextCode
.141d					OneComplement:
.141d	a5 06		lda $06				lda 	TOS
.141f	49 ff		eor #$ff			eor 	#$FF
.1421	85 06		sta $06				sta 	TOS
.1423	a5 07		lda $07				lda 	TOS+1
.1425	49 ff		eor #$ff			eor 	#$FF
.1427	85 07		sta $07				sta 	TOS+1
.1429	4c 00 00	jmp $0000			jmp 	NextCode
.142c					CheckMinus:
.142c	a5 07		lda $07				lda 	TOS+1
.142e	30 07		bmi $1437			bmi 	UnaryTrue
.1430					UnaryFalse:
.1430	64 06		stz $06				stz 	TOS
.1432	64 07		stz $07				stz 	TOS+1
.1434	4c 00 00	jmp $0000			jmp 	NextCode
.1437					UnaryTrue:
.1437	a9 ff		lda #$ff			lda 	#$FF
.1439	85 06		sta $06				sta 	TOS
.143b	85 07		sta $07				sta 	TOS+1
.143d	4c 00 00	jmp $0000			jmp 	NextCode
.1440					CheckZero:
.1440	a5 06		lda $06				lda 	TOS
.1442	05 07		ora $07				ora 	TOS+1
.1444	d0 ea		bne $1430			bne 	UnaryFalse
.1446	80 ef		bra $1437			bra 	UnaryTrue
.1448					SignTOS:
.1448	a5 07		lda $07				lda 	TOS+1
.144a	30 eb		bmi $1437			bmi		UnaryTrue
.144c	05 06		ora $06				ora 	TOS
.144e	f0 e0		beq $1430			beq 	UnaryFalse
.1450	a9 01		lda #$01			lda 	#1
.1452	85 06		sta $06				sta 	TOS
.1454	64 07		stz $07				stz		TOS+1
.1456	4c 00 00	jmp $0000			jmp 	NextCode
.1459					ByteSwap:
.1459	a5 06		lda $06				lda 	TOS
.145b	a4 07		ldy $07				ldy 	TOS+1
.145d	85 07		sta $07				sta 	TOS+1
.145f	84 06		sty $06				sty 	TOS
.1461	4c 00 00	jmp $0000			jmp 	NextCode
.1464					Times16:
.1464	06 06		asl $06				asl 	TOS
.1466	26 07		rol $07				rol 	TOS+1
.1468					Times8:
.1468	06 06		asl $06				asl 	TOS
.146a	26 07		rol $07				rol 	TOS+1
.146c					Times4:
.146c	06 06		asl $06				asl 	TOS
.146e	26 07		rol $07				rol 	TOS+1
.1470					Times2:
.1470	06 06		asl $06				asl 	TOS
.1472	26 07		rol $07				rol 	TOS+1
.1474	4c 00 00	jmp $0000			jmp 	NextCode
.1477					Divide16:
.1477	46 07		lsr $07				lsr 	TOS+1
.1479	66 06		ror $06				ror 	TOS
.147b					Divide8:
.147b	46 07		lsr $07				lsr 	TOS+1
.147d	66 06		ror $06				ror 	TOS
.147f					Divide4:
.147f	46 07		lsr $07				lsr 	TOS+1
.1481	66 06		ror $06				ror 	TOS
.1483					Divide2:
.1483	46 07		lsr $07				lsr 	TOS+1
.1485	66 06		ror $06				ror 	TOS
.1487	4c 00 00	jmp $0000			jmp 	NextCode
.148a					Times256:
.148a	a5 06		lda $06				lda 	TOS
.148c	85 07		sta $07				sta 	TOS+1
.148e	64 06		stz $06				stz 	TOS
.1490	4c 00 00	jmp $0000			jmp 	NextCode
.1493					Divide256:
.1493	a5 07		lda $07				lda 	TOS+1
.1495	85 06		sta $06				sta 	TOS
.1497	64 07		stz $07				stz 	TOS+1
.1499	4c 00 00	jmp $0000			jmp 	NextCode
.149c					RandomNumber:
.149c	a5 06		lda $06				lda 	TOS
.149e	48		pha				pha
.149f	a5 07		lda $07				lda 	TOS+1
.14a1	48		pha				pha
.14a2	a5 1b		lda $1b				lda 	randomSeed
.14a4	05 1c		ora $1c				ora 	randomSeed+1
.14a6	d0 08		bne $14b0			bne 	_RH_NoInit
.14a8	a9 7c		lda #$7c			lda 	#$7C
.14aa	85 1b		sta $1b				sta 	randomSeed
.14ac	a9 a1		lda #$a1			lda 	#$A1
.14ae	85 1c		sta $1c				sta 	randomSeed+1
.14b0					_RH_NoInit:
.14b0	a5 1b		lda $1b				lda 	randomSeed
.14b2	4a		lsr a		        lsr		a
.14b3	26 1c		rol $1c		        rol 	randomSeed+1
.14b5	90 02		bcc $14b9	        bcc 	_RH_NoEor
.14b7	49 b4		eor #$b4	        eor 	#$B4
.14b9					_RH_NoEor:
.14b9	85 1b		sta $1b		        sta 	randomSeed
.14bb	45 1c		eor $1c		        eor 	randomSeed+1
.14bd	85 07		sta $07		        sta 	TOS+1
.14bf	a5 1b		lda $1b		        lda 	randomSeed
.14c1	85 06		sta $06		        sta 	TOS
.14c3	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/data/literals.src

.14c6					Constant0:
.14c6	a5 06		lda $06				lda 	TOS
.14c8	48		pha				pha
.14c9	a5 07		lda $07				lda 	TOS+1
.14cb	48		pha				pha
.14cc	64 06		stz $06				stz 	TOS
.14ce	64 07		stz $07				stz 	TOS+1
.14d0	4c 00 00	jmp $0000			jmp 	NextCode
.14d3					ConstantMinus1:
.14d3	a5 06		lda $06				lda 	TOS
.14d5	48		pha				pha
.14d6	a5 07		lda $07				lda 	TOS+1
.14d8	48		pha				pha
.14d9	a9 ff		lda #$ff			lda 	#$FF
.14db	85 06		sta $06				sta 	TOS
.14dd	85 07		sta $07				sta 	TOS+1
.14df	4c 00 00	jmp $0000			jmp 	NextCode
.14e2					C1:
.14e2	a0 01		ldy #$01			ldy 	#1
.14e4	80 24		bra $150a			bra 	Const1Byte
.14e6					C2:
.14e6	a0 02		ldy #$02			ldy 	#2
.14e8	80 20		bra $150a			bra 	Const1Byte
.14ea					C3:
.14ea	a0 03		ldy #$03			ldy 	#3
.14ec	80 1c		bra $150a			bra 	Const1Byte
.14ee					C4:
.14ee	a0 04		ldy #$04			ldy 	#4
.14f0	80 18		bra $150a			bra 	Const1Byte
.14f2					C5:
.14f2	a0 05		ldy #$05			ldy 	#5
.14f4	80 14		bra $150a			bra 	Const1Byte
.14f6					C8:
.14f6	a0 08		ldy #$08			ldy 	#8
.14f8	80 10		bra $150a			bra 	Const1Byte
.14fa					C10:
.14fa	a0 0a		ldy #$0a			ldy 	#10
.14fc	80 0c		bra $150a			bra 	Const1Byte
.14fe					C15:
.14fe	a0 0f		ldy #$0f			ldy 	#15
.1500	80 08		bra $150a			bra 	Const1Byte
.1502					C16:
.1502	a0 10		ldy #$10			ldy 	#16
.1504	80 04		bra $150a			bra 	Const1Byte
.1506					C24:
.1506	a0 18		ldy #$18			ldy 	#24
.1508	80 00		bra $150a			bra 	Const1Byte
.150a					Const1Byte:
.150a	a5 06		lda $06				lda 	TOS
.150c	48		pha				pha
.150d	a5 07		lda $07				lda 	TOS+1
.150f	48		pha				pha
.1510	84 06		sty $06				sty 	TOS
.1512	64 07		stz $07				stz 	TOS+1
.1514	4c 00 00	jmp $0000			jmp 	NextCode
.1517					C32:
.1517	a0 20		ldy #$20			ldy 	#32
.1519	80 ef		bra $150a			bra 	Const1Byte
.151b					C63:
.151b	a0 3f		ldy #$3f			ldy 	#63
.151d	80 eb		bra $150a			bra 	Const1Byte
.151f					C64:
.151f	a0 40		ldy #$40			ldy 	#64
.1521	80 e7		bra $150a			bra 	Const1Byte
.1523					C100:
.1523	a0 64		ldy #$64			ldy 	#100
.1525	80 e3		bra $150a			bra 	Const1Byte
.1527					C127:
.1527	a0 7f		ldy #$7f			ldy 	#127
.1529	80 df		bra $150a			bra 	Const1Byte
.152b					C128:
.152b	a0 80		ldy #$80			ldy 	#128
.152d	80 db		bra $150a			bra 	Const1Byte
.152f					C255:
.152f	a0 ff		ldy #$ff			ldy 	#255
.1531	80 d7		bra $150a			bra 	Const1Byte
.1533					Const2Byte:
.1533	85 06		sta $06				sta 	TOS
.1535	84 07		sty $07				sty 	TOS+1
.1537	4c 00 00	jmp $0000			jmp 	NextCode
.153a					C256:
.153a	a5 06		lda $06				lda 	TOS
.153c	48		pha				pha
.153d	a5 07		lda $07				lda 	TOS+1
.153f	48		pha				pha
.1540	a9 00		lda #$00			lda 	#(256) & $FF
.1542	a0 01		ldy #$01			ldy 	#(256) >> 8
.1544	80 ed		bra $1533			bra 	Const2Byte
.1546					C512:
.1546	a5 06		lda $06				lda 	TOS
.1548	48		pha				pha
.1549	a5 07		lda $07				lda 	TOS+1
.154b	48		pha				pha
.154c	a9 00		lda #$00			lda 	#(512) & $FF
.154e	a0 02		ldy #$02			ldy 	#(512) >> 8
.1550	80 e1		bra $1533			bra 	Const2Byte
.1552					C1024:
.1552	a5 06		lda $06				lda 	TOS
.1554	48		pha				pha
.1555	a5 07		lda $07				lda 	TOS+1
.1557	48		pha				pha
.1558	a9 00		lda #$00			lda 	#(1024) & $FF
.155a	a0 04		ldy #$04			ldy 	#(1024) >> 8
.155c	80 d5		bra $1533			bra 	Const2Byte
.155e					C4096:
.155e	a5 06		lda $06				lda 	TOS
.1560	48		pha				pha
.1561	a5 07		lda $07				lda 	TOS+1
.1563	48		pha				pha
.1564	a9 00		lda #$00			lda 	#(4096) & $FF
.1566	a0 10		ldy #$10			ldy 	#(4096) >> 8
.1568	80 c9		bra $1533			bra 	Const2Byte
.156a					C32767:
.156a	a5 06		lda $06				lda 	TOS
.156c	48		pha				pha
.156d	a5 07		lda $07				lda 	TOS+1
.156f	48		pha				pha
.1570	a9 ff		lda #$ff			lda 	#(32767) & $FF
.1572	a0 7f		ldy #$7f			ldy 	#(32767) >> 8
.1574	80 bd		bra $1533			bra 	Const2Byte
.1576					C32768:
.1576	a5 06		lda $06				lda 	TOS
.1578	48		pha				pha
.1579	a5 07		lda $07				lda 	TOS+1
.157b	48		pha				pha
.157c	a9 00		lda #$00			lda 	#(32768) & $FF
.157e	a0 80		ldy #$80			ldy 	#(32768) >> 8
.1580	80 b1		bra $1533			bra 	Const2Byte

;******  Return to file: kernel.asm


;******  Processing file: words/data/stack.src

.1582					Drop:
.1582	68		pla				pla
.1583	85 07		sta $07				sta 	TOS+1
.1585	68		pla				pla
.1586	85 06		sta $06				sta 	TOS
.1588	4c 00 00	jmp $0000			jmp 	NextCode
.158b					TestDup:
.158b	a5 06		lda $06				lda 	TOS
.158d	05 07		ora $07				ora 	TOS+1
.158f	d0 03		bne $1594			bne 	Dup
.1591	4c 00 00	jmp $0000			jmp 	NextCode
.1594					Dup:
.1594	a5 06		lda $06				lda 	TOS
.1596	48		pha				pha
.1597	a5 07		lda $07				lda 	TOS+1
.1599	48		pha				pha
.159a	4c 00 00	jmp $0000			jmp 	NextCode
.159d					Swap:
.159d	86 10		stx $10				stx 	temp1
.159f	7a		ply				ply
.15a0	fa		plx				plx
.15a1	a5 06		lda $06				lda 	TOS
.15a3	48		pha				pha
.15a4	a5 07		lda $07				lda 	TOS+1
.15a6	48		pha				pha
.15a7	86 06		stx $06				stx 	TOS
.15a9	84 07		sty $07				sty 	TOS+1
.15ab	a6 10		ldx $10				ldx 	temp1
.15ad	4c 00 00	jmp $0000			jmp 	NextCode
.15b0					Over:
.15b0	a5 06		lda $06				lda 	TOS
.15b2	48		pha				pha
.15b3	a5 07		lda $07				lda 	TOS+1
.15b5	48		pha				pha
.15b6	86 10		stx $10				stx 	temp1
.15b8	ba		tsx				tsx
.15b9	bd 04 01	lda $0104,x			lda 	stack3low,x
.15bc	85 06		sta $06				sta 	TOS
.15be	bd 03 01	lda $0103,x			lda 	stack3High,x
.15c1	85 07		sta $07				sta 	TOS+1
.15c3	a6 10		ldx $10				ldx 	temp1
.15c5	4c 00 00	jmp $0000			jmp 	NextCode
.15c8					Nip:
.15c8	68		pla				pla
.15c9	68		pla				pla
.15ca	4c 00 00	jmp $0000			jmp 	NextCode
.15cd					Rot:
.15cd	86 10		stx $10				stx 	temp1
.15cf	ba		tsx				tsx
.15d0	bd 04 01	lda $0104,x			lda 	Stack3Low,x
.15d3	a8		tay				tay
.15d4	bd 02 01	lda $0102,x			lda 	Stack2Low,x
.15d7	9d 04 01	sta $0104,x			sta 	Stack3Low,x
.15da	a5 06		lda $06				lda 	TOS
.15dc	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.15df	84 06		sty $06				sty 	TOS
.15e1	bd 03 01	lda $0103,x			lda 	Stack3High,x
.15e4	a8		tay				tay
.15e5	bd 01 01	lda $0101,x			lda 	Stack2High,x
.15e8	9d 03 01	sta $0103,x			sta 	Stack3High,x
.15eb	a5 07		lda $07				lda 	TOS+1
.15ed	9d 01 01	sta $0101,x			sta 	Stack2High,x
.15f0	84 07		sty $07				sty 	TOS+1
.15f2	a6 10		ldx $10				ldx 	temp1
.15f4	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/data/memory.src

.15f7					ByteRead:
.15f7	b2 06		lda ($06)			lda 	(TOS)
.15f9	85 06		sta $06				sta 	TOS
.15fb	64 07		stz $07				stz 	TOS+1
.15fd	4c 00 00	jmp $0000			jmp 	NextCode
.1600					WordRead:
.1600	a0 01		ldy #$01			ldy 	#1
.1602	b1 06		lda ($06),y			lda 	(TOS),y
.1604	a8		tay				tay
.1605	b2 06		lda ($06)			lda 	(TOS)
.1607	85 06		sta $06				sta 	TOS
.1609	84 07		sty $07				sty 	TOS+1
.160b	4c 00 00	jmp $0000			jmp 	NextCode
.160e					ByteWrite:
.160e	68		pla				pla
.160f	68		pla				pla
.1610	92 06		sta ($06)			sta 	(TOS)
.1612	68		pla				pla
.1613	85 07		sta $07				sta 	TOS+1
.1615	68		pla				pla
.1616	85 06		sta $06				sta 	TOS
.1618	4c 00 00	jmp $0000			jmp 	NextCode
.161b					WordWrite:
.161b	68		pla				pla
.161c	a0 01		ldy #$01			ldy 	#1
.161e	91 06		sta ($06),y			sta 	(TOS),y
.1620	68		pla				pla
.1621	92 06		sta ($06)			sta 	(TOS)
.1623	68		pla				pla
.1624	85 07		sta $07				sta 	TOS+1
.1626	68		pla				pla
.1627	85 06		sta $06				sta 	TOS
.1629	4c 00 00	jmp $0000			jmp 	NextCode
.162c					WordAdd:
.162c	7a		ply				ply
.162d	68		pla				pla
.162e	18		clc				clc
.162f	72 06		adc ($06)			adc 	(TOS)
.1631	92 06		sta ($06)			sta 	(TOS)
.1633	98		tya				tya
.1634	a0 01		ldy #$01			ldy 	#1
.1636	71 06		adc ($06),y			adc 	(TOS),y
.1638	91 06		sta ($06),y			sta 	(TOS),y
.163a	68		pla				pla
.163b	85 07		sta $07				sta 	TOS+1
.163d	68		pla				pla
.163e	85 06		sta $06				sta 	TOS
.1640	4c 00 00	jmp $0000			jmp 	NextCode
.1643					AllocateMemory:
.1643	a5 06		lda $06				lda 	TOS 						; save memory required on stack.
.1645	48		pha				pha
.1646	a5 07		lda $07				lda 	TOS+1
.1648	48		pha				pha
.1649	a5 0e		lda $0e				lda 	nextFreeMem 				; copy free mem address to TOS
.164b	85 06		sta $06				sta 	TOS
.164d	a5 0f		lda $0f				lda 	nextFreeMem+1
.164f	85 07		sta $07				sta 	TOS+1
.1651	7a		ply				ply 								; advance the free ram pointer
.1652	68		pla				pla
.1653	20 ba 1b	jsr $1bba			jsr 	AdvanceFreeMem
.1656	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/encode/encode.src

.1659					EncodeProgram:
.1659	48		pha				pha 								; save registers.
.165a	da		phx				phx
.165b	5a		phy				phy
.165c	84 09		sty $09				sty 	srcPtr+1					; save source pointer.
.165e	85 08		sta $08				sta		srcPtr
.1660	20 85 18	jsr $1885			jsr 	EncodeTrimTrailingSpaces 	; remove trailing spaces.
.1663	a9 03		lda #$03			lda 	#3 							; reset the encode Buffer
.1665	8d 10 09	sta $0910			sta 	encodeBuffer 				; this is also the write ptr/offset
.1668	9c 11 09	stz $0911			stz 	encodeBuffer+1 				; the line number
.166b	9c 12 09	stz $0912			stz 	encodeBuffer+2 				; which is initially zero.
.166e	b2 08		lda ($08)			lda 	(srcPtr) 					; check if first character is digit
.1670	20 30 18	jsr $1830			jsr 	CheckIsDigit
.1673	90 09		bcc $167e			bcc 	_EPNoLineNumber 			; if so there is a line number
.1675	20 52 18	jsr $1852			jsr 	EncodeGetConstant 			; extract that constant from the source
.1678	8d 11 09	sta $0911			sta 	encodeBuffer+1 				; that is the line number
.167b	8c 12 09	sty $0912			sty 	encodeBuffer+2
.167e					_EPNoLineNumber:
.167e					EncodeLoop:
.167e	20 77 18	jsr $1877			jsr 	EncSkipSpaces 				; skip over spaces
.1681	b2 08		lda ($08)			lda 	(srcPtr) 					; reached end ?
.1683	d0 0b		bne $1690			bne 	_EPNotEnd
.1685					_EPEndEncode:
.1685	a9 e6		lda #$e6			lda 	#NextLine & $FF 			; compile $$nextline to mark eol
.1687	a0 1e		ldy #$1e			ldy 	#NextLine >> 8
.1689	20 08 18	jsr $1808			jsr 	EncodeWriteWord
.168c	7a		ply				ply									; restore and exit.
.168d	fa		plx				plx
.168e	68		pla				pla
.168f	60		rts				rts
.1690					_EPNotEnd:
.1690	b2 08		lda ($08)			lda 	(srcPtr)
.1692	c9 22		cmp #$22			cmp 	#'"'						; is it a quoted string or comment ?
.1694	f0 04		beq $169a			beq 	_EPIsComStr
.1696	c9 27		cmp #$27			cmp 	#"'"
.1698	d0 05		bne $169f			bne 	_EPNotComStr
.169a					_EPIsComStr:
.169a	20 5f 17	jsr $175f			jsr 	EncodeCommentString
.169d	80 df		bra $167e			bra 	EncodeLoop
.169f					_EPNotComStr:
.169f	38		sec				sec
.16a0	20 64 18	jsr $1864			jsr 	EncSetBit7Word
.16a3	20 9e 18	jsr $189e			jsr 	EncodeSearchDictionary		; look it up
.16a6	90 44		bcc $16ec			bcc 	_EPNotInDictionary
.16a8	85 10		sta $10				sta 	temp1 						; save dictionary record address
.16aa	84 11		sty $11				sty 	temp1+1
.16ac	a0 01		ldy #$01			ldy 	#1
.16ae	b1 10		lda ($10),y			lda 	(temp1),y 					; check if has an encode bit
.16b0	29 20		and #$20			and 	#$20
.16b2	d0 12		bne $16c6			bne 	_EPEncodeRoutine 			; if so, do special routine.
.16b4	a0 02		ldy #$02			ldy 	#2 							; write out the routine address
.16b6	b1 10		lda ($10),y			lda 	(temp1),y
.16b8	20 12 18	jsr $1812			jsr 	EncodeWriteByte
.16bb	c8		iny				iny
.16bc	b1 10		lda ($10),y			lda 	(temp1),y
.16be	20 12 18	jsr $1812			jsr 	EncodeWriteByte
.16c1	20 3c 18	jsr $183c			jsr 	EncodeMoveNextWord 			; advance to the next and loop
.16c4	80 b8		bra $167e			bra 	EncodeLoop
.16c6					_EPEncodeRoutine:
.16c6	a0 01		ldy #$01			ldy 	#1							; get type bit
.16c8	b1 10		lda ($10),y			lda 	(temp1),y
.16ca	a0 04		ldy #$04			ldy 	#4							; encoder here if no decoder
.16cc	29 10		and #$10			and 	#$10 						; but decoder comes first
.16ce	f0 02		beq $16d2			beq 	_EPENoDecoder
.16d0	c8		iny				iny 								; so if it exists, adjust for it.
.16d1	c8		iny				iny
.16d2					_EPENoDecoder:
.16d2	b1 10		lda ($10),y			lda 	(temp1),y 					; copy exec addr to temp2
.16d4	85 12		sta $12				sta 	temp2
.16d6	c8		iny				iny
.16d7	b1 10		lda ($10),y			lda 	(temp1),y
.16d9	85 13		sta $13				sta 	temp2+1
.16db	48		pha				pha 								; call routine preserving state
.16dc	da		phx				phx
.16dd	5a		phy				phy
.16de	20 e9 16	jsr $16e9			jsr 	_EPECallTemp2
.16e1	7a		ply				ply
.16e2	fa		plx				plx
.16e3	68		pla				pla
.16e4	20 3c 18	jsr $183c			jsr 	EncodeMoveNextWord 			; advance to the next and loop
.16e7	80 95		bra $167e			bra 	EncodeLoop
.16e9					_EPECallTemp2:
.16e9	6c 12 00	jmp ($0012)			jmp 	(temp2)
.16ec					_EPNotInDictionary:
.16ec	20 ba 17	jsr $17ba			jsr 	EncodeSearchUserDefined 	; are there any user defined routines
.16ef	90 19		bcc $170a			bcc 	_EPNotDefined
.16f1	48		pha				pha
.16f2	a9 3a		lda #$3a			lda	 	#CallHandler & $FF 			; write code call handler
.16f4	20 12 18	jsr $1812			jsr 	EncodeWriteByte
.16f7	a9 1a		lda #$1a			lda	 	#CallHandler >> 8
.16f9	20 12 18	jsr $1812			jsr 	EncodeWriteByte
.16fc	68		pla				pla 								; write line number
.16fd	20 12 18	jsr $1812			jsr 	EncodeWriteByte
.1700	98		tya				tya
.1701	20 12 18	jsr $1812			jsr 	EncodeWriteByte
.1704	20 3c 18	jsr $183c			jsr 	EncodeMoveNextWord 			; advance to the next and loop
.1707	4c 7e 16	jmp $167e			jmp 	EncodeLoop
.170a					_EPNotDefined:
.170a	b2 08		lda ($08)			lda 	(srcPtr) 					; first character
.170c	c9 3c		cmp #$3c			cmp 	#"<"						; is it <line> which is call syntax
.170e	f0 29		beq $1739			beq 	_EPCallDirect
.1710	c9 21		cmp #$21			cmp 	#"!"						; check for variable operators
.1712	f0 42		beq $1756			beq 	_EPVariable
.1714	c9 40		cmp #$40			cmp 	#"@"
.1716	f0 3e		beq $1756			beq 	_EPVariable
.1718	c9 26		cmp #$26			cmp 	#"&"
.171a	f0 3a		beq $1756			beq 	_EPVariable
.171c	a9 a5		lda #$a5			lda 	#Literal2Byte & $FF 		; write out 2 byte literal
.171e	a0 10		ldy #$10			ldy 	#Literal2Byte >> 8
.1720	20 08 18	jsr $1808			jsr 	EncodeWriteWord
.1723					_EPOutputConstant:
.1723	20 52 18	jsr $1852			jsr 	EncodeGetConstant 			; extract that constant from the source
.1726	90 06		bcc $172e			bcc 	_EPFail 					; if can't find one, that's us done.
.1728	20 08 18	jsr $1808			jsr 	EncodeWriteWord 			; write out the encoded value.
.172b	4c 7e 16	jmp $167e			jmp 	EncodeLoop 					; and go round again.
.172e					_EPFail:
.172e	20 3f 10	jsr $103f			jsr 	ErrorHandler
>1731	53 59 4e 54 41 58 3f 00				.text 	"SYNTAX?",0
.1739					_EPCallDirect:
.1739	a9 3a		lda #$3a			lda	 	#CallHandler & $FF 			; write code call handler
.173b	a0 1a		ldy #$1a			ldy	 	#CallHandler >> 8
.173d	20 08 18	jsr $1808			jsr 	EncodeWriteWord
.1740	a9 01		lda #$01			lda 	#1
.1742	20 48 18	jsr $1848			jsr 	EncodeAddSrcPtr 			; skip over the <
.1745	a0 ff		ldy #$ff			ldy 	#255 						; scan forward for last character.
.1747					_EPToLast:
.1747	c8		iny				iny
.1748	b1 08		lda ($08),y			lda 	(srcPtr),y
.174a	10 fb		bpl $1747			bpl	 	_EPToLast
.174c	c9 be		cmp #$be			cmp 	#">"+$80 					; must be >
.174e	d0 de		bne $172e			bne 	_EPFail
.1750	a9 20		lda #$20			lda 	#" " 						; strip back to a number, erases last char
.1752	91 08		sta ($08),y			sta 	(srcPtr),y
.1754	80 cd		bra $1723			bra 	_EPOutputConstant 			; borrow the number routines extract/compile constant
.1756					_EPVariable:
.1756	20 f2 18	jsr $18f2			jsr 	EncodeVariableReference
.1759	20 3c 18	jsr $183c			jsr 	EncodeMoveNextWord 			; advance to the next and loop
.175c	4c 7e 16	jmp $167e			jmp 	EncodeLoop

;******  Return to file: kernel.asm


;******  Processing file: words/encode/comstr.src

.175f					EncodeCommentString:
.175f	b2 08		lda ($08)			lda 	(srcPtr) 					; get first character
.1761	64 10		stz $10				stz 	temp1 						; other terminator = EOL
.1763	aa		tax				tax 								; save in X
.1764	a9 fd		lda #$fd			lda 	#(SkipComment & $FF)		; get the routine to use
.1766	a0 1e		ldy #$1e			ldy 	#(SkipComment >> 8)
.1768	e0 27		cpx #$27			cpx 	#"'"
.176a	f0 06		beq $1772			beq 	_ECSGotCmd
.176c	86 10		stx $10				stx		temp1 						; other terminator = "
.176e	a9 cd		lda #$cd			lda 	#(LiteralString & $FF)
.1770	a0 10		ldy #$10			ldy 	#(LiteralString >> 8)
.1772					_ECSGotCmd:
.1772	20 08 18	jsr $1808			jsr 	EncodeWriteWord 			; write word out.
.1775	a9 01		lda #$01			lda 	#1 							; skip over ' or "
.1777	20 48 18	jsr $1848			jsr 	EncodeAddSrcPtr
.177a	e0 27		cpx #$27			cpx 	#"'"						; if ' then skip spaces
.177c	d0 03		bne $1781			bne 	_ECNoSkipSpaces
.177e	20 77 18	jsr $1877			jsr 	EncSkipSpaces
.1781					_ECNoSkipSpaces:
.1781	ae 10 09	ldx $0910			ldx 	encodeBuffer 				; keep offset to buffer in X.
.1784	a9 01		lda #$01			lda 	#1
.1786	20 12 18	jsr $1812			jsr 	EncodeWriteByte 			; write total length, so far 1.
.1789	a0 00		ldy #$00			ldy 	#0 							; for reading the actual text
.178b					_ECSCopyText:
.178b	b1 08		lda ($08),y			lda 	(srcPtr),y 					; get next
.178d	f0 18		beq $17a7			beq 	_ECSEndOfLine 				; end of line ?
.178f	c5 10		cmp $10				cmp 	temp1						; is it the other terminator
.1791	f0 09		beq $179c			beq 	_ECSEndOfString 			; if so must be closing quote.
.1793	20 12 18	jsr $1812			jsr 	EncodeWriteByte 			; write the byte out
.1796	fe 10 09	inc $0910,x			inc 	encodeBuffer,x				; increase length
.1799	c8		iny				iny 								; next character
.179a	80 ef		bra $178b			bra 	_ECSCopyText
.179c					_ECSEndOfString:
.179c	c8		iny				iny 								; skip closing quote.
.179d	a9 00		lda #$00			lda 	#0 							; write out ASCIIZ
.179f	20 12 18	jsr $1812			jsr 	EncodeWriteByte
.17a2	fe 10 09	inc $0910,x			inc 	encodeBuffer,x 				; fix the length up.
.17a5	80 0e		bra $17b5			bra 	_ECSComplete 				; and just patching up srcPtr to do.
.17a7					_ECSEndOfLine:
.17a7	a5 10		lda $10				lda 	temp1 						; missing closing quote
.17a9	f0 0a		beq $17b5			beq 	_ECSComplete 				; if we were doing a string.
.17ab	20 3f 10	jsr $103f			jsr 	ErrorHandler
>17ae	51 55 4f 54 45 3f 00				.text 	"QUOTE?",0
.17b5					_ECSComplete:
.17b5	98		tya				tya									; skip over.
.17b6	20 48 18	jsr $1848			jsr 	EncodeAddSrcPtr
.17b9	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/encode/encdef.src

.17ba					EncodeSearchUserDefined:
.17ba	38		sec				sec 								; temp1 = srcPtr-6 because the
.17bb	a5 08		lda $08				lda 	srcPtr				 		; name is 6 in (offset line# $$call len)
.17bd	e9 06		sbc #$06			sbc		#6
.17bf	85 10		sta $10				sta 	temp1
.17c1	a5 09		lda $09				lda 	srcPtr+1
.17c3	e9 00		sbc #$00			sbc 	#0
.17c5	85 11		sta $11				sta 	temp1+1
.17c7	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.17c9	85 12		sta $12				sta 	0+(temp2)
.17cb	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.17cd	85 13		sta $13				sta 	1+(temp2)
.17cf					_ESULoop:
.17cf	b2 12		lda ($12)			lda 	(temp2) 					; reached the end (offset 0)
.17d1	f0 33		beq $1806			beq 	_ESUFail
.17d3	a0 03		ldy #$03			ldy 	#3 							; check it is $$define
.17d5	b1 12		lda ($12),y			lda 	(temp2),y
.17d7	c9 22		cmp #$22			cmp 	#DefineCode & $FF
.17d9	d0 1e		bne $17f9			bne 	_ESUNext
.17db	c8		iny				iny
.17dc	b1 12		lda ($12),y			lda 	(temp2),y
.17de	c9 1f		cmp #$1f			cmp 	#DefineCode >> 8
.17e0	d0 17		bne $17f9			bne 	_ESUNext
.17e2	c8		iny				iny 								; skip length byte.
.17e3					_ESUCompare:
.17e3	c8		iny				iny
.17e4	b1 12		lda ($12),y			lda 	(temp2),y
.17e6	d1 10		cmp ($10),y			cmp 	(temp1),y
.17e8	d0 0f		bne $17f9			bne 	_ESUNext
.17ea	0a		asl a				asl 	a 							; bit 7 set => found it.
.17eb	90 f6		bcc $17e3			bcc 	_ESUCompare
.17ed	a0 01		ldy #$01			ldy 	#1
.17ef	b1 12		lda ($12),y			lda 	(temp2),y 					; read in the line number to YA
.17f1	aa		tax				tax
.17f2	c8		iny				iny
.17f3	b1 12		lda ($12),y			lda 	(temp2),y
.17f5	a8		tay				tay
.17f6	8a		txa				txa
.17f7	38		sec				sec 								; return with carry set as found
.17f8	60		rts				rts
.17f9					_ESUNext:
.17f9	18		clc				clc
.17fa	a5 12		lda $12				lda 	temp2
.17fc	72 12		adc ($12)			adc 	(temp2)
.17fe	85 12		sta $12				sta 	temp2
.1800	90 02		bcc $1804			bcc 	_NoCarryAdv
.1802	e6 13		inc $13				inc 	temp2+1
.1804					_NoCarryAdv:
.1804	80 c9		bra $17cf			bra 	_ESULoop 					; and loop round
.1806					_ESUFail:
.1806	18		clc				clc
.1807	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/encode/encutils.src

.1808					EncodeWriteWord:
.1808	48		pha				pha
.1809	20 12 18	jsr $1812			jsr 	EncodeWriteByte
.180c	98		tya				tya
.180d	20 12 18	jsr $1812			jsr 	EncodeWriteByte
.1810	68		pla				pla
.1811	60		rts				rts
.1812					EncodeWriteByte:
.1812	da		phx				phx
.1813	ae 10 09	ldx $0910			ldx 	encodeBuffer
.1816	9d 10 09	sta $0910,x			sta 	encodeBuffer,x
.1819	9e 11 09	stz $0911,x			stz 	encodeBuffer+1,x
.181c	9e 12 09	stz $0912,x			stz 	encodeBuffer+2,x
.181f	ee 10 09	inc $0910			inc 	encodeBuffer
.1822	fa		plx				plx
.1823	60		rts				rts
.1824					CheckIsLetter:
.1824	c9 41		cmp #$41			cmp 	#"A"						; return CS if A..Z
.1826	90 06		bcc $182e			bcc 	_CILFail
.1828	c9 5b		cmp #$5b			cmp 	#"Z"+1
.182a	b0 02		bcs $182e			bcs 	_CILFail
.182c	38		sec				sec
.182d	60		rts				rts
.182e					_CILFail:
.182e	18		clc				clc
.182f	60		rts				rts
.1830					CheckIsDigit:
.1830	c9 30		cmp #$30			cmp 	#"0"						; return CS if 0..9
.1832	90 06		bcc $183a			bcc 	_CIDFail
.1834	c9 3a		cmp #$3a			cmp 	#"9"+1
.1836	b0 02		bcs $183a			bcs 	_CIDFail
.1838	38		sec				sec
.1839	60		rts				rts
.183a					_CIDFail:
.183a	18		clc				clc
.183b	60		rts				rts
.183c					EncodeMoveNextWord:
.183c	a0 ff		ldy #$ff			ldy 	#255 						; search forward
.183e					_EPNWLoop:
.183e	c8		iny				iny
.183f	b1 08		lda ($08),y			lda 	(srcPtr),y
.1841	c9 21		cmp #$21			cmp 	#" "+1						; looking for <= space
.1843	b0 f9		bcs $183e			bcs 	_EPNWLoop
.1845	98		tya				tya
.1846	80 00		bra $1848			bra 	EncodeAddSrcPtr
.1848					EncodeAddSrcPtr:
.1848	18		clc				clc 								; add offset
.1849	65 08		adc $08				adc 	srcPtr
.184b	85 08		sta $08				sta 	srcPtr
.184d	90 02		bcc $1851			bcc 	_EASPNoCarry
.184f	e6 09		inc $09				inc 	srcPtr+1					; carry through
.1851					_EASPNoCarry:
.1851	60		rts				rts
.1852					EncodeGetConstant:
.1852	a5 08		lda $08				lda 	srcPtr 						; get source
.1854	a4 09		ldy $09				ldy 	srcPtr+1
.1856	20 58 1e	jsr $1e58			jsr 	ConvertToInteger 			; call converter
.1859	90 08		bcc $1863			bcc 	_EGCExit
.185b	20 48 18	jsr $1848			jsr 	EncodeAddSrcPtr 			; if passed add chars to src ptr
.185e	a5 14		lda $14				lda 	temp3 						; get result into YA
.1860	a4 15		ldy $15				ldy 	temp3+1
.1862	38		sec				sec 								; return CS
.1863					_EGCExit:
.1863	60		rts				rts
.1864					EncSetBit7Word:
.1864	08		php				php 								; save carry
.1865	a0 ff		ldy #$ff			ldy 	#255 						; scan forward for space/NULL
.1867					_ESB7Loop:
.1867	c8		iny				iny
.1868	b1 08		lda ($08),y			lda 	(srcPtr),y
.186a	c9 21		cmp #$21			cmp 	#" "+1 						; while > ' '
.186c	b0 f9		bcs $1867			bcs 	_ESB7Loop
.186e	88		dey				dey									; previous character
.186f	b1 08		lda ($08),y			lda 	(srcPtr),y 					; read it
.1871	0a		asl a				asl 	a 							; shift bit 7 out
.1872	28		plp				plp 								; restore carry
.1873	6a		ror a				ror 	a 							; shift it in
.1874	91 08		sta ($08),y			sta 	(srcPtr),y 					; write back and exit
.1876	60		rts				rts
.1877					EncSkipSpaces:
.1877	b2 08		lda ($08)			lda 	(srcPtr) 					; skip over spaces/ reached end
.1879	c9 20		cmp #$20			cmp 	#32
.187b	d0 07		bne $1884			bne 	_ESNotSpace
.187d	a9 01		lda #$01			lda 	#1
.187f	20 48 18	jsr $1848			jsr 	EncodeAddSrcPtr
.1882	80 f3		bra $1877			bra	 	EncSkipSpaces
.1884					_ESNotSpace:
.1884	60		rts				rts
.1885					EncodeTrimTrailingSpaces:
.1885	a0 ff		ldy #$ff			ldy 	#255 						; find EOS
.1887					_ETTFindEnd:
.1887	c8		iny				iny
.1888	b1 08		lda ($08),y			lda 	(srcPtr),y
.188a	d0 fb		bne $1887			bne 	_ETTFindEnd
.188c					_ETTRemoveSpace:
.188c	c0 00		cpy #$00			cpy 	#0 							; start of string
.188e	f0 0d		beq $189d			beq 	_ETTExit
.1890	88		dey				dey 								; previous character 1..32
.1891	b1 08		lda ($08),y			lda 	(srcPtr),y
.1893	c9 21		cmp #$21			cmp 	#32+1
.1895	b0 06		bcs $189d			bcs 	_ETTExit
.1897	a9 00		lda #$00			lda 	#0 							; erase it and go round again
.1899	91 08		sta ($08),y			sta 	(srcPtr),y
.189b	80 ef		bra $188c			bra 	_ETTRemoveSpace
.189d					_ETTExit:
.189d	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/encode/encsearch.src

.189e					EncodeSearchDictionary:
.189e	a9 42		lda #$42			lda 	#(Dictionary) & $FF
.18a0	85 10		sta $10				sta 	0+(temp1)
.18a2	a9 21		lda #$21			lda 	#(Dictionary) >> 8
.18a4	85 11		sta $11				sta 	1+(temp1)
.18a6					_ESDLoop:
.18a6	b2 10		lda ($10)			lda 	(temp1) 					; end of dictionary return with CC.
.18a8	18		clc				clc
.18a9	f0 46		beq $18f1			beq 	_ESDExit
.18ab	a0 01		ldy #$01			ldy 	#1 							; get control bits, get offset to name.
.18ad	b1 10		lda ($10),y			lda 	(temp1),y
.18af	4a		lsr a				lsr 	a 							; encode/decode bits move to 0,1
.18b0	4a		lsr a				lsr 	a
.18b1	4a		lsr a				lsr 	a
.18b2	4a		lsr a				lsr 	a
.18b3	c8		iny				iny 								; Y = 2
.18b4	4a		lsr a				lsr 	a
.18b5	90 01		bcc $18b8			bcc 	_ESDNotDec
.18b7	c8		iny				iny
.18b8					_ESDNotDec:
.18b8	4a		lsr a				lsr 	a
.18b9	90 01		bcc $18bc			bcc 	_ESDNotInc
.18bb	c8		iny				iny
.18bc					_ESDNotInc:
.18bc	98		tya				tya
.18bd	0a		asl a				asl 	a 							; A is now 4,6,8 offset to name.
.18be	a8		tay				tay
.18bf	b1 10		lda ($10),y			lda 	(temp1),y 					; quick check of first character
.18c1	d2 08		cmp ($08)			cmp 	(srcPtr)
.18c3	d0 1f		bne $18e4			bne 	_ESDNext 					; do not match, go to next
.18c5	98		tya				tya 								; make temp2 point to the name in
.18c6	18		clc				clc 								; the dictionary.
.18c7	65 10		adc $10				adc 	temp1
.18c9	85 12		sta $12				sta 	temp2
.18cb	a5 11		lda $11				lda 	temp1+1
.18cd	69 00		adc #$00			adc 	#0
.18cf	85 13		sta $13				sta 	temp2+1
.18d1	a0 ff		ldy #$ff			ldy 	#255 						; now start matching up.
.18d3					_ESDCompare:
.18d3	c8		iny				iny
.18d4	b1 08		lda ($08),y			lda 	(srcPtr),y
.18d6	d1 12		cmp ($12),y			cmp 	(temp2),y
.18d8	d0 0a		bne $18e4			bne 	_ESDNext
.18da	0a		asl a				asl 	a
.18db	90 f6		bcc $18d3			bcc 	_ESDCompare
.18dd	a5 10		lda $10				lda 	temp1 						; return address in YA and carry set.
.18df	a4 11		ldy $11				ldy 	temp1+1
.18e1	38		sec				sec
.18e2	80 0d		bra $18f1			bra 	_ESDExit
.18e4					_ESDNext:
.18e4	18		clc				clc
.18e5	a5 10		lda $10				lda 	temp1
.18e7	72 10		adc ($10)			adc 	(temp1)
.18e9	85 10		sta $10				sta 	temp1
.18eb	90 b9		bcc $18a6			bcc 	_ESDLoop
.18ed	e6 11		inc $11				inc 	temp1+1
.18ef	80 b5		bra $18a6			bra 	_ESDLoop
.18f1					_ESDExit:
.18f1	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/encode/encvar.src

.18f2					EncodeVariableReference:
.18f2	b2 08		lda ($08)			lda 	(srcPtr)					; get the type, use it to identify the routine
.18f4	a2 ef		ldx #$ef			ldx 	#VarAddressHandler & $FF
.18f6	a0 1f		ldy #$1f			ldy 	#VarAddressHandler >> 8
.18f8	c9 26		cmp #$26			cmp 	#"&"
.18fa	f0 0c		beq $1908			beq 	_EVFHaveAddress
.18fc	a2 09		ldx #$09			ldx 	#VarReadHandler & $FF
.18fe	a0 20		ldy #$20			ldy 	#VarReadHandler >> 8
.1900	c9 40		cmp #$40			cmp 	#"@"
.1902	f0 04		beq $1908			beq 	_EVFHaveAddress
.1904	a2 25		ldx #$25			ldx 	#VarWriteHandler & $FF
.1906	a0 20		ldy #$20			ldy 	#VarWriteHandler >> 8
.1908					_EVFHaveAddress:
.1908	8a		txa				txa
.1909	20 08 18	jsr $1808			jsr 	EncodeWriteWord 			; write it out.
.190c	a0 01		ldy #$01			ldy 	#1 							; get the first charactere
.190e	b1 08		lda ($08),y			lda 	(srcPtr),y
.1910	29 7f		and #$7f			and 	#$7F 						; might be the last.
.1912	20 24 18	jsr $1824			jsr 	CheckIsLetter 				; is it A-Z
.1915	90 1a		bcc $1931			bcc 	EVFFail
.1917	29 1f		and #$1f			and 	#31 						; make 1-26
.1919	85 10		sta $10				sta 	temp1 						; start building the name in temp1
.191b	64 11		stz $11				stz 	temp1+1
.191d	38		sec				sec 								; possible char 2
.191e	20 3e 19	jsr $193e			jsr 	EncVarAlNum
.1921	18		clc				clc 								; possible char 3
.1922	20 3e 19	jsr $193e			jsr 	EncVarAlNum
.1925	b1 08		lda ($08),y			lda 	(srcPtr),y 					; more text after ?
.1927	10 08		bpl $1931			bpl 	EVFFail
.1929	a5 10		lda $10				lda 	temp1 						; write out variable identifier.
.192b	a4 11		ldy $11				ldy 	temp1+1
.192d	20 08 18	jsr $1808			jsr 	EncodeWriteWord
.1930	60		rts				rts
.1931					EVFFail:
.1931	20 3f 10	jsr $103f			jsr 	ErrorHandler
>1934	56 41 52 49 41 42 4c 45				.text 	"VARIABLE?",0
>193c	3f 00
.193e					EncVarAlNum:
.193e	b1 08		lda ($08),y			lda 	(srcPtr),y 					; points to the  last char processed.
.1940	10 01		bpl $1943			bpl 	_EVAContinue
.1942	60		rts				rts
.1943					_EVAContinue:
.1943	08		php				php 								; CS x 32 ; CC x 32 x 40
.1944	c8		iny				iny 								; get the next character, strip bit 7
.1945	b1 08		lda ($08),y			lda 	(srcPtr),y
.1947	29 7f		and #$7f			and 	#$7F
.1949	20 24 18	jsr $1824			jsr 	CheckIsLetter 				; letter ?
.194c	b0 08		bcs $1956			bcs 	_EVACharOkay
.194e	20 30 18	jsr $1830			jsr 	CheckIsDigit				; fail if not digit.
.1951	90 de		bcc $1931			bcc 	EVFFail
.1953	18		clc				clc
.1954	69 2b		adc #$2b			adc 	#"Z"+1-"0"					; shift 0 so after Z
.1956					_EVACharOkay:
.1956	38		sec				sec 								; range 1-36
.1957	e9 40		sbc #$40			sbc 	#64
.1959	28		plp				plp 								; which multiplier ?
.195a	90 0f		bcc $196b			bcc 	_EVATimes32x40
.195c	85 12		sta $12				sta 	temp2 						; save in temp2 - A x 32
.195e	64 13		stz $13				stz 	temp2+1
.1960	a2 05		ldx #$05			ldx 	#5
.1962	06 12		asl $12		_EVA32:	asl 	temp2
.1964	26 13		rol $13				rol 	temp2+1
.1966	ca		dex				dex
.1967	d0 f9		bne $1962			bne 	_EVA32
.1969	80 0b		bra $1976			bra 	_EVAAddVar
.196b					_EVATimes32x40:
.196b	85 13		sta $13				sta 	temp2+1						; 32 x 40 = 1280 or $500, so temp2 = A x 256 x 5
.196d	64 12		stz $12				stz 	temp2
.196f	0a		asl a				asl 	a
.1970	0a		asl a				asl 	a
.1971	18		clc				clc
.1972	65 13		adc $13				adc 	temp2+1
.1974	85 13		sta $13				sta 	temp2+1
.1976					_EVAAddVar:
.1976	18		clc				clc
.1977	a5 10		lda $10				lda 	temp1
.1979	65 12		adc $12				adc 	temp2
.197b	85 10		sta $10				sta 	temp1
.197d	a5 11		lda $11				lda 	temp1+1
.197f	65 13		adc $13				adc 	temp2+1
.1981	85 11		sta $11				sta 	temp1+1
.1983	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/structures/fornext.src

.1984					ForHandler:
.1984	e6 05		inc $05				inc 	rsp 						; bump the RSP
.1986	a4 05		ldy $05				ldy 	rsp 						; get return stack and push TOS/$FF on it.
.1988	c0 40		cpy #$40			cpy 	#$40 						; overflow
.198a	f0 18		beq $19a4			beq 	_FHOverflow
.198c	a5 07		lda $07				lda 	TOS+1
.198e	99 40 07	sta $0740,y			sta 	returnStackHigh,y
.1991	a5 06		lda $06				lda 	TOS
.1993	99 00 07	sta $0700,y			sta 	returnStackLow,y
.1996	a9 ff		lda #$ff			lda 	#$FF
.1998	99 80 07	sta $0780,y			sta 	returnStackX,y
.199b	68		pla				pla
.199c	85 07		sta $07				sta 	TOS+1
.199e	68		pla				pla
.199f	85 06		sta $06				sta 	TOS
.19a1	4c 00 00	jmp $0000			jmp 	NextCode
.19a4					_FHOverflow:
.19a4	20 3f 10	jsr $103f			jsr 	ErrorHandler
>19a7	46 4f 52 20 53 54 41 43				.text 	"FOR STACK?",0
>19af	4b 3f 00
.19b2					NextHandler:
.19b2	da		phx				phx
.19b3	a6 05		ldx $05				ldx 	rsp 						; get current stack ptr
.19b5	bd 80 07	lda $0780,x			lda 	returnStackX,x 				; check it's a FOR Loop
.19b8	c9 ff		cmp #$ff			cmp 	#$FF
.19ba	d0 21		bne $19dd			bne 	NHNoFor
.19bc	bd 00 07	lda $0700,x			lda 	returnStackLow,x 			; decrement the count
.19bf	d0 03		bne $19c4			bne 	_NHNoBorrow
.19c1	de 40 07	dec $0740,x			dec 	returnStackHigh,x
.19c4					_NHNoBorrow:
.19c4	de 00 07	dec $0700,x			dec 	returnStackLow,x
.19c7	bd 00 07	lda $0700,x			lda 	returnStackLow,x 			; have we reached the end ?
.19ca	1d 40 07	ora $0740,x			ora 	returnStackHigh,x
.19cd	fa		plx				plx 								; restore X and re-test
.19ce	09 00		ora #$00			ora 	#0
.19d0	f0 05		beq $19d7			beq 	_NHComplete 				; if so then complete, else loop.
.19d2	e8		inx				inx 								; advance to branch
.19d3	e8		inx				inx
.19d4	4c 30 1a	jmp $1a30			jmp 	BranchAlways
.19d7					_NHComplete:
.19d7	e8		inx				inx 								; skip over the branch quantity
.19d8	c6 05		dec $05				dec 	rsp 						; drop the indx
.19da	4c 00 00	jmp $0000			jmp 	NextCode
.19dd					NHNoFor:
.19dd	20 3f 10	jsr $103f			jsr 	ErrorHandler
>19e0	4e 4f 20 46 4f 52 3f 00				.text 	"NO FOR?",0
.19e8					GetIndex:
.19e8	a4 05		ldy $05				ldy 	rsp 						; get current stack ptr
.19ea	b9 80 07	lda $0780,y			lda 	returnStackX,y 				; check it's a FOR Loop
.19ed	c9 ff		cmp #$ff			cmp 	#$FF
.19ef	d0 ec		bne $19dd			bne 	NHNoFor
.19f1	a5 06		lda $06				lda 	TOS
.19f3	48		pha				pha
.19f4	a5 07		lda $07				lda 	TOS+1
.19f6	48		pha				pha
.19f7	b9 00 07	lda $0700,y			lda 	returnStackLow,y 			; put counter-1 out
.19fa	38		sec				sec
.19fb	e9 01		sbc #$01			sbc 	#1
.19fd	85 06		sta $06				sta 	TOS
.19ff	b9 40 07	lda $0740,y			lda 	returnStackHigh,y
.1a02	e9 00		sbc #$00			sbc 	#0
.1a04	85 07		sta $07				sta 	TOS+1
.1a06	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/structures/ifelseendif.src

.1a09					IfHandler:
.1a09	4c 18 1a	jmp $1a18			jmp 	BranchIfZero
.1a0c					ElseHandler:
.1a0c	4c 2e 1a	jmp $1a2e			jmp 	BranchTestSucceedsNoPop
.1a0f					EndIfHandler:
.1a0f	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/structures/repeatuntil.src

.1a12					RepeatHandler:
.1a12	4c 00 00	jmp $0000			jmp 	NextCode
.1a15					UntilHandler:
.1a15	4c 18 1a	jmp $1a18			jmp 	BranchIfZero

;******  Return to file: kernel.asm


;******  Processing file: words/system/branch.src

.1a18					BranchIfZero:
.1a18	a5 06		lda $06				lda 	TOS 						; check TOS = 0
.1a1a	05 07		ora $07				ora 	TOS+1
.1a1c	f0 0a		beq $1a28			beq 	BranchTestSucceeds
.1a1e					BranchTestFails:
.1a1e	68		pla				pla
.1a1f	85 07		sta $07				sta 	TOS+1
.1a21	68		pla				pla
.1a22	85 06		sta $06				sta 	TOS
.1a24	e8		inx				inx 								; skip over the relative branch.
.1a25	4c 00 00	jmp $0000			jmp 	NextCode
.1a28					BranchTestSucceeds:
.1a28	68		pla				pla
.1a29	85 07		sta $07				sta 	TOS+1
.1a2b	68		pla				pla
.1a2c	85 06		sta $06				sta 	TOS
.1a2e					BranchTestSucceedsNoPop:
.1a2e	e8		inx				inx 								; advance by two, to the offset
.1a2f	e8		inx				inx
.1a30					BranchAlways:
.1a30	8a		txa				txa 								; A = Y = position
.1a31	a8		tay				tay 								; (IP),Y now points to the branch target
.1a32	b1 03		lda ($03),y			lda 	(IP),y 						; adjust the position
.1a34	aa		tax				tax 								; position back in this line.
.1a35	ca		dex				dex
.1a36	ca		dex				dex
.1a37	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/system/callhandler.src

.1a3a					CallHandler:
.1a3a	e8		inx				inx									; bump X to the call address.
.1a3b	e8		inx				inx
.1a3c	e6 05		inc $05				inc 	rsp 						; bump the RSP (first time to zero)
.1a3e	a4 05		ldy $05				ldy 	rsp 						; get return stack and push IP/X on it.
.1a40	c0 40		cpy #$40			cpy 	#$40 						; overflow
.1a42	f0 4b		beq $1a8f			beq 	_CHOverflow
.1a44	a5 04		lda $04				lda 	IP+1
.1a46	99 40 07	sta $0740,y			sta 	returnStackHigh,y
.1a49	a5 03		lda $03				lda 	IP
.1a4b	99 00 07	sta $0700,y			sta 	returnStackLow,y
.1a4e	8a		txa				txa
.1a4f	99 80 07	sta $0780,y			sta 	returnStackX,y
.1a52	8a		txa				txa 								; get the line number into temp1.
.1a53	a8		tay				tay
.1a54	b1 03		lda ($03),y			lda 	(IP),y
.1a56	85 10		sta $10				sta 	temp1
.1a58	c8		iny				iny
.1a59	b1 03		lda ($03),y			lda 	(IP),y
.1a5b	85 11		sta $11				sta 	temp1+1
.1a5d	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.1a5f	85 03		sta $03				sta 	0+(IP)
.1a61	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.1a63	85 04		sta $04				sta 	1+(IP)
.1a65	b2 03		lda ($03)			lda 	(IP)						; no program code ?
.1a67	f0 17		beq $1a80			beq 	_CHFail
.1a69	a0 01		ldy #$01			ldy 	#1 							; Y = 1 throughout.
.1a6b					_CHSearch:
.1a6b	b1 03		lda ($03),y			lda 	(IP),y 						; check LSB of line number
.1a6d	c5 10		cmp $10				cmp 	temp1
.1a6f	f0 2d		beq $1a9e			beq 	_CHFoundLSB
.1a71					_CHSearchNext:
.1a71	18		clc				clc
.1a72	a5 03		lda $03				lda 	IP
.1a74	72 03		adc ($03)			adc 	(IP)
.1a76	85 03		sta $03				sta 	IP
.1a78	90 02		bcc $1a7c			bcc 	_NoCarryAdv
.1a7a	e6 04		inc $04				inc 	IP+1
.1a7c					_NoCarryAdv:
.1a7c	b2 03		lda ($03)			lda 	(IP)						; check reached the end.
.1a7e	d0 eb		bne $1a6b			bne 	_CHSearch
.1a80					_CHFail:
.1a80	20 3f 10	jsr $103f			jsr 	ErrorHandler
>1a83	44 45 46 49 4e 49 54 49				.text 	"DEFINITION?",0
>1a8b	4f 4e 3f 00
.1a8f					_CHOverflow:
.1a8f	20 3f 10	jsr $103f			jsr 	ErrorHandler
>1a92	53 54 41 43 4b 44 45 50				.text 	"STACKDEPTH?",0
>1a9a	54 48 3f 00
.1a9e					_CHFoundLSB:
.1a9e	c8		iny				iny 								; get MSB
.1a9f	b1 03		lda ($03),y			lda 	(IP),y
.1aa1	88		dey				dey
.1aa2	c5 11		cmp $11				cmp 	temp1+1 					; matches, if not contineu
.1aa4	d0 cb		bne $1a71			bne 	_CHSearchNext
.1aa6	a0 03		ldy #$03			ldy 	#3	 						; check it begins with $$define
.1aa8	b1 03		lda ($03),y			lda 	(IP),y
.1aaa	c9 22		cmp #$22			cmp 	#DefineCode & $FF
.1aac	d0 d2		bne $1a80			bne 	_CHFail
.1aae	c8		iny				iny
.1aaf	b1 03		lda ($03),y			lda 	(IP),y
.1ab1	c9 1f		cmp #$1f			cmp 	#DefineCode >> 8
.1ab3	d0 cb		bne $1a80			bne 	_CHFail
.1ab5	c8		iny				iny
.1ab6	b1 03		lda ($03),y			lda 	(IP),y 						; this is the length of the define name
.1ab8	18		clc				clc
.1ab9	69 03		adc #$03			adc 	#5-2 						; $$define token, line number, offset - 2 for Next
.1abb	aa		tax				tax
.1abc	4c 00 00	jmp $0000			jmp 	NextCode
.1abf					ReturnHandler:
.1abf	a4 05		ldy $05				ldy 	rsp 						; get rsp
.1ac1	30 15		bmi $1ad8			bmi 	_RHUnderflow 				; if -ve underflowed
.1ac3	c6 05		dec $05				dec 	rsp 						; decrement rsp
.1ac5	b9 40 07	lda $0740,y			lda 	returnStackHigh,y 			; restore IP/X
.1ac8	85 04		sta $04				sta 	IP+1
.1aca	b9 00 07	lda $0700,y			lda 	returnStackLow,y
.1acd	85 03		sta $03				sta 	IP
.1acf	b9 80 07	lda $0780,y			lda 	returnStackX,y
.1ad2	aa		tax				tax
.1ad3	f0 0e		beq $1ae3			beq 	_RHInLoop 					; this means you have done :something for ; next
.1ad5	4c 00 00	jmp $0000			jmp 	NextCode
.1ad8					_RHUnderflow:
.1ad8	20 3f 10	jsr $103f			jsr 	ErrorHandler
>1adb	52 45 54 55 52 4e 3f 00				.text 	"RETURN?",0
.1ae3					_RHInLoop:
.1ae3	20 3f 10	jsr $103f			jsr 	ErrorHandler
>1ae6	52 45 54 55 52 4e 20 49				.text 	"RETURN IN LOOP?",0
>1aee	4e 20 4c 4f 4f 50 3f 00
.1af6					CallHandlerDecode:
.1af6	a9 03		lda #$03			lda 	#CTH_Call					; space
.1af8	20 bd 1c	jsr $1cbd			jsr 	DecodeWriteBuffer
.1afb	b1 08		lda ($08),y			lda 	(srcPtr),y 					; get line number into YA
.1afd	aa		tax				tax
.1afe	c8		iny				iny
.1aff	b1 08		lda ($08),y			lda 	(srcPtr),y
.1b01	a8		tay				tay
.1b02	8a		txa				txa
.1b03	20 40 1b	jsr $1b40			jsr 	FindLine 					; try to locate that line.
.1b06	b0 11		bcs $1b19			bcs 	_CHDFound 					; if found .....
.1b08					_CHDLineOnly:
.1b08	48		pha				pha
.1b09	a9 3c		lda #$3c			lda 	#"<"
.1b0b	20 bd 1c	jsr $1cbd			jsr 	DecodeWriteBuffer
.1b0e	68		pla				pla
.1b0f	18		clc				clc 								; output unsigned
.1b10	20 df 1c	jsr $1cdf			jsr 	DecodeYAToBuffer
.1b13	a9 3e		lda #$3e			lda 	#">"
.1b15	20 bd 1c	jsr $1cbd			jsr 	DecodeWriteBuffer
.1b18	60		rts				rts
.1b19					_CHDFound:
.1b19	48		pha				pha 								; save YA
.1b1a	5a		phy				phy
.1b1b	a0 03		ldy #$03			ldy 	#3 							; check first is $$define
.1b1d	b1 10		lda ($10),y			lda 	(temp1),y
.1b1f	c9 22		cmp #$22			cmp 	#DefineCode & 255
.1b21	d0 07		bne $1b2a			bne 	_CHDNoDefine
.1b23	c8		iny				iny
.1b24	b1 10		lda ($10),y			lda 	(temp1),y
.1b26	c9 1f		cmp #$1f			cmp 	#DefineCode >> 8
.1b28	f0 04		beq $1b2e			beq 	_CHDFoundDefine
.1b2a					_CHDNoDefine:
.1b2a	7a		ply				ply									; restore the line number and print it in <>
.1b2b	68		pla				pla
.1b2c	80 da		bra $1b08			bra 	_CHDLineOnly
.1b2e					_CHDFoundDefine:
.1b2e	68		pla				pla 								; throw saved line number.
.1b2f	68		pla				pla
.1b30	a0 05		ldy #$05			ldy 	#5 							; 3,4 $$define 5 length, name has bit 7 set at end
.1b32					_CHDOutName:
.1b32	c8		iny				iny 								; next
.1b33	b1 10		lda ($10),y			lda 	(temp1),y 					; print char no bit 7
.1b35	48		pha				pha
.1b36	29 7f		and #$7f			and 	#$7F
.1b38	20 bd 1c	jsr $1cbd			jsr 	DecodeWriteBuffer
.1b3b	68		pla				pla
.1b3c	0a		asl a				asl 	a 							; bit 7 to carry
.1b3d	90 f3		bcc $1b32			bcc 	_CHDOutName
.1b3f	60		rts				rts
.1b40					FindLine:
.1b40	48		pha				pha 								; save registers
.1b41	da		phx				phx
.1b42	5a		phy				phy
.1b43	85 12		sta $12				sta 	temp2 						; temp2 = target line#
.1b45	84 13		sty $13				sty 	temp2+1
.1b47	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.1b49	85 10		sta $10				sta 	0+(temp1)
.1b4b	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.1b4d	85 11		sta $11				sta 	1+(temp1)
.1b4f					_FLLoop:
.1b4f	b2 10		lda ($10)			lda 	(temp1) 					; found end ?
.1b51	18		clc				clc									; if so exit with CC.
.1b52	f0 1d		beq $1b71			beq 	_FLExit
.1b54	a0 01		ldy #$01			ldy 	#1 							; check line # match
.1b56	b1 10		lda ($10),y			lda 	(temp1),y
.1b58	c5 12		cmp $12				cmp 	temp2
.1b5a	d0 08		bne $1b64			bne 	_FLNext
.1b5c	c8		iny				iny
.1b5d	b1 10		lda ($10),y			lda 	(temp1),y
.1b5f	c5 13		cmp $13				cmp 	temp2+1
.1b61	38		sec				sec 								; if so exit with CS
.1b62	f0 0d		beq $1b71			beq 	_FLExit
.1b64					_FLNext:
.1b64	18		clc				clc
.1b65	a5 10		lda $10				lda 	temp1
.1b67	72 10		adc ($10)			adc 	(temp1)
.1b69	85 10		sta $10				sta 	temp1
.1b6b	90 02		bcc $1b6f			bcc 	_NoCarryAdv
.1b6d	e6 11		inc $11				inc 	temp1+1
.1b6f					_NoCarryAdv:
.1b6f	80 de		bra $1b4f			bra 	_FLLoop 					; keep looking.
.1b71					_FLExit:
.1b71	7a		ply				ply
.1b72	fa		plx				plx
.1b73	68		pla				pla
.1b74	60		rts				rts
.1b75	18		clc				clc
.1b76	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/clrnew.src

.1b77					NewHandler:
.1b77	9c 00 40	stz $4000			stz 	ProgramMemory 				; Make the first offset zero.
.1b7a	20 8d 1b	jsr $1b8d			jsr 	ClearVariableSpace 			; clear variables, reset pointers
.1b7d	4c 00 00	jmp $0000			jmp 	NextCode
.1b80					ClrHandler:
.1b80	86 10		stx $10				stx 	temp1
.1b82	a2 80		ldx #$80			ldx 	#NumberStackBase
.1b84	9a		txs				txs
.1b85	a6 10		ldx $10				ldx 	temp1
.1b87	20 8d 1b	jsr $1b8d			jsr 	ClearVariableSpace 			; clear variables, reset pointers
.1b8a	4c 00 00	jmp $0000			jmp 	NextCode
.1b8d					ClearVariableSpace:
.1b8d	a9 ff		lda #$ff			lda 	#$FF
.1b8f	85 05		sta $05				sta 	rsp
.1b91	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.1b93	85 0e		sta $0e				sta 	0+(nextFreeMem)
.1b95	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.1b97	85 0f		sta $0f				sta 	1+(nextFreeMem)
.1b99	a0 1f		ldy #$1f			ldy 	#hashTableSize*2-1 			; erase the hash table (used for variables)
.1b9b					_CVSHashClear:
.1b9b	a9 00		lda #$00			lda 	#0 							; all the first record pointers are $00
.1b9d	99 40 06	sta $0640,y			sta 	hashTable,y
.1ba0	88		dey				dey
.1ba1	10 f8		bpl $1b9b			bpl 	_CVSHashClear
.1ba3					_CVSFindEnd:
.1ba3	18		clc				clc
.1ba4	a5 0e		lda $0e				lda 	nextFreeMem
.1ba6	72 0e		adc ($0e)			adc 	(nextFreeMem)
.1ba8	85 0e		sta $0e				sta 	nextFreeMem
.1baa	90 02		bcc $1bae			bcc 	_NoCarryAdv
.1bac	e6 0f		inc $0f				inc 	nextFreeMem+1
.1bae					_NoCarryAdv:
.1bae	b2 0e		lda ($0e)			lda 	(nextFreeMem)
.1bb0	d0 f1		bne $1ba3			bne 	_CVSFindEnd
.1bb2	a9 08		lda #$08			lda 	#8 							; this puts a gap in, more for clarity than anything.
.1bb4	a0 00		ldy #$00			ldy 	#0
.1bb6	20 ba 1b	jsr $1bba			jsr 	AdvanceFreeMem				; we need +1 because the previous code leaves the
.1bb9	60		rts				rts 								; free mem pointer pointing to the last zero offset
.1bba					AdvanceFreeMem:
.1bba	18		clc				clc
.1bbb	65 0e		adc $0e				adc 	nextFreeMem
.1bbd	85 0e		sta $0e				sta 	nextFreeMem
.1bbf	98		tya				tya
.1bc0	65 0f		adc $0f				adc 	nextFreeMem+1
.1bc2	85 0f		sta $0f				sta 	nextFreeMem+1
.1bc4	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/debug.src

.1bc5					ExitDump:
.1bc5	ba		tsx				tsx 								; save Data Stack in temp1
.1bc6	86 10		stx $10				stx 	temp1
.1bc8	4c ff ff	jmp $ffff			jmp 	$FFFF 						; makes the X16-Emulator dump-exit.
.1bcb					BreakCmd:
>1bcb	ff						.byte 	$FF
.1bcc	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/system/decode.src

.1bcf					DecodeLineIntoBufPtr:
.1bcf	48		pha				pha
.1bd0	da		phx				phx
.1bd1	5a		phy				phy
.1bd2	85 08		sta $08				sta 	srcPtr 						; save the source line.
.1bd4	84 09		sty $09				sty 	srcPtr+1
.1bd6	90 1b		bcc $1bf3			bcc 	_DecodeNoLineNumber
.1bd8	a0 01		ldy #$01			ldy 	#1 							; get line # to YA
.1bda	b1 08		lda ($08),y			lda 	(srcPtr),y
.1bdc	aa		tax				tax
.1bdd	c8		iny				iny
.1bde	b1 08		lda ($08),y			lda 	(srcPtr),y
.1be0	a8		tay				tay
.1be1	8a		txa				txa
.1be2	18		clc				clc
.1be3	20 df 1c	jsr $1cdf			jsr 	DecodeYAToBuffer 			; convert to string in buffer
.1be6	aa		tax				tax 								; count in X
.1be7					_DecodeLineSpace:
.1be7	e0 05		cpx #$05			cpx 	#5
.1be9	f0 08		beq $1bf3			beq 	_DecodeNoLineNumber
.1beb	a9 20		lda #$20			lda 	#" " 						; pad to 5 spaces
.1bed	20 bd 1c	jsr $1cbd			jsr 	DecodeWriteBuffer
.1bf0	e8		inx				inx
.1bf1	80 f4		bra $1be7			bra 	_DecodeLineSpace
.1bf3					_DecodeNoLineNumber:
.1bf3	a0 03		ldy #$03			ldy 	#3 							; initial position.
.1bf5					_DecodeLoop:
.1bf5	b1 08		lda ($08),y			lda 	(srcPtr),y 					; copy the current character to temp1
.1bf7	85 10		sta $10				sta 	temp1 						; must be an execution address.
.1bf9	c8		iny				iny
.1bfa	b1 08		lda ($08),y			lda 	(srcPtr),y
.1bfc	85 11		sta $11				sta 	temp1+1
.1bfe	c8		iny				iny 								; y points to the byte after it.
.1bff	a5 10		lda $10				lda 	temp1
.1c01	c9 e6		cmp #$e6			cmp 	#NextLine & $FF
.1c03	d0 06		bne $1c0b			bne 	_DecodeNotEOL
.1c05	a5 11		lda $11				lda 	temp1+1
.1c07	c9 1e		cmp #$1e			cmp 	#NextLine >> 8
.1c09	f0 0b		beq $1c16			beq 	_DecodeEOL
.1c0b					_DecodeNotEOL:
.1c0b	20 1e 1c	jsr $1c1e			jsr 	IdentifyCodeWord
.1c0e	20 68 1c	jsr $1c68			jsr 	DecodeFoundWord
.1c11	20 52 1c	jsr $1c52			jsr 	AdvanceToNext 				; advance to next entry in the line.
.1c14	80 df		bra $1bf5			bra 	_DecodeLoop 				; and go round again
.1c16					_DecodeEOL:
.1c16	a9 00		lda #$00			lda 	#0
.1c18	92 0a		sta ($0a)			sta 	(bufPtr)
.1c1a	7a		ply				ply 								; restore registers and exit
.1c1b	fa		plx				plx
.1c1c	68		pla				pla
.1c1d	60		rts				rts
.1c1e					IdentifyCodeWord:
.1c1e	5a		phy				phy 								; save current position on the stack.
.1c1f	a9 42		lda #$42			lda 	#(Dictionary) & $FF
.1c21	85 0c		sta $0c				sta 	0+(matchPtr)
.1c23	a9 21		lda #$21			lda 	#(Dictionary) >> 8
.1c25	85 0d		sta $0d				sta 	1+(matchPtr)
.1c27					_DecodeIdentify:
.1c27	a0 02		ldy #$02			ldy 	#2 							; have we found a match ?
.1c29	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.1c2b	c5 10		cmp $10				cmp 	temp1
.1c2d	d0 07		bne $1c36			bne 	_DecodeIdNext
.1c2f	c8		iny				iny
.1c30	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.1c32	c5 11		cmp $11				cmp 	temp1+1
.1c34	f0 1a		beq $1c50			beq 	_DecodeIdFound
.1c36					_DecodeIdNext:
.1c36	18		clc				clc
.1c37	b2 0c		lda ($0c)			lda 	(matchPtr)
.1c39	f0 0a		beq $1c45			beq 	_DecodeIdIssue
.1c3b	65 0c		adc $0c				adc 	matchPtr
.1c3d	85 0c		sta $0c				sta 	matchPtr
.1c3f	90 e6		bcc $1c27			bcc 	_DecodeIdentify
.1c41	e6 0d		inc $0d				inc 	matchPtr+1
.1c43	80 e2		bra $1c27			bra 	_DecodeIdentify
.1c45					_DecodeIdIssue:
.1c45	20 3f 10	jsr $103f			jsr 	ErrorHandler
>1c48	44 45 43 4f 44 45 3f 00				.text 	"DECODE?",0
.1c50					_DecodeIdFound:
.1c50	7a		ply				ply 								; restore position.
.1c51	60		rts				rts
.1c52					AdvanceToNext:
.1c52	5a		phy				phy 								; get the parameter count from bits 0-1 of the type byte
.1c53	a0 01		ldy #$01			ldy 	#1
.1c55	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.1c57	29 03		and #$03			and 	#3 							; bits 0-1.
.1c59	7a		ply				ply
.1c5a	c9 03		cmp #$03			cmp 	#3 							; is it n-bytes e.g. specified by the next byte
.1c5c	d0 02		bne $1c60			bne 	_ATN012
.1c5e	b1 08		lda ($08),y			lda 	(srcPtr),y 					; if so, use that byte as the overall length.
.1c60					_ATN012:
.1c60	85 12		sta $12				sta 	temp2 						; now add that to Y
.1c62	98		tya				tya
.1c63	18		clc				clc
.1c64	65 12		adc $12				adc 	temp2
.1c66	a8		tay				tay
.1c67	60		rts				rts
.1c68					DecodeFoundWord:
.1c68	5a		phy				phy 								; save current position
.1c69	84 12		sty $12				sty		temp2 						; put it in temp2 as well.
.1c6b	a0 01		ldy #$01			ldy 	#1 							; get the type byte
.1c6d	b1 0c		lda ($0c),y			lda 	(matchPtr),y 				; is there a special decoder check (bit 4 set) ?
.1c6f	29 10		and #$10			and 	#$10
.1c71	d0 0e		bne $1c81			bne 	_DFWSpecialDecoder
.1c73	b1 0c		lda ($0c),y			lda 	(matchPtr),y 				; reget it.
.1c75	30 08		bmi $1c7f			bmi 	_DFWExit 					; if hidden word (bit 7 set)
.1c77	a9 06		lda #$06			lda 	#CTH_Keyword				; output a space to the buffer
.1c79	20 bd 1c	jsr $1cbd			jsr 	DecodeWriteBuffer
.1c7c	20 9a 1c	jsr $1c9a			jsr 	DecodeCurrentWord 			; expand that.
.1c7f					_DFWExit:
.1c7f	7a		ply				ply 								; restore current position
.1c80	60		rts				rts
.1c81					_DFWSpecialDecoder:
.1c81	a0 04		ldy #$04			ldy 	#4 							; the decode word address is at offset 4,5
.1c83	b1 0c		lda ($0c),y			lda 	(matchPtr),y 				; copy this into temp2
.1c85	85 12		sta $12				sta 	temp2
.1c87	c8		iny				iny
.1c88	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.1c8a	85 13		sta $13				sta 	temp2+1
.1c8c	7a		ply				ply 	 							; restore current position into Y
.1c8d	48		pha				pha 								; save registers
.1c8e	da		phx				phx
.1c8f	5a		phy				phy
.1c90	20 97 1c	jsr $1c97			jsr 	_DFWCallDecoder				; call the decoder routine
.1c93	7a		ply				ply 								; restore registers and exit
.1c94	fa		plx				plx
.1c95	68		pla				pla
.1c96	60		rts				rts
.1c97					_DFWCallDecoder:
.1c97	6c 12 00	jmp ($0012)			jmp 	(temp2)
.1c9a					DecodeCurrentWord:
.1c9a	5a		phy				phy
.1c9b	a0 01		ldy #$01			ldy 	#1 							; read type byte
.1c9d	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.1c9f	a0 04		ldy #$04			ldy 	#4 							; original offset
.1ca1	4a		lsr a				lsr 	a 							; encoder/decoder bits in 0-1
.1ca2	4a		lsr a				lsr 	a 							; add 2 to Y for each encoder/decoder
.1ca3	4a		lsr a				lsr 	a 							; bit set.
.1ca4	4a		lsr a				lsr 	a
.1ca5	4a		lsr a				lsr 	a 							; decoder bit
.1ca6	90 02		bcc $1caa			bcc 	_DWBNoDec
.1ca8	c8		iny				iny
.1ca9	c8		iny				iny
.1caa					_DWBNoDec:
.1caa	4a		lsr a				lsr 	a
.1cab	90 02		bcc $1caf			bcc 	_DWBNoEnc
.1cad	c8		iny				iny
.1cae	c8		iny				iny
.1caf					_DWBNoEnc:
.1caf					_DWBWordOut:
.1caf	b1 0c		lda ($0c),y			lda 	(matchPtr),y 				; output until bit 7 set.
.1cb1	48		pha				pha
.1cb2	29 7f		and #$7f			and 	#$7F
.1cb4	20 bd 1c	jsr $1cbd			jsr		DecodeWriteBuffer
.1cb7	c8		iny				iny
.1cb8	68		pla				pla
.1cb9	10 f4		bpl $1caf			bpl 	_DWBWordOut
.1cbb	7a		ply				ply 								; restore Y and exit
.1cbc	60		rts				rts
.1cbd					DecodeWriteBuffer:
.1cbd	92 0a		sta ($0a)			sta 	(bufPtr)
.1cbf	e6 0a		inc $0a				inc 	bufPtr
.1cc1	d0 02		bne $1cc5			bne 	_DWBNoCarry
.1cc3	e6 0b		inc $0b				inc 	bufPtr+1
.1cc5					_DWBNoCarry:
.1cc5	60		rts				rts
.1cc6					DecodeOutputData:
.1cc6	48		pha				pha
.1cc7	da		phx				phx
.1cc8	5a		phy				phy
.1cc9	b1 08		lda ($08),y			lda 	(srcPtr),y 					; length + 1
.1ccb	aa		tax				tax
.1ccc					_DODLoop:
.1ccc	ca		dex				dex 								; done it all ?
.1ccd	f0 0c		beq $1cdb			beq		_DODExit
.1ccf	c8		iny				iny 								; output next character
.1cd0	b1 08		lda ($08),y			lda 	(srcPtr),y
.1cd2	29 7f		and #$7f			and 	#$7F
.1cd4	f0 f6		beq $1ccc			beq 	_DODLoop 					; don't print NULL
.1cd6	20 bd 1c	jsr $1cbd			jsr 	DecodeWriteBuffer
.1cd9	80 f1		bra $1ccc			bra 	_DODLoop
.1cdb					_DODExit:
.1cdb	7a		ply				ply
.1cdc	fa		plx				plx
.1cdd	68		pla				pla
.1cde	60		rts				rts
.1cdf					DecodeYAToBuffer:
.1cdf	da		phx				phx
.1ce0	5a		phy				phy
.1ce1	48		pha				pha
.1ce2	a5 0a		lda $0a				lda 	bufPtr 						; copy bufPtr to temp2
.1ce4	85 12		sta $12				sta 	temp2
.1ce6	a5 0b		lda $0b				lda 	bufPtr+1
.1ce8	85 13		sta $13				sta 	temp2+1
.1cea	68		pla				pla
.1ceb	20 84 1f	jsr $1f84			jsr 	ConvertToStringMain 		; convert YA to string there
.1cee	aa		tax				tax 								; chars output to X
.1cef	18		clc				clc
.1cf0	65 0a		adc $0a				adc 	bufPtr 						; add to buffer pointer
.1cf2	85 0a		sta $0a				sta 	bufPtr
.1cf4	90 02		bcc $1cf8			bcc 	_DYABNoCarry
.1cf6	e6 0b		inc $0b				inc 	bufPtr+1
.1cf8					_DYABNoCarry:
.1cf8	8a		txa				txa 								; count in A
.1cf9	7a		ply				ply									; restore and exit.
.1cfa	fa		plx				plx
.1cfb	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/list.src

.1cfc					ListCode:
.1cfc	64 1e		stz $1e				stz 	ListLowest 					; zero lowest line#
.1cfe	64 1f		stz $1f				stz 	ListLowest+1
.1d00	a9 14		lda #$14			lda 	#20 						; show max 20 after lowest line
.1d02	85 1d		sta $1d				sta 	ListCount
.1d04	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.1d06	85 18		sta $18				sta 	0+(listPtr)
.1d08	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.1d0a	85 19		sta $19				sta 	1+(listPtr)
.1d0c	86 10		stx $10				stx 	temp1						; S->A
.1d0e	ba		tsx				tsx
.1d0f	8a		txa				txa
.1d10	a6 10		ldx $10				ldx 	temp1
.1d12	c9 80		cmp #$80			cmp 	#NumberStackBase
.1d14	f0 0e		beq $1d24			beq 	_LCLoop
.1d16	a5 06		lda $06				lda 	TOS 						; copy TOS to lowest
.1d18	85 1e		sta $1e				sta 	ListLowest
.1d1a	a5 07		lda $07				lda 	TOS+1
.1d1c	85 1f		sta $1f				sta 	ListLowest+1
.1d1e	68		pla				pla
.1d1f	85 07		sta $07				sta 	TOS+1
.1d21	68		pla				pla
.1d22	85 06		sta $06				sta 	TOS
.1d24					_LCLoop:
.1d24	b2 18		lda ($18)			lda 	(listPtr)					; reached end ?
.1d26	f0 4e		beq $1d76			beq 	_LCExit
.1d28	a0 01		ldy #$01			ldy 	#1							; >= list lowest
.1d2a	b1 18		lda ($18),y			lda 	(listPtr),y
.1d2c	c5 1e		cmp $1e				cmp 	ListLowest
.1d2e	c8		iny				iny
.1d2f	b1 18		lda ($18),y			lda 	(listPtr),y
.1d31	e5 1f		sbc $1f				sbc 	ListLowest+1
.1d33	90 34		bcc $1d69			bcc 	_LCNext
.1d35	a9 10		lda #$10			lda 	#(textBuffer) & $FF
.1d37	85 0a		sta $0a				sta 	0+(bufPtr)
.1d39	a9 08		lda #$08			lda 	#(textBuffer) >> 8
.1d3b	85 0b		sta $0b				sta 	1+(bufPtr)
.1d3d	a5 18		lda $18				lda 	listPtr 					; output the line.
.1d3f	a4 19		ldy $19				ldy 	listPtr+1
.1d41	38		sec				sec
.1d42	20 cf 1b	jsr $1bcf			jsr 	DecodeLineIntoBufPtr
.1d45	a9 02		lda #$02			lda 	#CTH_LineNo
.1d47	20 34 11	jsr $1134			jsr 	ExternColour
.1d4a	a0 ff		ldy #$ff			ldy 	#255
.1d4c					_LCLoop2:
.1d4c	c8		iny				iny
.1d4d	b9 10 08	lda $0810,y			lda 	textBuffer,y
.1d50	f0 0e		beq $1d60			beq 	_LCEnd
.1d52	c9 20		cmp #$20			cmp 	#32
.1d54	b0 05		bcs $1d5b			bcs 	_LCPrint
.1d56	20 34 11	jsr $1134			jsr 	ExternColour
.1d59	a9 20		lda #$20			lda 	#32
.1d5b					_LCPrint:
.1d5b	20 2a 11	jsr $112a			jsr 	ExternPrint
.1d5e	80 ec		bra $1d4c			bra 	_LCLoop2
.1d60	a9 0d		lda #$0d	_LCEnd:	lda 	#13 						; new line
.1d62	20 2a 11	jsr $112a			jsr 	ExternPrint
.1d65	c6 1d		dec $1d				dec 	ListCount					; done all the lines allowed
.1d67	f0 0d		beq $1d76			beq 	_LCExit
.1d69					_LCNext:
.1d69	18		clc				clc
.1d6a	a5 18		lda $18				lda 	listPtr
.1d6c	72 18		adc ($18)			adc 	(listPtr)
.1d6e	85 18		sta $18				sta 	listPtr
.1d70	90 02		bcc $1d74			bcc 	_NoCarryAdv
.1d72	e6 19		inc $19				inc 	listPtr+1
.1d74					_NoCarryAdv:
.1d74	80 ae		bra $1d24			bra 	_LCLoop 					; go round again.
.1d76					_LCExit:
.1d76	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/system/miscellany.src

.1d79					RunProgram:
.1d79	86 10		stx $10				stx 	temp1
.1d7b	a2 80		ldx #$80			ldx 	#NumberStackBase
.1d7d	9a		txs				txs
.1d7e	a6 10		ldx $10				ldx 	temp1
.1d80	20 8d 1b	jsr $1b8d			jsr 	ClearVariableSpace 			; clear variables etc.
.1d83	a2 00		ldx #$00			ldx		#ProgramMemory & $FF		; boot address
.1d85	a0 40		ldy #$40			ldy 	#ProgramMemory >>8
.1d87	20 94 10	jsr $1094			jsr 	InitialiseCoreCode 			; initialise the NEXT routine at $00
.1d8a	4c 00 00	jmp $0000			jmp 	NextCode
.1d8d					Call6502:
.1d8d	a5 06		lda $06				lda 	TOS 						; copy call address
.1d8f	85 10		sta $10				sta 	temp1
.1d91	a5 07		lda $07				lda 	TOS+1
.1d93	85 11		sta $11				sta 	temp1+1
.1d95	68		pla				pla
.1d96	85 07		sta $07				sta 	TOS+1
.1d98	68		pla				pla
.1d99	85 06		sta $06				sta 	TOS
.1d9b	20 a1 1d	jsr $1da1			jsr 	_CallTemp1 					; call it
.1d9e	4c 00 00	jmp $0000			jmp 	NextCode
.1da1					_CallTemp1:
.1da1	6c 10 00	jmp ($0010)			jmp 	(temp1)
.1da4					AssertCode:
.1da4	a5 06		lda $06				lda 	TOS 						; TOS = 0
.1da6	05 07		ora $07				ora 	TOS+1
.1da8	f0 09		beq $1db3			beq 	_ASFail 					; if zero fail
.1daa	68		pla				pla
.1dab	85 07		sta $07				sta 	TOS+1
.1dad	68		pla				pla
.1dae	85 06		sta $06				sta 	TOS
.1db0	4c 00 00	jmp $0000			jmp 	NextCode
.1db3					_ASFail:
.1db3	20 3f 10	jsr $103f			jsr 	ErrorHandler
>1db6	41 53 53 45 52 54 00				.text 	"ASSERT",0
.1dbd					StopCode:
.1dbd	20 3f 10	jsr $103f			jsr 	ErrorHandler
>1dc0	53 54 4f 50 00					.text 	"STOP",0
.1dc5					EndProgram:
.1dc5	4c 14 10	jmp $1014			jmp 	WarmStart
.1dc8					VlistCode:
.1dc8	a9 42		lda #$42			lda 	#(Dictionary) & $FF
.1dca	85 10		sta $10				sta 	0+(temp1)
.1dcc	a9 21		lda #$21			lda 	#(Dictionary) >> 8
.1dce	85 11		sta $11				sta 	1+(temp1)
.1dd0	a0 01		ldy #$01	_VLLoop:ldy 	#1							; type byte
.1dd2	b1 10		lda ($10),y			lda 	(temp1),y
.1dd4	a0 04		ldy #$04			ldy 	#4 							; Y = 4
.1dd6	4a		lsr a				lsr 	a 							; shift bits 4 and 5 to 0,1
.1dd7	4a		lsr a				lsr 	a
.1dd8	4a		lsr a				lsr		a
.1dd9	4a		lsr a				lsr 	a
.1dda	4a		lsr a				lsr 	a 							; add those bits in
.1ddb	90 02		bcc $1ddf			bcc 	_VLNoDec
.1ddd	c8		iny				iny
.1dde	c8		iny				iny
.1ddf					_VLNoDec:
.1ddf	4a		lsr a				lsr 	a
.1de0	90 02		bcc $1de4			bcc 	_VLNoEnc
.1de2	c8		iny				iny
.1de3	c8		iny				iny
.1de4					_VLNoEnc:
.1de4	b1 10		lda ($10),y			lda 	(temp1),y 					; remove $$ words
.1de6	c9 24		cmp #$24			cmp 	#"$"
.1de8	d0 06		bne $1df0			bne 	_VLPrint
.1dea	c8		iny				iny
.1deb	51 10		eor ($10),y			eor 	(temp1),y
.1ded	f0 13		beq $1e02			beq 	_VLNext
.1def	88		dey				dey
.1df0					_VLPrint:
.1df0	b1 10		lda ($10),y			lda 	(temp1),y
.1df2	48		pha				pha
.1df3	c8		iny				iny
.1df4	29 7f		and #$7f			and 	#$7F
.1df6	20 2a 11	jsr $112a			jsr 	ExternPrint
.1df9	68		pla				pla
.1dfa	0a		asl a				asl 	a
.1dfb	90 f3		bcc $1df0			bcc 	_VLPrint
.1dfd	a9 20		lda #$20			lda 	#32
.1dff	20 2a 11	jsr $112a			jsr 	ExternPrint
.1e02					_VLNext:
.1e02	18		clc				clc 								; go to next
.1e03	b2 10		lda ($10)			lda 	(temp1)
.1e05	65 10		adc $10				adc 	temp1
.1e07	85 10		sta $10				sta 	temp1
.1e09	90 02		bcc $1e0d			bcc 	_VLNoCarry
.1e0b	e6 11		inc $11				inc 	temp1+1
.1e0d					_VLNoCarry:
.1e0d	b2 10		lda ($10)			lda 	(temp1)
.1e0f	d0 bf		bne $1dd0			bne 	_VLLoop
.1e11	a9 0d		lda #$0d			lda 	#13
.1e13	20 2a 11	jsr $112a			jsr 	ExternPrint
.1e16	4c 00 00	jmp $0000			jmp 	NextCode
.1e19					DumpStack:
.1e19	86 10		stx $10				stx 	temp1 						; X -> A
.1e1b	ba		tsx				tsx
.1e1c	8a		txa				txa
.1e1d	a6 10		ldx $10				ldx 	temp1
.1e1f	c9 80		cmp #$80			cmp 	#NumberStackBase 			; out of range, exit
.1e21	f0 32		beq $1e55			beq 	_DSExit
.1e23	48		pha				pha 								; save it
.1e24	a9 07		lda #$07			lda 	#COL_WHITE
.1e26	20 34 11	jsr $1134			jsr 	ExternColour
.1e29	a5 06		lda $06				lda 	TOS 						; print TOS then stack values backwards
.1e2b	a4 07		ldy $07				ldy 	TOS+1
.1e2d	38		sec				sec 								; print unsigned.
.1e2e	20 5e 1f	jsr $1f5e			jsr 	PrintYA
.1e31	a9 06		lda #$06			lda 	#COL_CYAN
.1e33	20 34 11	jsr $1134			jsr 	ExternColour
.1e36	7a		ply				ply 								; restore offset
.1e37	a9 20		lda #$20	_DSLoop:lda 	#" " 						; space
.1e39	20 2a 11	jsr $112a			jsr 	ExternPrint
.1e3c	5a		phy				phy 								; save pos
.1e3d	b9 01 01	lda $0101,y			lda 	$0101,y 					; read stack item
.1e40	48		pha				pha
.1e41	b9 02 01	lda $0102,y			lda 	$0102,y
.1e44	7a		ply				ply
.1e45	38		sec				sec
.1e46	20 5e 1f	jsr $1f5e			jsr 	PrintYA 					; print it
.1e49	7a		ply				ply 								; restore and advance pos
.1e4a	c8		iny				iny
.1e4b	c8		iny				iny
.1e4c	c0 7e		cpy #$7e			cpy 	#NumberStackBase-2 			; till done whole stack.
.1e4e	d0 e7		bne $1e37			bne 	_DSLoop
.1e50	a9 0d		lda #$0d			lda 	#13
.1e52	20 2a 11	jsr $112a			jsr 	ExternPrint
.1e55					_DSExit:
.1e55	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/system/toint.src

.1e58					ConvertToInteger:
.1e58	84 17		sty $17				sty 	temp4+1
.1e5a	85 16		sta $16				sta 	temp4
.1e5c	64 14		stz $14				stz 	temp3 						; reset value
.1e5e	64 15		stz $15				stz 	temp3+1
.1e60	64 10		stz $10				stz 	temp1 						; temp1 = 0 (decimal) 255 (hex)
.1e62	a0 00		ldy #$00			ldy 	#0 							; look at first character
.1e64	b1 16		lda ($16),y			lda 	(temp4),y
.1e66	49 2d		eor #$2d			eor 	#"-"						; zero if '-'
.1e68	85 11		sta $11				sta 	temp1+1 					; save this in temp1+1
.1e6a	d0 01		bne $1e6d			bne 	_CTINotMinus
.1e6c	c8		iny				iny									; skip -
.1e6d					_CTINotMinus:
.1e6d	b1 16		lda ($16),y			lda 	(temp4),y
.1e6f	c9 24		cmp #$24			cmp		#'$'						; if $ then skip it and set hex flag
.1e71	d0 03		bne $1e76			bne 	_CTILoop
.1e73	c6 10		dec $10				dec 	temp1
.1e75	c8		iny				iny
.1e76					_CTILoop:
.1e76	b1 16		lda ($16),y			lda 	(temp4),y 					; next digit
.1e78	29 7f		and #$7f			and 	#$7F 						; drop end of word flag
.1e7a	38		sec				sec
.1e7b	e9 30		sbc #$30			sbc 	#'0' 						; put in range '0'+
.1e7d	90 65		bcc $1ee4			bcc 	_CTIFail 					; out of range.
.1e7f	c9 0a		cmp #$0a			cmp 	#10 						; in 0-9 ?
.1e81	90 0b		bcc $1e8e			bcc 	_CTILegal
.1e83	c9 11		cmp #$11			cmp 	#'A'-'0'					; between 9 and A ?
.1e85	90 5d		bcc $1ee4			bcc 	_CTIFail
.1e87	38		sec				sec
.1e88	e9 07		sbc #$07			sbc 	#7 							; hex adjust
.1e8a	c9 10		cmp #$10			cmp 	#16 						; out of range ?
.1e8c	b0 56		bcs $1ee4			bcs 	_CTIFail
.1e8e					_CTILegal:
.1e8e	48		pha				pha 								; save digit value.
.1e8f	06 14		asl $14				asl 	temp3
.1e91	26 15		rol $15				rol 	temp3+1
.1e93	a5 14		lda $14				lda 	temp3 						; copy x2 into temp2
.1e95	85 12		sta $12				sta 	temp2
.1e97	a5 15		lda $15				lda 	temp3+1
.1e99	85 13		sta $13				sta 	temp2+1
.1e9b	06 14		asl $14				asl 	temp3
.1e9d	26 15		rol $15				rol 	temp3+1
.1e9f	06 14		asl $14				asl 	temp3
.1ea1	26 15		rol $15				rol 	temp3+1
.1ea3	24 10		bit $10				bit 	temp1 						; hexadecimal
.1ea5	10 07		bpl $1eae			bpl 	_CTIDecimal
.1ea7	06 14		asl $14				asl 	temp3
.1ea9	26 15		rol $15				rol 	temp3+1
.1eab	68		pla				pla 								; get digit back
.1eac	80 12		bra $1ec0			bra 	_CTIAddLoop
.1eae					_CTIDecimal:
.1eae	18		clc				clc 								; x 8 + x 2 = x 10
.1eaf	a5 14		lda $14				lda 	temp3
.1eb1	65 12		adc $12				adc 	temp2
.1eb3	85 14		sta $14				sta 	temp3
.1eb5	a5 15		lda $15				lda 	temp3+1
.1eb7	65 13		adc $13				adc 	temp2+1
.1eb9	85 15		sta $15				sta 	temp3+1
.1ebb	68		pla				pla 								; check digit 0-9
.1ebc	c9 0a		cmp #$0a			cmp 	#10
.1ebe	b0 24		bcs $1ee4			bcs 	_CTIFail
.1ec0					_CTIAddLoop:
.1ec0	18		clc				clc
.1ec1	65 14		adc $14				adc 	temp3
.1ec3	85 14		sta $14				sta 	temp3
.1ec5	90 02		bcc $1ec9			bcc 	_CTINoCarry
.1ec7	e6 15		inc $15				inc 	temp3+1
.1ec9					_CTINoCarry:
.1ec9	c8		iny				iny
.1eca	b1 16		lda ($16),y			lda 	(temp4),y 					; was this the last character
.1ecc	c9 21		cmp #$21			cmp 	#32+1
.1ece	b0 a6		bcs $1e76			bcs 	_CTILoop 					; no, go back.
.1ed0	a5 11		lda $11				lda 	temp1+1 					; was it - ?
.1ed2	d0 0d		bne $1ee1			bne 	_CTIOkay
.1ed4	38		sec				sec
.1ed5	a9 00		lda #$00			lda 	#0 							; negate temp3.
.1ed7	e5 14		sbc $14				sbc 	temp3
.1ed9	85 14		sta $14				sta 	temp3
.1edb	a9 00		lda #$00			lda 	#0
.1edd	e5 15		sbc $15				sbc 	temp3+1
.1edf	85 15		sta $15				sta 	temp3+1
.1ee1					_CTIOkay:
.1ee1	98		tya				tya
.1ee2	38		sec				sec
.1ee3	60		rts				rts
.1ee4					_CTIFail:
.1ee4	18		clc				clc
.1ee5	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/skipper.src

.1ee6					NextLine:
.1ee6	18		clc				clc
.1ee7	a5 03		lda $03				lda 	IP
.1ee9	72 03		adc ($03)			adc 	(IP)
.1eeb	85 03		sta $03				sta 	IP
.1eed	90 02		bcc $1ef1			bcc 	_NoCarryAdv
.1eef	e6 04		inc $04				inc 	IP+1
.1ef1					_NoCarryAdv:
.1ef1	b2 03		lda ($03)			lda 	(IP)						; is there any following program ?
.1ef3	f0 05		beq $1efa			beq 	_NLGoEnd
.1ef5	a2 01		ldx #$01			ldx 	#1 							; start 3 in (-2 for Next)
.1ef7	4c 00 00	jmp $0000			jmp 	NextCode
.1efa					_NLGoEnd:
.1efa	4c 14 10	jmp $1014			jmp 	WarmStart
.1efd					SkipComment:
.1efd	e8		inx				inx									; (IP),X points to the length.
.1efe	e8		inx				inx
.1eff	8a		txa				txa
.1f00	a8		tay				tay 								; put into Y
.1f01	18		clc				clc
.1f02	71 03		adc ($03),y			adc 	(IP),y 						; add the length to X
.1f04	aa		tax				tax 								; put back in X
.1f05	ca		dex				dex
.1f06	ca		dex				dex
.1f07	4c 00 00	jmp $0000			jmp 	NextCode
.1f0a					CommentDecoder:
.1f0a	a9 06		lda #$06			lda 	#CTH_Keyword
.1f0c	20 bd 1c	jsr $1cbd			jsr 	DecodeWriteBuffer
.1f0f	a9 27		lda #$27			lda 	#"'"
.1f11	20 bd 1c	jsr $1cbd			jsr 	DecodeWriteBuffer
.1f14	a9 0b		lda #$0b			lda 	#CTH_Comment
.1f16	20 bd 1c	jsr $1cbd			jsr 	DecodeWriteBuffer
.1f19	20 c6 1c	jsr $1cc6			jsr 	DecodeOutputData
.1f1c	a9 20		lda #$20			lda 	#32
.1f1e	20 bd 1c	jsr $1cbd			jsr 	DecodeWriteBuffer
.1f21	60		rts				rts
.1f22					DefineCode:
.1f22	20 3f 10	jsr $103f			jsr 	ErrorHandler
>1f25	44 45 46 49 4e 49 54 49				.text 	"DEFINITION?",0
>1f2d	4f 4e 3f 00
.1f31					DefineDecoder:
.1f31	a9 07		lda #$07			lda 	#CTH_Definition
.1f33	20 bd 1c	jsr $1cbd			jsr 	DecodeWriteBuffer
.1f36	a9 3a		lda #$3a			lda 	#":"
.1f38	20 bd 1c	jsr $1cbd			jsr 	DecodeWriteBuffer
.1f3b	20 c6 1c	jsr $1cc6			jsr 	DecodeOutputData
.1f3e	a9 20		lda #$20			lda 	#32
.1f40	20 bd 1c	jsr $1cbd			jsr 	DecodeWriteBuffer
.1f43	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/tostr.src

.1f44					IntToString:
.1f44	a9 10		lda #$10			lda 	#(textBuffer) & $FF
.1f46	85 12		sta $12				sta 	0+(temp2)
.1f48	a9 08		lda #$08			lda 	#(textBuffer) >> 8
.1f4a	85 13		sta $13				sta 	1+(temp2)
.1f4c	a5 06		lda $06				lda 	TOS 						; value in YA
.1f4e	a4 07		ldy $07				ldy 	TOS+1
.1f50	20 80 1f	jsr $1f80			jsr 	ConvertToString
.1f53	a9 10		lda #$10			lda 	#(textBuffer) & $FF
.1f55	85 06		sta $06				sta 	0+(TOS)
.1f57	a9 08		lda #$08			lda 	#(textBuffer) >> 8
.1f59	85 07		sta $07				sta 	1+(TOS)
.1f5b	4c 00 00	jmp $0000			jmp 	NextCode
.1f5e					PrintYA:
.1f5e	48		pha				pha
.1f5f	da		phx				phx
.1f60	5a		phy				phy
.1f61	48		pha				pha
.1f62	a9 10		lda #$10			lda 	#(textBuffer) & $FF
.1f64	85 12		sta $12				sta 	0+(temp2)
.1f66	a9 08		lda #$08			lda 	#(textBuffer) >> 8
.1f68	85 13		sta $13				sta 	1+(temp2)
.1f6a	68		pla				pla
.1f6b	20 80 1f	jsr $1f80			jsr 	ConvertToString
.1f6e	a2 00		ldx #$00			ldx 	#0
.1f70					_PrintYALoop:
.1f70	bd 10 08	lda $0810,x			lda 	textBuffer,x
.1f73	20 2a 11	jsr $112a			jsr 	ExternPrint
.1f76	e8		inx				inx
.1f77	bd 10 08	lda $0810,x			lda 	textBuffer,x
.1f7a	d0 f4		bne $1f70			bne 	_PrintYALoop
.1f7c	7a		ply				ply
.1f7d	fa		plx				plx
.1f7e	68		pla				pla
.1f7f	60		rts				rts
.1f80					ConvertToString:
.1f80	38		sec				sec
.1f81	80 01		bra $1f84			bra 	ConvertToStringMain
.1f83					ConvertToStringUnsigned:
.1f83	18		clc				clc
.1f84					ConvertToStringMain:
.1f84	da		phx				phx									; save XY
.1f85	5a		phy				phy
.1f86	64 1a		stz $1a				stz 	SignCount 					; this is zero suppression
.1f88	85 10		sta $10				sta 	temp1 						; save YA in temp1
.1f8a	84 11		sty $11				sty 	temp1+1
.1f8c	a0 00		ldy #$00			ldy 	#0 							; index to result.
.1f8e	90 16		bcc $1fa6			bcc 	_CTSUnsigned 				; if carry clear do not adjust for -
.1f90	a5 11		lda $11				lda 	temp1+1 					; is it negative
.1f92	10 12		bpl $1fa6			bpl 	_CTSUnsigned
.1f94	a9 2d		lda #$2d			lda 	#"-"						; output - sign
.1f96	91 12		sta ($12),y			sta 	(temp2),y
.1f98	c8		iny				iny
.1f99	38		sec				sec 								; negate temp1
.1f9a	a9 00		lda #$00			lda 	#0
.1f9c	e5 10		sbc $10				sbc 	temp1
.1f9e	85 10		sta $10				sta 	temp1
.1fa0	a9 00		lda #$00			lda 	#0
.1fa2	e5 11		sbc $11				sbc 	temp1+1
.1fa4	85 11		sta $11				sta 	temp1+1
.1fa6					_CTSUnsigned:
.1fa6	a2 00		ldx #$00			ldx 	#0 							; index into subtraction table
.1fa8					_CTSLoop:
.1fa8	a9 2f		lda #$2f			lda 	#"0"-1						; set the digit to '0' code.
.1faa	91 12		sta ($12),y			sta 	(temp2),y
.1fac					_CTSSubLoop:
.1fac	b1 12		lda ($12),y			lda 	(temp2),y 					; bump the count
.1fae	1a		inc a				inc 	a
.1faf	91 12		sta ($12),y			sta 	(temp2),y
.1fb1	38		sec				sec 								; do subtraction saving interim result
.1fb2	a5 10		lda $10				lda 	temp1
.1fb4	fd e7 1f	sbc $1fe7,x			sbc 	_CTSTable,x
.1fb7	48		pha				pha
.1fb8	a5 11		lda $11				lda 	temp1+1
.1fba	fd e8 1f	sbc $1fe8,x			sbc 	_CTSTable+1,x
.1fbd	90 07		bcc $1fc6			bcc 	_CTSCantSubtract 			; end of subtraction.
.1fbf	85 11		sta $11				sta 	temp1+1 					; save result back
.1fc1	68		pla				pla
.1fc2	85 10		sta $10				sta 	temp1
.1fc4	80 e6		bra $1fac			bra 	_CTSSubLoop
.1fc6					_CTSCantSubtract:
.1fc6	68		pla				pla 								; throw away interim
.1fc7	e8		inx				inx 								; next subtractor
.1fc8	e8		inx				inx
.1fc9	b1 12		lda ($12),y			lda 	(temp2),y 					; update leading zero
.1fcb	49 30		eor #$30			eor 	#"0"
.1fcd	05 1a		ora $1a				ora 	SignCount
.1fcf	85 1a		sta $1a				sta 	SignCount
.1fd1	f0 01		beq $1fd4			beq		_CTSLZ 						; if all zeros so far suppress.
.1fd3	c8		iny				iny 								; next character
.1fd4					_CTSLZ:
.1fd4	e0 08		cpx #$08			cpx 	#_CTSTableEnd-_CTSTable 	; done them all ?
.1fd6	d0 d0		bne $1fa8			bne 	_CTSLoop
.1fd8					_CTSComplete:
.1fd8	a5 10		lda $10				lda		temp1 						; get remainder 0-9
.1fda	09 30		ora #$30			ora 	#48 						; ASCII
.1fdc	91 12		sta ($12),y			sta 	(temp2),y					; write out
.1fde	c8		iny				iny
.1fdf	a9 00		lda #$00			lda 	#0							; make ASCIIZ
.1fe1	91 12		sta ($12),y			sta 	(temp2),y
.1fe3	98		tya				tya 								; size in A
.1fe4	7a		ply				ply									; pull and exit.
.1fe5	fa		plx				plx
.1fe6	60		rts				rts
.1fe7					_CTSTable:
>1fe7	10 27 e8 03 64 00 0a 00				.word 	10000,1000,100,10 			; subtractors, this is a simple version.
.1fef					_CTSTableEnd:

;******  Return to file: kernel.asm


;******  Processing file: words/system/varhandlers.src

.1fef					VarAddressHandler:
.1fef	18		clc				clc 								; find variable, error if it doesn't exist.
.1ff0	20 41 20	jsr $2041			jsr 	VariableFind
.1ff3	a5 06		lda $06				lda 	TOS
.1ff5	48		pha				pha
.1ff6	a5 07		lda $07				lda 	TOS+1
.1ff8	48		pha				pha
.1ff9	a5 10		lda $10				lda 	temp1 						; the address is the new value
.1ffb	85 06		sta $06				sta 	TOS
.1ffd	a5 11		lda $11				lda		temp1+1
.1fff	85 07		sta $07				sta 	TOS+1
.2001	4c 00 00	jmp $0000			jmp 	NextCode
.2004					VarAddrHandlerDecode:
.2004	a9 26		lda #$26			lda 	#"&"
.2006	4c ef 20	jmp $20ef			jmp 	VarHandlerDecode
.2009					VarReadHandler:
.2009	18		clc				clc 								; find variable, error if it doesn't exist.
.200a	20 41 20	jsr $2041			jsr 	VariableFind
.200d	a5 06		lda $06				lda 	TOS
.200f	48		pha				pha
.2010	a5 07		lda $07				lda 	TOS+1
.2012	48		pha				pha
.2013	b2 10		lda ($10)			lda 	(temp1)						; read variable address to TOS
.2015	85 06		sta $06				sta 	TOS
.2017	a0 01		ldy #$01			ldy 	#1
.2019	b1 10		lda ($10),y			lda 	(temp1),y
.201b	85 07		sta $07				sta 	TOS+1
.201d	4c 00 00	jmp $0000			jmp 	NextCode
.2020					VarReadHandlerDecode:
.2020	a9 40		lda #$40			lda 	#"@"
.2022	4c ef 20	jmp $20ef			jmp 	VarHandlerDecode
.2025					VarWriteHandler:
.2025	38		sec				sec 								; find variable, create it if it doesn't exist.
.2026	20 41 20	jsr $2041			jsr 	VariableFind
.2029	a5 06		lda $06				lda 	TOS 						; write TOS to that address.
.202b	92 10		sta ($10)			sta 	(temp1)
.202d	a5 07		lda $07				lda 	TOS+1
.202f	a0 01		ldy #$01			ldy 	#1
.2031	91 10		sta ($10),y			sta 	(temp1),y
.2033	68		pla				pla
.2034	85 07		sta $07				sta 	TOS+1
.2036	68		pla				pla
.2037	85 06		sta $06				sta 	TOS
.2039	4c 00 00	jmp $0000			jmp 	NextCode
.203c					VarWriteHandlerDecode:
.203c	a9 21		lda #$21			lda 	#"!"
.203e	4c ef 20	jmp $20ef			jmp 	VarHandlerDecode
.2041					VariableFind:
.2041	08		php				php 								; save autocreate flag.
.2042	e8		inx				inx 								; advance to/over the variable name.
.2043	e8		inx				inx
.2044	8a		txa				txa 								; put in Y
.2045	a8		tay				tay
.2046	b1 03		lda ($03),y			lda 	(IP),y 						; copy name word into temp2
.2048	85 12		sta $12				sta 	temp2
.204a	c8		iny				iny
.204b	b1 03		lda ($03),y			lda 	(IP),y
.204d	85 13		sta $13				sta 	temp2+1
.204f	c9 1b		cmp #$1b			cmp 	#27 						; check for A-Z
.2051	b0 0f		bcs $2062			bcs 	_VFLong
.2053	a5 13		lda $13				lda 	temp2+1
.2055	d0 0b		bne $2062			bne 	_VFLong
.2057	a5 12		lda $12				lda 	temp2						; this is the index
.2059	0a		asl a				asl 	a 							; double it
.205a	85 10		sta $10				sta 	temp1
.205c	a9 06		lda #$06			lda 	#azVariables >> 8			; set the MSB
.205e	85 11		sta $11				sta 	temp1+1
.2060	28		plp				plp 								; throw creation flag, it always exists.
.2061	60		rts				rts
.2062					_VFLong:
.2062	a5 12		lda $12				lda 	temp2 						; built a hash table index into temp3/temp4
.2064	6a		ror a				ror 	a
.2065	6a		ror a				ror 	a
.2066	6a		ror a				ror 	a
.2067	6a		ror a				ror 	a
.2068	45 12		eor $12				eor 	temp2
.206a	45 13		eor $13				eor 	temp2+1
.206c	29 0f		and #$0f			and 	#(hashTableSize-1)			; force into range
.206e	0a		asl a				asl 	a
.206f	69 40		adc #$40			adc 	#hashTable & $FF 			; make an address of the head => temp1/3
.2071	85 10		sta $10				sta 	temp1
.2073	85 14		sta $14				sta 	temp3
.2075	a9 06		lda #$06			lda 	#hashTable >> 8
.2077	85 11		sta $11				sta 	temp1+1
.2079	85 15		sta $15				sta 	temp3+1
.207b					_VFSearch:
.207b	a0 01		ldy #$01			ldy 	#1							; read MSB of first record
.207d	b1 10		lda ($10),y			lda 	(temp1),y
.207f	f0 23		beq $20a4			beq 	_VFNotFound 				; is MSB is zero, can't be a variable record
.2081	a8		tay				tay 								; follow the link through.
.2082	b2 10		lda ($10)			lda 	(temp1)
.2084	85 10		sta $10				sta 	temp1
.2086	84 11		sty $11				sty 	temp1+1
.2088	a0 04		ldy #$04			ldy 	#4							; check if the name matches
.208a	b1 10		lda ($10),y			lda 	(temp1),y
.208c	c5 12		cmp $12				cmp 	temp2
.208e	d0 eb		bne $207b			bne 	_VFSearch 					; if it doesn't, follow the next link.
.2090	c8		iny				iny 								; same for 2nd byte of name
.2091	b1 10		lda ($10),y			lda 	(temp1),y
.2093	c5 13		cmp $13				cmp 	temp2+1
.2095	d0 e4		bne $207b			bne 	_VFSearch
.2097	18		clc				clc
.2098	a5 10		lda $10				lda 	temp1 						; make temp1 point to the data at offset 2
.209a	69 02		adc #$02			adc 	#2
.209c	85 10		sta $10				sta 	temp1
.209e	90 02		bcc $20a2			bcc 	_VFNoPage1
.20a0	e6 11		inc $11				inc 	temp1+1
.20a2					_VFNoPage1:
.20a2	28		plp				plp 								; don't need to worry about creation flag
.20a3	60		rts				rts
.20a4					_VFNotFound:
.20a4	28		plp				plp 								; was carry set, e.g. create a new record if not found ?
.20a5	b0 0d		bcs $20b4			bcs 	_VFCreate
.20a7	20 3f 10	jsr $103f			jsr 	ErrorHandler
>20aa	56 41 52 49 41 42 4c 45				.text 	"VARIABLE?",0
>20b2	3f 00
.20b4					_VFCreate:
.20b4	a0 01		ldy #$01			ldy 	#1
.20b6	b2 14		lda ($14)			lda 	(temp3) 					; copy the head link to the first 2 bytes
.20b8	92 0e		sta ($0e)			sta 	(nextFreeMem)
.20ba	b1 14		lda ($14),y			lda 	(temp3),y
.20bc	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.20be	c8		iny				iny
.20bf	a9 00		lda #$00			lda 	#0	 						; write zero initialised data out.
.20c1	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.20c3	c8		iny				iny
.20c4	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.20c6	c8		iny				iny
.20c7	a5 12		lda $12				lda 	temp2 						; copy the name out
.20c9	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.20cb	c8		iny				iny
.20cc	a5 13		lda $13				lda 	temp2+1
.20ce	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.20d0	a0 01		ldy #$01			ldy 	#1
.20d2	a5 0e		lda $0e				lda 	nextFreeMem 				; update the head link
.20d4	92 14		sta ($14)			sta 	(temp3)
.20d6	a5 0f		lda $0f				lda 	nextFreeMem+1
.20d8	91 14		sta ($14),y			sta 	(temp3),y
.20da	18		clc				clc
.20db	a5 0e		lda $0e				lda 	nextFreeMem 				; put nextFreeMem+2 in temp1 (data pointer)
.20dd	69 02		adc #$02			adc 	#2
.20df	85 10		sta $10				sta 	temp1
.20e1	a5 0f		lda $0f				lda 	nextFreeMem+1
.20e3	69 00		adc #$00			adc 	#0
.20e5	85 11		sta $11				sta 	temp1+1
.20e7	a9 06		lda #$06			lda 	#6							; shift freemem pointer up 6
.20e9	a0 00		ldy #$00			ldy 	#0
.20eb	20 ba 1b	jsr $1bba			jsr 	AdvanceFreeMem
.20ee	60		rts				rts
.20ef					VarHandlerDecode:
.20ef	48		pha				pha 								; save, leading space
.20f0	a9 20		lda #$20			lda 	#" "
.20f2	20 bd 1c	jsr $1cbd			jsr 	DecodeWriteBuffer
.20f5	68		pla				pla 								; restore and write type
.20f6	20 bd 1c	jsr $1cbd			jsr 	DecodeWriteBuffer
.20f9	b1 08		lda ($08),y			lda 	(srcPtr),y 					; copy to temp1
.20fb	85 10		sta $10				sta 	temp1
.20fd	c8		iny				iny
.20fe	b1 08		lda ($08),y			lda 	(srcPtr),y
.2100	85 11		sta $11				sta 	temp1+1
.2102	a5 10		lda $10				lda 	temp1 						; output the first character
.2104	29 1f		and #$1f			and 	#31
.2106	20 31 21	jsr $2131			jsr 	VHOutVarChar
.2109	a2 05		ldx #$05			ldx 	#5 							; divide temp1 by 32
.210b					_VHDShift:
.210b	46 11		lsr $11				lsr 	temp1+1
.210d	66 10		ror $10				ror 	temp1
.210f	ca		dex				dex
.2110	d0 f9		bne $210b			bne 	_VHDShift
.2112	a2 ff		ldx #$ff			ldx 	#255 						; now divide that by 40 by repeated subtraction.
.2114					_VHDDiv40:
.2114	e8		inx				inx
.2115	38		sec				sec
.2116	a5 10		lda $10				lda 	temp1
.2118	e9 28		sbc #$28			sbc 	#40
.211a	a8		tay				tay
.211b	a5 11		lda $11				lda 	temp1+1
.211d	e9 00		sbc #$00			sbc 	#0
.211f	90 06		bcc $2127			bcc 	_VHDivDone
.2121	85 11		sta $11				sta 	temp1+1
.2123	84 10		sty $10				sty 	temp1
.2125	80 ed		bra $2114			bra 	_VHDDiv40
.2127					_VHDivDone:
.2127	a5 10		lda $10				lda 	temp1 						; remainder
.2129	20 31 21	jsr $2131			jsr 	VHOutVarChar
.212c	8a		txa				txa
.212d	20 31 21	jsr $2131			jsr 	VHOutVarChar 				; and result.
.2130	60		rts				rts
.2131					VHOutVarChar:
.2131	c9 00		cmp #$00			cmp 	#0
.2133	f0 0c		beq $2141			beq 	_VHOExit
.2135	18		clc				clc
.2136	69 40		adc #$40			adc 	#64 						; 65-90 A-Z 91-100 0-9
.2138	c9 5b		cmp #$5b			cmp 	#91 						; convert back ?
.213a	90 02		bcc $213e			bcc 	_VHOOut
.213c	e9 2b		sbc #$2b			sbc 	#91-48 						; adjust to digit
.213e					_VHOOut:
.213e	20 bd 1c	jsr $1cbd			jsr 	DecodeWriteBuffer
.2141					_VHOExit:
.2141	60		rts				rts

;******  Return to file: kernel.asm

.2142					Dictionary:

;******  Processing file: generated/dictionary.inc

>2142	05					.byte	_end1-*
>2143	00					.byte	$00
>2144	1b 16					.word	WordWrite
>2146	a1					.byte	$a1
.2147					_end1:
>2147	10					.byte	_end2-*
>2148	52					.byte	$52
>2149	25 20					.word	VarWriteHandler
>214b	3c 20					.word	VarWriteHandlerDecode
>214d	24 24 21 48 41 4e 44 4c			.byte	$24,$24,$21,$48,$41,$4e,$44,$4c,$45,$d2
>2155	45 d2
.2157					_end2:
>2157	10					.byte	_end3-*
>2158	52					.byte	$52
>2159	ef 1f					.word	VarAddressHandler
>215b	04 20					.word	VarAddrHandlerDecode
>215d	24 24 26 48 41 4e 44 4c			.byte	$24,$24,$26,$48,$41,$4e,$44,$4c,$45,$d2
>2165	45 d2
.2167					_end3:
>2167	10					.byte	_end4-*
>2168	52					.byte	$52
>2169	09 20					.word	VarReadHandler
>216b	20 20					.word	VarReadHandlerDecode
>216d	24 24 40 48 41 4e 44 4c			.byte	$24,$24,$40,$48,$41,$4e,$44,$4c,$45,$d2
>2175	45 d2
.2177					_end4:
>2177	0c					.byte	_end5-*
>2178	52					.byte	$52
>2179	3a 1a					.word	CallHandler
>217b	f6 1a					.word	CallHandlerDecode
>217d	24 24 43 41 4c cc			.byte	$24,$24,$43,$41,$4c,$cc
.2183					_end5:
>2183	0f					.byte	_end6-*
>2184	53					.byte	$53
>2185	fd 1e					.word	SkipComment
>2187	0a 1f					.word	CommentDecoder
>2189	24 24 43 4f 4d 4d 45 4e			.byte	$24,$24,$43,$4f,$4d,$4d,$45,$4e,$d4
>2191	d4
.2192					_end6:
>2192	0e					.byte	_end7-*
>2193	53					.byte	$53
>2194	22 1f					.word	DefineCode
>2196	31 1f					.word	DefineDecoder
>2198	24 24 44 45 46 49 4e c5			.byte	$24,$24,$44,$45,$46,$49,$4e,$c5
.21a0					_end7:
>21a0	0f					.byte	_end8-*
>21a1	52					.byte	$52
>21a2	a5 10					.word	Literal2Byte
>21a4	bb 10					.word	Literal2ByteDecode
>21a6	24 24 4c 49 54 45 52 41			.byte	$24,$24,$4c,$49,$54,$45,$52,$41,$cc
>21ae	cc
.21af					_end8:
>21af	0e					.byte	_end9-*
>21b0	80					.byte	$80
>21b1	e6 1e					.word	NextLine
>21b3	24 24 4e 45 58 54 4c 49			.byte	$24,$24,$4e,$45,$58,$54,$4c,$49,$4e,$c5
>21bb	4e c5
.21bd					_end9:
>21bd	0e					.byte	_end10-*
>21be	53					.byte	$53
>21bf	cd 10					.word	LiteralString
>21c1	ec 10					.word	LiteralStringDecoder
>21c3	24 24 53 54 52 49 4e c7			.byte	$24,$24,$53,$54,$52,$49,$4e,$c7
.21cb					_end10:
>21cb	05					.byte	_end11-*
>21cc	00					.byte	$00
>21cd	97 13					.word	Multiply16x16
>21cf	aa					.byte	$aa
.21d0					_end11:
>21d0	05					.byte	_end12-*
>21d1	00					.byte	$00
>21d2	04 12					.word	Add
>21d4	ab					.byte	$ab
.21d5					_end12:
>21d5	06					.byte	_end13-*
>21d6	00					.byte	$00
>21d7	2c 16					.word	WordAdd
>21d9	2b a1					.byte	$2b,$a1
.21db					_end13:
>21db	05					.byte	_end14-*
>21dc	00					.byte	$00
>21dd	13 12					.word	Subtract
>21df	ad					.byte	$ad
.21e0					_end14:
>21e0	06					.byte	_end15-*
>21e1	00					.byte	$00
>21e2	d3 14					.word	ConstantMinus1
>21e4	2d b1					.byte	$2d,$b1
.21e6					_end15:
>21e6	06					.byte	_end16-*
>21e7	00					.byte	$00
>21e8	19 1e					.word	DumpStack
>21ea	2e ae					.byte	$2e,$ae
.21ec					_end16:
>21ec	05					.byte	_end17-*
>21ed	00					.byte	$00
>21ee	e8 12					.word	Divide16x16
>21f0	af					.byte	$af
.21f1					_end17:
>21f1	05					.byte	_end18-*
>21f2	00					.byte	$00
>21f3	c6 14					.word	Constant0
>21f5	b0					.byte	$b0
.21f6					_end18:
>21f6	06					.byte	_end19-*
>21f7	00					.byte	$00
>21f8	2c 14					.word	CheckMinus
>21fa	30 bc					.byte	$30,$bc
.21fc					_end19:
>21fc	06					.byte	_end20-*
>21fd	00					.byte	$00
>21fe	40 14					.word	CheckZero
>2200	30 bd					.byte	$30,$bd
.2202					_end20:
>2202	05					.byte	_end21-*
>2203	00					.byte	$00
>2204	e2 14					.word	C1
>2206	b1					.byte	$b1
.2207					_end21:
>2207	06					.byte	_end22-*
>2208	00					.byte	$00
>2209	d6 13					.word	Unary1Plus
>220b	31 ab					.byte	$31,$ab
.220d					_end22:
>220d	06					.byte	_end23-*
>220e	00					.byte	$00
>220f	ed 13					.word	Unary1Minus
>2211	31 ad					.byte	$31,$ad
.2213					_end23:
>2213	06					.byte	_end24-*
>2214	00					.byte	$00
>2215	fa 14					.word	C10
>2217	31 b0					.byte	$31,$b0
.2219					_end24:
>2219	07					.byte	_end25-*
>221a	00					.byte	$00
>221b	23 15					.word	C100
>221d	31 30 b0				.byte	$31,$30,$b0
.2220					_end25:
>2220	08					.byte	_end26-*
>2221	00					.byte	$00
>2222	52 15					.word	C1024
>2224	31 30 32 b4				.byte	$31,$30,$32,$b4
.2228					_end26:
>2228	07					.byte	_end27-*
>2229	00					.byte	$00
>222a	27 15					.word	C127
>222c	31 32 b7				.byte	$31,$32,$b7
.222f					_end27:
>222f	07					.byte	_end28-*
>2230	00					.byte	$00
>2231	2b 15					.word	C128
>2233	31 32 b8				.byte	$31,$32,$b8
.2236					_end28:
>2236	06					.byte	_end29-*
>2237	00					.byte	$00
>2238	fe 14					.word	C15
>223a	31 b5					.byte	$31,$b5
.223c					_end29:
>223c	06					.byte	_end30-*
>223d	00					.byte	$00
>223e	02 15					.word	C16
>2240	31 b6					.byte	$31,$b6
.2242					_end30:
>2242	07					.byte	_end31-*
>2243	00					.byte	$00
>2244	64 14					.word	Times16
>2246	31 36 aa				.byte	$31,$36,$aa
.2249					_end31:
>2249	07					.byte	_end32-*
>224a	00					.byte	$00
>224b	77 14					.word	Divide16
>224d	31 36 af				.byte	$31,$36,$af
.2250					_end32:
>2250	05					.byte	_end33-*
>2251	00					.byte	$00
>2252	e6 14					.word	C2
>2254	b2					.byte	$b2
.2255					_end33:
>2255	06					.byte	_end34-*
>2256	00					.byte	$00
>2257	70 14					.word	Times2
>2259	32 aa					.byte	$32,$aa
.225b					_end34:
>225b	06					.byte	_end35-*
>225c	00					.byte	$00
>225d	df 13					.word	Unary2Plus
>225f	32 ab					.byte	$32,$ab
.2261					_end35:
>2261	06					.byte	_end36-*
>2262	00					.byte	$00
>2263	f8 13					.word	Unary2Minus
>2265	32 ad					.byte	$32,$ad
.2267					_end36:
>2267	06					.byte	_end37-*
>2268	00					.byte	$00
>2269	83 14					.word	Divide2
>226b	32 af					.byte	$32,$af
.226d					_end37:
>226d	06					.byte	_end38-*
>226e	00					.byte	$00
>226f	06 15					.word	C24
>2271	32 b4					.byte	$32,$b4
.2273					_end38:
>2273	07					.byte	_end39-*
>2274	00					.byte	$00
>2275	2f 15					.word	C255
>2277	32 35 b5				.byte	$32,$35,$b5
.227a					_end39:
>227a	07					.byte	_end40-*
>227b	00					.byte	$00
>227c	3a 15					.word	C256
>227e	32 35 b6				.byte	$32,$35,$b6
.2281					_end40:
>2281	08					.byte	_end41-*
>2282	00					.byte	$00
>2283	8a 14					.word	Times256
>2285	32 35 36 aa				.byte	$32,$35,$36,$aa
.2289					_end41:
>2289	08					.byte	_end42-*
>228a	00					.byte	$00
>228b	93 14					.word	Divide256
>228d	32 35 36 af				.byte	$32,$35,$36,$af
.2291					_end42:
>2291	05					.byte	_end43-*
>2292	00					.byte	$00
>2293	ea 14					.word	C3
>2295	b3					.byte	$b3
.2296					_end43:
>2296	06					.byte	_end44-*
>2297	00					.byte	$00
>2298	17 15					.word	C32
>229a	33 b2					.byte	$33,$b2
.229c					_end44:
>229c	09					.byte	_end45-*
>229d	00					.byte	$00
>229e	6a 15					.word	C32767
>22a0	33 32 37 36 b7				.byte	$33,$32,$37,$36,$b7
.22a5					_end45:
>22a5	09					.byte	_end46-*
>22a6	00					.byte	$00
>22a7	76 15					.word	C32768
>22a9	33 32 37 36 b8				.byte	$33,$32,$37,$36,$b8
.22ae					_end46:
>22ae	05					.byte	_end47-*
>22af	00					.byte	$00
>22b0	ee 14					.word	C4
>22b2	b4					.byte	$b4
.22b3					_end47:
>22b3	06					.byte	_end48-*
>22b4	00					.byte	$00
>22b5	6c 14					.word	Times4
>22b7	34 aa					.byte	$34,$aa
.22b9					_end48:
>22b9	06					.byte	_end49-*
>22ba	00					.byte	$00
>22bb	7f 14					.word	Divide4
>22bd	34 af					.byte	$34,$af
.22bf					_end49:
>22bf	08					.byte	_end50-*
>22c0	00					.byte	$00
>22c1	5e 15					.word	C4096
>22c3	34 30 39 b6				.byte	$34,$30,$39,$b6
.22c7					_end50:
>22c7	05					.byte	_end51-*
>22c8	00					.byte	$00
>22c9	f2 14					.word	C5
>22cb	b5					.byte	$b5
.22cc					_end51:
>22cc	07					.byte	_end52-*
>22cd	00					.byte	$00
>22ce	46 15					.word	C512
>22d0	35 31 b2				.byte	$35,$31,$b2
.22d3					_end52:
>22d3	06					.byte	_end53-*
>22d4	00					.byte	$00
>22d5	1b 15					.word	C63
>22d7	36 b3					.byte	$36,$b3
.22d9					_end53:
>22d9	06					.byte	_end54-*
>22da	00					.byte	$00
>22db	1f 15					.word	C64
>22dd	36 b4					.byte	$36,$b4
.22df					_end54:
>22df	05					.byte	_end55-*
>22e0	00					.byte	$00
>22e1	f6 14					.word	C8
>22e3	b8					.byte	$b8
.22e4					_end55:
>22e4	06					.byte	_end56-*
>22e5	00					.byte	$00
>22e6	68 14					.word	Times8
>22e8	38 aa					.byte	$38,$aa
.22ea					_end56:
>22ea	06					.byte	_end57-*
>22eb	00					.byte	$00
>22ec	7b 14					.word	Divide8
>22ee	38 af					.byte	$38,$af
.22f0					_end57:
>22f0	05					.byte	_end58-*
>22f1	40					.byte	$40
>22f2	bf 1a					.word	ReturnHandler
>22f4	bb					.byte	$bb
.22f5					_end58:
>22f5	05					.byte	_end59-*
>22f6	00					.byte	$00
>22f7	84 12					.word	CheckLess
>22f9	bc					.byte	$bc
.22fa					_end59:
>22fa	06					.byte	_end60-*
>22fb	00					.byte	$00
>22fc	9d 12					.word	CheckLessEq
>22fe	3c bd					.byte	$3c,$bd
.2300					_end60:
>2300	06					.byte	_end61-*
>2301	00					.byte	$00
>2302	4d 12					.word	CheckNotEqual
>2304	3c be					.byte	$3c,$be
.2306					_end61:
>2306	05					.byte	_end62-*
>2307	00					.byte	$00
>2308	50 12					.word	CheckEqual
>230a	bd					.byte	$bd
.230b					_end62:
>230b	05					.byte	_end63-*
>230c	00					.byte	$00
>230d	a0 12					.word	CheckGreater
>230f	be					.byte	$be
.2310					_end63:
>2310	06					.byte	_end64-*
>2311	00					.byte	$00
>2312	81 12					.word	CheckGreaterEq
>2314	3e bd					.byte	$3e,$bd
.2316					_end64:
>2316	08					.byte	_end65-*
>2317	00					.byte	$00
>2318	8b 15					.word	TestDup
>231a	3f 44 55 d0				.byte	$3f,$44,$55,$d0
.231e					_end65:
>231e	05					.byte	_end66-*
>231f	00					.byte	$00
>2320	00 16					.word	WordRead
>2322	c0					.byte	$c0
.2323					_end66:
>2323	07					.byte	_end67-*
>2324	00					.byte	$00
>2325	06 14					.word	Absolute
>2327	41 42 d3				.byte	$41,$42,$d3
.232a					_end67:
>232a	09					.byte	_end68-*
>232b	00					.byte	$00
>232c	43 16					.word	AllocateMemory
>232e	41 4c 4c 4f c3				.byte	$41,$4c,$4c,$4f,$c3
.2333					_end68:
>2333	07					.byte	_end69-*
>2334	00					.byte	$00
>2335	26 12					.word	And
>2337	41 4e c4				.byte	$41,$4e,$c4
.233a					_end69:
>233a	0a					.byte	_end70-*
>233b	00					.byte	$00
>233c	a4 1d					.word	AssertCode
>233e	41 53 53 45 52 d4			.byte	$41,$53,$53,$45,$52,$d4
.2344					_end70:
>2344	09					.byte	_end71-*
>2345	00					.byte	$00
>2346	59 14					.word	ByteSwap
>2348	42 53 57 41 d0				.byte	$42,$53,$57,$41,$d0
.234d					_end71:
>234d	06					.byte	_end72-*
>234e	00					.byte	$00
>234f	0e 16					.word	ByteWrite
>2351	43 a1					.byte	$43,$a1
.2353					_end72:
>2353	06					.byte	_end73-*
>2354	00					.byte	$00
>2355	f7 15					.word	ByteRead
>2357	43 c0					.byte	$43,$c0
.2359					_end73:
>2359	07					.byte	_end74-*
>235a	00					.byte	$00
>235b	80 1b					.word	ClrHandler
>235d	43 4c d2				.byte	$43,$4c,$d2
.2360					_end74:
>2360	08					.byte	_end75-*
>2361	00					.byte	$00
>2362	82 15					.word	Drop
>2364	44 52 4f d0				.byte	$44,$52,$4f,$d0
.2368					_end75:
>2368	07					.byte	_end76-*
>2369	00					.byte	$00
>236a	94 15					.word	Dup
>236c	44 55 d0				.byte	$44,$55,$d0
.236f					_end76:
>236f	08					.byte	_end77-*
>2370	01					.byte	$01
>2371	0c 1a					.word	ElseHandler
>2373	45 4c 53 c5				.byte	$45,$4c,$53,$c5
.2377					_end77:
>2377	07					.byte	_end78-*
>2378	00					.byte	$00
>2379	c5 1d					.word	EndProgram
>237b	45 4e c4				.byte	$45,$4e,$c4
.237e					_end78:
>237e	09					.byte	_end79-*
>237f	00					.byte	$00
>2380	0f 1a					.word	EndIfHandler
>2382	45 4e 44 49 c6				.byte	$45,$4e,$44,$49,$c6
.2387					_end79:
>2387	07					.byte	_end80-*
>2388	00					.byte	$00
>2389	84 19					.word	ForHandler
>238b	46 4f d2				.byte	$46,$4f,$d2
.238e					_end80:
>238e	06					.byte	_end81-*
>238f	01					.byte	$01
>2390	09 1a					.word	IfHandler
>2392	49 c6					.byte	$49,$c6
.2394					_end81:
>2394	09					.byte	_end82-*
>2395	00					.byte	$00
>2396	e8 19					.word	GetIndex
>2398	49 4e 44 45 d8				.byte	$49,$4e,$44,$45,$d8
.239d					_end82:
>239d	08					.byte	_end83-*
>239e	00					.byte	$00
>239f	fc 1c					.word	ListCode
>23a1	4c 49 53 d4				.byte	$4c,$49,$53,$d4
.23a5					_end83:
>23a5	07					.byte	_end84-*
>23a6	00					.byte	$00
>23a7	bd 12					.word	Maximum
>23a9	4d 41 d8				.byte	$4d,$41,$d8
.23ac					_end84:
>23ac	07					.byte	_end85-*
>23ad	00					.byte	$00
>23ae	b9 12					.word	Minimum
>23b0	4d 49 ce				.byte	$4d,$49,$ce
.23b3					_end85:
>23b3	07					.byte	_end86-*
>23b4	00					.byte	$00
>23b5	f9 12					.word	Modulus16x16
>23b7	4d 4f c4				.byte	$4d,$4f,$c4
.23ba					_end86:
>23ba	0a					.byte	_end87-*
>23bb	00					.byte	$00
>23bc	0d 14					.word	Negate
>23be	4e 45 47 41 54 c5			.byte	$4e,$45,$47,$41,$54,$c5
.23c4					_end87:
>23c4	07					.byte	_end88-*
>23c5	00					.byte	$00
>23c6	77 1b					.word	NewHandler
>23c8	4e 45 d7				.byte	$4e,$45,$d7
.23cb					_end88:
>23cb	08					.byte	_end89-*
>23cc	01					.byte	$01
>23cd	b2 19					.word	NextHandler
>23cf	4e 45 58 d4				.byte	$4e,$45,$58,$d4
.23d3					_end89:
>23d3	07					.byte	_end90-*
>23d4	00					.byte	$00
>23d5	c8 15					.word	Nip
>23d7	4e 49 d0				.byte	$4e,$49,$d0
.23da					_end90:
>23da	07					.byte	_end91-*
>23db	00					.byte	$00
>23dc	1d 14					.word	OneComplement
>23de	4e 4f d4				.byte	$4e,$4f,$d4
.23e1					_end91:
>23e1	06					.byte	_end92-*
>23e2	00					.byte	$00
>23e3	40 12					.word	LogOr
>23e5	4f d2					.byte	$4f,$d2
.23e7					_end92:
>23e7	08					.byte	_end93-*
>23e8	00					.byte	$00
>23e9	b0 15					.word	Over
>23eb	4f 56 45 d2				.byte	$4f,$56,$45,$d2
.23ef					_end93:
>23ef	0a					.byte	_end94-*
>23f0	00					.byte	$00
>23f1	12 1a					.word	RepeatHandler
>23f3	52 45 50 45 41 d4			.byte	$52,$45,$50,$45,$41,$d4
.23f9					_end94:
>23f9	07					.byte	_end95-*
>23fa	00					.byte	$00
>23fb	9c 14					.word	RandomNumber
>23fd	52 4e c4				.byte	$52,$4e,$c4
.2400					_end95:
>2400	07					.byte	_end96-*
>2401	00					.byte	$00
>2402	cd 15					.word	Rot
>2404	52 4f d4				.byte	$52,$4f,$d4
.2407					_end96:
>2407	07					.byte	_end97-*
>2408	00					.byte	$00
>2409	79 1d					.word	RunProgram
>240b	52 55 ce				.byte	$52,$55,$ce
.240e					_end97:
>240e	07					.byte	_end98-*
>240f	00					.byte	$00
>2410	48 14					.word	SignTOS
>2412	53 47 ce				.byte	$53,$47,$ce
.2415					_end98:
>2415	08					.byte	_end99-*
>2416	00					.byte	$00
>2417	bd 1d					.word	StopCode
>2419	53 54 4f d0				.byte	$53,$54,$4f,$d0
.241d					_end99:
>241d	08					.byte	_end100-*
>241e	00					.byte	$00
>241f	9d 15					.word	Swap
>2421	53 57 41 d0				.byte	$53,$57,$41,$d0
.2425					_end100:
>2425	07					.byte	_end101-*
>2426	00					.byte	$00
>2427	8d 1d					.word	Call6502
>2429	53 59 d3				.byte	$53,$59,$d3
.242c					_end101:
>242c	0d					.byte	_end102-*
>242d	00					.byte	$00
>242e	44 1f					.word	IntToString
>2430	54 4f 2e 53 54 52 49 4e			.byte	$54,$4f,$2e,$53,$54,$52,$49,$4e,$c7
>2438	c7
.2439					_end102:
>2439	09					.byte	_end103-*
>243a	01					.byte	$01
>243b	15 1a					.word	UntilHandler
>243d	55 4e 54 49 cc				.byte	$55,$4e,$54,$49,$cc
.2442					_end103:
>2442	09					.byte	_end104-*
>2443	00					.byte	$00
>2444	c8 1d					.word	VlistCode
>2446	56 4c 49 53 d4				.byte	$56,$4c,$49,$53,$d4
.244b					_end104:
>244b	0a					.byte	_end105-*
>244c	40					.byte	$40
>244d	cb 1b					.word	BreakCmd
>244f	58 42 52 45 41 cb			.byte	$58,$42,$52,$45,$41,$cb
.2455					_end105:
>2455	09					.byte	_end106-*
>2456	00					.byte	$00
>2457	c5 1b					.word	ExitDump
>2459	58 44 55 4d d0				.byte	$58,$44,$55,$4d,$d0
.245e					_end106:
>245e	07					.byte	_end107-*
>245f	00					.byte	$00
>2460	33 12					.word	Xor
>2462	58 4f d2				.byte	$58,$4f,$d2
.2465					_end107:
>2465	00					.byte	0

;******  Return to file: kernel.asm

>3fff	ff						.byte 	$FF
.4000					ProgramMemory:

;******  End of listing
