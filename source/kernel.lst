
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -q -D encode=0 -c -o kernel_nocode.prg -L kernel.lst -l kernel.lbl kernel.asm
; Wed Jan 15 20:10:50 2020

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=0					encode=0

;******  Processing input file: kernel.asm

=$1000					RplBuild = $1000 							; code starts here.

;******  Processing file: code/data.asm

.0000					NextCode:
>0000							.fill 	5
=3					IP = NextCode+3 							; the IP which points to the current instruction
.0005					rsp:
>0005							.byte 	?
.0006					tos:
>0006							.word 	?
.0008					srcPtr:
>0008							.word 	?
.000a					bufPtr:
>000a							.word 	?
.000c					matchPtr:
>000c							.word 	?
.000e					nextFreeMem:
>000e							.word 	?
.0010					temp1:
>0010							.word 	?
.0012					temp2:
>0012							.word 	?
.0014					temp3:
>0014							.word 	?
.0016					temp4:
>0016							.word 	?
.0018					listPtr:
>0018							.word 	?
.001a					SignCount:
>001a							.byte 	?
.001b					RandomSeed:
>001b							.word 	?
.001d					ListCount:
>001d							.byte 	?
.001e					ListLowest:
>001e							.word 	?
=$102					stack2Low = $102							; access other stack members following tsx
=$101					stack2High = $101							; (which requires saving X, not on the stack !)
=$104					stack3Low = $104
=$103					stack3High = $103
=$600					azVariables = $600 							; 26 x 2 variables occupying 52 bytes * PAGE BOUNDARY *
=16					hashTableSize = 16 							; hash tables for variables.
=$640					hashTable = $640 							; hash tables start here * ALL ON ONE PAGE *
=$810					textBuffer = $810 							; buffer for text.
=$700					returnStack = $700							; return stack (1 page)
=$700					returnStackLow = returnStack
=1856					returnStackHigh = returnStack+$40
=1920					returnStackX = returnStack+$80
=$80					NumberStackBase = $80 						; number stack down from here.
=$910					encodeBuffer = $910 						; buffer for encoded program
=0					COL_BLACK = 0
=1					COL_RED = 1
=2					COL_GREEN = 2
=3					COL_YELLOW = 3
=4					COL_BLUE = 4
=5					COL_MAGENTA = 5
=6					COL_CYAN = 6
=7					COL_WHITE = 7
=8					COL_RVS = 8
=2					CTH_LineNo = COL_Green
=6					CTH_Keyword = COL_Cyan
=11					CTH_Comment = COL_Yellow+COL_Rvs
=7					CTH_Definition = COL_White
=5					CTH_String = COL_Magenta
=3					CTH_Call = COL_Yellow
=7					CTH_Variable = COL_White

;******  Return to file: kernel.asm

.1000	a2 ff		ldx #$ff			ldx 	#$FF 						; reset the stack
.1002	9a		txs				txs
.1003	20 31 11	jsr $1131			jsr 	ExternInitialise
.1006	a9 43		lda #$43			lda 	#BootMsg & $FF
.1008	a0 10		ldy #$10			ldy 	#BootMsg >> 8
.100a	20 23 12	jsr $1223			jsr 	EXPrintString
.100d					WarmStartBlankStack:
.100d	86 10		stx $10				stx 	temp1
.100f	a2 80		ldx #$80			ldx 	#NumberStackBase
.1011	9a		txs				txs
.1012	a6 10		ldx $10				ldx 	temp1
.1014					WarmStart:
.1014	a9 03		lda #$03			lda 	#COL_Yellow
.1016	20 68 11	jsr $1168			jsr 	ExternColour
.1019	20 8b 11	jsr $118b			jsr 	ExternInput
.101c	a9 06		lda #$06			lda 	#COL_Cyan
.101e	20 68 11	jsr $1168			jsr 	ExternColour
.1021	a2 10		ldx #$10			ldx 	#encodeBuffer & $FF 		; run what is in the encode buffer.
.1023	a0 09		ldy #$09			ldy 	#encodeBuffer >> 8
.1025	20 95 10	jsr $1095			jsr 	InitialiseCoreCode 			; initialise the NEXT routine at $00 so error line# works
.1028	a9 10		lda #$10			lda 	#textBuffer & $FF
.102a	a0 08		ldy #$08			ldy 	#textBuffer >> 8
.102c	20 8f 16	jsr $168f			jsr 	EncodeProgram
.102f	ad 11 09	lda $0911			lda 	encodeBuffer+1 				; has a line number been entered ?
.1032	0d 12 09	ora $0912			ora 	encodeBuffer+2
.1035	d0 07		bne $103e			bne 	LineEditor 					; if so, do the line editing code.
.1037	a9 ff		lda #$ff			lda 	#$FF
.1039	85 05		sta $05				sta 	rsp
.103b	4c 00 00	jmp $0000			jmp 	NextCode
.103e					LineEditor:
.103e	20 9e 1e	jsr $1e9e			jsr 	EditProgram
.1041	80 ca		bra $100d			bra 	WarmStartBlankStack
.1043					BootMsg:
>1043	2a 2a 2a 20 52 50 4c 2f				.text 	"*** RPL/C INTERPRETER ***",13,13
>104b	43 20 49 4e 54 45 52 50 52 45 54 45 52 20 2a 2a
>105b	2a 0d 0d
>105e	57 52 49 54 54 45 4e 20				.text	"WRITTEN BY PAUL ROBSON 2020",13,13
>1066	42 59 20 50 41 55 4c 20 52 4f 42 53 4f 4e 20 32
>1076	30 32 30 0d 0d
>107b	42 55 49 4c 44 3a 20				.text 	"BUILD: "

;******  Processing file: generated/timestamp.inc

>1082	5b 32 30 2d 30 31 2d 31			.text	"[20-01-15 20:10]"
>108a	35 20 32 30 3a 31 30 5d

;******  Return to file: kernel.asm

>1092	0d 0d 00					.byte 	13,13,0

;******  Processing file: code/core.src

.1095					InitialiseCoreCode:
.1095	a9 e8		lda #$e8			lda 	#$E8 					; Copy INX INX 			4 cycles when run
.1097	85 00		sta $00				sta 	NextCode
.1099	85 01		sta $01				sta 	NextCode+1
.109b	a9 7c		lda #$7c			lda 	#$7C 					; Copy JMP ($aaaa,x) 	6 cycles when run
.109d	85 02		sta $02				sta 	NextCode+2
.109f	86 03		stx $03				stx 	NextCode+3 				; set the indirect address (IP)
.10a1	84 04		sty $04				sty 	NextCode+4
.10a3	a2 01		ldx #$01			ldx 	#1 						; set up to run from provided word.
.10a5	60		rts				rts								; (2 INX skip offset and line#)
.10a6					Literal2Byte:
.10a6	a5 06		lda $06				lda 	TOS
.10a8	48		pha				pha
.10a9	a5 07		lda $07				lda 	TOS+1
.10ab	48		pha				pha
.10ac	e8		inx				inx  							; point X to the word
.10ad	e8		inx				inx
.10ae	8a		txa				txa 							; copy into Y
.10af	a8		tay				tay
.10b0	b1 03		lda ($03),y			lda 	(IP),y 					; read it. the LSB
.10b2	85 06		sta $06				sta 	TOS
.10b4	c8		iny				iny 							; read and push the MSB
.10b5	b1 03		lda ($03),y			lda 	(IP),y
.10b7	85 07		sta $07				sta 	TOS+1
.10b9	4c 00 00	jmp $0000			jmp 	NextCode
.10bc					Literal2ByteDecode:
.10bc	a9 06		lda #$06			lda 	#CTH_Keyword
.10be	20 5f 1e	jsr $1e5f			jsr 	DecodeWriteBuffer
.10c1	b1 08		lda ($08),y			lda 	(srcPtr),y
.10c3	aa		tax				tax
.10c4	c8		iny				iny
.10c5	b1 08		lda ($08),y			lda 	(srcPtr),y
.10c7	a8		tay				tay
.10c8	8a		txa				txa
.10c9	38		sec				sec 							; output signed
.10ca	20 81 1e	jsr $1e81			jsr 	DecodeYAToBuffer
.10cd	60		rts				rts
.10ce					LiteralString:
.10ce	a5 06		lda $06				lda 	TOS
.10d0	48		pha				pha
.10d1	a5 07		lda $07				lda 	TOS+1
.10d3	48		pha				pha
.10d4	e8		inx				inx
.10d5	e8		inx				inx 							; skip over current word
.10d6	8a		txa				txa 							; add to IP + 1 to give string address
.10d7	a8		tay				tay 							; put in Y
.10d8	38		sec				sec 							; make that TOS
.10d9	65 03		adc $03				adc 	IP
.10db	85 06		sta $06				sta 	TOS
.10dd	a5 04		lda $04				lda 	IP+1
.10df	69 00		adc #$00			adc 	#0
.10e1	85 07		sta $07				sta 	TOS+1
.10e3	8a		txa				txa 							; add data length to X
.10e4	18		clc				clc
.10e5	71 03		adc ($03),y			adc 	(IP),y
.10e7	aa		tax				tax
.10e8	ca		dex				dex
.10e9	ca		dex				dex
.10ea	4c 00 00	jmp $0000			jmp 	NextCode
.10ed					LiteralStringDecoder:
.10ed	a9 05		lda #$05			lda 	#CTH_String
.10ef	20 5f 1e	jsr $1e5f			jsr 	DecodeWriteBuffer
.10f2	a9 22		lda #$22			lda 	#'"'
.10f4	20 5f 1e	jsr $1e5f			jsr 	DecodeWriteBuffer
.10f7	20 68 1e	jsr $1e68			jsr 	DecodeOutputData
.10fa	20 5f 1e	jsr $1e5f			jsr 	DecodeWriteBuffer
.10fd	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: code/error.asm

.10fe					ErrorHandler:
.10fe	68		pla				pla 								; get message address
.10ff	7a		ply				ply
.1100	1a		inc a				inc 	a
.1101	d0 01		bne $1104			bne 	_EHNoCarry
.1103	c8		iny				iny
.1104					_EHNoCarry:
.1104	20 23 12	jsr $1223			jsr 	EXPrintString
.1107	a0 01		ldy #$01			ldy 	#1 							; check if there is a line #
.1109	b1 03		lda ($03),y			lda 	(IP),y
.110b	c8		iny				iny
.110c	11 03		ora ($03),y			ora 	(IP),y
.110e	f0 14		beq $1124			beq 	_EHNoLine
.1110	a9 2c		lda #$2c			lda 	#_EHMsg2 & $FF 				; print " at "
.1112	a0 11		ldy #$11			ldy 	#_EHMsg2 >> 8
.1114	20 23 12	jsr $1223			jsr 	EXPrintString
.1117	a0 02		ldy #$02			ldy 	#2 							; print line number
.1119	b1 03		lda ($03),y			lda 	(IP),y
.111b	48		pha				pha
.111c	88		dey				dey
.111d	b1 03		lda ($03),y			lda 	(IP),y
.111f	7a		ply				ply
.1120	18		clc				clc
.1121	20 85 22	jsr $2285			jsr 	PrintYA
.1124					_EHNoLine:
.1124	a9 0d		lda #$0d			lda 	#13
.1126	20 5e 11	jsr $115e			jsr 	ExternPrint
.1129	4c 0d 10	jmp $100d			jmp 	WarmStartBlankStack			; S is indeterminate
>112c	20 41 54 20 00			_EHMsg2:.text 	" AT ",0

;******  Return to file: kernel.asm


;******  Processing file: code/extern.asm

.1131					ExternInitialise:
.1131	a9 90		lda #$90			lda 	#144 						; set colour
.1133	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.1136	a9 01		lda #$01			lda 	#$01
.1138	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.113b	a9 0e		lda #$0e			lda 	#14							; lower case
.113d	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.1140	a9 93		lda #$93			lda 	#147 						; clear screen
.1142	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.1145	a9 07		lda #$07			lda 	#COL_WHITE 					; white text.
.1147	4c 68 11	jmp $1168			jmp 	ExternColour
.114a					ExternCheckBreak:
.114a	da		phx				phx 								; make sure we keep XY
.114b	5a		phy				phy
.114c	20 e1 ff	jsr $ffe1			jsr 	$FFE1						; STOP check on CBM KERNAL
.114f	f0 03		beq $1154			beq		_ECBExit 					; stopped
.1151	7a		ply				ply 								; restore and exit.
.1152	fa		plx				plx
.1153	60		rts				rts
.1154					_ECBExit:
.1154	20 fe 10	jsr $10fe			jsr 	ErrorHandler
>1157	45 53 43 41 50 45 00				.text 	"ESCAPE",0
.115e					ExternPrint:
.115e	48		pha				pha
.115f	da		phx				phx
.1160	5a		phy				phy
.1161	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.1164	7a		ply				ply
.1165	fa		plx				plx
.1166	68		pla				pla
.1167	60		rts				rts
.1168					ExternColour:
.1168	48		pha				pha
.1169	da		phx				phx
.116a	48		pha				pha
.116b	29 08		and #$08			and 	#8
.116d	0a		asl a				asl 	a
.116e	0a		asl a				asl 	a
.116f	0a		asl a				asl 	a
.1170	0a		asl a				asl 	a
.1171	49 92		eor #$92			eor 	#$92
.1173	20 5e 11	jsr $115e			jsr 	ExternPrint
.1176	68		pla				pla
.1177	29 07		and #$07			and 	#7
.1179	aa		tax				tax
.117a	bd 83 11	lda $1183,x			lda 	_ECTable,x
.117d	20 5e 11	jsr $115e			jsr 	ExternPrint
.1180	fa		plx				plx
.1181	68		pla				pla
.1182	60		rts				rts
.1183					_ECTable:
>1183	90						.byte 	144
>1184	1c						.byte 	28
>1185	1e						.byte 	30
>1186	9e						.byte 	158
>1187	1f						.byte 	31
>1188	9c						.byte 	156
>1189	9f						.byte 	159
>118a	05						.byte 	5
.118b					ExternInput:
.118b	a9 10		lda #$10			lda 	#(textBuffer & $FF)
.118d	85 14		sta $14				sta 	temp3
.118f	a9 08		lda #$08			lda 	#(textBuffer >> 8)
.1191	85 15		sta $15				sta 	temp3+1
.1193	20 cf ff	jsr $ffcf	_EIRead:jsr 	$FFCF
.1196	29 7f		and #$7f			and 	#$7F
.1198	c9 0d		cmp #$0d			cmp 	#13
.119a	f0 0a		beq $11a6			beq 	_EIExit
.119c	92 14		sta ($14)			sta 	(temp3)
.119e	e6 14		inc $14				inc 	temp3
.11a0	d0 f1		bne $1193			bne 	_EIRead
.11a2	e6 15		inc $15				inc 	temp3+1
.11a4	80 ed		bra $1193			bra 	_EIRead
.11a6	a9 00		lda #$00	_EIExit:lda 	#0
.11a8	92 14		sta ($14)			sta 	(temp3)
.11aa	a9 0d		lda #$0d			lda 	#13
.11ac	20 5e 11	jsr $115e			jsr 	ExternPrint
.11af	60		rts				rts
.11b0					ExternSave:
.11b0	da		phx				phx
.11b1	5a		phy				phy
.11b2	85 12		sta $12				sta 	temp2 						; save start
.11b4	84 13		sty $13				sty 	temp2+1
.11b6	20 18 12	jsr $1218			jsr 	EXGetLength 				; get length of file into A
.11b9	a6 14		ldx $14				ldx 	temp3
.11bb	a4 15		ldy $15				ldy 	temp3+1
.11bd	20 bd ff	jsr $ffbd			jsr 	$FFBD 						; set name
.11c0	a9 01		lda #$01			lda 	#1
.11c2	a2 08		ldx #$08			ldx 	#8	 						; device #8
.11c4	a0 00		ldy #$00			ldy 	#0
.11c6	20 ba ff	jsr $ffba			jsr 	$FFBA 						; set LFS
.11c9	a6 10		ldx $10				ldx 	temp1 						; end address
.11cb	a4 11		ldy $11				ldy 	temp1+1
.11cd	a9 12		lda #$12			lda 	#temp2
.11cf	20 d8 ff	jsr $ffd8			jsr 	$FFD8 						; save
.11d2	b0 03		bcs $11d7			bcs 	_ESSave
.11d4	7a		ply				ply
.11d5	fa		plx				plx
.11d6	60		rts				rts
.11d7					_ESSave:
.11d7	20 fe 10	jsr $10fe			jsr 	ErrorHandler
>11da	53 41 56 45 20 46 41 49				.text 	"SAVE FAILED",0
>11e2	4c 45 44 00
.11e6					ExternLoad:
.11e6	da		phx				phx 								; save XY
.11e7	5a		phy				phy
.11e8	48		pha				pha 								; save target
.11e9	5a		phy				phy
.11ea	20 18 12	jsr $1218			jsr 	EXGetLength 				; get length of file into A
.11ed	a6 14		ldx $14				ldx 	temp3
.11ef	a4 15		ldy $15				ldy 	temp3+1
.11f1	20 bd ff	jsr $ffbd			jsr 	$FFBD 						; set name
.11f4	a9 01		lda #$01			lda 	#1
.11f6	a2 08		ldx #$08			ldx 	#8	 						; device #8
.11f8	a0 00		ldy #$00			ldy 	#0
.11fa	20 ba ff	jsr $ffba			jsr 	$FFBA 						; set LFS
.11fd	7a		ply				ply 								; restore target to YX and call load
.11fe	fa		plx				plx
.11ff	a9 00		lda #$00			lda 	#0 							; load command
.1201	20 d5 ff	jsr $ffd5			jsr 	$FFD5
.1204	b0 03		bcs $1209			bcs 	_ESLoad
.1206	7a		ply				ply
.1207	fa		plx				plx
.1208	60		rts				rts
.1209					_ESLoad:
.1209	20 fe 10	jsr $10fe			jsr 	ErrorHandler
>120c	4c 4f 41 44 20 46 41 49				.text 	"LOAD FAILED",0
>1214	4c 45 44 00
.1218					EXGetLength:
.1218	5a		phy				phy
.1219	a0 ff		ldy #$ff			ldy 	#255
.121b	c8		iny		_EXGL0:	iny
.121c	b1 14		lda ($14),y			lda 	(temp3),y
.121e	d0 fb		bne $121b			bne 	_EXGL0
.1220	98		tya				tya
.1221	7a		ply				ply
.1222	60		rts				rts
.1223					EXPrintString:
.1223	48		pha				pha
.1224	5a		phy				phy
.1225	84 11		sty $11				sty 	temp1+1
.1227	85 10		sta $10				sta 	temp1
.1229	a0 00		ldy #$00			ldy 	#0
.122b					_EXPSLoop:
.122b	b1 10		lda ($10),y			lda 	(temp1),y
.122d	f0 08		beq $1237			beq 	_EXPSExit
.122f	29 7f		and #$7f			and 	#$7F
.1231	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.1234	c8		iny				iny
.1235	80 f4		bra $122b			bra 	_EXPSLoop
.1237					_EXPSExit:
.1237	7a		ply				ply
.1238	68		pla				pla
.1239	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/binary.src

.123a					Add:
.123a	7a		ply				ply
.123b	68		pla				pla
.123c	18		clc				clc
.123d	65 06		adc $06				adc 	TOS
.123f	85 06		sta $06				sta 	TOS
.1241	98		tya				tya
.1242	65 07		adc $07				adc 	TOS+1
.1244	85 07		sta $07				sta 	TOS+1
.1246	4c 00 00	jmp $0000			jmp 	NextCode
.1249					Subtract:
.1249	7a		ply				ply
.124a	68		pla				pla
.124b	38		sec				sec
.124c	49 ff		eor #$ff			eor 	#$FF
.124e	65 06		adc $06				adc 	TOS
.1250	85 06		sta $06				sta 	TOS
.1252	98		tya				tya
.1253	49 ff		eor #$ff			eor 	#$FF
.1255	65 07		adc $07				adc 	TOS+1
.1257	85 07		sta $07				sta 	TOS+1
.1259	4c 00 00	jmp $0000			jmp 	NextCode
.125c					And:
.125c	68		pla				pla
.125d	25 07		and $07				and 	TOS+1
.125f	85 07		sta $07				sta 	TOS+1
.1261	68		pla				pla
.1262	25 06		and $06				and 	TOS
.1264	85 06		sta $06				sta 	TOS
.1266	4c 00 00	jmp $0000			jmp 	NextCode
.1269					Xor:
.1269	68		pla				pla
.126a	45 07		eor $07				eor 	TOS+1
.126c	85 07		sta $07				sta 	TOS+1
.126e	68		pla				pla
.126f	45 06		eor $06				eor 	TOS
.1271	85 06		sta $06				sta 	TOS
.1273	4c 00 00	jmp $0000			jmp 	NextCode
.1276					LogOr:
.1276	68		pla				pla
.1277	05 07		ora $07				ora 	TOS+1
.1279	85 07		sta $07				sta 	TOS+1
.127b	68		pla				pla
.127c	05 06		ora $06				ora 	TOS
.127e	85 06		sta $06				sta 	TOS
.1280	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/compare.src

.1283					CheckNotEqual:
.1283	38		sec				sec
.1284	80 01		bra $1287			bra 	CECode
.1286					CheckEqual:
.1286	18		clc				clc
.1287					CECode:
.1287	86 10		stx $10				stx 	temp1
.1289	ba		tsx				tsx
.128a	08		php				php
.128b	a5 06		lda $06				lda 	TOS
.128d	5d 02 01	eor $0102,x			eor 	Stack2Low,x
.1290	d0 17		bne $12a9			bne	 	CompareFalse
.1292	a5 07		lda $07				lda 	TOS+1
.1294	5d 01 01	eor $0101,x			eor 	Stack2High,x
.1297	d0 10		bne $12a9			bne 	CompareFalse
.1299					CompareTrue:
.1299	a6 10		ldx $10				ldx 	temp1
.129b	28		plp				plp
.129c	b0 10		bcs $12ae			bcs		CompareFalse2
.129e					CompareTrue2:
.129e	68		pla				pla
.129f	68		pla				pla
.12a0	a9 ff		lda #$ff			lda 	#$FF
.12a2	85 06		sta $06				sta 	TOS
.12a4	85 07		sta $07				sta 	TOS+1
.12a6	4c 00 00	jmp $0000			jmp 	NextCode
.12a9					CompareFalse:
.12a9	a6 10		ldx $10				ldx 	temp1
.12ab	28		plp				plp
.12ac	b0 f0		bcs $129e			bcs		CompareTrue2
.12ae					CompareFalse2:
.12ae	68		pla				pla
.12af	68		pla				pla
.12b0	64 06		stz $06				stz 	TOS
.12b2	64 07		stz $07				stz 	TOS+1
.12b4	4c 00 00	jmp $0000			jmp 	NextCode
.12b7					CheckGreaterEq:
.12b7	38		sec				sec
.12b8	80 01		bra $12bb			bra		CLCode
.12ba					CheckLess:
.12ba	18		clc				clc
.12bb	86 10		stx $10		CLCode:	stx 	temp1
.12bd	ba		tsx				tsx
.12be	08		php				php
.12bf	18		clc				clc
.12c0	a5 06		lda $06				lda 	TOS
.12c2	fd 02 01	sbc $0102,x			sbc 	Stack2Low,x
.12c5	a5 07		lda $07				lda 	TOS+1
.12c7	fd 01 01	sbc $0101,x			sbc 	Stack2High,x
.12ca	50 02		bvc $12ce			bvc 	_CLNoFlip
.12cc	49 80		eor #$80			eor 	#$80
.12ce					_CLNoFlip:
.12ce	0a		asl a				asl 	a
.12cf	b0 d8		bcs $12a9			bcs 	CompareFalse
.12d1	80 c6		bra $1299			bra 	CompareTrue
.12d3					CheckLessEq:
.12d3	38		sec				sec
.12d4	80 01		bra $12d7			bra		CGCode
.12d6					CheckGreater:
.12d6	18		clc				clc
.12d7					CGCode:
.12d7	86 10		stx $10				stx 	temp1
.12d9	ba		tsx				tsx
.12da	08		php				php
.12db	18		clc				clc
.12dc	bd 02 01	lda $0102,x			lda 	Stack2Low,x
.12df	e5 06		sbc $06				sbc 	TOS
.12e1	bd 01 01	lda $0101,x			lda 	Stack2High,x
.12e4	e5 07		sbc $07				sbc 	TOS+1
.12e6	50 02		bvc $12ea			bvc 	_CGNoFlip
.12e8	49 80		eor #$80			eor 	#$80
.12ea					_CGNoFlip:
.12ea	0a		asl a				asl 	a
.12eb	b0 bc		bcs $12a9			bcs 	CompareFalse
.12ed	80 aa		bra $1299			bra 	CompareTrue
.12ef					Minimum:
.12ef	a9 00		lda #$00			lda 	#0
.12f1	80 02		bra $12f5			bra 	MinMaxCode
.12f3					Maximum:
.12f3	a9 80		lda #$80			lda 	#$80
.12f5					MinMaxCode:
.12f5	85 11		sta $11				sta 	temp1+1
.12f7	86 10		stx $10				stx 	temp1
.12f9	ba		tsx				tsx
.12fa	38		sec				sec
.12fb	a5 06		lda $06				lda 	TOS
.12fd	fd 02 01	sbc $0102,x			sbc 	Stack2Low,x
.1300	a5 07		lda $07				lda 	TOS+1
.1302	fd 01 01	sbc $0101,x			sbc 	Stack2High,x
.1305	50 02		bvc $1309			bvc 	_MMNoFlip
.1307	49 80		eor #$80			eor 	#$80
.1309					_MMNoFlip:
.1309	45 11		eor $11				eor 	temp1+1
.130b	30 0a		bmi $1317			bmi 	_MMNoCopy
.130d	bd 02 01	lda $0102,x			lda 	Stack2Low,x
.1310	85 06		sta $06				sta 	TOS
.1312	bd 01 01	lda $0101,x			lda 	Stack2High,x
.1315	85 07		sta $07				sta 	TOS+1
.1317					_MMNoCopy:
.1317	a6 10		ldx $10				ldx 	temp1
.1319	68		pla				pla
.131a	68		pla				pla
.131b	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/divide.src

.131e					Divide16x16:
.131e	86 12		stx $12				stx 	temp2
.1320	ba		tsx				tsx
.1321	20 44 13	jsr $1344			jsr 	IntegerDivide
.1324	68		pla				pla
.1325	85 07		sta $07				sta 	TOS+1
.1327	68		pla				pla
.1328	85 06		sta $06				sta 	TOS
.132a	a6 12		ldx $12				ldx 	temp2
.132c	4c 00 00	jmp $0000			jmp 	NextCode
.132f					Modulus16x16:
.132f	86 12		stx $12				stx 	temp2
.1331	ba		tsx				tsx
.1332	20 44 13	jsr $1344			jsr 	IntegerDivide
.1335	a6 12		ldx $12				ldx 	temp2
.1337	68		pla				pla
.1338	68		pla				pla
.1339	a5 10		lda $10				lda 	temp1
.133b	85 06		sta $06				sta 	TOS
.133d	a5 11		lda $11				lda 	temp1+1
.133f	85 07		sta $07				sta 	TOS+1
.1341	4c 00 00	jmp $0000			jmp 	NextCode
.1344					IntegerDivide:
.1344	a5 06		lda $06				lda 	TOS 				; check for division by zero.
.1346	05 07		ora $07				ora 	TOS+1
.1348	d0 14		bne $135e			bne 	_BFDOkay
.134a	20 fe 10	jsr $10fe			jsr 	ErrorHandler
>134d	44 49 56 49 53 49 4f 4e				.text 	"DIVISION BY ZERO",0
>1355	20 42 59 20 5a 45 52 4f 00
.135e					_BFDOkay:
.135e	64 10		stz $10				stz 	temp1 						; Q/Dividend/Left in +0
.1360	64 11		stz $11				stz 	temp1+1 					; M/Divisor/Right in +2
.1362	64 1a		stz $1a				stz 	SignCount 					; Count of signs.
.1364	20 9f 13	jsr $139f			jsr 	CheckIntegerNegate 			; negate 2nd (and bump sign count)
.1367	20 b9 13	jsr $13b9			jsr 	CheckTOSNegate 				; negate TOS (and bump sign count)
.136a	5a		phy				phy 								; Y is the counter
.136b	a0 10		ldy #$10			ldy 	#16 						; 16 iterations of the loop.
.136d					_BFDLoop:
.136d	1e 02 01	asl $0102,x			asl 	Stack2Low,x 				; shift AQ left.
.1370	3e 01 01	rol $0101,x			rol 	Stack2High,x
.1373	26 10		rol $10				rol 	temp1
.1375	26 11		rol $11				rol 	temp1+1
.1377	38		sec				sec
.1378	a5 10		lda $10				lda 	temp1+0 					; Calculate A-M on stack.
.137a	e5 06		sbc $06				sbc 	TOS
.137c	48		pha				pha
.137d	a5 11		lda $11				lda 	temp1+1
.137f	e5 07		sbc $07				sbc 	TOS+1
.1381	90 0f		bcc $1392			bcc 	_BFDNoAdd
.1383	85 11		sta $11				sta 	temp1+1
.1385	68		pla				pla
.1386	85 10		sta $10				sta 	temp1+0
.1388	bd 02 01	lda $0102,x			lda 	Stack2Low,x 				; set Q bit 1.
.138b	09 01		ora #$01			ora 	#1
.138d	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.1390	80 01		bra $1393			bra 	_BFDNext
.1392					_BFDNoAdd:
.1392	68		pla				pla 								; Throw away the intermediate calculations
.1393					_BFDNext:
.1393	88		dey				dey
.1394	d0 d7		bne $136d			bne 	_BFDLoop
.1396	7a		ply				ply 								; restore Y
.1397	46 1a		lsr $1a				lsr 	SignCount 					; if sign count odd,
.1399	90 03		bcc $139e			bcc 	_BFDUnsigned 				; then the result is signed
.139b	20 a5 13	jsr $13a5			jsr		IntegerNegateAlways 		; negate the result
.139e					_BFDUnsigned:
.139e	60		rts				rts
.139f					CheckIntegerNegate:
.139f	bd 01 01	lda $0101,x			lda 	Stack2High,x 				; is it -ve = MSB set ?
.13a2	30 01		bmi $13a5			bmi 	IntegerNegateAlways 		; if so negate it
.13a4	60		rts				rts
.13a5					IntegerNegateAlways:
.13a5	e6 1a		inc $1a				inc 	SignCount 					; bump the count of signs
.13a7	38		sec				sec 								; negate
.13a8	a9 00		lda #$00			lda 	#0
.13aa	fd 02 01	sbc $0102,x			sbc 	Stack2Low,x
.13ad	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.13b0	a9 00		lda #$00			lda 	#0
.13b2	fd 01 01	sbc $0101,x			sbc 	Stack2High,x
.13b5	9d 01 01	sta $0101,x			sta 	Stack2High,x
.13b8	60		rts				rts
.13b9					CheckTOSNegate:
.13b9	a5 07		lda $07				lda 	TOS+1
.13bb	10 0f		bpl $13cc			bpl		CTNNoChange
.13bd	e6 1a		inc $1a				inc 	SignCount
.13bf					TOSNegateAlways:
.13bf	38		sec				sec
.13c0	a9 00		lda #$00			lda 	#0
.13c2	e5 06		sbc $06				sbc 	TOS
.13c4	85 06		sta $06				sta 	TOS
.13c6	a9 00		lda #$00			lda 	#0
.13c8	e5 07		sbc $07				sbc 	TOS+1
.13ca	85 07		sta $07				sta 	TOS+1
.13cc					CTNNoChange:
.13cc	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/multiply.src

.13cd					Multiply16x16:
.13cd	86 10		stx $10				stx 	temp1
.13cf	ba		tsx				tsx
.13d0	bd 02 01	lda $0102,x			lda 	Stack2Low,x 				; 2nd value on stack to temp1
.13d3	85 12		sta $12				sta 	temp2
.13d5	bd 01 01	lda $0101,x			lda		Stack2High,x
.13d8	85 13		sta $13				sta 	temp2+1
.13da	9e 02 01	stz $0102,x			stz 	Stack2Low,x 				; zero 2nd value on stack
.13dd	9e 01 01	stz $0101,x			stz 	Stack2High,x
.13e0					_MultLoop:
.13e0	46 13		lsr $13				lsr 	temp2+1 					; ror temp2 into C
.13e2	66 12		ror $12				ror 	temp2
.13e4	90 11		bcc $13f7			bcc 	_MultNoAdd
.13e6	18		clc				clc 								; add 1st to 2nd
.13e7	a5 06		lda $06				lda 	TOS
.13e9	7d 02 01	adc $0102,x			adc 	Stack2Low,x
.13ec	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.13ef	a5 07		lda $07				lda 	TOS+1
.13f1	7d 01 01	adc $0101,x			adc 	Stack2High,x
.13f4	9d 01 01	sta $0101,x			sta 	Stack2High,x
.13f7					_MultNoAdd:
.13f7	06 06		asl $06				asl 	TOS 						; shift 1st left
.13f9	26 07		rol $07				rol 	TOS+1
.13fb	a5 12		lda $12				lda 	temp2	 					; until zero
.13fd	05 13		ora $13				ora 	temp2+1
.13ff	d0 df		bne $13e0			bne 	_MultLoop
.1401	a6 10		ldx $10				ldx 	temp1 						; restore X load result
.1403	68		pla				pla
.1404	85 07		sta $07				sta 	TOS+1
.1406	68		pla				pla
.1407	85 06		sta $06				sta 	TOS
.1409	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/unary.src

.140c					Unary1Plus:
.140c	e6 06		inc $06				inc 	TOS
.140e	d0 02		bne $1412			bne 	_U1PSkip
.1410	e6 07		inc $07				inc 	TOS+1
.1412					_U1PSkip:
.1412	4c 00 00	jmp $0000			jmp 	NextCode
.1415					Unary2Plus:
.1415	18		clc				clc
.1416	a5 06		lda $06				lda 	TOS
.1418	69 02		adc #$02			adc 	#2
.141a	85 06		sta $06				sta 	TOS
.141c	90 02		bcc $1420			bcc 	_U1PSkip
.141e	e6 07		inc $07				inc 	TOS+1
.1420					_U1PSkip:
.1420	4c 00 00	jmp $0000			jmp 	NextCode
.1423					Unary1Minus:
.1423	a5 06		lda $06				lda 	TOS
.1425	d0 02		bne $1429			bne 	_U1MSkip
.1427	c6 07		dec $07				dec 	TOS+1
.1429					_U1MSkip:
.1429	c6 06		dec $06				dec 	TOS
.142b	4c 00 00	jmp $0000			jmp 	NextCode
.142e					Unary2Minus:
.142e	38		sec				sec
.142f	a5 06		lda $06				lda 	TOS
.1431	e9 02		sbc #$02			sbc 	#2
.1433	85 06		sta $06				sta 	TOS
.1435	b0 02		bcs $1439			bcs 	_U1PSkip
.1437	c6 07		dec $07				dec 	TOS+1
.1439					_U1PSkip:
.1439	4c 00 00	jmp $0000			jmp 	NextCode
.143c					Absolute:
.143c	a5 07		lda $07				lda 	TOS+1
.143e	30 03		bmi $1443			bmi 	Negate
.1440	4c 00 00	jmp $0000			jmp 	NextCode
.1443					Negate:
.1443	38		sec				sec
.1444	a9 00		lda #$00			lda 	#0
.1446	e5 06		sbc $06				sbc 	TOS
.1448	85 06		sta $06				sta 	TOS
.144a	a9 00		lda #$00			lda 	#0
.144c	e5 07		sbc $07				sbc 	TOS+1
.144e	85 07		sta $07				sta 	TOS+1
.1450	4c 00 00	jmp $0000			jmp 	NextCode
.1453					OneComplement:
.1453	a5 06		lda $06				lda 	TOS
.1455	49 ff		eor #$ff			eor 	#$FF
.1457	85 06		sta $06				sta 	TOS
.1459	a5 07		lda $07				lda 	TOS+1
.145b	49 ff		eor #$ff			eor 	#$FF
.145d	85 07		sta $07				sta 	TOS+1
.145f	4c 00 00	jmp $0000			jmp 	NextCode
.1462					CheckMinus:
.1462	a5 07		lda $07				lda 	TOS+1
.1464	30 07		bmi $146d			bmi 	UnaryTrue
.1466					UnaryFalse:
.1466	64 06		stz $06				stz 	TOS
.1468	64 07		stz $07				stz 	TOS+1
.146a	4c 00 00	jmp $0000			jmp 	NextCode
.146d					UnaryTrue:
.146d	a9 ff		lda #$ff			lda 	#$FF
.146f	85 06		sta $06				sta 	TOS
.1471	85 07		sta $07				sta 	TOS+1
.1473	4c 00 00	jmp $0000			jmp 	NextCode
.1476					CheckZero:
.1476	a5 06		lda $06				lda 	TOS
.1478	05 07		ora $07				ora 	TOS+1
.147a	d0 ea		bne $1466			bne 	UnaryFalse
.147c	80 ef		bra $146d			bra 	UnaryTrue
.147e					SignTOS:
.147e	a5 07		lda $07				lda 	TOS+1
.1480	30 eb		bmi $146d			bmi		UnaryTrue
.1482	05 06		ora $06				ora 	TOS
.1484	f0 e0		beq $1466			beq 	UnaryFalse
.1486	a9 01		lda #$01			lda 	#1
.1488	85 06		sta $06				sta 	TOS
.148a	64 07		stz $07				stz		TOS+1
.148c	4c 00 00	jmp $0000			jmp 	NextCode
.148f					ByteSwap:
.148f	a5 06		lda $06				lda 	TOS
.1491	a4 07		ldy $07				ldy 	TOS+1
.1493	85 07		sta $07				sta 	TOS+1
.1495	84 06		sty $06				sty 	TOS
.1497	4c 00 00	jmp $0000			jmp 	NextCode
.149a					Times16:
.149a	06 06		asl $06				asl 	TOS
.149c	26 07		rol $07				rol 	TOS+1
.149e					Times8:
.149e	06 06		asl $06				asl 	TOS
.14a0	26 07		rol $07				rol 	TOS+1
.14a2					Times4:
.14a2	06 06		asl $06				asl 	TOS
.14a4	26 07		rol $07				rol 	TOS+1
.14a6					Times2:
.14a6	06 06		asl $06				asl 	TOS
.14a8	26 07		rol $07				rol 	TOS+1
.14aa	4c 00 00	jmp $0000			jmp 	NextCode
.14ad					Divide16:
.14ad	46 07		lsr $07				lsr 	TOS+1
.14af	66 06		ror $06				ror 	TOS
.14b1					Divide8:
.14b1	46 07		lsr $07				lsr 	TOS+1
.14b3	66 06		ror $06				ror 	TOS
.14b5					Divide4:
.14b5	46 07		lsr $07				lsr 	TOS+1
.14b7	66 06		ror $06				ror 	TOS
.14b9					Divide2:
.14b9	46 07		lsr $07				lsr 	TOS+1
.14bb	66 06		ror $06				ror 	TOS
.14bd	4c 00 00	jmp $0000			jmp 	NextCode
.14c0					Times256:
.14c0	a5 06		lda $06				lda 	TOS
.14c2	85 07		sta $07				sta 	TOS+1
.14c4	64 06		stz $06				stz 	TOS
.14c6	4c 00 00	jmp $0000			jmp 	NextCode
.14c9					Divide256:
.14c9	a5 07		lda $07				lda 	TOS+1
.14cb	85 06		sta $06				sta 	TOS
.14cd	64 07		stz $07				stz 	TOS+1
.14cf	4c 00 00	jmp $0000			jmp 	NextCode
.14d2					RandomNumber:
.14d2	a5 06		lda $06				lda 	TOS
.14d4	48		pha				pha
.14d5	a5 07		lda $07				lda 	TOS+1
.14d7	48		pha				pha
.14d8	a5 1b		lda $1b				lda 	randomSeed
.14da	05 1c		ora $1c				ora 	randomSeed+1
.14dc	d0 08		bne $14e6			bne 	_RH_NoInit
.14de	a9 7c		lda #$7c			lda 	#$7C
.14e0	85 1b		sta $1b				sta 	randomSeed
.14e2	a9 a1		lda #$a1			lda 	#$A1
.14e4	85 1c		sta $1c				sta 	randomSeed+1
.14e6					_RH_NoInit:
.14e6	a5 1b		lda $1b				lda 	randomSeed
.14e8	4a		lsr a		        lsr		a
.14e9	26 1c		rol $1c		        rol 	randomSeed+1
.14eb	90 02		bcc $14ef	        bcc 	_RH_NoEor
.14ed	49 b4		eor #$b4	        eor 	#$B4
.14ef					_RH_NoEor:
.14ef	85 1b		sta $1b		        sta 	randomSeed
.14f1	45 1c		eor $1c		        eor 	randomSeed+1
.14f3	85 07		sta $07		        sta 	TOS+1
.14f5	a5 1b		lda $1b		        lda 	randomSeed
.14f7	85 06		sta $06		        sta 	TOS
.14f9	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/data/literals.src

.14fc					Constant0:
.14fc	a5 06		lda $06				lda 	TOS
.14fe	48		pha				pha
.14ff	a5 07		lda $07				lda 	TOS+1
.1501	48		pha				pha
.1502	64 06		stz $06				stz 	TOS
.1504	64 07		stz $07				stz 	TOS+1
.1506	4c 00 00	jmp $0000			jmp 	NextCode
.1509					ConstantMinus1:
.1509	a5 06		lda $06				lda 	TOS
.150b	48		pha				pha
.150c	a5 07		lda $07				lda 	TOS+1
.150e	48		pha				pha
.150f	a9 ff		lda #$ff			lda 	#$FF
.1511	85 06		sta $06				sta 	TOS
.1513	85 07		sta $07				sta 	TOS+1
.1515	4c 00 00	jmp $0000			jmp 	NextCode
.1518					C1:
.1518	a0 01		ldy #$01			ldy 	#1
.151a	80 24		bra $1540			bra 	Const1Byte
.151c					C2:
.151c	a0 02		ldy #$02			ldy 	#2
.151e	80 20		bra $1540			bra 	Const1Byte
.1520					C3:
.1520	a0 03		ldy #$03			ldy 	#3
.1522	80 1c		bra $1540			bra 	Const1Byte
.1524					C4:
.1524	a0 04		ldy #$04			ldy 	#4
.1526	80 18		bra $1540			bra 	Const1Byte
.1528					C5:
.1528	a0 05		ldy #$05			ldy 	#5
.152a	80 14		bra $1540			bra 	Const1Byte
.152c					C8:
.152c	a0 08		ldy #$08			ldy 	#8
.152e	80 10		bra $1540			bra 	Const1Byte
.1530					C10:
.1530	a0 0a		ldy #$0a			ldy 	#10
.1532	80 0c		bra $1540			bra 	Const1Byte
.1534					C15:
.1534	a0 0f		ldy #$0f			ldy 	#15
.1536	80 08		bra $1540			bra 	Const1Byte
.1538					C16:
.1538	a0 10		ldy #$10			ldy 	#16
.153a	80 04		bra $1540			bra 	Const1Byte
.153c					C24:
.153c	a0 18		ldy #$18			ldy 	#24
.153e	80 00		bra $1540			bra 	Const1Byte
.1540					Const1Byte:
.1540	a5 06		lda $06				lda 	TOS
.1542	48		pha				pha
.1543	a5 07		lda $07				lda 	TOS+1
.1545	48		pha				pha
.1546	84 06		sty $06				sty 	TOS
.1548	64 07		stz $07				stz 	TOS+1
.154a	4c 00 00	jmp $0000			jmp 	NextCode
.154d					C32:
.154d	a0 20		ldy #$20			ldy 	#32
.154f	80 ef		bra $1540			bra 	Const1Byte
.1551					C63:
.1551	a0 3f		ldy #$3f			ldy 	#63
.1553	80 eb		bra $1540			bra 	Const1Byte
.1555					C64:
.1555	a0 40		ldy #$40			ldy 	#64
.1557	80 e7		bra $1540			bra 	Const1Byte
.1559					C100:
.1559	a0 64		ldy #$64			ldy 	#100
.155b	80 e3		bra $1540			bra 	Const1Byte
.155d					C127:
.155d	a0 7f		ldy #$7f			ldy 	#127
.155f	80 df		bra $1540			bra 	Const1Byte
.1561					C128:
.1561	a0 80		ldy #$80			ldy 	#128
.1563	80 db		bra $1540			bra 	Const1Byte
.1565					C255:
.1565	a0 ff		ldy #$ff			ldy 	#255
.1567	80 d7		bra $1540			bra 	Const1Byte
.1569					Const2Byte:
.1569	85 06		sta $06				sta 	TOS
.156b	84 07		sty $07				sty 	TOS+1
.156d	4c 00 00	jmp $0000			jmp 	NextCode
.1570					C256:
.1570	a5 06		lda $06				lda 	TOS
.1572	48		pha				pha
.1573	a5 07		lda $07				lda 	TOS+1
.1575	48		pha				pha
.1576	a9 00		lda #$00			lda 	#(256) & $FF
.1578	a0 01		ldy #$01			ldy 	#(256) >> 8
.157a	80 ed		bra $1569			bra 	Const2Byte
.157c					C512:
.157c	a5 06		lda $06				lda 	TOS
.157e	48		pha				pha
.157f	a5 07		lda $07				lda 	TOS+1
.1581	48		pha				pha
.1582	a9 00		lda #$00			lda 	#(512) & $FF
.1584	a0 02		ldy #$02			ldy 	#(512) >> 8
.1586	80 e1		bra $1569			bra 	Const2Byte
.1588					C1024:
.1588	a5 06		lda $06				lda 	TOS
.158a	48		pha				pha
.158b	a5 07		lda $07				lda 	TOS+1
.158d	48		pha				pha
.158e	a9 00		lda #$00			lda 	#(1024) & $FF
.1590	a0 04		ldy #$04			ldy 	#(1024) >> 8
.1592	80 d5		bra $1569			bra 	Const2Byte
.1594					C4096:
.1594	a5 06		lda $06				lda 	TOS
.1596	48		pha				pha
.1597	a5 07		lda $07				lda 	TOS+1
.1599	48		pha				pha
.159a	a9 00		lda #$00			lda 	#(4096) & $FF
.159c	a0 10		ldy #$10			ldy 	#(4096) >> 8
.159e	80 c9		bra $1569			bra 	Const2Byte
.15a0					C32767:
.15a0	a5 06		lda $06				lda 	TOS
.15a2	48		pha				pha
.15a3	a5 07		lda $07				lda 	TOS+1
.15a5	48		pha				pha
.15a6	a9 ff		lda #$ff			lda 	#(32767) & $FF
.15a8	a0 7f		ldy #$7f			ldy 	#(32767) >> 8
.15aa	80 bd		bra $1569			bra 	Const2Byte
.15ac					C32768:
.15ac	a5 06		lda $06				lda 	TOS
.15ae	48		pha				pha
.15af	a5 07		lda $07				lda 	TOS+1
.15b1	48		pha				pha
.15b2	a9 00		lda #$00			lda 	#(32768) & $FF
.15b4	a0 80		ldy #$80			ldy 	#(32768) >> 8
.15b6	80 b1		bra $1569			bra 	Const2Byte

;******  Return to file: kernel.asm


;******  Processing file: words/data/stack.src

.15b8					Drop:
.15b8	68		pla				pla
.15b9	85 07		sta $07				sta 	TOS+1
.15bb	68		pla				pla
.15bc	85 06		sta $06				sta 	TOS
.15be	4c 00 00	jmp $0000			jmp 	NextCode
.15c1					TestDup:
.15c1	a5 06		lda $06				lda 	TOS
.15c3	05 07		ora $07				ora 	TOS+1
.15c5	d0 03		bne $15ca			bne 	Dup
.15c7	4c 00 00	jmp $0000			jmp 	NextCode
.15ca					Dup:
.15ca	a5 06		lda $06				lda 	TOS
.15cc	48		pha				pha
.15cd	a5 07		lda $07				lda 	TOS+1
.15cf	48		pha				pha
.15d0	4c 00 00	jmp $0000			jmp 	NextCode
.15d3					Swap:
.15d3	86 10		stx $10				stx 	temp1
.15d5	7a		ply				ply
.15d6	fa		plx				plx
.15d7	a5 06		lda $06				lda 	TOS
.15d9	48		pha				pha
.15da	a5 07		lda $07				lda 	TOS+1
.15dc	48		pha				pha
.15dd	86 06		stx $06				stx 	TOS
.15df	84 07		sty $07				sty 	TOS+1
.15e1	a6 10		ldx $10				ldx 	temp1
.15e3	4c 00 00	jmp $0000			jmp 	NextCode
.15e6					Over:
.15e6	a5 06		lda $06				lda 	TOS
.15e8	48		pha				pha
.15e9	a5 07		lda $07				lda 	TOS+1
.15eb	48		pha				pha
.15ec	86 10		stx $10				stx 	temp1
.15ee	ba		tsx				tsx
.15ef	bd 04 01	lda $0104,x			lda 	stack3low,x
.15f2	85 06		sta $06				sta 	TOS
.15f4	bd 03 01	lda $0103,x			lda 	stack3High,x
.15f7	85 07		sta $07				sta 	TOS+1
.15f9	a6 10		ldx $10				ldx 	temp1
.15fb	4c 00 00	jmp $0000			jmp 	NextCode
.15fe					Nip:
.15fe	68		pla				pla
.15ff	68		pla				pla
.1600	4c 00 00	jmp $0000			jmp 	NextCode
.1603					Rot:
.1603	86 10		stx $10				stx 	temp1
.1605	ba		tsx				tsx
.1606	bd 04 01	lda $0104,x			lda 	Stack3Low,x
.1609	a8		tay				tay
.160a	bd 02 01	lda $0102,x			lda 	Stack2Low,x
.160d	9d 04 01	sta $0104,x			sta 	Stack3Low,x
.1610	a5 06		lda $06				lda 	TOS
.1612	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.1615	84 06		sty $06				sty 	TOS
.1617	bd 03 01	lda $0103,x			lda 	Stack3High,x
.161a	a8		tay				tay
.161b	bd 01 01	lda $0101,x			lda 	Stack2High,x
.161e	9d 03 01	sta $0103,x			sta 	Stack3High,x
.1621	a5 07		lda $07				lda 	TOS+1
.1623	9d 01 01	sta $0101,x			sta 	Stack2High,x
.1626	84 07		sty $07				sty 	TOS+1
.1628	a6 10		ldx $10				ldx 	temp1
.162a	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/data/memory.src

.162d					ByteRead:
.162d	b2 06		lda ($06)			lda 	(TOS)
.162f	85 06		sta $06				sta 	TOS
.1631	64 07		stz $07				stz 	TOS+1
.1633	4c 00 00	jmp $0000			jmp 	NextCode
.1636					WordRead:
.1636	a0 01		ldy #$01			ldy 	#1
.1638	b1 06		lda ($06),y			lda 	(TOS),y
.163a	a8		tay				tay
.163b	b2 06		lda ($06)			lda 	(TOS)
.163d	85 06		sta $06				sta 	TOS
.163f	84 07		sty $07				sty 	TOS+1
.1641	4c 00 00	jmp $0000			jmp 	NextCode
.1644					ByteWrite:
.1644	68		pla				pla
.1645	68		pla				pla
.1646	92 06		sta ($06)			sta 	(TOS)
.1648	68		pla				pla
.1649	85 07		sta $07				sta 	TOS+1
.164b	68		pla				pla
.164c	85 06		sta $06				sta 	TOS
.164e	4c 00 00	jmp $0000			jmp 	NextCode
.1651					WordWrite:
.1651	68		pla				pla
.1652	a0 01		ldy #$01			ldy 	#1
.1654	91 06		sta ($06),y			sta 	(TOS),y
.1656	68		pla				pla
.1657	92 06		sta ($06)			sta 	(TOS)
.1659	68		pla				pla
.165a	85 07		sta $07				sta 	TOS+1
.165c	68		pla				pla
.165d	85 06		sta $06				sta 	TOS
.165f	4c 00 00	jmp $0000			jmp 	NextCode
.1662					WordAdd:
.1662	7a		ply				ply
.1663	68		pla				pla
.1664	18		clc				clc
.1665	72 06		adc ($06)			adc 	(TOS)
.1667	92 06		sta ($06)			sta 	(TOS)
.1669	98		tya				tya
.166a	a0 01		ldy #$01			ldy 	#1
.166c	71 06		adc ($06),y			adc 	(TOS),y
.166e	91 06		sta ($06),y			sta 	(TOS),y
.1670	68		pla				pla
.1671	85 07		sta $07				sta 	TOS+1
.1673	68		pla				pla
.1674	85 06		sta $06				sta 	TOS
.1676	4c 00 00	jmp $0000			jmp 	NextCode
.1679					AllocateMemory:
.1679	a5 06		lda $06				lda 	TOS 						; save memory required on stack.
.167b	48		pha				pha
.167c	a5 07		lda $07				lda 	TOS+1
.167e	48		pha				pha
.167f	a5 0e		lda $0e				lda 	nextFreeMem 				; copy free mem address to TOS
.1681	85 06		sta $06				sta 	TOS
.1683	a5 0f		lda $0f				lda 	nextFreeMem+1
.1685	85 07		sta $07				sta 	TOS+1
.1687	7a		ply				ply 								; advance the free ram pointer
.1688	68		pla				pla
.1689	20 59 1d	jsr $1d59			jsr 	AdvanceFreeMem
.168c	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/encode/encode.src

.168f					EncodeProgram:
.168f	48		pha				pha 								; save registers.
.1690	da		phx				phx
.1691	5a		phy				phy
.1692	84 09		sty $09				sty 	srcPtr+1					; save source pointer.
.1694	85 08		sta $08				sta		srcPtr
.1696	a9 ff		lda #$ff			lda 	#$FF
.1698	85 05		sta $05				sta 	rsp
.169a	a6 05		ldx $05				ldx 	rsp 						; this is the current stack entry type, so $00 means
.169c	9e 40 07	stz $0740,x			stz 	returnStackHigh,x 			; an initial "until" will fail as it's looking for "R" here (repeat)
.169f	20 13 19	jsr $1913			jsr 	EncodeTrimTrailingSpaces 	; remove trailing spaces.
.16a2	a9 03		lda #$03			lda 	#3 							; reset the encode Buffer
.16a4	8d 10 09	sta $0910			sta 	encodeBuffer 				; this is also the write ptr/offset
.16a7	9c 11 09	stz $0911			stz 	encodeBuffer+1 				; the line number
.16aa	9c 12 09	stz $0912			stz 	encodeBuffer+2 				; which is initially zero.
.16ad	b2 08		lda ($08)			lda 	(srcPtr) 					; check if first character is digit
.16af	20 be 18	jsr $18be			jsr 	CheckIsDigit
.16b2	90 09		bcc $16bd			bcc 	_EPNoLineNumber 			; if so there is a line number
.16b4	20 e0 18	jsr $18e0			jsr 	EncodeGetConstant 			; extract that constant from the source
.16b7	8d 11 09	sta $0911			sta 	encodeBuffer+1 				; that is the line number
.16ba	8c 12 09	sty $0912			sty 	encodeBuffer+2
.16bd					_EPNoLineNumber:
.16bd					EncodeLoop:
.16bd	20 05 19	jsr $1905			jsr 	EncSkipSpaces 				; skip over spaces
.16c0	b2 08		lda ($08)			lda 	(srcPtr) 					; reached end ?
.16c2	d0 23		bne $16e7			bne 	_EPNotEnd
.16c4					_EPEndEncode:
.16c4	a9 72		lda #$72			lda 	#NextLine & $FF 			; compile $$nextline to mark eol
.16c6	a0 21		ldy #$21			ldy 	#NextLine >> 8
.16c8	20 96 18	jsr $1896			jsr 	EncodeWriteWord
.16cb	a5 05		lda $05				lda 	rsp 						; is the return stack empty ?
.16cd	c9 ff		cmp #$ff			cmp 	#$FF
.16cf	d0 04		bne $16d5			bne 	_EPIncomplete
.16d1	7a		ply				ply									; restore and exit.
.16d2	fa		plx				plx
.16d3	68		pla				pla
.16d4	60		rts				rts
.16d5					_EPIncomplete:
.16d5	20 fe 10	jsr $10fe			jsr 	ErrorHandler
>16d8	53 54 52 55 43 54 55 52				.text 	"STRUCTURE OPEN",0
>16e0	45 20 4f 50 45 4e 00
.16e7					_EPNotEnd:
.16e7	b2 08		lda ($08)			lda 	(srcPtr)
.16e9	c9 22		cmp #$22			cmp 	#'"'						; is it a quoted string or comment ?
.16eb	f0 04		beq $16f1			beq 	_EPIsComStr
.16ed	c9 27		cmp #$27			cmp 	#"'"
.16ef	d0 05		bne $16f6			bne 	_EPNotComStr
.16f1					_EPIsComStr:
.16f1	20 e3 17	jsr $17e3			jsr 	EncodeCommentString
.16f4	80 c7		bra $16bd			bra 	EncodeLoop
.16f6					_EPNotComStr:
.16f6	38		sec				sec
.16f7	20 f2 18	jsr $18f2			jsr 	EncSetBit7Word
.16fa	20 3a 19	jsr $193a			jsr 	EncodeSearchDictionary		; look it up
.16fd	90 45		bcc $1744			bcc 	_EPNotInDictionary
.16ff	85 10		sta $10				sta 	temp1 						; save dictionary record address
.1701	84 11		sty $11				sty 	temp1+1
.1703	a0 01		ldy #$01			ldy 	#1
.1705	b1 10		lda ($10),y			lda 	(temp1),y 					; check if has an encode bit
.1707	29 20		and #$20			and 	#$20
.1709	d0 12		bne $171d			bne 	_EPEncodeRoutine 			; if so, do special routine.
.170b	a0 02		ldy #$02			ldy 	#2 							; write out the routine address
.170d	b1 10		lda ($10),y			lda 	(temp1),y
.170f	20 a0 18	jsr $18a0			jsr 	EncodeWriteByte
.1712	c8		iny				iny
.1713	b1 10		lda ($10),y			lda 	(temp1),y
.1715	20 a0 18	jsr $18a0			jsr 	EncodeWriteByte
.1718	20 ca 18	jsr $18ca			jsr 	EncodeMoveNextWord 			; advance to the next and loop
.171b	80 a0		bra $16bd			bra 	EncodeLoop
.171d					_EPEncodeRoutine:
.171d	a0 01		ldy #$01			ldy 	#1							; get type bit
.171f	b1 10		lda ($10),y			lda 	(temp1),y
.1721	a0 04		ldy #$04			ldy 	#4							; encoder here if no decoder
.1723	29 10		and #$10			and 	#$10 						; but decoder comes first
.1725	f0 02		beq $1729			beq 	_EPENoDecoder
.1727	c8		iny				iny 								; so if it exists, adjust for it.
.1728	c8		iny				iny
.1729					_EPENoDecoder:
.1729	b1 10		lda ($10),y			lda 	(temp1),y 					; copy exec addr to temp2
.172b	85 12		sta $12				sta 	temp2
.172d	c8		iny				iny
.172e	b1 10		lda ($10),y			lda 	(temp1),y
.1730	85 13		sta $13				sta 	temp2+1
.1732	48		pha				pha 								; call routine preserving state
.1733	da		phx				phx
.1734	5a		phy				phy
.1735	20 41 17	jsr $1741			jsr 	_EPECallTemp2
.1738	7a		ply				ply
.1739	fa		plx				plx
.173a	68		pla				pla
.173b	20 ca 18	jsr $18ca			jsr 	EncodeMoveNextWord 			; advance to the next and loop
.173e	4c bd 16	jmp $16bd			jmp 	EncodeLoop
.1741					_EPECallTemp2:
.1741	6c 12 00	jmp ($0012)			jmp 	(temp2)
.1744					_EPNotInDictionary:
.1744	20 48 18	jsr $1848			jsr 	EncodeSearchUserDefined 	; are there any user defined routines
.1747	90 19		bcc $1762			bcc 	_EPNotDefined
.1749	48		pha				pha
.174a	a9 bc		lda #$bc			lda	 	#CallHandler & $FF 			; write code call handler
.174c	20 a0 18	jsr $18a0			jsr 	EncodeWriteByte
.174f	a9 1b		lda #$1b			lda	 	#CallHandler >> 8
.1751	20 a0 18	jsr $18a0			jsr 	EncodeWriteByte
.1754	68		pla				pla 								; write line number
.1755	20 a0 18	jsr $18a0			jsr 	EncodeWriteByte
.1758	98		tya				tya
.1759	20 a0 18	jsr $18a0			jsr 	EncodeWriteByte
.175c	20 ca 18	jsr $18ca			jsr 	EncodeMoveNextWord 			; advance to the next and loop
.175f	4c bd 16	jmp $16bd			jmp 	EncodeLoop
.1762					_EPNotDefined:
.1762	b2 08		lda ($08)			lda 	(srcPtr) 					; first character
.1764	c9 3a		cmp #$3a			cmp 	#":"						; is it :<routine> ?
.1766	f0 58		beq $17c0			beq 	_EPDefinition
.1768	c9 3c		cmp #$3c			cmp 	#"<"						; is it <line> which is call syntax
.176a	f0 2e		beq $179a			beq 	_EPCallDirect
.176c	c9 21		cmp #$21			cmp 	#"!"						; check for variable operators
.176e	f0 47		beq $17b7			beq 	_EPVariable
.1770	c9 40		cmp #$40			cmp 	#"@"
.1772	f0 43		beq $17b7			beq 	_EPVariable
.1774	c9 26		cmp #$26			cmp 	#"&"
.1776	f0 3f		beq $17b7			beq 	_EPVariable
.1778	a9 a6		lda #$a6			lda 	#Literal2Byte & $FF 		; write out 2 byte literal
.177a	a0 10		ldy #$10			ldy 	#Literal2Byte >> 8
.177c	20 96 18	jsr $1896			jsr 	EncodeWriteWord
.177f					_EPOutputConstant:
.177f	20 e0 18	jsr $18e0			jsr 	EncodeGetConstant 			; extract that constant from the source
.1782	90 06		bcc $178a			bcc 	_EPFail 					; if can't find one, that's us done.
.1784	20 96 18	jsr $1896			jsr 	EncodeWriteWord 			; write out the encoded value.
.1787	4c bd 16	jmp $16bd			jmp 	EncodeLoop 					; and go round again.
.178a					_EPFail:
.178a	20 fe 10	jsr $10fe			jsr 	ErrorHandler
>178d	53 59 4e 54 41 58 20 45				.text 	"SYNTAX ERROR",0
>1795	52 52 4f 52 00
.179a					_EPCallDirect:
.179a	a9 bc		lda #$bc			lda	 	#CallHandler & $FF 			; write code call handler
.179c	a0 1b		ldy #$1b			ldy	 	#CallHandler >> 8
.179e	20 96 18	jsr $1896			jsr 	EncodeWriteWord
.17a1	a9 01		lda #$01			lda 	#1
.17a3	20 d6 18	jsr $18d6			jsr 	EncodeAddSrcPtr 			; skip over the <
.17a6	a0 ff		ldy #$ff			ldy 	#255 						; scan forward for last character.
.17a8					_EPToLast:
.17a8	c8		iny				iny
.17a9	b1 08		lda ($08),y			lda 	(srcPtr),y
.17ab	10 fb		bpl $17a8			bpl	 	_EPToLast
.17ad	c9 be		cmp #$be			cmp 	#">"+$80 					; must be >
.17af	d0 d9		bne $178a			bne 	_EPFail
.17b1	a9 20		lda #$20			lda 	#" " 						; strip back to a number, erases last char
.17b3	91 08		sta ($08),y			sta 	(srcPtr),y
.17b5	80 c8		bra $177f			bra 	_EPOutputConstant 			; borrow the number routines extract/compile constant
.17b7					_EPVariable:
.17b7	20 8e 19	jsr $198e			jsr 	EncodeVariableReference
.17ba	20 ca 18	jsr $18ca			jsr 	EncodeMoveNextWord 			; advance to the next and loop
.17bd	4c bd 16	jmp $16bd			jmp 	EncodeLoop
.17c0					_EPDefinition:
.17c0	a9 b4		lda #$b4			lda	 	#DefineCode & $FF 			; write code call handler
.17c2	a0 21		ldy #$21			ldy	 	#DefineCode >> 8
.17c4	20 96 18	jsr $1896			jsr 	EncodeWriteWord
.17c7	ae 10 09	ldx $0910			ldx 	encodeBuffer 				; position
.17ca	a9 01		lda #$01			lda 	#1 							; write default size
.17cc	20 a0 18	jsr $18a0			jsr 	EncodeWriteByte
.17cf	a0 00		ldy #$00			ldy 	#0 							; copy definition over.
.17d1	c8		iny		_EPCopy:iny
.17d2	b1 08		lda ($08),y			lda 	(srcPtr),y
.17d4	20 a0 18	jsr $18a0			jsr 	EncodeWriteByte
.17d7	fe 10 09	inc $0910,x			inc 	encodeBuffer,x 				; update length.
.17da	0a		asl a				asl 	a
.17db	90 f4		bcc $17d1			bcc 	_EPCopy
.17dd	20 ca 18	jsr $18ca			jsr 	EncodeMoveNextWord 			; advance to the next and loop
.17e0	4c bd 16	jmp $16bd			jmp 	EncodeLoop

;******  Return to file: kernel.asm


;******  Processing file: words/encode/comstr.src

.17e3					EncodeCommentString:
.17e3	b2 08		lda ($08)			lda 	(srcPtr) 					; get first character
.17e5	64 10		stz $10				stz 	temp1 						; other terminator = EOL
.17e7	aa		tax				tax 								; save in X
.17e8	a9 89		lda #$89			lda 	#(SkipComment & $FF)		; get the routine to use
.17ea	a0 21		ldy #$21			ldy 	#(SkipComment >> 8)
.17ec	e0 27		cpx #$27			cpx 	#"'"
.17ee	f0 06		beq $17f6			beq 	_ECSGotCmd
.17f0	86 10		stx $10				stx		temp1 						; other terminator = "
.17f2	a9 ce		lda #$ce			lda 	#(LiteralString & $FF)
.17f4	a0 10		ldy #$10			ldy 	#(LiteralString >> 8)
.17f6					_ECSGotCmd:
.17f6	20 96 18	jsr $1896			jsr 	EncodeWriteWord 			; write word out.
.17f9	a9 01		lda #$01			lda 	#1 							; skip over ' or "
.17fb	20 d6 18	jsr $18d6			jsr 	EncodeAddSrcPtr
.17fe	e0 27		cpx #$27			cpx 	#"'"						; if ' then skip spaces
.1800	d0 03		bne $1805			bne 	_ECNoSkipSpaces
.1802	20 05 19	jsr $1905			jsr 	EncSkipSpaces
.1805					_ECNoSkipSpaces:
.1805	ae 10 09	ldx $0910			ldx 	encodeBuffer 				; keep offset to buffer in X.
.1808	a9 01		lda #$01			lda 	#1
.180a	20 a0 18	jsr $18a0			jsr 	EncodeWriteByte 			; write total length, so far 1.
.180d	a0 00		ldy #$00			ldy 	#0 							; for reading the actual text
.180f					_ECSCopyText:
.180f	b1 08		lda ($08),y			lda 	(srcPtr),y 					; get next
.1811	f0 18		beq $182b			beq 	_ECSEndOfLine 				; end of line ?
.1813	c5 10		cmp $10				cmp 	temp1						; is it the other terminator
.1815	f0 09		beq $1820			beq 	_ECSEndOfString 			; if so must be closing quote.
.1817	20 a0 18	jsr $18a0			jsr 	EncodeWriteByte 			; write the byte out
.181a	fe 10 09	inc $0910,x			inc 	encodeBuffer,x				; increase length
.181d	c8		iny				iny 								; next character
.181e	80 ef		bra $180f			bra 	_ECSCopyText
.1820					_ECSEndOfString:
.1820	c8		iny				iny 								; skip closing quote.
.1821	a9 00		lda #$00			lda 	#0 							; write out ASCIIZ
.1823	20 a0 18	jsr $18a0			jsr 	EncodeWriteByte
.1826	fe 10 09	inc $0910,x			inc 	encodeBuffer,x 				; fix the length up.
.1829	80 18		bra $1843			bra 	_ECSComplete 				; and just patching up srcPtr to do.
.182b					_ECSEndOfLine:
.182b	a5 10		lda $10				lda 	temp1 						; missing closing quote
.182d	f0 14		beq $1843			beq 	_ECSComplete 				; if we were doing a string.
.182f	20 fe 10	jsr $10fe			jsr 	ErrorHandler
>1832	4e 4f 20 43 4c 4f 53 49				.text 	"NO CLOSING QUOTE",0
>183a	4e 47 20 51 55 4f 54 45 00
.1843					_ECSComplete:
.1843	98		tya				tya									; skip over.
.1844	20 d6 18	jsr $18d6			jsr 	EncodeAddSrcPtr
.1847	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/encode/encdef.src

.1848					EncodeSearchUserDefined:
.1848	38		sec				sec 								; temp1 = srcPtr-6 because the
.1849	a5 08		lda $08				lda 	srcPtr				 		; name is 6 in (offset line# $$call len)
.184b	e9 06		sbc #$06			sbc		#6
.184d	85 10		sta $10				sta 	temp1
.184f	a5 09		lda $09				lda 	srcPtr+1
.1851	e9 00		sbc #$00			sbc 	#0
.1853	85 11		sta $11				sta 	temp1+1
.1855	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.1857	85 12		sta $12				sta 	0+(temp2)
.1859	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.185b	85 13		sta $13				sta 	1+(temp2)
.185d					_ESULoop:
.185d	b2 12		lda ($12)			lda 	(temp2) 					; reached the end (offset 0)
.185f	f0 33		beq $1894			beq 	_ESUFail
.1861	a0 03		ldy #$03			ldy 	#3 							; check it is $$define
.1863	b1 12		lda ($12),y			lda 	(temp2),y
.1865	c9 b4		cmp #$b4			cmp 	#DefineCode & $FF
.1867	d0 1e		bne $1887			bne 	_ESUNext
.1869	c8		iny				iny
.186a	b1 12		lda ($12),y			lda 	(temp2),y
.186c	c9 21		cmp #$21			cmp 	#DefineCode >> 8
.186e	d0 17		bne $1887			bne 	_ESUNext
.1870	c8		iny				iny 								; skip length byte.
.1871					_ESUCompare:
.1871	c8		iny				iny
.1872	b1 12		lda ($12),y			lda 	(temp2),y
.1874	d1 10		cmp ($10),y			cmp 	(temp1),y
.1876	d0 0f		bne $1887			bne 	_ESUNext
.1878	0a		asl a				asl 	a 							; bit 7 set => found it.
.1879	90 f6		bcc $1871			bcc 	_ESUCompare
.187b	a0 01		ldy #$01			ldy 	#1
.187d	b1 12		lda ($12),y			lda 	(temp2),y 					; read in the line number to YA
.187f	aa		tax				tax
.1880	c8		iny				iny
.1881	b1 12		lda ($12),y			lda 	(temp2),y
.1883	a8		tay				tay
.1884	8a		txa				txa
.1885	38		sec				sec 								; return with carry set as found
.1886	60		rts				rts
.1887					_ESUNext:
.1887	18		clc				clc
.1888	a5 12		lda $12				lda 	temp2
.188a	72 12		adc ($12)			adc 	(temp2)
.188c	85 12		sta $12				sta 	temp2
.188e	90 02		bcc $1892			bcc 	_NoCarryAdv
.1890	e6 13		inc $13				inc 	temp2+1
.1892					_NoCarryAdv:
.1892	80 c9		bra $185d			bra 	_ESULoop 					; and loop round
.1894					_ESUFail:
.1894	18		clc				clc
.1895	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/encode/encutils.src

.1896					EncodeWriteWord:
.1896	48		pha				pha
.1897	20 a0 18	jsr $18a0			jsr 	EncodeWriteByte
.189a	98		tya				tya
.189b	20 a0 18	jsr $18a0			jsr 	EncodeWriteByte
.189e	68		pla				pla
.189f	60		rts				rts
.18a0					EncodeWriteByte:
.18a0	da		phx				phx
.18a1	ae 10 09	ldx $0910			ldx 	encodeBuffer
.18a4	9d 10 09	sta $0910,x			sta 	encodeBuffer,x
.18a7	9e 11 09	stz $0911,x			stz 	encodeBuffer+1,x
.18aa	9e 12 09	stz $0912,x			stz 	encodeBuffer+2,x
.18ad	ee 10 09	inc $0910			inc 	encodeBuffer
.18b0	fa		plx				plx
.18b1	60		rts				rts
.18b2					CheckIsLetter:
.18b2	c9 41		cmp #$41			cmp 	#"A"						; return CS if A..Z
.18b4	90 06		bcc $18bc			bcc 	_CILFail
.18b6	c9 5b		cmp #$5b			cmp 	#"Z"+1
.18b8	b0 02		bcs $18bc			bcs 	_CILFail
.18ba	38		sec				sec
.18bb	60		rts				rts
.18bc					_CILFail:
.18bc	18		clc				clc
.18bd	60		rts				rts
.18be					CheckIsDigit:
.18be	c9 30		cmp #$30			cmp 	#"0"						; return CS if 0..9
.18c0	90 06		bcc $18c8			bcc 	_CIDFail
.18c2	c9 3a		cmp #$3a			cmp 	#"9"+1
.18c4	b0 02		bcs $18c8			bcs 	_CIDFail
.18c6	38		sec				sec
.18c7	60		rts				rts
.18c8					_CIDFail:
.18c8	18		clc				clc
.18c9	60		rts				rts
.18ca					EncodeMoveNextWord:
.18ca	a0 ff		ldy #$ff			ldy 	#255 						; search forward
.18cc					_EPNWLoop:
.18cc	c8		iny				iny
.18cd	b1 08		lda ($08),y			lda 	(srcPtr),y
.18cf	c9 21		cmp #$21			cmp 	#" "+1						; looking for <= space
.18d1	b0 f9		bcs $18cc			bcs 	_EPNWLoop
.18d3	98		tya				tya
.18d4	80 00		bra $18d6			bra 	EncodeAddSrcPtr
.18d6					EncodeAddSrcPtr:
.18d6	18		clc				clc 								; add offset
.18d7	65 08		adc $08				adc 	srcPtr
.18d9	85 08		sta $08				sta 	srcPtr
.18db	90 02		bcc $18df			bcc 	_EASPNoCarry
.18dd	e6 09		inc $09				inc 	srcPtr+1					; carry through
.18df					_EASPNoCarry:
.18df	60		rts				rts
.18e0					EncodeGetConstant:
.18e0	a5 08		lda $08				lda 	srcPtr 						; get source
.18e2	a4 09		ldy $09				ldy 	srcPtr+1
.18e4	20 dd 21	jsr $21dd			jsr 	ConvertToInteger 			; call converter
.18e7	90 08		bcc $18f1			bcc 	_EGCExit
.18e9	20 d6 18	jsr $18d6			jsr 	EncodeAddSrcPtr 			; if passed add chars to src ptr
.18ec	a5 14		lda $14				lda 	temp3 						; get result into YA
.18ee	a4 15		ldy $15				ldy 	temp3+1
.18f0	38		sec				sec 								; return CS
.18f1					_EGCExit:
.18f1	60		rts				rts
.18f2					EncSetBit7Word:
.18f2	08		php				php 								; save carry
.18f3	a0 ff		ldy #$ff			ldy 	#255 						; scan forward for space/NULL
.18f5					_ESB7Loop:
.18f5	c8		iny				iny
.18f6	b1 08		lda ($08),y			lda 	(srcPtr),y
.18f8	c9 21		cmp #$21			cmp 	#" "+1 						; while > ' '
.18fa	b0 f9		bcs $18f5			bcs 	_ESB7Loop
.18fc	88		dey				dey									; previous character
.18fd	b1 08		lda ($08),y			lda 	(srcPtr),y 					; read it
.18ff	0a		asl a				asl 	a 							; shift bit 7 out
.1900	28		plp				plp 								; restore carry
.1901	6a		ror a				ror 	a 							; shift it in
.1902	91 08		sta ($08),y			sta 	(srcPtr),y 					; write back and exit
.1904	60		rts				rts
.1905					EncSkipSpaces:
.1905	b2 08		lda ($08)			lda 	(srcPtr) 					; skip over spaces/ reached end
.1907	c9 20		cmp #$20			cmp 	#32
.1909	d0 07		bne $1912			bne 	_ESNotSpace
.190b	a9 01		lda #$01			lda 	#1
.190d	20 d6 18	jsr $18d6			jsr 	EncodeAddSrcPtr
.1910	80 f3		bra $1905			bra	 	EncSkipSpaces
.1912					_ESNotSpace:
.1912	60		rts				rts
.1913					EncodeTrimTrailingSpaces:
.1913	a0 ff		ldy #$ff			ldy 	#255 						; find EOS
.1915					_ETTFindEnd:
.1915	c8		iny				iny
.1916	b1 08		lda ($08),y			lda 	(srcPtr),y
.1918	d0 fb		bne $1915			bne 	_ETTFindEnd
.191a					_ETTRemoveSpace:
.191a	c0 00		cpy #$00			cpy 	#0 							; start of string
.191c	f0 0d		beq $192b			beq 	_ETTExit
.191e	88		dey				dey 								; previous character 1..32
.191f	b1 08		lda ($08),y			lda 	(srcPtr),y
.1921	c9 21		cmp #$21			cmp 	#32+1
.1923	b0 06		bcs $192b			bcs 	_ETTExit
.1925	a9 00		lda #$00			lda 	#0 							; erase it and go round again
.1927	91 08		sta ($08),y			sta 	(srcPtr),y
.1929	80 ef		bra $191a			bra 	_ETTRemoveSpace
.192b					_ETTExit:
.192b	60		rts				rts
.192c					EncodePushPosMarkerOnStack:
.192c	e6 05		inc $05				inc 	rsp 						; make space on rstack
.192e	a6 05		ldx $05				ldx 	rsp							; access it
.1930	9d 40 07	sta $0740,x			sta 	returnStackHigh,x			; save marker
.1933	ad 10 09	lda $0910			lda 	encodeBuffer 				; save position in encode buffer
.1936	9d 80 07	sta $0780,x			sta 	returnStackX,x
.1939	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/encode/encsearch.src

.193a					EncodeSearchDictionary:
.193a	a9 c1		lda #$c1			lda 	#(Dictionary) & $FF
.193c	85 10		sta $10				sta 	0+(temp1)
.193e	a9 24		lda #$24			lda 	#(Dictionary) >> 8
.1940	85 11		sta $11				sta 	1+(temp1)
.1942					_ESDLoop:
.1942	b2 10		lda ($10)			lda 	(temp1) 					; end of dictionary return with CC.
.1944	18		clc				clc
.1945	f0 46		beq $198d			beq 	_ESDExit
.1947	a0 01		ldy #$01			ldy 	#1 							; get control bits, get offset to name.
.1949	b1 10		lda ($10),y			lda 	(temp1),y
.194b	4a		lsr a				lsr 	a 							; encode/decode bits move to 0,1
.194c	4a		lsr a				lsr 	a
.194d	4a		lsr a				lsr 	a
.194e	4a		lsr a				lsr 	a
.194f	c8		iny				iny 								; Y = 2
.1950	4a		lsr a				lsr 	a
.1951	90 01		bcc $1954			bcc 	_ESDNotDec
.1953	c8		iny				iny
.1954					_ESDNotDec:
.1954	4a		lsr a				lsr 	a
.1955	90 01		bcc $1958			bcc 	_ESDNotInc
.1957	c8		iny				iny
.1958					_ESDNotInc:
.1958	98		tya				tya
.1959	0a		asl a				asl 	a 							; A is now 4,6,8 offset to name.
.195a	a8		tay				tay
.195b	b1 10		lda ($10),y			lda 	(temp1),y 					; quick check of first character
.195d	d2 08		cmp ($08)			cmp 	(srcPtr)
.195f	d0 1f		bne $1980			bne 	_ESDNext 					; do not match, go to next
.1961	98		tya				tya 								; make temp2 point to the name in
.1962	18		clc				clc 								; the dictionary.
.1963	65 10		adc $10				adc 	temp1
.1965	85 12		sta $12				sta 	temp2
.1967	a5 11		lda $11				lda 	temp1+1
.1969	69 00		adc #$00			adc 	#0
.196b	85 13		sta $13				sta 	temp2+1
.196d	a0 ff		ldy #$ff			ldy 	#255 						; now start matching up.
.196f					_ESDCompare:
.196f	c8		iny				iny
.1970	b1 08		lda ($08),y			lda 	(srcPtr),y
.1972	d1 12		cmp ($12),y			cmp 	(temp2),y
.1974	d0 0a		bne $1980			bne 	_ESDNext
.1976	0a		asl a				asl 	a
.1977	90 f6		bcc $196f			bcc 	_ESDCompare
.1979	a5 10		lda $10				lda 	temp1 						; return address in YA and carry set.
.197b	a4 11		ldy $11				ldy 	temp1+1
.197d	38		sec				sec
.197e	80 0d		bra $198d			bra 	_ESDExit
.1980					_ESDNext:
.1980	18		clc				clc
.1981	a5 10		lda $10				lda 	temp1
.1983	72 10		adc ($10)			adc 	(temp1)
.1985	85 10		sta $10				sta 	temp1
.1987	90 b9		bcc $1942			bcc 	_ESDLoop
.1989	e6 11		inc $11				inc 	temp1+1
.198b	80 b5		bra $1942			bra 	_ESDLoop
.198d					_ESDExit:
.198d	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/encode/encvar.src

.198e					EncodeVariableReference:
.198e	b2 08		lda ($08)			lda 	(srcPtr)					; get the type, use it to identify the routine
.1990	a2 16		ldx #$16			ldx 	#VarAddressHandler & $FF
.1992	a0 23		ldy #$23			ldy 	#VarAddressHandler >> 8
.1994	c9 26		cmp #$26			cmp 	#"&"
.1996	f0 0c		beq $19a4			beq 	_EVFHaveAddress
.1998	a2 33		ldx #$33			ldx 	#VarReadHandler & $FF
.199a	a0 23		ldy #$23			ldy 	#VarReadHandler >> 8
.199c	c9 40		cmp #$40			cmp 	#"@"
.199e	f0 04		beq $19a4			beq 	_EVFHaveAddress
.19a0	a2 52		ldx #$52			ldx 	#VarWriteHandler & $FF
.19a2	a0 23		ldy #$23			ldy 	#VarWriteHandler >> 8
.19a4					_EVFHaveAddress:
.19a4	8a		txa				txa
.19a5	20 96 18	jsr $1896			jsr 	EncodeWriteWord 			; write it out.
.19a8	a0 01		ldy #$01			ldy 	#1 							; get the first charactere
.19aa	b1 08		lda ($08),y			lda 	(srcPtr),y
.19ac	29 7f		and #$7f			and 	#$7F 						; might be the last.
.19ae	20 b2 18	jsr $18b2			jsr 	CheckIsLetter 				; is it A-Z
.19b1	90 1a		bcc $19cd			bcc 	EVFFail
.19b3	29 1f		and #$1f			and 	#31 						; make 1-26
.19b5	85 10		sta $10				sta 	temp1 						; start building the name in temp1
.19b7	64 11		stz $11				stz 	temp1+1
.19b9	38		sec				sec 								; possible char 2
.19ba	20 e2 19	jsr $19e2			jsr 	EncVarAlNum
.19bd	18		clc				clc 								; possible char 3
.19be	20 e2 19	jsr $19e2			jsr 	EncVarAlNum
.19c1	b1 08		lda ($08),y			lda 	(srcPtr),y 					; more text after ?
.19c3	10 08		bpl $19cd			bpl 	EVFFail
.19c5	a5 10		lda $10				lda 	temp1 						; write out variable identifier.
.19c7	a4 11		ldy $11				ldy 	temp1+1
.19c9	20 96 18	jsr $1896			jsr 	EncodeWriteWord
.19cc	60		rts				rts
.19cd					EVFFail:
.19cd	20 fe 10	jsr $10fe			jsr 	ErrorHandler
>19d0	42 41 44 20 56 41 52 49				.text 	"BAD VARIABLE NAME",0
>19d8	41 42 4c 45 20 4e 41 4d 45 00
.19e2					EncVarAlNum:
.19e2	b1 08		lda ($08),y			lda 	(srcPtr),y 					; points to the  last char processed.
.19e4	10 01		bpl $19e7			bpl 	_EVAContinue
.19e6	60		rts				rts
.19e7					_EVAContinue:
.19e7	08		php				php 								; CS x 32 ; CC x 32 x 40
.19e8	c8		iny				iny 								; get the next character, strip bit 7
.19e9	b1 08		lda ($08),y			lda 	(srcPtr),y
.19eb	29 7f		and #$7f			and 	#$7F
.19ed	20 b2 18	jsr $18b2			jsr 	CheckIsLetter 				; letter ?
.19f0	b0 08		bcs $19fa			bcs 	_EVACharOkay
.19f2	20 be 18	jsr $18be			jsr 	CheckIsDigit				; fail if not digit.
.19f5	90 d6		bcc $19cd			bcc 	EVFFail
.19f7	18		clc				clc
.19f8	69 2b		adc #$2b			adc 	#"Z"+1-"0"					; shift 0 so after Z
.19fa					_EVACharOkay:
.19fa	38		sec				sec 								; range 1-36
.19fb	e9 40		sbc #$40			sbc 	#64
.19fd	28		plp				plp 								; which multiplier ?
.19fe	90 0f		bcc $1a0f			bcc 	_EVATimes32x40
.1a00	85 12		sta $12				sta 	temp2 						; save in temp2 - A x 32
.1a02	64 13		stz $13				stz 	temp2+1
.1a04	a2 05		ldx #$05			ldx 	#5
.1a06	06 12		asl $12		_EVA32:	asl 	temp2
.1a08	26 13		rol $13				rol 	temp2+1
.1a0a	ca		dex				dex
.1a0b	d0 f9		bne $1a06			bne 	_EVA32
.1a0d	80 0b		bra $1a1a			bra 	_EVAAddVar
.1a0f					_EVATimes32x40:
.1a0f	85 13		sta $13				sta 	temp2+1						; 32 x 40 = 1280 or $500, so temp2 = A x 256 x 5
.1a11	64 12		stz $12				stz 	temp2
.1a13	0a		asl a				asl 	a
.1a14	0a		asl a				asl 	a
.1a15	18		clc				clc
.1a16	65 13		adc $13				adc 	temp2+1
.1a18	85 13		sta $13				sta 	temp2+1
.1a1a					_EVAAddVar:
.1a1a	18		clc				clc
.1a1b	a5 10		lda $10				lda 	temp1
.1a1d	65 12		adc $12				adc 	temp2
.1a1f	85 10		sta $10				sta 	temp1
.1a21	a5 11		lda $11				lda 	temp1+1
.1a23	65 13		adc $13				adc 	temp2+1
.1a25	85 11		sta $11				sta 	temp1+1
.1a27	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/structures/fornext.src

.1a28					ForHandler:
.1a28	e6 05		inc $05				inc 	rsp 						; bump the RSP
.1a2a	a4 05		ldy $05				ldy 	rsp 						; get return stack and push TOS/$FF on it.
.1a2c	c0 40		cpy #$40			cpy 	#$40 						; overflow
.1a2e	f0 18		beq $1a48			beq 	_FHOverflow
.1a30	a5 07		lda $07				lda 	TOS+1
.1a32	99 40 07	sta $0740,y			sta 	returnStackHigh,y
.1a35	a5 06		lda $06				lda 	TOS
.1a37	99 00 07	sta $0700,y			sta 	returnStackLow,y
.1a3a	a9 ff		lda #$ff			lda 	#$FF
.1a3c	99 80 07	sta $0780,y			sta 	returnStackX,y
.1a3f	68		pla				pla
.1a40	85 07		sta $07				sta 	TOS+1
.1a42	68		pla				pla
.1a43	85 06		sta $06				sta 	TOS
.1a45	4c 00 00	jmp $0000			jmp 	NextCode
.1a48					_FHOverflow:
.1a48	20 fe 10	jsr $10fe			jsr 	ErrorHandler
>1a4b	53 54 52 55 43 54 55 52				.text 	"STRUCTURE OVERFLOW",0
>1a53	45 20 4f 56 45 52 46 4c 4f 57 00
.1a5e					ForEncoder:
.1a5e	a9 28		lda #$28			lda 	#ForHandler & $FF 			; for handler
.1a60	a0 1a		ldy #$1a			ldy 	#ForHandler >> 8
.1a62	20 96 18	jsr $1896			jsr 	EncodeWriteWord
.1a65	a9 46		lda #$46			lda 	#"F" 						; for marker
.1a67	20 2c 19	jsr $192c			jsr 	EncodePushPosMarkerOnStack
.1a6a	60		rts				rts
.1a6b					NextHandler:
.1a6b	da		phx				phx
.1a6c	a6 05		ldx $05				ldx 	rsp 						; get current stack ptr
.1a6e	bd 80 07	lda $0780,x			lda 	returnStackX,x 				; check it's a FOR Loop
.1a71	c9 ff		cmp #$ff			cmp 	#$FF
.1a73	d0 21		bne $1a96			bne 	NHNoFor
.1a75	bd 00 07	lda $0700,x			lda 	returnStackLow,x 			; decrement the count
.1a78	d0 03		bne $1a7d			bne 	_NHNoBorrow
.1a7a	de 40 07	dec $0740,x			dec 	returnStackHigh,x
.1a7d					_NHNoBorrow:
.1a7d	de 00 07	dec $0700,x			dec 	returnStackLow,x
.1a80	bd 00 07	lda $0700,x			lda 	returnStackLow,x 			; have we reached the end ?
.1a83	1d 40 07	ora $0740,x			ora 	returnStackHigh,x
.1a86	fa		plx				plx 								; restore X and re-test
.1a87	09 00		ora #$00			ora 	#0
.1a89	f0 05		beq $1a90			beq 	_NHComplete 				; if so then complete, else loop.
.1a8b	e8		inx				inx 								; advance to branch
.1a8c	e8		inx				inx
.1a8d	4c b2 1b	jmp $1bb2			jmp 	BranchAlways
.1a90					_NHComplete:
.1a90	e8		inx				inx 								; skip over the branch quantity
.1a91	c6 05		dec $05				dec 	rsp 						; drop the indx
.1a93	4c 00 00	jmp $0000			jmp 	NextCode
.1a96					NHNoFor:
.1a96	20 fe 10	jsr $10fe			jsr 	ErrorHandler
>1a99	4f 55 54 20 4f 46 20 46				.text 	"OUT OF FOR SCOPE",0
>1aa1	4f 52 20 53 43 4f 50 45 00
.1aaa					NextEncoder:
.1aaa	a9 6b		lda #$6b			lda 	#NextHandler & $FF 			; next code
.1aac	a0 1a		ldy #$1a			ldy 	#NextHandler >> 8
.1aae	20 96 18	jsr $1896			jsr 	EncodeWriteWord
.1ab1	a6 05		ldx $05				ldx 	rsp 						; get stack offset and pop
.1ab3	c6 05		dec $05				dec 	rsp
.1ab5	bd 40 07	lda $0740,x			lda 	returnStackHigh,x 			; check it is a for
.1ab8	c9 46		cmp #$46			cmp 	#"F"
.1aba	d0 07		bne $1ac3			bne 	_NENoFor
.1abc	bd 80 07	lda $0780,x			lda 	returnStackX,x 				; write the branch
.1abf	20 a0 18	jsr $18a0			jsr 	EncodeWriteByte
.1ac2	60		rts				rts
.1ac3					_NENoFor:
.1ac3	20 fe 10	jsr $10fe			jsr 	ErrorHandler
>1ac6	4d 49 53 53 49 4e 47 20				.text 	"MISSING FOR",0
>1ace	46 4f 52 00
.1ad2					GetIndex:
.1ad2	a4 05		ldy $05				ldy 	rsp 						; get current stack ptr
.1ad4	b9 80 07	lda $0780,y			lda 	returnStackX,y 				; check it's a FOR Loop
.1ad7	c9 ff		cmp #$ff			cmp 	#$FF
.1ad9	d0 bb		bne $1a96			bne 	NHNoFor
.1adb	a5 06		lda $06				lda 	TOS
.1add	48		pha				pha
.1ade	a5 07		lda $07				lda 	TOS+1
.1ae0	48		pha				pha
.1ae1	b9 00 07	lda $0700,y			lda 	returnStackLow,y 			; put counter-1 out
.1ae4	38		sec				sec
.1ae5	e9 01		sbc #$01			sbc 	#1
.1ae7	85 06		sta $06				sta 	TOS
.1ae9	b9 40 07	lda $0740,y			lda 	returnStackHigh,y
.1aec	e9 00		sbc #$00			sbc 	#0
.1aee	85 07		sta $07				sta 	TOS+1
.1af0	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/structures/ifelseendif.src

.1af3					IfHandler:
.1af3	4c 9a 1b	jmp $1b9a			jmp 	BranchIfZero
.1af6					IfEncoder:
.1af6	a9 f3		lda #$f3			lda 	#IfHandler & $FF 			; if handler
.1af8	a0 1a		ldy #$1a			ldy 	#IfHandler >> 8
.1afa	20 96 18	jsr $1896			jsr 	EncodeWriteWord
.1afd	a9 49		lda #$49			lda 	#"I" 						; if marker
.1aff	20 2c 19	jsr $192c			jsr 	EncodePushPosMarkerOnStack
.1b02	a9 00		lda #$00			lda 	#0
.1b04	20 a0 18	jsr $18a0			jsr 	EncodeWriteByte 			; dummy write.
.1b07	60		rts				rts
.1b08					ElseHandler:
.1b08	4c b0 1b	jmp $1bb0			jmp 	BranchTestSucceedsNoPop
.1b0b					ElseEncoder:
.1b0b	a9 08		lda #$08			lda 	#ElseHandler & $FF 			; else handler
.1b0d	a0 1b		ldy #$1b			ldy 	#ElseHandler >> 8
.1b0f	20 96 18	jsr $1896			jsr 	EncodeWriteWord
.1b12	ad 10 09	lda $0910			lda 	encodeBuffer 				; push current position
.1b15	48		pha				pha
.1b16	a9 00		lda #$00			lda 	#0 							; zero branch
.1b18	20 a0 18	jsr $18a0			jsr 	EncodeWriteByte
.1b1b	20 38 1b	jsr $1b38			jsr 	IfPatch 					; fix up the branch.
.1b1e	a9 49		lda #$49			lda 	#"I" 						; recreate if marker
.1b20	20 2c 19	jsr $192c			jsr 	EncodePushPosMarkerOnStack
.1b23	68		pla				pla 								; address to patch
.1b24	a6 05		ldx $05				ldx 	rsp
.1b26	9d 80 07	sta $0780,x			sta 	returnStackX,x 				; and overwrite the target address
.1b29	60		rts				rts
.1b2a					EndIfHandler:
.1b2a	4c 00 00	jmp $0000			jmp 	NextCode
.1b2d					EndIfEncoder:
.1b2d	a9 2a		lda #$2a			lda 	#EndIfHandler & $FF 		; endif handler
.1b2f	a0 1b		ldy #$1b			ldy 	#EndIfHandler >> 8
.1b31	20 96 18	jsr $1896			jsr 	EncodeWriteWord
.1b34	20 38 1b	jsr $1b38			jsr 	IfPatch
.1b37	60		rts				rts
.1b38					IfPatch:
.1b38	a6 05		ldx $05				ldx 	rsp 						; get stack offset and pop
.1b3a	c6 05		dec $05				dec 	rsp
.1b3c	bd 40 07	lda $0740,x			lda 	returnStackHigh,x 			; check it is an if.
.1b3f	c9 49		cmp #$49			cmp 	#"I"
.1b41	d0 0b		bne $1b4e			bne 	_NENoIf
.1b43	bd 80 07	lda $0780,x			lda 	returnStackX,x 				; this is what you patch.
.1b46	aa		tax				tax
.1b47	ad 10 09	lda $0910			lda 	encodeBuffer 				; with the current position.
.1b4a	9d 10 09	sta $0910,x			sta 	encodeBuffer,x
.1b4d	60		rts				rts
.1b4e					_NENoIf:
.1b4e	20 fe 10	jsr $10fe			jsr 	ErrorHandler
>1b51	4d 49 53 53 49 4e 47 20				.text 	"MISSING IF",0
>1b59	49 46 00

;******  Return to file: kernel.asm


;******  Processing file: words/structures/repeatuntil.src

.1b5c					RepeatHandler:
.1b5c	4c 00 00	jmp $0000			jmp 	NextCode
.1b5f					RepeatEncoder:
.1b5f	a9 5c		lda #$5c			lda 	#RepeatHandler & $FF 		; repeat marker
.1b61	a0 1b		ldy #$1b			ldy 	#RepeatHandler >> 8
.1b63	20 96 18	jsr $1896			jsr 	EncodeWriteWord
.1b66	a9 52		lda #$52			lda 	#"R" 						; repeat marker
.1b68	20 2c 19	jsr $192c			jsr 	EncodePushPosMarkerOnStack
.1b6b	60		rts				rts
.1b6c					UntilHandler:
.1b6c	4c 9a 1b	jmp $1b9a			jmp 	BranchIfZero
.1b6f					UntilEncoder:
.1b6f	a9 6c		lda #$6c			lda 	#UntilHandler & $FF 		; until code
.1b71	a0 1b		ldy #$1b			ldy 	#UntilHandler >> 8
.1b73	20 96 18	jsr $1896			jsr 	EncodeWriteWord
.1b76	a6 05		ldx $05				ldx 	rsp 						; get stack offset and pop
.1b78	c6 05		dec $05				dec 	rsp
.1b7a	bd 40 07	lda $0740,x			lda 	returnStackHigh,x 			; check it is a repeat
.1b7d	c9 52		cmp #$52			cmp 	#"R"
.1b7f	d0 07		bne $1b88			bne 	_UENoRepeat
.1b81	bd 80 07	lda $0780,x			lda 	returnStackX,x 				; write the branch
.1b84	20 a0 18	jsr $18a0			jsr 	EncodeWriteByte
.1b87	60		rts				rts
.1b88					_UENoRepeat:
.1b88	20 fe 10	jsr $10fe			jsr 	ErrorHandler
>1b8b	4d 49 53 53 49 4e 47 20				.text 	"MISSING REPEAT",0
>1b93	52 45 50 45 41 54 00

;******  Return to file: kernel.asm


;******  Processing file: words/system/branch.src

.1b9a					BranchIfZero:
.1b9a	a5 06		lda $06				lda 	TOS 						; check TOS = 0
.1b9c	05 07		ora $07				ora 	TOS+1
.1b9e	f0 0a		beq $1baa			beq 	BranchTestSucceeds
.1ba0					BranchTestFails:
.1ba0	68		pla				pla
.1ba1	85 07		sta $07				sta 	TOS+1
.1ba3	68		pla				pla
.1ba4	85 06		sta $06				sta 	TOS
.1ba6	e8		inx				inx 								; skip over the relative branch.
.1ba7	4c 00 00	jmp $0000			jmp 	NextCode
.1baa					BranchTestSucceeds:
.1baa	68		pla				pla
.1bab	85 07		sta $07				sta 	TOS+1
.1bad	68		pla				pla
.1bae	85 06		sta $06				sta 	TOS
.1bb0					BranchTestSucceedsNoPop:
.1bb0	e8		inx				inx 								; advance by two, to the offset
.1bb1	e8		inx				inx
.1bb2					BranchAlways:
.1bb2	8a		txa				txa 								; A = Y = position
.1bb3	a8		tay				tay 								; (IP),Y now points to the branch target
.1bb4	b1 03		lda ($03),y			lda 	(IP),y 						; adjust the position
.1bb6	aa		tax				tax 								; position back in this line.
.1bb7	ca		dex				dex
.1bb8	ca		dex				dex
.1bb9	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/system/callhandler.src

.1bbc					CallHandler:
.1bbc	e8		inx				inx									; bump X to the call address.
.1bbd	e8		inx				inx
.1bbe	e6 05		inc $05				inc 	rsp 						; bump the RSP (first time to zero)
.1bc0	a4 05		ldy $05				ldy 	rsp 						; get return stack and push IP/X on it.
.1bc2	c0 40		cpy #$40			cpy 	#$40 						; overflow
.1bc4	f0 54		beq $1c1a			beq 	_CHOverflow
.1bc6	a5 04		lda $04				lda 	IP+1
.1bc8	99 40 07	sta $0740,y			sta 	returnStackHigh,y
.1bcb	a5 03		lda $03				lda 	IP
.1bcd	99 00 07	sta $0700,y			sta 	returnStackLow,y
.1bd0	8a		txa				txa
.1bd1	99 80 07	sta $0780,y			sta 	returnStackX,y
.1bd4	8a		txa				txa 								; get the line number into temp1.
.1bd5	a8		tay				tay
.1bd6	b1 03		lda ($03),y			lda 	(IP),y
.1bd8	85 10		sta $10				sta 	temp1
.1bda	c8		iny				iny
.1bdb	b1 03		lda ($03),y			lda 	(IP),y
.1bdd	85 11		sta $11				sta 	temp1+1
.1bdf	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.1be1	85 03		sta $03				sta 	0+(IP)
.1be3	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.1be5	85 04		sta $04				sta 	1+(IP)
.1be7	b2 03		lda ($03)			lda 	(IP)						; no program code ?
.1be9	f0 17		beq $1c02			beq 	_CHFail
.1beb	a0 01		ldy #$01			ldy 	#1 							; Y = 1 throughout.
.1bed					_CHSearch:
.1bed	b1 03		lda ($03),y			lda 	(IP),y 						; check LSB of line number
.1bef	c5 10		cmp $10				cmp 	temp1
.1bf1	f0 3e		beq $1c31			beq 	_CHFoundLSB
.1bf3					_CHSearchNext:
.1bf3	18		clc				clc
.1bf4	a5 03		lda $03				lda 	IP
.1bf6	72 03		adc ($03)			adc 	(IP)
.1bf8	85 03		sta $03				sta 	IP
.1bfa	90 02		bcc $1bfe			bcc 	_NoCarryAdv
.1bfc	e6 04		inc $04				inc 	IP+1
.1bfe					_NoCarryAdv:
.1bfe	b2 03		lda ($03)			lda 	(IP)						; check reached the end.
.1c00	d0 eb		bne $1bed			bne 	_CHSearch
.1c02					_CHFail:
.1c02	20 fe 10	jsr $10fe			jsr 	ErrorHandler
>1c05	43 41 4e 54 20 46 49 4e				.text 	"CANT FIND DEFINITION",0
>1c0d	44 20 44 45 46 49 4e 49 54 49 4f 4e 00
.1c1a					_CHOverflow:
.1c1a	20 fe 10	jsr $10fe			jsr 	ErrorHandler
>1c1d	43 41 4c 4c 20 53 54 41				.text 	"CALL STACK OVERFLOW",0
>1c25	43 4b 20 4f 56 45 52 46 4c 4f 57 00
.1c31					_CHFoundLSB:
.1c31	c8		iny				iny 								; get MSB
.1c32	b1 03		lda ($03),y			lda 	(IP),y
.1c34	88		dey				dey
.1c35	c5 11		cmp $11				cmp 	temp1+1 					; matches, if not contineu
.1c37	d0 ba		bne $1bf3			bne 	_CHSearchNext
.1c39	a0 03		ldy #$03			ldy 	#3	 						; check it begins with $$define
.1c3b	b1 03		lda ($03),y			lda 	(IP),y
.1c3d	c9 b4		cmp #$b4			cmp 	#DefineCode & $FF
.1c3f	d0 c1		bne $1c02			bne 	_CHFail
.1c41	c8		iny				iny
.1c42	b1 03		lda ($03),y			lda 	(IP),y
.1c44	c9 21		cmp #$21			cmp 	#DefineCode >> 8
.1c46	d0 ba		bne $1c02			bne 	_CHFail
.1c48	c8		iny				iny
.1c49	b1 03		lda ($03),y			lda 	(IP),y 						; this is the length of the define name
.1c4b	18		clc				clc
.1c4c	69 03		adc #$03			adc 	#5-2 						; $$define token, line number, offset - 2 for Next
.1c4e	aa		tax				tax
.1c4f	4c 00 00	jmp $0000			jmp 	NextCode
.1c52					ReturnHandler:
.1c52	a4 05		ldy $05				ldy 	rsp 						; get rsp
.1c54	30 15		bmi $1c6b			bmi 	_RHUnderflow 				; if -ve underflowed
.1c56	c6 05		dec $05				dec 	rsp 						; decrement rsp
.1c58	b9 40 07	lda $0740,y			lda 	returnStackHigh,y 			; restore IP/X
.1c5b	85 04		sta $04				sta 	IP+1
.1c5d	b9 00 07	lda $0700,y			lda 	returnStackLow,y
.1c60	85 03		sta $03				sta 	IP
.1c62	b9 80 07	lda $0780,y			lda 	returnStackX,y
.1c65	aa		tax				tax
.1c66	f0 15		beq $1c7d			beq 	_RHInLoop 					; this means you have done :something for ; next
.1c68	4c 00 00	jmp $0000			jmp 	NextCode
.1c6b					_RHUnderflow:
.1c6b	20 fe 10	jsr $10fe			jsr 	ErrorHandler
>1c6e	4d 49 53 53 49 4e 47 20				.text 	"MISSING RETURN",0
>1c76	52 45 54 55 52 4e 00
.1c7d					_RHInLoop:
.1c7d	20 fe 10	jsr $10fe			jsr 	ErrorHandler
>1c80	52 45 54 55 52 4e 20 49				.text 	"RETURN IN LOOP ERROR",0
>1c88	4e 20 4c 4f 4f 50 20 45 52 52 4f 52 00
.1c95					CallHandlerDecode:
.1c95	a9 03		lda #$03			lda 	#CTH_Call					; space
.1c97	20 5f 1e	jsr $1e5f			jsr 	DecodeWriteBuffer
.1c9a	b1 08		lda ($08),y			lda 	(srcPtr),y 					; get line number into YA
.1c9c	aa		tax				tax
.1c9d	c8		iny				iny
.1c9e	b1 08		lda ($08),y			lda 	(srcPtr),y
.1ca0	a8		tay				tay
.1ca1	8a		txa				txa
.1ca2	20 df 1c	jsr $1cdf			jsr 	FindLine 					; try to locate that line.
.1ca5	b0 11		bcs $1cb8			bcs 	_CHDFound 					; if found .....
.1ca7					_CHDLineOnly:
.1ca7	48		pha				pha
.1ca8	a9 3c		lda #$3c			lda 	#"<"
.1caa	20 5f 1e	jsr $1e5f			jsr 	DecodeWriteBuffer
.1cad	68		pla				pla
.1cae	18		clc				clc 								; output unsigned
.1caf	20 81 1e	jsr $1e81			jsr 	DecodeYAToBuffer
.1cb2	a9 3e		lda #$3e			lda 	#">"
.1cb4	20 5f 1e	jsr $1e5f			jsr 	DecodeWriteBuffer
.1cb7	60		rts				rts
.1cb8					_CHDFound:
.1cb8	48		pha				pha 								; save YA
.1cb9	5a		phy				phy
.1cba	a0 03		ldy #$03			ldy 	#3 							; check first is $$define
.1cbc	b1 10		lda ($10),y			lda 	(temp1),y
.1cbe	c9 b4		cmp #$b4			cmp 	#DefineCode & 255
.1cc0	d0 07		bne $1cc9			bne 	_CHDNoDefine
.1cc2	c8		iny				iny
.1cc3	b1 10		lda ($10),y			lda 	(temp1),y
.1cc5	c9 21		cmp #$21			cmp 	#DefineCode >> 8
.1cc7	f0 04		beq $1ccd			beq 	_CHDFoundDefine
.1cc9					_CHDNoDefine:
.1cc9	7a		ply				ply									; restore the line number and print it in <>
.1cca	68		pla				pla
.1ccb	80 da		bra $1ca7			bra 	_CHDLineOnly
.1ccd					_CHDFoundDefine:
.1ccd	68		pla				pla 								; throw saved line number.
.1cce	68		pla				pla
.1ccf	a0 05		ldy #$05			ldy 	#5 							; 3,4 $$define 5 length, name has bit 7 set at end
.1cd1					_CHDOutName:
.1cd1	c8		iny				iny 								; next
.1cd2	b1 10		lda ($10),y			lda 	(temp1),y 					; print char no bit 7
.1cd4	48		pha				pha
.1cd5	29 7f		and #$7f			and 	#$7F
.1cd7	20 5f 1e	jsr $1e5f			jsr 	DecodeWriteBuffer
.1cda	68		pla				pla
.1cdb	0a		asl a				asl 	a 							; bit 7 to carry
.1cdc	90 f3		bcc $1cd1			bcc 	_CHDOutName
.1cde	60		rts				rts
.1cdf					FindLine:
.1cdf	48		pha				pha 								; save registers
.1ce0	da		phx				phx
.1ce1	5a		phy				phy
.1ce2	85 12		sta $12				sta 	temp2 						; temp2 = target line#
.1ce4	84 13		sty $13				sty 	temp2+1
.1ce6	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.1ce8	85 10		sta $10				sta 	0+(temp1)
.1cea	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.1cec	85 11		sta $11				sta 	1+(temp1)
.1cee					_FLLoop:
.1cee	b2 10		lda ($10)			lda 	(temp1) 					; found end ?
.1cf0	18		clc				clc									; if so exit with CC.
.1cf1	f0 1d		beq $1d10			beq 	_FLExit
.1cf3	a0 01		ldy #$01			ldy 	#1 							; check line # match
.1cf5	b1 10		lda ($10),y			lda 	(temp1),y
.1cf7	c5 12		cmp $12				cmp 	temp2
.1cf9	d0 08		bne $1d03			bne 	_FLNext
.1cfb	c8		iny				iny
.1cfc	b1 10		lda ($10),y			lda 	(temp1),y
.1cfe	c5 13		cmp $13				cmp 	temp2+1
.1d00	38		sec				sec 								; if so exit with CS
.1d01	f0 0d		beq $1d10			beq 	_FLExit
.1d03					_FLNext:
.1d03	18		clc				clc
.1d04	a5 10		lda $10				lda 	temp1
.1d06	72 10		adc ($10)			adc 	(temp1)
.1d08	85 10		sta $10				sta 	temp1
.1d0a	90 02		bcc $1d0e			bcc 	_NoCarryAdv
.1d0c	e6 11		inc $11				inc 	temp1+1
.1d0e					_NoCarryAdv:
.1d0e	80 de		bra $1cee			bra 	_FLLoop 					; keep looking.
.1d10					_FLExit:
.1d10	7a		ply				ply
.1d11	fa		plx				plx
.1d12	68		pla				pla
.1d13	60		rts				rts
.1d14	18		clc				clc
.1d15	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/clrnew.src

.1d16					NewHandler:
.1d16	9c 00 40	stz $4000			stz 	ProgramMemory 				; Make the first offset zero.
.1d19	20 2c 1d	jsr $1d2c			jsr 	ClearVariableSpace 			; clear variables, reset pointers
.1d1c	4c 00 00	jmp $0000			jmp 	NextCode
.1d1f					ClrHandler:
.1d1f	86 10		stx $10				stx 	temp1
.1d21	a2 80		ldx #$80			ldx 	#NumberStackBase
.1d23	9a		txs				txs
.1d24	a6 10		ldx $10				ldx 	temp1
.1d26	20 2c 1d	jsr $1d2c			jsr 	ClearVariableSpace 			; clear variables, reset pointers
.1d29	4c 00 00	jmp $0000			jmp 	NextCode
.1d2c					ClearVariableSpace:
.1d2c	a9 ff		lda #$ff			lda 	#$FF
.1d2e	85 05		sta $05				sta 	rsp
.1d30	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.1d32	85 0e		sta $0e				sta 	0+(nextFreeMem)
.1d34	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.1d36	85 0f		sta $0f				sta 	1+(nextFreeMem)
.1d38	a0 1f		ldy #$1f			ldy 	#hashTableSize*2-1 			; erase the hash table (used for variables)
.1d3a					_CVSHashClear:
.1d3a	a9 00		lda #$00			lda 	#0 							; all the first record pointers are $00
.1d3c	99 40 06	sta $0640,y			sta 	hashTable,y
.1d3f	88		dey				dey
.1d40	10 f8		bpl $1d3a			bpl 	_CVSHashClear
.1d42					_CVSFindEnd:
.1d42	18		clc				clc
.1d43	a5 0e		lda $0e				lda 	nextFreeMem
.1d45	72 0e		adc ($0e)			adc 	(nextFreeMem)
.1d47	85 0e		sta $0e				sta 	nextFreeMem
.1d49	90 02		bcc $1d4d			bcc 	_NoCarryAdv
.1d4b	e6 0f		inc $0f				inc 	nextFreeMem+1
.1d4d					_NoCarryAdv:
.1d4d	b2 0e		lda ($0e)			lda 	(nextFreeMem)
.1d4f	d0 f1		bne $1d42			bne 	_CVSFindEnd
.1d51	a9 08		lda #$08			lda 	#8 							; this puts a gap in, more for clarity than anything.
.1d53	a0 00		ldy #$00			ldy 	#0
.1d55	20 59 1d	jsr $1d59			jsr 	AdvanceFreeMem				; we need +1 because the previous code leaves the
.1d58	60		rts				rts 								; free mem pointer pointing to the last zero offset
.1d59					AdvanceFreeMem:
.1d59	18		clc				clc
.1d5a	65 0e		adc $0e				adc 	nextFreeMem
.1d5c	85 0e		sta $0e				sta 	nextFreeMem
.1d5e	98		tya				tya
.1d5f	65 0f		adc $0f				adc 	nextFreeMem+1
.1d61	85 0f		sta $0f				sta 	nextFreeMem+1
.1d63	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/debug.src

.1d64					ExitDump:
.1d64	ba		tsx				tsx 								; save Data Stack in temp1
.1d65	86 10		stx $10				stx 	temp1
.1d67	4c ff ff	jmp $ffff			jmp 	$FFFF 						; makes the X16-Emulator dump-exit.
.1d6a					BreakCmd:
>1d6a	ff						.byte 	$FF
.1d6b	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/system/decode.src

.1d6e					DecodeLineIntoBufPtr:
.1d6e	48		pha				pha
.1d6f	da		phx				phx
.1d70	5a		phy				phy
.1d71	85 08		sta $08				sta 	srcPtr 						; save the source line.
.1d73	84 09		sty $09				sty 	srcPtr+1
.1d75	90 1b		bcc $1d92			bcc 	_DecodeNoLineNumber
.1d77	a0 01		ldy #$01			ldy 	#1 							; get line # to YA
.1d79	b1 08		lda ($08),y			lda 	(srcPtr),y
.1d7b	aa		tax				tax
.1d7c	c8		iny				iny
.1d7d	b1 08		lda ($08),y			lda 	(srcPtr),y
.1d7f	a8		tay				tay
.1d80	8a		txa				txa
.1d81	18		clc				clc
.1d82	20 81 1e	jsr $1e81			jsr 	DecodeYAToBuffer 			; convert to string in buffer
.1d85	aa		tax				tax 								; count in X
.1d86					_DecodeLineSpace:
.1d86	e0 05		cpx #$05			cpx 	#5
.1d88	f0 08		beq $1d92			beq 	_DecodeNoLineNumber
.1d8a	a9 20		lda #$20			lda 	#" " 						; pad to 5 spaces
.1d8c	20 5f 1e	jsr $1e5f			jsr 	DecodeWriteBuffer
.1d8f	e8		inx				inx
.1d90	80 f4		bra $1d86			bra 	_DecodeLineSpace
.1d92					_DecodeNoLineNumber:
.1d92	a0 03		ldy #$03			ldy 	#3 							; initial position.
.1d94					_DecodeLoop:
.1d94	b1 08		lda ($08),y			lda 	(srcPtr),y 					; copy the current character to temp1
.1d96	85 10		sta $10				sta 	temp1 						; must be an execution address.
.1d98	c8		iny				iny
.1d99	b1 08		lda ($08),y			lda 	(srcPtr),y
.1d9b	85 11		sta $11				sta 	temp1+1
.1d9d	c8		iny				iny 								; y points to the byte after it.
.1d9e	a5 10		lda $10				lda 	temp1
.1da0	c9 72		cmp #$72			cmp 	#NextLine & $FF
.1da2	d0 06		bne $1daa			bne 	_DecodeNotEOL
.1da4	a5 11		lda $11				lda 	temp1+1
.1da6	c9 21		cmp #$21			cmp 	#NextLine >> 8
.1da8	f0 0b		beq $1db5			beq 	_DecodeEOL
.1daa					_DecodeNotEOL:
.1daa	20 bd 1d	jsr $1dbd			jsr 	IdentifyCodeWord
.1dad	20 0a 1e	jsr $1e0a			jsr 	DecodeFoundWord
.1db0	20 f4 1d	jsr $1df4			jsr 	AdvanceToNext 				; advance to next entry in the line.
.1db3	80 df		bra $1d94			bra 	_DecodeLoop 				; and go round again
.1db5					_DecodeEOL:
.1db5	a9 00		lda #$00			lda 	#0
.1db7	92 0a		sta ($0a)			sta 	(bufPtr)
.1db9	7a		ply				ply 								; restore registers and exit
.1dba	fa		plx				plx
.1dbb	68		pla				pla
.1dbc	60		rts				rts
.1dbd					IdentifyCodeWord:
.1dbd	5a		phy				phy 								; save current position on the stack.
.1dbe	a9 c1		lda #$c1			lda 	#(Dictionary) & $FF
.1dc0	85 0c		sta $0c				sta 	0+(matchPtr)
.1dc2	a9 24		lda #$24			lda 	#(Dictionary) >> 8
.1dc4	85 0d		sta $0d				sta 	1+(matchPtr)
.1dc6					_DecodeIdentify:
.1dc6	a0 02		ldy #$02			ldy 	#2 							; have we found a match ?
.1dc8	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.1dca	c5 10		cmp $10				cmp 	temp1
.1dcc	d0 07		bne $1dd5			bne 	_DecodeIdNext
.1dce	c8		iny				iny
.1dcf	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.1dd1	c5 11		cmp $11				cmp 	temp1+1
.1dd3	f0 1d		beq $1df2			beq 	_DecodeIdFound
.1dd5					_DecodeIdNext:
.1dd5	18		clc				clc
.1dd6	b2 0c		lda ($0c)			lda 	(matchPtr)
.1dd8	f0 0a		beq $1de4			beq 	_DecodeIdIssue
.1dda	65 0c		adc $0c				adc 	matchPtr
.1ddc	85 0c		sta $0c				sta 	matchPtr
.1dde	90 e6		bcc $1dc6			bcc 	_DecodeIdentify
.1de0	e6 0d		inc $0d				inc 	matchPtr+1
.1de2	80 e2		bra $1dc6			bra 	_DecodeIdentify
.1de4					_DecodeIdIssue:
.1de4	20 fe 10	jsr $10fe			jsr 	ErrorHandler
>1de7	44 45 43 4f 44 45 2f 42				.text 	"DECODE/BUG",0
>1def	55 47 00
.1df2					_DecodeIdFound:
.1df2	7a		ply				ply 								; restore position.
.1df3	60		rts				rts
.1df4					AdvanceToNext:
.1df4	5a		phy				phy 								; get the parameter count from bits 0-1 of the type byte
.1df5	a0 01		ldy #$01			ldy 	#1
.1df7	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.1df9	29 03		and #$03			and 	#3 							; bits 0-1.
.1dfb	7a		ply				ply
.1dfc	c9 03		cmp #$03			cmp 	#3 							; is it n-bytes e.g. specified by the next byte
.1dfe	d0 02		bne $1e02			bne 	_ATN012
.1e00	b1 08		lda ($08),y			lda 	(srcPtr),y 					; if so, use that byte as the overall length.
.1e02					_ATN012:
.1e02	85 12		sta $12				sta 	temp2 						; now add that to Y
.1e04	98		tya				tya
.1e05	18		clc				clc
.1e06	65 12		adc $12				adc 	temp2
.1e08	a8		tay				tay
.1e09	60		rts				rts
.1e0a					DecodeFoundWord:
.1e0a	5a		phy				phy 								; save current position
.1e0b	84 12		sty $12				sty		temp2 						; put it in temp2 as well.
.1e0d	a0 01		ldy #$01			ldy 	#1 							; get the type byte
.1e0f	b1 0c		lda ($0c),y			lda 	(matchPtr),y 				; is there a special decoder check (bit 4 set) ?
.1e11	29 10		and #$10			and 	#$10
.1e13	d0 0e		bne $1e23			bne 	_DFWSpecialDecoder
.1e15	b1 0c		lda ($0c),y			lda 	(matchPtr),y 				; reget it.
.1e17	30 08		bmi $1e21			bmi 	_DFWExit 					; if hidden word (bit 7 set)
.1e19	a9 06		lda #$06			lda 	#CTH_Keyword				; output a space to the buffer
.1e1b	20 5f 1e	jsr $1e5f			jsr 	DecodeWriteBuffer
.1e1e	20 3c 1e	jsr $1e3c			jsr 	DecodeCurrentWord 			; expand that.
.1e21					_DFWExit:
.1e21	7a		ply				ply 								; restore current position
.1e22	60		rts				rts
.1e23					_DFWSpecialDecoder:
.1e23	a0 04		ldy #$04			ldy 	#4 							; the decode word address is at offset 4,5
.1e25	b1 0c		lda ($0c),y			lda 	(matchPtr),y 				; copy this into temp2
.1e27	85 12		sta $12				sta 	temp2
.1e29	c8		iny				iny
.1e2a	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.1e2c	85 13		sta $13				sta 	temp2+1
.1e2e	7a		ply				ply 	 							; restore current position into Y
.1e2f	48		pha				pha 								; save registers
.1e30	da		phx				phx
.1e31	5a		phy				phy
.1e32	20 39 1e	jsr $1e39			jsr 	_DFWCallDecoder				; call the decoder routine
.1e35	7a		ply				ply 								; restore registers and exit
.1e36	fa		plx				plx
.1e37	68		pla				pla
.1e38	60		rts				rts
.1e39					_DFWCallDecoder:
.1e39	6c 12 00	jmp ($0012)			jmp 	(temp2)
.1e3c					DecodeCurrentWord:
.1e3c	5a		phy				phy
.1e3d	a0 01		ldy #$01			ldy 	#1 							; read type byte
.1e3f	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.1e41	a0 04		ldy #$04			ldy 	#4 							; original offset
.1e43	4a		lsr a				lsr 	a 							; encoder/decoder bits in 0-1
.1e44	4a		lsr a				lsr 	a 							; add 2 to Y for each encoder/decoder
.1e45	4a		lsr a				lsr 	a 							; bit set.
.1e46	4a		lsr a				lsr 	a
.1e47	4a		lsr a				lsr 	a 							; decoder bit
.1e48	90 02		bcc $1e4c			bcc 	_DWBNoDec
.1e4a	c8		iny				iny
.1e4b	c8		iny				iny
.1e4c					_DWBNoDec:
.1e4c	4a		lsr a				lsr 	a
.1e4d	90 02		bcc $1e51			bcc 	_DWBNoEnc
.1e4f	c8		iny				iny
.1e50	c8		iny				iny
.1e51					_DWBNoEnc:
.1e51					_DWBWordOut:
.1e51	b1 0c		lda ($0c),y			lda 	(matchPtr),y 				; output until bit 7 set.
.1e53	48		pha				pha
.1e54	29 7f		and #$7f			and 	#$7F
.1e56	20 5f 1e	jsr $1e5f			jsr		DecodeWriteBuffer
.1e59	c8		iny				iny
.1e5a	68		pla				pla
.1e5b	10 f4		bpl $1e51			bpl 	_DWBWordOut
.1e5d	7a		ply				ply 								; restore Y and exit
.1e5e	60		rts				rts
.1e5f					DecodeWriteBuffer:
.1e5f	92 0a		sta ($0a)			sta 	(bufPtr)
.1e61	e6 0a		inc $0a				inc 	bufPtr
.1e63	d0 02		bne $1e67			bne 	_DWBNoCarry
.1e65	e6 0b		inc $0b				inc 	bufPtr+1
.1e67					_DWBNoCarry:
.1e67	60		rts				rts
.1e68					DecodeOutputData:
.1e68	48		pha				pha
.1e69	da		phx				phx
.1e6a	5a		phy				phy
.1e6b	b1 08		lda ($08),y			lda 	(srcPtr),y 					; length + 1
.1e6d	aa		tax				tax
.1e6e					_DODLoop:
.1e6e	ca		dex				dex 								; done it all ?
.1e6f	f0 0c		beq $1e7d			beq		_DODExit
.1e71	c8		iny				iny 								; output next character
.1e72	b1 08		lda ($08),y			lda 	(srcPtr),y
.1e74	29 7f		and #$7f			and 	#$7F
.1e76	f0 f6		beq $1e6e			beq 	_DODLoop 					; don't print NULL
.1e78	20 5f 1e	jsr $1e5f			jsr 	DecodeWriteBuffer
.1e7b	80 f1		bra $1e6e			bra 	_DODLoop
.1e7d					_DODExit:
.1e7d	7a		ply				ply
.1e7e	fa		plx				plx
.1e7f	68		pla				pla
.1e80	60		rts				rts
.1e81					DecodeYAToBuffer:
.1e81	da		phx				phx
.1e82	5a		phy				phy
.1e83	48		pha				pha
.1e84	a5 0a		lda $0a				lda 	bufPtr 						; copy bufPtr to temp2
.1e86	85 12		sta $12				sta 	temp2
.1e88	a5 0b		lda $0b				lda 	bufPtr+1
.1e8a	85 13		sta $13				sta 	temp2+1
.1e8c	68		pla				pla
.1e8d	20 ab 22	jsr $22ab			jsr 	ConvertToStringMain 		; convert YA to string there
.1e90	aa		tax				tax 								; chars output to X
.1e91	18		clc				clc
.1e92	65 0a		adc $0a				adc 	bufPtr 						; add to buffer pointer
.1e94	85 0a		sta $0a				sta 	bufPtr
.1e96	90 02		bcc $1e9a			bcc 	_DYABNoCarry
.1e98	e6 0b		inc $0b				inc 	bufPtr+1
.1e9a					_DYABNoCarry:
.1e9a	8a		txa				txa 								; count in A
.1e9b	7a		ply				ply									; restore and exit.
.1e9c	fa		plx				plx
.1e9d	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/edit.src

.1e9e					EditProgram:
.1e9e	20 1b 1f	jsr $1f1b			jsr 	EDFindLine					; find line address -> temp1
.1ea1	90 0f		bcc $1eb2			bcc 	_EPNotFound 				; if missing don't delete it.
.1ea3	a5 10		lda $10				lda 	temp1 						; save line address
.1ea5	48		pha				pha
.1ea6	a5 11		lda $11				lda 	temp1+1
.1ea8	48		pha				pha
.1ea9	20 c0 1e	jsr $1ec0			jsr 	EDDeleteLine 				; delete the line
.1eac	68		pla				pla 								; restore line address
.1ead	85 11		sta $11				sta 	temp1+1
.1eaf	68		pla				pla
.1eb0	85 10		sta $10				sta 	temp1
.1eb2					_EPNotFound:
.1eb2	ad 10 09	lda $0910			lda 	encodeBuffer 				; is there anything in the line.
.1eb5	c9 05		cmp #$05			cmp 	#5 							; <offset> <line#> <next line>
.1eb7	f0 03		beq $1ebc			beq 	_EPNoInsert
.1eb9	20 e3 1e	jsr $1ee3			jsr 	EDInsertLine 				; insert line back in.
.1ebc					_EPNoInsert:
.1ebc	20 2c 1d	jsr $1d2c			jsr 	ClearVariableSpace
.1ebf	60		rts				rts
.1ec0					EDDeleteLine:
.1ec0	20 2c 1d	jsr $1d2c			jsr 	ClearVariableSpace
.1ec3	a0 00		ldy #$00			ldy 	#0 							; this is the offset to copy down.
.1ec5	a2 00		ldx #$00			ldx 	#0
.1ec7	b1 10		lda ($10),y			lda 	(temp1),y
.1ec9	a8		tay				tay 								; put in Y
.1eca					_EDDelLoop:
.1eca	b1 10		lda ($10),y			lda 	(temp1),y 					; get it
.1ecc	81 10		sta ($10,x)			sta 	(temp1,x) 					; write it.
.1ece	a5 10		lda $10				lda 	temp1 						; check if pointer has reached the end of
.1ed0	c5 0e		cmp $0e				cmp		nextFreeMem 				; low memory. We will have copied down an
.1ed2	d0 06		bne $1eda			bne 	_EDDelNext 					; extra pile of stuff - technically should
.1ed4	a5 11		lda $11				lda 	temp1+1 					; check the upper value (e.g. temp1+y)
.1ed6	c5 0f		cmp $0f				cmp 	nextFreeMem+1				; doesn't really matter.
.1ed8	f0 08		beq $1ee2			beq		_EDDelExit
.1eda					_EDDelNext:
.1eda	e6 10		inc $10				inc 	temp1 						; go to next byte.
.1edc	d0 ec		bne $1eca			bne 	_EDDelLoop
.1ede	e6 11		inc $11				inc 	temp1+1
.1ee0	80 e8		bra $1eca			bra 	_EDDelLoop
.1ee2					_EDDelExit:
.1ee2	60		rts				rts
.1ee3					EDInsertLine:
.1ee3	20 2c 1d	jsr $1d2c			jsr 	ClearVariableSpace
.1ee6	a5 0e		lda $0e				lda 	nextFreeMem 				; copy high memory to temp3
.1ee8	85 14		sta $14				sta 	temp3
.1eea	a5 0f		lda $0f				lda 	nextFreeMem+1
.1eec	85 15		sta $15				sta 	temp3+1
.1eee	ac 10 09	ldy $0910			ldy 	encodeBuffer 				; space to move it to in Y
.1ef1	a2 00		ldx #$00			ldx 	#0
.1ef3					_EDInsLoop:
.1ef3	a1 14		lda ($14,x)			lda 	(temp3,x)					; copy it up
.1ef5	91 14		sta ($14),y			sta 	(temp3),y
.1ef7	a5 14		lda $14				lda 	temp3 						; reached the insert point (temp1)
.1ef9	c5 10		cmp $10				cmp 	temp1
.1efb	d0 06		bne $1f03			bne 	_EDINextShift
.1efd	a5 15		lda $15				lda 	temp3+1
.1eff	c5 11		cmp $11				cmp 	temp1+1
.1f01	f0 0a		beq $1f0d			beq 	_EDIShiftOver
.1f03					_EDINextShift:
.1f03	a5 14		lda $14				lda 	temp3 						; decrement the copy pointer.
.1f05	d0 02		bne $1f09			bne 	_EDINoBorrow
.1f07	c6 15		dec $15				dec 	temp3+1
.1f09					_EDINoBorrow:
.1f09	c6 14		dec $14				dec 	temp3
.1f0b	80 e6		bra $1ef3			bra 	_EDInsLoop
.1f0d					_EDIShiftOver:
.1f0d	a0 00		ldy #$00			ldy 	#0
.1f0f					_EDICopyCode:
.1f0f	b9 10 09	lda $0910,y			lda 	encodeBuffer,y				; read from the current line
.1f12	91 10		sta ($10),y			sta 	(temp1),y 					; write out
.1f14	c8		iny				iny 								; bump pointers
.1f15	cc 10 09	cpy $0910			cpy 	encodeBuffer 				; done the whole lot ?
.1f18	d0 f5		bne $1f0f			bne 	_EDICopyCode
.1f1a	60		rts				rts
.1f1b					EDFindLine:
.1f1b	a9 00		lda #$00			lda 	#(programMemory) & $FF
.1f1d	85 10		sta $10				sta 	0+(temp1)
.1f1f	a9 40		lda #$40			lda 	#(programMemory) >> 8
.1f21	85 11		sta $11				sta 	1+(temp1)
.1f23					_EDFLLoop:
.1f23	b2 10		lda ($10)			lda 	(temp1) 					; check offset
.1f25	f0 24		beq $1f4b			beq 	_EDFLFail 					; then obviously that's the end ;-) (great comment !)
.1f27	a0 01		ldy #$01			ldy 	#1							; look at line #
.1f29	38		sec				sec
.1f2a	ad 11 09	lda $0911			lda 	encodeBuffer+1				; subtract the current from the target
.1f2d	f1 10		sbc ($10),y			sbc 	(temp1),y 					; so if searching for 100 and this one is 90,
.1f2f	aa		tax				tax	 								; this will return 10.
.1f30	ad 12 09	lda $0912			lda 	encodeBuffer+2
.1f33	c8		iny				iny
.1f34	f1 10		sbc ($10),y			sbc 	(temp1),y
.1f36	90 13		bcc $1f4b			bcc 	_EDFLFail					; if target < current then failed.
.1f38	d0 04		bne $1f3e			bne 	_EDFLNext 					; if non-zero then goto next
.1f3a	e0 00		cpx #$00			cpx 	#0 							; same for the LSB - zero if match found.
.1f3c	f0 0f		beq $1f4d			beq 	_EDFLFound
.1f3e					_EDFLNext:
.1f3e	18		clc				clc
.1f3f	a5 10		lda $10				lda 	temp1
.1f41	72 10		adc ($10)			adc 	(temp1)
.1f43	85 10		sta $10				sta 	temp1
.1f45	90 02		bcc $1f49			bcc 	_NoCarryAdv
.1f47	e6 11		inc $11				inc 	temp1+1
.1f49					_NoCarryAdv:
.1f49	80 d8		bra $1f23			bra 	_EDFLLoop
.1f4b					_EDFLFail:
.1f4b	18		clc				clc
.1f4c	60		rts				rts
.1f4d					_EDFLFound:
.1f4d	38		sec				sec
.1f4e	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/list.src

.1f4f					ListCode:
.1f4f	64 1e		stz $1e				stz 	ListLowest 					; zero lowest line#
.1f51	64 1f		stz $1f				stz 	ListLowest+1
.1f53	a9 18		lda #$18			lda 	#24 						; show max 24 after lowest line
.1f55	85 1d		sta $1d				sta 	ListCount
.1f57	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.1f59	85 18		sta $18				sta 	0+(listPtr)
.1f5b	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.1f5d	85 19		sta $19				sta 	1+(listPtr)
.1f5f	86 10		stx $10				stx 	temp1						; S->A
.1f61	ba		tsx				tsx
.1f62	8a		txa				txa
.1f63	a6 10		ldx $10				ldx 	temp1
.1f65	c9 80		cmp #$80			cmp 	#NumberStackBase
.1f67	f0 0e		beq $1f77			beq 	_LCLoop
.1f69	a5 06		lda $06				lda 	TOS 						; copy TOS to lowest
.1f6b	85 1e		sta $1e				sta 	ListLowest
.1f6d	a5 07		lda $07				lda 	TOS+1
.1f6f	85 1f		sta $1f				sta 	ListLowest+1
.1f71	68		pla				pla
.1f72	85 07		sta $07				sta 	TOS+1
.1f74	68		pla				pla
.1f75	85 06		sta $06				sta 	TOS
.1f77					_LCLoop:
.1f77	b2 18		lda ($18)			lda 	(listPtr)					; reached end ?
.1f79	f0 4c		beq $1fc7			beq 	_LCExit
.1f7b	a0 01		ldy #$01			ldy 	#1							; >= list lowest
.1f7d	b1 18		lda ($18),y			lda 	(listPtr),y
.1f7f	c5 1e		cmp $1e				cmp 	ListLowest
.1f81	c8		iny				iny
.1f82	b1 18		lda ($18),y			lda 	(listPtr),y
.1f84	e5 1f		sbc $1f				sbc 	ListLowest+1
.1f86	90 32		bcc $1fba			bcc 	_LCNext
.1f88	a9 10		lda #$10			lda 	#(textBuffer) & $FF
.1f8a	85 0a		sta $0a				sta 	0+(bufPtr)
.1f8c	a9 08		lda #$08			lda 	#(textBuffer) >> 8
.1f8e	85 0b		sta $0b				sta 	1+(bufPtr)
.1f90	a5 18		lda $18				lda 	listPtr 					; output the line.
.1f92	a4 19		ldy $19				ldy 	listPtr+1
.1f94	38		sec				sec
.1f95	20 6e 1d	jsr $1d6e			jsr 	DecodeLineIntoBufPtr
.1f98	a9 02		lda #$02			lda 	#CTH_LineNo
.1f9a	20 68 11	jsr $1168			jsr 	ExternColour
.1f9d	a0 ff		ldy #$ff			ldy 	#255
.1f9f					_LCLoop2:
.1f9f	c8		iny				iny
.1fa0	b9 10 08	lda $0810,y			lda 	textBuffer,y
.1fa3	f0 0e		beq $1fb3			beq 	_LCEnd
.1fa5	c9 20		cmp #$20			cmp 	#32
.1fa7	b0 05		bcs $1fae			bcs 	_LCPrint
.1fa9	20 68 11	jsr $1168			jsr 	ExternColour
.1fac	a9 20		lda #$20			lda 	#32
.1fae					_LCPrint:
.1fae	20 5e 11	jsr $115e			jsr 	ExternPrint
.1fb1	80 ec		bra $1f9f			bra 	_LCLoop2
.1fb3	a9 0d		lda #$0d	_LCEnd:	lda 	#13 						; new line
.1fb5	20 5e 11	jsr $115e			jsr 	ExternPrint
.1fb8	c6 1d		dec $1d				dec 	ListCount					; done all the lines allowed
.1fba					_LCNext:
.1fba	18		clc				clc
.1fbb	a5 18		lda $18				lda 	listPtr
.1fbd	72 18		adc ($18)			adc 	(listPtr)
.1fbf	85 18		sta $18				sta 	listPtr
.1fc1	90 02		bcc $1fc5			bcc 	_NoCarryAdv
.1fc3	e6 19		inc $19				inc 	listPtr+1
.1fc5					_NoCarryAdv:
.1fc5	80 b0		bra $1f77			bra 	_LCLoop 					; go round again.
.1fc7					_LCExit:
.1fc7	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/system/miscellany.src

.1fca					RunProgram:
.1fca	86 10		stx $10				stx 	temp1
.1fcc	a2 80		ldx #$80			ldx 	#NumberStackBase
.1fce	9a		txs				txs
.1fcf	a6 10		ldx $10				ldx 	temp1
.1fd1	20 2c 1d	jsr $1d2c			jsr 	ClearVariableSpace 			; clear variables etc.
.1fd4	a2 00		ldx #$00			ldx		#ProgramMemory & $FF		; boot address
.1fd6	a0 40		ldy #$40			ldy 	#ProgramMemory >>8
.1fd8	20 95 10	jsr $1095			jsr 	InitialiseCoreCode 			; initialise the NEXT routine at $00
.1fdb	4c 00 00	jmp $0000			jmp 	NextCode
.1fde					Call6502:
.1fde	a5 06		lda $06				lda 	TOS 						; copy call address
.1fe0	85 10		sta $10				sta 	temp1
.1fe2	a5 07		lda $07				lda 	TOS+1
.1fe4	85 11		sta $11				sta 	temp1+1
.1fe6	68		pla				pla
.1fe7	85 07		sta $07				sta 	TOS+1
.1fe9	68		pla				pla
.1fea	85 06		sta $06				sta 	TOS
.1fec	20 f2 1f	jsr $1ff2			jsr 	_CallTemp1 					; call it
.1fef	4c 00 00	jmp $0000			jmp 	NextCode
.1ff2					_CallTemp1:
.1ff2	6c 10 00	jmp ($0010)			jmp 	(temp1)
.1ff5					AssertCode:
.1ff5	a5 06		lda $06				lda 	TOS 						; TOS = 0
.1ff7	05 07		ora $07				ora 	TOS+1
.1ff9	f0 09		beq $2004			beq 	_ASFail 					; if zero fail
.1ffb	68		pla				pla
.1ffc	85 07		sta $07				sta 	TOS+1
.1ffe	68		pla				pla
.1fff	85 06		sta $06				sta 	TOS
.2001	4c 00 00	jmp $0000			jmp 	NextCode
.2004					_ASFail:
.2004	20 fe 10	jsr $10fe			jsr 	ErrorHandler
>2007	41 53 53 45 52 54 00				.text 	"ASSERT",0
.200e					StopCode:
.200e	20 fe 10	jsr $10fe			jsr 	ErrorHandler
>2011	53 54 4f 50 00					.text 	"STOP",0
.2016					EndProgram:
.2016	4c 14 10	jmp $1014			jmp 	WarmStart
.2019					VlistCode:
.2019	a9 c1		lda #$c1			lda 	#(Dictionary) & $FF
.201b	85 10		sta $10				sta 	0+(temp1)
.201d	a9 24		lda #$24			lda 	#(Dictionary) >> 8
.201f	85 11		sta $11				sta 	1+(temp1)
.2021	a0 01		ldy #$01	_VLLoop:ldy 	#1							; type byte
.2023	b1 10		lda ($10),y			lda 	(temp1),y
.2025	a0 04		ldy #$04			ldy 	#4 							; Y = 4
.2027	4a		lsr a				lsr 	a 							; shift bits 4 and 5 to 0,1
.2028	4a		lsr a				lsr 	a
.2029	4a		lsr a				lsr		a
.202a	4a		lsr a				lsr 	a
.202b	4a		lsr a				lsr 	a 							; add those bits in
.202c	90 02		bcc $2030			bcc 	_VLNoDec
.202e	c8		iny				iny
.202f	c8		iny				iny
.2030					_VLNoDec:
.2030	4a		lsr a				lsr 	a
.2031	90 02		bcc $2035			bcc 	_VLNoEnc
.2033	c8		iny				iny
.2034	c8		iny				iny
.2035					_VLNoEnc:
.2035	b1 10		lda ($10),y			lda 	(temp1),y 					; remove $$ words
.2037	c9 24		cmp #$24			cmp 	#"$"
.2039	d0 06		bne $2041			bne 	_VLPrint
.203b	c8		iny				iny
.203c	51 10		eor ($10),y			eor 	(temp1),y
.203e	f0 13		beq $2053			beq 	_VLNext
.2040	88		dey				dey
.2041					_VLPrint:
.2041	b1 10		lda ($10),y			lda 	(temp1),y
.2043	48		pha				pha
.2044	c8		iny				iny
.2045	29 7f		and #$7f			and 	#$7F
.2047	20 5e 11	jsr $115e			jsr 	ExternPrint
.204a	68		pla				pla
.204b	0a		asl a				asl 	a
.204c	90 f3		bcc $2041			bcc 	_VLPrint
.204e	a9 20		lda #$20			lda 	#32
.2050	20 5e 11	jsr $115e			jsr 	ExternPrint
.2053					_VLNext:
.2053	18		clc				clc 								; go to next
.2054	b2 10		lda ($10)			lda 	(temp1)
.2056	65 10		adc $10				adc 	temp1
.2058	85 10		sta $10				sta 	temp1
.205a	90 02		bcc $205e			bcc 	_VLNoCarry
.205c	e6 11		inc $11				inc 	temp1+1
.205e					_VLNoCarry:
.205e	b2 10		lda ($10)			lda 	(temp1)
.2060	d0 bf		bne $2021			bne 	_VLLoop
.2062	a9 0d		lda #$0d			lda 	#13
.2064	20 5e 11	jsr $115e			jsr 	ExternPrint
.2067	4c 00 00	jmp $0000			jmp 	NextCode
.206a					DumpStack:
.206a	a9 5b		lda #$5b			lda		#"["
.206c	20 5e 11	jsr $115e			jsr 	ExternPrint
.206f	86 10		stx $10				stx 	temp1 						; X -> A
.2071	ba		tsx				tsx
.2072	8a		txa				txa
.2073	a6 10		ldx $10				ldx 	temp1
.2075	c9 80		cmp #$80			cmp 	#NumberStackBase 			; out of range, exit
.2077	f0 2f		beq $20a8			beq 	_DSExit
.2079	48		pha				pha 								; save it
.207a	a9 07		lda #$07			lda 	#COL_WHITE
.207c	20 68 11	jsr $1168			jsr 	ExternColour
.207f	a5 06		lda $06				lda 	TOS 						; print TOS then stack values backwards
.2081	a4 07		ldy $07				ldy 	TOS+1
.2083	38		sec				sec 								; print unsigned.
.2084	20 85 22	jsr $2285			jsr 	PrintYA
.2087	a9 06		lda #$06			lda 	#COL_CYAN
.2089	20 68 11	jsr $1168			jsr 	ExternColour
.208c	7a		ply				ply 								; restore offset
.208d					_DSLoop:
.208d	c0 7e		cpy #$7e			cpy 	#NumberStackBase-2 			; till done whole stack.
.208f	f0 17		beq $20a8			beq 	_DSExit
.2091	a9 20		lda #$20			lda 	#" " 						; space
.2093	20 5e 11	jsr $115e			jsr 	ExternPrint
.2096	5a		phy				phy 								; save pos
.2097	b9 01 01	lda $0101,y			lda 	$0101,y 					; read stack item
.209a	48		pha				pha
.209b	b9 02 01	lda $0102,y			lda 	$0102,y
.209e	7a		ply				ply
.209f	38		sec				sec
.20a0	20 85 22	jsr $2285			jsr 	PrintYA 					; print it
.20a3	7a		ply				ply 								; restore and advance pos
.20a4	c8		iny				iny
.20a5	c8		iny				iny
.20a6	80 e5		bra $208d			bra 	_DSLoop
.20a8					_DSExit:
.20a8	a9 5d		lda #$5d			lda		#"]"
.20aa	20 5e 11	jsr $115e			jsr 	ExternPrint
.20ad	a9 0d		lda #$0d			lda 	#13
.20af	20 5e 11	jsr $115e			jsr 	ExternPrint
.20b2	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/system/saveload.src

.20b5					System_Save:
.20b5	20 2c 1d	jsr $1d2c			jsr 	ClearVariableSpace  		; make sure start/end are right
.20b8	20 37 21	jsr $2137			jsr 	ExtendWithDictionary 		; attach the dictionary addresses.
.20bb	20 e3 20	jsr $20e3			jsr 	SLGetFileName 				; get filename -> temp3
.20be	a5 0e		lda $0e				lda 	nextFreeMem 				; end address
.20c0	85 10		sta $10				sta 	temp1
.20c2	a5 0f		lda $0f				lda 	nextFreeMem+1
.20c4	85 11		sta $11				sta 	temp1+1
.20c6	a9 00		lda #$00			lda 	#ProgramMemory & $FF 		; program start to YA
.20c8	a0 40		ldy #$40			ldy 	#ProgramMemory >> 8
.20ca	20 b0 11	jsr $11b0			jsr 	ExternSave
.20cd	20 2c 1d	jsr $1d2c			jsr 	ClearVariableSpace  		; make sure start/end are right
.20d0	4c 0d 10	jmp $100d			jmp 	WarmStartBlankStack
.20d3					System_Load:
.20d3	20 e3 20	jsr $20e3			jsr 	SLGetFileName 				; get filename -> temp3
.20d6	a9 00		lda #$00			lda 	#ProgramMemory & $FF 		; program start to YA
.20d8	a0 40		ldy #$40			ldy 	#ProgramMemory >> 8
.20da	20 e6 11	jsr $11e6			jsr 	ExternLoad
.20dd	20 2c 1d	jsr $1d2c			jsr 	ClearVariableSpace 			; reset everything.
.20e0	4c 0d 10	jmp $100d			jmp 	WarmStartBlankStack
.20e3					SLGetFileName:
.20e3	ba		tsx				tsx
.20e4	e0 80		cpx #$80			cpx 	#NumberStackBase
.20e6	f0 3a		beq $2122			beq 	_SLFNFail
.20e8	a9 10		lda #$10			lda 	#textBuffer & $FF 			; f/n in input buffer.
.20ea	85 14		sta $14				sta 	temp3
.20ec	a9 08		lda #$08			lda 	#textBuffer >> 8
.20ee	85 15		sta $15				sta 	temp3+1
.20f0	a0 00		ldy #$00			ldy 	#0
.20f2	b1 06		lda ($06),y	_SLCopy:lda 	(TOS),y
.20f4	91 14		sta ($14),y			sta 	(temp3),y
.20f6	c8		iny				iny
.20f7	c9 00		cmp #$00			cmp		#0
.20f9	d0 f7		bne $20f2			bne 	_SLCopy
.20fb	88		dey				dey
.20fc	a2 03		ldx #$03			ldx 	#3 							; check if it ends in .RPL
.20fe					_SLCheckEnd:
.20fe	88		dey				dey
.20ff	bd 32 21	lda $2132,x			lda 	_SLFNExtension,x
.2102	d1 14		cmp ($14),y			cmp 	(temp3),y
.2104	d0 05		bne $210b			bne 	_SLNoExtension
.2106	ca		dex				dex
.2107	10 f5		bpl $20fe			bpl 	_SLCheckEnd
.2109	80 16		bra $2121			bra 	_SLExit
.210b					_SLNoExtension:
.210b	a0 ff		ldy #$ff			ldy 	#255						; add the extension.
.210d					_SLFindend:
.210d	c8		iny				iny
.210e	b9 10 08	lda $0810,y			lda 	textBuffer,y
.2111	d0 fa		bne $210d			bne 	_SLFindend
.2113	a2 00		ldx #$00			ldx 	#0
.2115					_SLAppend:
.2115	bd 32 21	lda $2132,x			lda 	_SLFNExtension,x
.2118	99 10 08	sta $0810,y			sta 	textBuffer,y
.211b	e8		inx				inx
.211c	c8		iny				iny
.211d	c9 00		cmp #$00			cmp 	#0
.211f	d0 f4		bne $2115			bne 	_SLAppend
.2121					_SLExit:
.2121	60		rts				rts
.2122					_SLFNFail:
.2122	20 fe 10	jsr $10fe			jsr 	ErrorHandler
>2125	42 41 44 20 46 49 4c 45				.text 	"BAD FILENAME",0
>212d	4e 41 4d 45 00
.2132					_SLFNExtension:
>2132	2e 52 50 4c 00					.text 	".RPL",0
.2137					ExtendWithDictionary:
.2137	20 60 21	jsr $2160			jsr 	_EWDMarker 					; 8 bytes after the final offset write a marker
.213a	a9 c1		lda #$c1			lda 	#(Dictionary) & $FF
.213c	85 10		sta $10				sta 	0+(temp1)
.213e	a9 24		lda #$24			lda 	#(Dictionary) >> 8
.2140	85 11		sta $11				sta 	1+(temp1)
.2142					_EWDLoop:
.2142	b2 10		lda ($10)			lda 	(temp1)						; end
.2144	f0 1a		beq $2160			beq 	_EWDMarker
.2146	a0 02		ldy #$02			ldy 	#2 							; output the address
.2148	b1 10		lda ($10),y			lda 	(temp1),y
.214a	20 69 21	jsr $2169			jsr 	_EWDWrite
.214d	c8		iny				iny
.214e	b1 10		lda ($10),y			lda 	(temp1),y
.2150	20 69 21	jsr $2169			jsr 	_EWDWrite
.2153	18		clc				clc 								; next entry.
.2154	a5 10		lda $10				lda 	temp1
.2156	72 10		adc ($10)			adc 	(temp1)
.2158	85 10		sta $10				sta 	temp1
.215a	90 e6		bcc $2142			bcc 	_EWDLoop
.215c	e6 11		inc $11				inc 	temp1+1
.215e	80 e2		bra $2142			bra 	_EWDLoop
.2160					_EWDMarker:
.2160	a9 ff		lda #$ff			lda 	#$FF
.2162	20 69 21	jsr $2169			jsr 	_EWDWrite
.2165	20 69 21	jsr $2169			jsr 	_EWDWrite
.2168	60		rts				rts
.2169					_EWDWrite:
.2169	92 0e		sta ($0e)			sta 	(nextFreeMem)
.216b	e6 0e		inc $0e				inc 	nextFreeMem
.216d	d0 02		bne $2171			bne 	_EWDExit
.216f	e6 0f		inc $0f				inc 	nextFreeMem+1
.2171					_EWDExit:
.2171	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/skipper.src

.2172					NextLine:
.2172	18		clc				clc
.2173	a5 03		lda $03				lda 	IP
.2175	72 03		adc ($03)			adc 	(IP)
.2177	85 03		sta $03				sta 	IP
.2179	90 02		bcc $217d			bcc 	_NoCarryAdv
.217b	e6 04		inc $04				inc 	IP+1
.217d					_NoCarryAdv:
.217d	b2 03		lda ($03)			lda 	(IP)						; is there any following program ?
.217f	f0 05		beq $2186			beq 	_NLGoEnd
.2181	a2 01		ldx #$01			ldx 	#1 							; start 3 in (-2 for Next)
.2183	4c 00 00	jmp $0000			jmp 	NextCode
.2186					_NLGoEnd:
.2186	4c 14 10	jmp $1014			jmp 	WarmStart
.2189					SkipComment:
.2189	e8		inx				inx									; (IP),X points to the length.
.218a	e8		inx				inx
.218b	8a		txa				txa
.218c	a8		tay				tay 								; put into Y
.218d	18		clc				clc
.218e	71 03		adc ($03),y			adc 	(IP),y 						; add the length to X
.2190	aa		tax				tax 								; put back in X
.2191	ca		dex				dex
.2192	ca		dex				dex
.2193	4c 00 00	jmp $0000			jmp 	NextCode
.2196					CommentDecoder:
.2196	a9 06		lda #$06			lda 	#CTH_Keyword
.2198	20 5f 1e	jsr $1e5f			jsr 	DecodeWriteBuffer
.219b	a9 27		lda #$27			lda 	#"'"
.219d	20 5f 1e	jsr $1e5f			jsr 	DecodeWriteBuffer
.21a0	b1 08		lda ($08),y			lda 	(srcPtr),y 					; check if there is no data
.21a2	c9 01		cmp #$01			cmp 	#1
.21a4	f0 0d		beq $21b3			beq 	_CDEmpty 					; if so print nothing.
.21a6	a9 0b		lda #$0b			lda 	#CTH_Comment
.21a8	20 5f 1e	jsr $1e5f			jsr 	DecodeWriteBuffer
.21ab	20 68 1e	jsr $1e68			jsr 	DecodeOutputData
.21ae	a9 20		lda #$20			lda 	#32
.21b0	20 5f 1e	jsr $1e5f			jsr 	DecodeWriteBuffer
.21b3					_CDEmpty
.21b3	60		rts				rts
.21b4					DefineCode:
.21b4	20 fe 10	jsr $10fe			jsr 	ErrorHandler
>21b7	52 45 41 43 48 45 44 20				.text 	"REACHED DEFINITION",0
>21bf	44 45 46 49 4e 49 54 49 4f 4e 00
.21ca					DefineDecoder:
.21ca	a9 07		lda #$07			lda 	#CTH_Definition
.21cc	20 5f 1e	jsr $1e5f			jsr 	DecodeWriteBuffer
.21cf	a9 3a		lda #$3a			lda 	#":"
.21d1	20 5f 1e	jsr $1e5f			jsr 	DecodeWriteBuffer
.21d4	20 68 1e	jsr $1e68			jsr 	DecodeOutputData
.21d7	a9 20		lda #$20			lda 	#32
.21d9	20 5f 1e	jsr $1e5f			jsr 	DecodeWriteBuffer
.21dc	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/toint.src

.21dd					ConvertToInteger:
.21dd	84 17		sty $17				sty 	temp4+1
.21df	85 16		sta $16				sta 	temp4
.21e1	64 14		stz $14				stz 	temp3 						; reset value
.21e3	64 15		stz $15				stz 	temp3+1
.21e5	64 10		stz $10				stz 	temp1 						; temp1 = 0 (decimal) 255 (hex)
.21e7	a0 00		ldy #$00			ldy 	#0 							; look at first character
.21e9	b1 16		lda ($16),y			lda 	(temp4),y
.21eb	49 2d		eor #$2d			eor 	#"-"						; zero if '-'
.21ed	85 11		sta $11				sta 	temp1+1 					; save this in temp1+1
.21ef	d0 01		bne $21f2			bne 	_CTINotMinus
.21f1	c8		iny				iny									; skip -
.21f2					_CTINotMinus:
.21f2	b1 16		lda ($16),y			lda 	(temp4),y
.21f4	c9 24		cmp #$24			cmp		#'$'						; if $ then skip it and set hex flag
.21f6	d0 03		bne $21fb			bne 	_CTILoop
.21f8	c6 10		dec $10				dec 	temp1
.21fa	c8		iny				iny
.21fb					_CTILoop:
.21fb	b1 16		lda ($16),y			lda 	(temp4),y 					; next digit
.21fd	29 7f		and #$7f			and 	#$7F 						; drop end of word flag
.21ff	38		sec				sec
.2200	e9 30		sbc #$30			sbc 	#'0' 						; put in range '0'+
.2202	90 65		bcc $2269			bcc 	_CTIFail 					; out of range.
.2204	c9 0a		cmp #$0a			cmp 	#10 						; in 0-9 ?
.2206	90 0b		bcc $2213			bcc 	_CTILegal
.2208	c9 11		cmp #$11			cmp 	#'A'-'0'					; between 9 and A ?
.220a	90 5d		bcc $2269			bcc 	_CTIFail
.220c	38		sec				sec
.220d	e9 07		sbc #$07			sbc 	#7 							; hex adjust
.220f	c9 10		cmp #$10			cmp 	#16 						; out of range ?
.2211	b0 56		bcs $2269			bcs 	_CTIFail
.2213					_CTILegal:
.2213	48		pha				pha 								; save digit value.
.2214	06 14		asl $14				asl 	temp3
.2216	26 15		rol $15				rol 	temp3+1
.2218	a5 14		lda $14				lda 	temp3 						; copy x2 into temp2
.221a	85 12		sta $12				sta 	temp2
.221c	a5 15		lda $15				lda 	temp3+1
.221e	85 13		sta $13				sta 	temp2+1
.2220	06 14		asl $14				asl 	temp3
.2222	26 15		rol $15				rol 	temp3+1
.2224	06 14		asl $14				asl 	temp3
.2226	26 15		rol $15				rol 	temp3+1
.2228	24 10		bit $10				bit 	temp1 						; hexadecimal
.222a	10 07		bpl $2233			bpl 	_CTIDecimal
.222c	06 14		asl $14				asl 	temp3
.222e	26 15		rol $15				rol 	temp3+1
.2230	68		pla				pla 								; get digit back
.2231	80 12		bra $2245			bra 	_CTIAddLoop
.2233					_CTIDecimal:
.2233	18		clc				clc 								; x 8 + x 2 = x 10
.2234	a5 14		lda $14				lda 	temp3
.2236	65 12		adc $12				adc 	temp2
.2238	85 14		sta $14				sta 	temp3
.223a	a5 15		lda $15				lda 	temp3+1
.223c	65 13		adc $13				adc 	temp2+1
.223e	85 15		sta $15				sta 	temp3+1
.2240	68		pla				pla 								; check digit 0-9
.2241	c9 0a		cmp #$0a			cmp 	#10
.2243	b0 24		bcs $2269			bcs 	_CTIFail
.2245					_CTIAddLoop:
.2245	18		clc				clc
.2246	65 14		adc $14				adc 	temp3
.2248	85 14		sta $14				sta 	temp3
.224a	90 02		bcc $224e			bcc 	_CTINoCarry
.224c	e6 15		inc $15				inc 	temp3+1
.224e					_CTINoCarry:
.224e	c8		iny				iny
.224f	b1 16		lda ($16),y			lda 	(temp4),y 					; was this the last character
.2251	c9 21		cmp #$21			cmp 	#32+1
.2253	b0 a6		bcs $21fb			bcs 	_CTILoop 					; no, go back.
.2255	a5 11		lda $11				lda 	temp1+1 					; was it - ?
.2257	d0 0d		bne $2266			bne 	_CTIOkay
.2259	38		sec				sec
.225a	a9 00		lda #$00			lda 	#0 							; negate temp3.
.225c	e5 14		sbc $14				sbc 	temp3
.225e	85 14		sta $14				sta 	temp3
.2260	a9 00		lda #$00			lda 	#0
.2262	e5 15		sbc $15				sbc 	temp3+1
.2264	85 15		sta $15				sta 	temp3+1
.2266					_CTIOkay:
.2266	98		tya				tya
.2267	38		sec				sec
.2268	60		rts				rts
.2269					_CTIFail:
.2269	18		clc				clc
.226a	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/tostr.src

.226b					IntToString:
.226b	a9 10		lda #$10			lda 	#(textBuffer) & $FF
.226d	85 12		sta $12				sta 	0+(temp2)
.226f	a9 08		lda #$08			lda 	#(textBuffer) >> 8
.2271	85 13		sta $13				sta 	1+(temp2)
.2273	a5 06		lda $06				lda 	TOS 						; value in YA
.2275	a4 07		ldy $07				ldy 	TOS+1
.2277	20 a7 22	jsr $22a7			jsr 	ConvertToString
.227a	a9 10		lda #$10			lda 	#(textBuffer) & $FF
.227c	85 06		sta $06				sta 	0+(TOS)
.227e	a9 08		lda #$08			lda 	#(textBuffer) >> 8
.2280	85 07		sta $07				sta 	1+(TOS)
.2282	4c 00 00	jmp $0000			jmp 	NextCode
.2285					PrintYA:
.2285	48		pha				pha
.2286	da		phx				phx
.2287	5a		phy				phy
.2288	48		pha				pha
.2289	a9 10		lda #$10			lda 	#(textBuffer) & $FF
.228b	85 12		sta $12				sta 	0+(temp2)
.228d	a9 08		lda #$08			lda 	#(textBuffer) >> 8
.228f	85 13		sta $13				sta 	1+(temp2)
.2291	68		pla				pla
.2292	20 ab 22	jsr $22ab			jsr 	ConvertToStringMain
.2295	a2 00		ldx #$00			ldx 	#0
.2297					_PrintYALoop:
.2297	bd 10 08	lda $0810,x			lda 	textBuffer,x
.229a	20 5e 11	jsr $115e			jsr 	ExternPrint
.229d	e8		inx				inx
.229e	bd 10 08	lda $0810,x			lda 	textBuffer,x
.22a1	d0 f4		bne $2297			bne 	_PrintYALoop
.22a3	7a		ply				ply
.22a4	fa		plx				plx
.22a5	68		pla				pla
.22a6	60		rts				rts
.22a7					ConvertToString:
.22a7	38		sec				sec
.22a8	80 01		bra $22ab			bra 	ConvertToStringMain
.22aa					ConvertToStringUnsigned:
.22aa	18		clc				clc
.22ab					ConvertToStringMain:
.22ab	da		phx				phx									; save XY
.22ac	5a		phy				phy
.22ad	64 1a		stz $1a				stz 	SignCount 					; this is zero suppression
.22af	85 10		sta $10				sta 	temp1 						; save YA in temp1
.22b1	84 11		sty $11				sty 	temp1+1
.22b3	a0 00		ldy #$00			ldy 	#0 							; index to result.
.22b5	90 16		bcc $22cd			bcc 	_CTSUnsigned 				; if carry clear do not adjust for -
.22b7	a5 11		lda $11				lda 	temp1+1 					; is it negative
.22b9	10 12		bpl $22cd			bpl 	_CTSUnsigned
.22bb	a9 2d		lda #$2d			lda 	#"-"						; output - sign
.22bd	91 12		sta ($12),y			sta 	(temp2),y
.22bf	c8		iny				iny
.22c0	38		sec				sec 								; negate temp1
.22c1	a9 00		lda #$00			lda 	#0
.22c3	e5 10		sbc $10				sbc 	temp1
.22c5	85 10		sta $10				sta 	temp1
.22c7	a9 00		lda #$00			lda 	#0
.22c9	e5 11		sbc $11				sbc 	temp1+1
.22cb	85 11		sta $11				sta 	temp1+1
.22cd					_CTSUnsigned:
.22cd	a2 00		ldx #$00			ldx 	#0 							; index into subtraction table
.22cf					_CTSLoop:
.22cf	a9 2f		lda #$2f			lda 	#"0"-1						; set the digit to '0' code.
.22d1	91 12		sta ($12),y			sta 	(temp2),y
.22d3					_CTSSubLoop:
.22d3	b1 12		lda ($12),y			lda 	(temp2),y 					; bump the count
.22d5	1a		inc a				inc 	a
.22d6	91 12		sta ($12),y			sta 	(temp2),y
.22d8	38		sec				sec 								; do subtraction saving interim result
.22d9	a5 10		lda $10				lda 	temp1
.22db	fd 0e 23	sbc $230e,x			sbc 	_CTSTable,x
.22de	48		pha				pha
.22df	a5 11		lda $11				lda 	temp1+1
.22e1	fd 0f 23	sbc $230f,x			sbc 	_CTSTable+1,x
.22e4	90 07		bcc $22ed			bcc 	_CTSCantSubtract 			; end of subtraction.
.22e6	85 11		sta $11				sta 	temp1+1 					; save result back
.22e8	68		pla				pla
.22e9	85 10		sta $10				sta 	temp1
.22eb	80 e6		bra $22d3			bra 	_CTSSubLoop
.22ed					_CTSCantSubtract:
.22ed	68		pla				pla 								; throw away interim
.22ee	e8		inx				inx 								; next subtractor
.22ef	e8		inx				inx
.22f0	b1 12		lda ($12),y			lda 	(temp2),y 					; update leading zero
.22f2	49 30		eor #$30			eor 	#"0"
.22f4	05 1a		ora $1a				ora 	SignCount
.22f6	85 1a		sta $1a				sta 	SignCount
.22f8	f0 01		beq $22fb			beq		_CTSLZ 						; if all zeros so far suppress.
.22fa	c8		iny				iny 								; next character
.22fb					_CTSLZ:
.22fb	e0 08		cpx #$08			cpx 	#_CTSTableEnd-_CTSTable 	; done them all ?
.22fd	d0 d0		bne $22cf			bne 	_CTSLoop
.22ff					_CTSComplete:
.22ff	a5 10		lda $10				lda		temp1 						; get remainder 0-9
.2301	09 30		ora #$30			ora 	#48 						; ASCII
.2303	91 12		sta ($12),y			sta 	(temp2),y					; write out
.2305	c8		iny				iny
.2306	a9 00		lda #$00			lda 	#0							; make ASCIIZ
.2308	91 12		sta ($12),y			sta 	(temp2),y
.230a	98		tya				tya 								; size in A
.230b	7a		ply				ply									; pull and exit.
.230c	fa		plx				plx
.230d	60		rts				rts
.230e					_CTSTable:
>230e	10 27 e8 03 64 00 0a 00				.word 	10000,1000,100,10 			; subtractors, this is a simple version.
.2316					_CTSTableEnd:

;******  Return to file: kernel.asm


;******  Processing file: words/system/varhandlers.src

.2316					VarAddressHandler:
.2316	18		clc				clc 								; find variable, error if it doesn't exist.
.2317	20 b9 23	jsr $23b9			jsr 	VariableFind
.231a	20 93 23	jsr $2393			jsr 	VariableCheckIndex
.231d	a5 06		lda $06				lda 	TOS
.231f	48		pha				pha
.2320	a5 07		lda $07				lda 	TOS+1
.2322	48		pha				pha
.2323	a5 10		lda $10				lda 	temp1 						; the address is the new value
.2325	85 06		sta $06				sta 	TOS
.2327	a5 11		lda $11				lda		temp1+1
.2329	85 07		sta $07				sta 	TOS+1
.232b	4c 00 00	jmp $0000			jmp 	NextCode
.232e					VarAddrHandlerDecode:
.232e	a9 26		lda #$26			lda 	#"&"
.2330	4c 6e 24	jmp $246e			jmp 	VarHandlerDecode
.2333					VarReadHandler:
.2333	18		clc				clc 								; find variable, error if it doesn't exist.
.2334	20 b9 23	jsr $23b9			jsr 	VariableFind
.2337	20 93 23	jsr $2393			jsr 	VariableCheckIndex
.233a	a5 06		lda $06				lda 	TOS
.233c	48		pha				pha
.233d	a5 07		lda $07				lda 	TOS+1
.233f	48		pha				pha
.2340	b2 10		lda ($10)			lda 	(temp1)						; read variable address to TOS
.2342	85 06		sta $06				sta 	TOS
.2344	a0 01		ldy #$01			ldy 	#1
.2346	b1 10		lda ($10),y			lda 	(temp1),y
.2348	85 07		sta $07				sta 	TOS+1
.234a	4c 00 00	jmp $0000			jmp 	NextCode
.234d					VarReadHandlerDecode:
.234d	a9 40		lda #$40			lda 	#"@"
.234f	4c 6e 24	jmp $246e			jmp 	VarHandlerDecode
.2352					VarWriteHandler:
.2352	38		sec				sec 								; find variable, create it if it doesn't exist.
.2353	20 b9 23	jsr $23b9			jsr 	VariableFind
.2356	20 93 23	jsr $2393			jsr 	VariableCheckIndex
.2359	a5 06		lda $06				lda 	TOS 						; write TOS to that address.
.235b	92 10		sta ($10)			sta 	(temp1)
.235d	a5 07		lda $07				lda 	TOS+1
.235f	a0 01		ldy #$01			ldy 	#1
.2361	91 10		sta ($10),y			sta 	(temp1),y
.2363	68		pla				pla
.2364	85 07		sta $07				sta 	TOS+1
.2366	68		pla				pla
.2367	85 06		sta $06				sta 	TOS
.2369	4c 00 00	jmp $0000			jmp 	NextCode
.236c					VarWriteHandlerDecode:
.236c	a9 21		lda #$21			lda 	#"!"
.236e	4c 6e 24	jmp $246e			jmp 	VarHandlerDecode
.2371					IndexHandler:
.2371	20 fe 10	jsr $10fe			jsr 	ErrorHandler
>2374	24 24 49 4e 44 45 58 3a				.text 	"$$INDEX:BUG",0
>237c	42 55 47 00
.2380					IndexHandlerDecode:
.2380	a9 5b		lda #$5b			lda 	#"["
.2382	20 5f 1e	jsr $1e5f			jsr 	DecodeWriteBuffer
.2385	b1 08		lda ($08),y			lda 	(srcPtr),y
.2387	a0 00		ldy #$00			ldy 	#0
.2389	38		sec				sec
.238a	20 81 1e	jsr $1e81			jsr 	DecodeYAToBuffer
.238d	a9 5d		lda #$5d			lda 	#"]"
.238f	20 5f 1e	jsr $1e5f			jsr 	DecodeWriteBuffer
.2392	60		rts				rts
.2393					VariableCheckIndex:
.2393	8a		txa				txa 								; next is $$index ?
.2394	a8		tay				tay
.2395	c8		iny				iny
.2396	c8		iny				iny
.2397	b1 03		lda ($03),y			lda 	(IP),y
.2399	c9 71		cmp #$71			cmp 	#IndexHandler & $FF
.239b	d0 1b		bne $23b8			bne 	_VCIExit
.239d	c8		iny				iny
.239e	b1 03		lda ($03),y			lda 	(IP),y
.23a0	c9 23		cmp #$23			cmp 	#IndexHandler >> 8
.23a2	d0 14		bne $23b8			bne 	_VCIExit
.23a4	98		tya				tya 								; fix X backup 3 on from where we started
.23a5	aa		tax				tax
.23a6	c8		iny				iny 								; get the index
.23a7	b1 03		lda ($03),y			lda 	(IP),y
.23a9	0a		asl a				asl 	a 							; double it, add to (temp1) -> temp1
.23aa	a0 01		ldy #$01			ldy 	#1
.23ac	72 10		adc ($10)			adc 	(temp1) 					; do the indirection e.g. the look up.
.23ae	48		pha				pha
.23af	b1 10		lda ($10),y			lda 	(temp1),y
.23b1	69 00		adc #$00			adc 	#0
.23b3	85 11		sta $11				sta 	temp1+1
.23b5	68		pla				pla
.23b6	85 10		sta $10				sta 	temp1
.23b8					_VCIExit:
.23b8	60		rts				rts
.23b9					VariableFind:
.23b9	08		php				php 								; save autocreate flag.
.23ba	e8		inx				inx 								; advance to/over the variable name.
.23bb	e8		inx				inx
.23bc	8a		txa				txa 								; put in Y
.23bd	a8		tay				tay
.23be	b1 03		lda ($03),y			lda 	(IP),y 						; copy name word into temp2
.23c0	85 12		sta $12				sta 	temp2
.23c2	c8		iny				iny
.23c3	b1 03		lda ($03),y			lda 	(IP),y
.23c5	85 13		sta $13				sta 	temp2+1
.23c7	c9 1b		cmp #$1b			cmp 	#27 						; check for A-Z
.23c9	b0 0f		bcs $23da			bcs 	_VFLong
.23cb	a5 13		lda $13				lda 	temp2+1
.23cd	d0 0b		bne $23da			bne 	_VFLong
.23cf	a5 12		lda $12				lda 	temp2						; this is the index
.23d1	0a		asl a				asl 	a 							; double it
.23d2	85 10		sta $10				sta 	temp1
.23d4	a9 06		lda #$06			lda 	#azVariables >> 8			; set the MSB
.23d6	85 11		sta $11				sta 	temp1+1
.23d8	28		plp				plp 								; throw creation flag, it always exists.
.23d9	60		rts				rts
.23da					_VFLong:
.23da	a5 12		lda $12				lda 	temp2 						; built a hash table index into temp3/temp4
.23dc	6a		ror a				ror 	a
.23dd	6a		ror a				ror 	a
.23de	6a		ror a				ror 	a
.23df	6a		ror a				ror 	a
.23e0	45 12		eor $12				eor 	temp2
.23e2	45 13		eor $13				eor 	temp2+1
.23e4	29 0f		and #$0f			and 	#(hashTableSize-1)			; force into range
.23e6	0a		asl a				asl 	a
.23e7	69 40		adc #$40			adc 	#hashTable & $FF 			; make an address of the head => temp1/3
.23e9	85 10		sta $10				sta 	temp1
.23eb	85 14		sta $14				sta 	temp3
.23ed	a9 06		lda #$06			lda 	#hashTable >> 8
.23ef	85 11		sta $11				sta 	temp1+1
.23f1	85 15		sta $15				sta 	temp3+1
.23f3					_VFSearch:
.23f3	a0 01		ldy #$01			ldy 	#1							; read MSB of first record
.23f5	b1 10		lda ($10),y			lda 	(temp1),y
.23f7	f0 23		beq $241c			beq 	_VFNotFound 				; is MSB is zero, can't be a variable record
.23f9	a8		tay				tay 								; follow the link through.
.23fa	b2 10		lda ($10)			lda 	(temp1)
.23fc	85 10		sta $10				sta 	temp1
.23fe	84 11		sty $11				sty 	temp1+1
.2400	a0 04		ldy #$04			ldy 	#4							; check if the name matches
.2402	b1 10		lda ($10),y			lda 	(temp1),y
.2404	c5 12		cmp $12				cmp 	temp2
.2406	d0 eb		bne $23f3			bne 	_VFSearch 					; if it doesn't, follow the next link.
.2408	c8		iny				iny 								; same for 2nd byte of name
.2409	b1 10		lda ($10),y			lda 	(temp1),y
.240b	c5 13		cmp $13				cmp 	temp2+1
.240d	d0 e4		bne $23f3			bne 	_VFSearch
.240f	18		clc				clc
.2410	a5 10		lda $10				lda 	temp1 						; make temp1 point to the data at offset 2
.2412	69 02		adc #$02			adc 	#2
.2414	85 10		sta $10				sta 	temp1
.2416	90 02		bcc $241a			bcc 	_VFNoPage1
.2418	e6 11		inc $11				inc 	temp1+1
.241a					_VFNoPage1:
.241a	28		plp				plp 								; don't need to worry about creation flag
.241b	60		rts				rts
.241c					_VFNotFound:
.241c	28		plp				plp 								; was carry set, e.g. create a new record if not found ?
.241d	b0 14		bcs $2433			bcs 	_VFCreate
.241f	20 fe 10	jsr $10fe			jsr 	ErrorHandler
>2422	4e 4f 20 53 55 43 48 20				.text 	"NO SUCH VARIABLE",0
>242a	56 41 52 49 41 42 4c 45 00
.2433					_VFCreate:
.2433	a0 01		ldy #$01			ldy 	#1
.2435	b2 14		lda ($14)			lda 	(temp3) 					; copy the head link to the first 2 bytes
.2437	92 0e		sta ($0e)			sta 	(nextFreeMem)
.2439	b1 14		lda ($14),y			lda 	(temp3),y
.243b	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.243d	c8		iny				iny
.243e	a9 00		lda #$00			lda 	#0	 						; write zero initialised data out.
.2440	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.2442	c8		iny				iny
.2443	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.2445	c8		iny				iny
.2446	a5 12		lda $12				lda 	temp2 						; copy the name out
.2448	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.244a	c8		iny				iny
.244b	a5 13		lda $13				lda 	temp2+1
.244d	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.244f	a0 01		ldy #$01			ldy 	#1
.2451	a5 0e		lda $0e				lda 	nextFreeMem 				; update the head link
.2453	92 14		sta ($14)			sta 	(temp3)
.2455	a5 0f		lda $0f				lda 	nextFreeMem+1
.2457	91 14		sta ($14),y			sta 	(temp3),y
.2459	18		clc				clc
.245a	a5 0e		lda $0e				lda 	nextFreeMem 				; put nextFreeMem+2 in temp1 (data pointer)
.245c	69 02		adc #$02			adc 	#2
.245e	85 10		sta $10				sta 	temp1
.2460	a5 0f		lda $0f				lda 	nextFreeMem+1
.2462	69 00		adc #$00			adc 	#0
.2464	85 11		sta $11				sta 	temp1+1
.2466	a9 06		lda #$06			lda 	#6							; shift freemem pointer up 6
.2468	a0 00		ldy #$00			ldy 	#0
.246a	20 59 1d	jsr $1d59			jsr 	AdvanceFreeMem
.246d	60		rts				rts
.246e					VarHandlerDecode:
.246e	48		pha				pha 								; save, leading space
.246f	a9 07		lda #$07			lda 	#CTH_Variable
.2471	20 5f 1e	jsr $1e5f			jsr 	DecodeWriteBuffer
.2474	68		pla				pla 								; restore and write type
.2475	20 5f 1e	jsr $1e5f			jsr 	DecodeWriteBuffer
.2478	b1 08		lda ($08),y			lda 	(srcPtr),y 					; copy to temp1
.247a	85 10		sta $10				sta 	temp1
.247c	c8		iny				iny
.247d	b1 08		lda ($08),y			lda 	(srcPtr),y
.247f	85 11		sta $11				sta 	temp1+1
.2481	a5 10		lda $10				lda 	temp1 						; output the first character
.2483	29 1f		and #$1f			and 	#31
.2485	20 b0 24	jsr $24b0			jsr 	VHOutVarChar
.2488	a2 05		ldx #$05			ldx 	#5 							; divide temp1 by 32
.248a					_VHDShift:
.248a	46 11		lsr $11				lsr 	temp1+1
.248c	66 10		ror $10				ror 	temp1
.248e	ca		dex				dex
.248f	d0 f9		bne $248a			bne 	_VHDShift
.2491	a2 ff		ldx #$ff			ldx 	#255 						; now divide that by 40 by repeated subtraction.
.2493					_VHDDiv40:
.2493	e8		inx				inx
.2494	38		sec				sec
.2495	a5 10		lda $10				lda 	temp1
.2497	e9 28		sbc #$28			sbc 	#40
.2499	a8		tay				tay
.249a	a5 11		lda $11				lda 	temp1+1
.249c	e9 00		sbc #$00			sbc 	#0
.249e	90 06		bcc $24a6			bcc 	_VHDivDone
.24a0	85 11		sta $11				sta 	temp1+1
.24a2	84 10		sty $10				sty 	temp1
.24a4	80 ed		bra $2493			bra 	_VHDDiv40
.24a6					_VHDivDone:
.24a6	a5 10		lda $10				lda 	temp1 						; remainder
.24a8	20 b0 24	jsr $24b0			jsr 	VHOutVarChar
.24ab	8a		txa				txa
.24ac	20 b0 24	jsr $24b0			jsr 	VHOutVarChar 				; and result.
.24af	60		rts				rts
.24b0					VHOutVarChar:
.24b0	c9 00		cmp #$00			cmp 	#0
.24b2	f0 0c		beq $24c0			beq 	_VHOExit
.24b4	18		clc				clc
.24b5	69 40		adc #$40			adc 	#64 						; 65-90 A-Z 91-100 0-9
.24b7	c9 5b		cmp #$5b			cmp 	#91 						; convert back ?
.24b9	90 02		bcc $24bd			bcc 	_VHOOut
.24bb	e9 2b		sbc #$2b			sbc 	#91-48 						; adjust to digit
.24bd					_VHOOut:
.24bd	20 5f 1e	jsr $1e5f			jsr 	DecodeWriteBuffer
.24c0					_VHOExit:
.24c0	60		rts				rts

;******  Return to file: kernel.asm

.24c1					Dictionary:

;******  Processing file: generated/dictionary.inc

>24c1	05					.byte	_end0-*
>24c2	00					.byte	$00
>24c3	51 16					.word	WordWrite
>24c5	a1					.byte	$a1
.24c6					_end0:
>24c6	10					.byte	_end1-*
>24c7	52					.byte	$52
>24c8	52 23					.word	VarWriteHandler
>24ca	6c 23					.word	VarWriteHandlerDecode
>24cc	24 24 21 48 41 4e 44 4c			.byte	$24,$24,$21,$48,$41,$4e,$44,$4c,$45,$d2
>24d4	45 d2
.24d6					_end1:
>24d6	10					.byte	_end2-*
>24d7	52					.byte	$52
>24d8	16 23					.word	VarAddressHandler
>24da	2e 23					.word	VarAddrHandlerDecode
>24dc	24 24 26 48 41 4e 44 4c			.byte	$24,$24,$26,$48,$41,$4e,$44,$4c,$45,$d2
>24e4	45 d2
.24e6					_end2:
>24e6	10					.byte	_end3-*
>24e7	52					.byte	$52
>24e8	33 23					.word	VarReadHandler
>24ea	4d 23					.word	VarReadHandlerDecode
>24ec	24 24 40 48 41 4e 44 4c			.byte	$24,$24,$40,$48,$41,$4e,$44,$4c,$45,$d2
>24f4	45 d2
.24f6					_end3:
>24f6	0c					.byte	_end4-*
>24f7	52					.byte	$52
>24f8	bc 1b					.word	CallHandler
>24fa	95 1c					.word	CallHandlerDecode
>24fc	24 24 43 41 4c cc			.byte	$24,$24,$43,$41,$4c,$cc
.2502					_end4:
>2502	0f					.byte	_end5-*
>2503	53					.byte	$53
>2504	89 21					.word	SkipComment
>2506	96 21					.word	CommentDecoder
>2508	24 24 43 4f 4d 4d 45 4e			.byte	$24,$24,$43,$4f,$4d,$4d,$45,$4e,$d4
>2510	d4
.2511					_end5:
>2511	0e					.byte	_end6-*
>2512	53					.byte	$53
>2513	b4 21					.word	DefineCode
>2515	ca 21					.word	DefineDecoder
>2517	24 24 44 45 46 49 4e c5			.byte	$24,$24,$44,$45,$46,$49,$4e,$c5
.251f					_end6:
>251f	0f					.byte	_end7-*
>2520	52					.byte	$52
>2521	a6 10					.word	Literal2Byte
>2523	bc 10					.word	Literal2ByteDecode
>2525	24 24 4c 49 54 45 52 41			.byte	$24,$24,$4c,$49,$54,$45,$52,$41,$cc
>252d	cc
.252e					_end7:
>252e	0e					.byte	_end8-*
>252f	80					.byte	$80
>2530	72 21					.word	NextLine
>2532	24 24 4e 45 58 54 4c 49			.byte	$24,$24,$4e,$45,$58,$54,$4c,$49,$4e,$c5
>253a	4e c5
.253c					_end8:
>253c	0e					.byte	_end9-*
>253d	53					.byte	$53
>253e	ce 10					.word	LiteralString
>2540	ed 10					.word	LiteralStringDecoder
>2542	24 24 53 54 52 49 4e c7			.byte	$24,$24,$53,$54,$52,$49,$4e,$c7
.254a					_end9:
>254a	05					.byte	_end10-*
>254b	00					.byte	$00
>254c	cd 13					.word	Multiply16x16
>254e	aa					.byte	$aa
.254f					_end10:
>254f	05					.byte	_end11-*
>2550	00					.byte	$00
>2551	3a 12					.word	Add
>2553	ab					.byte	$ab
.2554					_end11:
>2554	06					.byte	_end12-*
>2555	00					.byte	$00
>2556	62 16					.word	WordAdd
>2558	2b a1					.byte	$2b,$a1
.255a					_end12:
>255a	05					.byte	_end13-*
>255b	00					.byte	$00
>255c	49 12					.word	Subtract
>255e	ad					.byte	$ad
.255f					_end13:
>255f	06					.byte	_end14-*
>2560	00					.byte	$00
>2561	09 15					.word	ConstantMinus1
>2563	2d b1					.byte	$2d,$b1
.2565					_end14:
>2565	06					.byte	_end15-*
>2566	00					.byte	$00
>2567	6a 20					.word	DumpStack
>2569	2e ae					.byte	$2e,$ae
.256b					_end15:
>256b	05					.byte	_end16-*
>256c	00					.byte	$00
>256d	1e 13					.word	Divide16x16
>256f	af					.byte	$af
.2570					_end16:
>2570	05					.byte	_end17-*
>2571	00					.byte	$00
>2572	fc 14					.word	Constant0
>2574	b0					.byte	$b0
.2575					_end17:
>2575	06					.byte	_end18-*
>2576	00					.byte	$00
>2577	62 14					.word	CheckMinus
>2579	30 bc					.byte	$30,$bc
.257b					_end18:
>257b	06					.byte	_end19-*
>257c	00					.byte	$00
>257d	76 14					.word	CheckZero
>257f	30 bd					.byte	$30,$bd
.2581					_end19:
>2581	05					.byte	_end20-*
>2582	00					.byte	$00
>2583	18 15					.word	C1
>2585	b1					.byte	$b1
.2586					_end20:
>2586	06					.byte	_end21-*
>2587	00					.byte	$00
>2588	0c 14					.word	Unary1Plus
>258a	31 ab					.byte	$31,$ab
.258c					_end21:
>258c	06					.byte	_end22-*
>258d	00					.byte	$00
>258e	23 14					.word	Unary1Minus
>2590	31 ad					.byte	$31,$ad
.2592					_end22:
>2592	06					.byte	_end23-*
>2593	00					.byte	$00
>2594	30 15					.word	C10
>2596	31 b0					.byte	$31,$b0
.2598					_end23:
>2598	07					.byte	_end24-*
>2599	00					.byte	$00
>259a	59 15					.word	C100
>259c	31 30 b0				.byte	$31,$30,$b0
.259f					_end24:
>259f	08					.byte	_end25-*
>25a0	00					.byte	$00
>25a1	88 15					.word	C1024
>25a3	31 30 32 b4				.byte	$31,$30,$32,$b4
.25a7					_end25:
>25a7	07					.byte	_end26-*
>25a8	00					.byte	$00
>25a9	5d 15					.word	C127
>25ab	31 32 b7				.byte	$31,$32,$b7
.25ae					_end26:
>25ae	07					.byte	_end27-*
>25af	00					.byte	$00
>25b0	61 15					.word	C128
>25b2	31 32 b8				.byte	$31,$32,$b8
.25b5					_end27:
>25b5	06					.byte	_end28-*
>25b6	00					.byte	$00
>25b7	34 15					.word	C15
>25b9	31 b5					.byte	$31,$b5
.25bb					_end28:
>25bb	06					.byte	_end29-*
>25bc	00					.byte	$00
>25bd	38 15					.word	C16
>25bf	31 b6					.byte	$31,$b6
.25c1					_end29:
>25c1	07					.byte	_end30-*
>25c2	00					.byte	$00
>25c3	9a 14					.word	Times16
>25c5	31 36 aa				.byte	$31,$36,$aa
.25c8					_end30:
>25c8	07					.byte	_end31-*
>25c9	00					.byte	$00
>25ca	ad 14					.word	Divide16
>25cc	31 36 af				.byte	$31,$36,$af
.25cf					_end31:
>25cf	05					.byte	_end32-*
>25d0	00					.byte	$00
>25d1	1c 15					.word	C2
>25d3	b2					.byte	$b2
.25d4					_end32:
>25d4	06					.byte	_end33-*
>25d5	00					.byte	$00
>25d6	a6 14					.word	Times2
>25d8	32 aa					.byte	$32,$aa
.25da					_end33:
>25da	06					.byte	_end34-*
>25db	00					.byte	$00
>25dc	15 14					.word	Unary2Plus
>25de	32 ab					.byte	$32,$ab
.25e0					_end34:
>25e0	06					.byte	_end35-*
>25e1	00					.byte	$00
>25e2	2e 14					.word	Unary2Minus
>25e4	32 ad					.byte	$32,$ad
.25e6					_end35:
>25e6	06					.byte	_end36-*
>25e7	00					.byte	$00
>25e8	b9 14					.word	Divide2
>25ea	32 af					.byte	$32,$af
.25ec					_end36:
>25ec	06					.byte	_end37-*
>25ed	00					.byte	$00
>25ee	3c 15					.word	C24
>25f0	32 b4					.byte	$32,$b4
.25f2					_end37:
>25f2	07					.byte	_end38-*
>25f3	00					.byte	$00
>25f4	65 15					.word	C255
>25f6	32 35 b5				.byte	$32,$35,$b5
.25f9					_end38:
>25f9	07					.byte	_end39-*
>25fa	00					.byte	$00
>25fb	70 15					.word	C256
>25fd	32 35 b6				.byte	$32,$35,$b6
.2600					_end39:
>2600	08					.byte	_end40-*
>2601	00					.byte	$00
>2602	c0 14					.word	Times256
>2604	32 35 36 aa				.byte	$32,$35,$36,$aa
.2608					_end40:
>2608	08					.byte	_end41-*
>2609	00					.byte	$00
>260a	c9 14					.word	Divide256
>260c	32 35 36 af				.byte	$32,$35,$36,$af
.2610					_end41:
>2610	05					.byte	_end42-*
>2611	00					.byte	$00
>2612	20 15					.word	C3
>2614	b3					.byte	$b3
.2615					_end42:
>2615	06					.byte	_end43-*
>2616	00					.byte	$00
>2617	4d 15					.word	C32
>2619	33 b2					.byte	$33,$b2
.261b					_end43:
>261b	09					.byte	_end44-*
>261c	00					.byte	$00
>261d	a0 15					.word	C32767
>261f	33 32 37 36 b7				.byte	$33,$32,$37,$36,$b7
.2624					_end44:
>2624	09					.byte	_end45-*
>2625	00					.byte	$00
>2626	ac 15					.word	C32768
>2628	33 32 37 36 b8				.byte	$33,$32,$37,$36,$b8
.262d					_end45:
>262d	05					.byte	_end46-*
>262e	00					.byte	$00
>262f	24 15					.word	C4
>2631	b4					.byte	$b4
.2632					_end46:
>2632	06					.byte	_end47-*
>2633	00					.byte	$00
>2634	a2 14					.word	Times4
>2636	34 aa					.byte	$34,$aa
.2638					_end47:
>2638	06					.byte	_end48-*
>2639	00					.byte	$00
>263a	b5 14					.word	Divide4
>263c	34 af					.byte	$34,$af
.263e					_end48:
>263e	08					.byte	_end49-*
>263f	00					.byte	$00
>2640	94 15					.word	C4096
>2642	34 30 39 b6				.byte	$34,$30,$39,$b6
.2646					_end49:
>2646	05					.byte	_end50-*
>2647	00					.byte	$00
>2648	28 15					.word	C5
>264a	b5					.byte	$b5
.264b					_end50:
>264b	07					.byte	_end51-*
>264c	00					.byte	$00
>264d	7c 15					.word	C512
>264f	35 31 b2				.byte	$35,$31,$b2
.2652					_end51:
>2652	06					.byte	_end52-*
>2653	00					.byte	$00
>2654	51 15					.word	C63
>2656	36 b3					.byte	$36,$b3
.2658					_end52:
>2658	06					.byte	_end53-*
>2659	00					.byte	$00
>265a	55 15					.word	C64
>265c	36 b4					.byte	$36,$b4
.265e					_end53:
>265e	05					.byte	_end54-*
>265f	00					.byte	$00
>2660	2c 15					.word	C8
>2662	b8					.byte	$b8
.2663					_end54:
>2663	06					.byte	_end55-*
>2664	00					.byte	$00
>2665	9e 14					.word	Times8
>2667	38 aa					.byte	$38,$aa
.2669					_end55:
>2669	06					.byte	_end56-*
>266a	00					.byte	$00
>266b	b1 14					.word	Divide8
>266d	38 af					.byte	$38,$af
.266f					_end56:
>266f	05					.byte	_end57-*
>2670	40					.byte	$40
>2671	52 1c					.word	ReturnHandler
>2673	bb					.byte	$bb
.2674					_end57:
>2674	05					.byte	_end58-*
>2675	00					.byte	$00
>2676	ba 12					.word	CheckLess
>2678	bc					.byte	$bc
.2679					_end58:
>2679	06					.byte	_end59-*
>267a	00					.byte	$00
>267b	d3 12					.word	CheckLessEq
>267d	3c bd					.byte	$3c,$bd
.267f					_end59:
>267f	06					.byte	_end60-*
>2680	00					.byte	$00
>2681	83 12					.word	CheckNotEqual
>2683	3c be					.byte	$3c,$be
.2685					_end60:
>2685	05					.byte	_end61-*
>2686	00					.byte	$00
>2687	86 12					.word	CheckEqual
>2689	bd					.byte	$bd
.268a					_end61:
>268a	05					.byte	_end62-*
>268b	00					.byte	$00
>268c	d6 12					.word	CheckGreater
>268e	be					.byte	$be
.268f					_end62:
>268f	06					.byte	_end63-*
>2690	00					.byte	$00
>2691	b7 12					.word	CheckGreaterEq
>2693	3e bd					.byte	$3e,$bd
.2695					_end63:
>2695	08					.byte	_end64-*
>2696	00					.byte	$00
>2697	c1 15					.word	TestDup
>2699	3f 44 55 d0				.byte	$3f,$44,$55,$d0
.269d					_end64:
>269d	05					.byte	_end65-*
>269e	00					.byte	$00
>269f	36 16					.word	WordRead
>26a1	c0					.byte	$c0
.26a2					_end65:
>26a2	07					.byte	_end66-*
>26a3	00					.byte	$00
>26a4	3c 14					.word	Absolute
>26a6	41 42 d3				.byte	$41,$42,$d3
.26a9					_end66:
>26a9	09					.byte	_end67-*
>26aa	00					.byte	$00
>26ab	79 16					.word	AllocateMemory
>26ad	41 4c 4c 4f c3				.byte	$41,$4c,$4c,$4f,$c3
.26b2					_end67:
>26b2	07					.byte	_end68-*
>26b3	00					.byte	$00
>26b4	5c 12					.word	And
>26b6	41 4e c4				.byte	$41,$4e,$c4
.26b9					_end68:
>26b9	0a					.byte	_end69-*
>26ba	00					.byte	$00
>26bb	f5 1f					.word	AssertCode
>26bd	41 53 53 45 52 d4			.byte	$41,$53,$53,$45,$52,$d4
.26c3					_end69:
>26c3	09					.byte	_end70-*
>26c4	00					.byte	$00
>26c5	8f 14					.word	ByteSwap
>26c7	42 53 57 41 d0				.byte	$42,$53,$57,$41,$d0
.26cc					_end70:
>26cc	06					.byte	_end71-*
>26cd	00					.byte	$00
>26ce	44 16					.word	ByteWrite
>26d0	43 a1					.byte	$43,$a1
.26d2					_end71:
>26d2	06					.byte	_end72-*
>26d3	00					.byte	$00
>26d4	2d 16					.word	ByteRead
>26d6	43 c0					.byte	$43,$c0
.26d8					_end72:
>26d8	07					.byte	_end73-*
>26d9	00					.byte	$00
>26da	1f 1d					.word	ClrHandler
>26dc	43 4c d2				.byte	$43,$4c,$d2
.26df					_end73:
>26df	08					.byte	_end74-*
>26e0	00					.byte	$00
>26e1	b8 15					.word	Drop
>26e3	44 52 4f d0				.byte	$44,$52,$4f,$d0
.26e7					_end74:
>26e7	07					.byte	_end75-*
>26e8	00					.byte	$00
>26e9	ca 15					.word	Dup
>26eb	44 55 d0				.byte	$44,$55,$d0
.26ee					_end75:
>26ee	0a					.byte	_end76-*
>26ef	21					.byte	$21
>26f0	08 1b					.word	ElseHandler
>26f2	0b 1b					.word	ElseEncoder
>26f4	45 4c 53 c5				.byte	$45,$4c,$53,$c5
.26f8					_end76:
>26f8	07					.byte	_end77-*
>26f9	00					.byte	$00
>26fa	16 20					.word	EndProgram
>26fc	45 4e c4				.byte	$45,$4e,$c4
.26ff					_end77:
>26ff	0b					.byte	_end78-*
>2700	20					.byte	$20
>2701	2a 1b					.word	EndIfHandler
>2703	2d 1b					.word	EndIfEncoder
>2705	45 4e 44 49 c6				.byte	$45,$4e,$44,$49,$c6
.270a					_end78:
>270a	09					.byte	_end79-*
>270b	20					.byte	$20
>270c	28 1a					.word	ForHandler
>270e	5e 1a					.word	ForEncoder
>2710	46 4f d2				.byte	$46,$4f,$d2
.2713					_end79:
>2713	08					.byte	_end80-*
>2714	21					.byte	$21
>2715	f3 1a					.word	IfHandler
>2717	f6 1a					.word	IfEncoder
>2719	49 c6					.byte	$49,$c6
.271b					_end80:
>271b	09					.byte	_end81-*
>271c	00					.byte	$00
>271d	d2 1a					.word	GetIndex
>271f	49 4e 44 45 d8				.byte	$49,$4e,$44,$45,$d8
.2724					_end81:
>2724	08					.byte	_end82-*
>2725	00					.byte	$00
>2726	4f 1f					.word	ListCode
>2728	4c 49 53 d4				.byte	$4c,$49,$53,$d4
.272c					_end82:
>272c	07					.byte	_end83-*
>272d	00					.byte	$00
>272e	f3 12					.word	Maximum
>2730	4d 41 d8				.byte	$4d,$41,$d8
.2733					_end83:
>2733	07					.byte	_end84-*
>2734	00					.byte	$00
>2735	ef 12					.word	Minimum
>2737	4d 49 ce				.byte	$4d,$49,$ce
.273a					_end84:
>273a	07					.byte	_end85-*
>273b	00					.byte	$00
>273c	2f 13					.word	Modulus16x16
>273e	4d 4f c4				.byte	$4d,$4f,$c4
.2741					_end85:
>2741	0a					.byte	_end86-*
>2742	00					.byte	$00
>2743	43 14					.word	Negate
>2745	4e 45 47 41 54 c5			.byte	$4e,$45,$47,$41,$54,$c5
.274b					_end86:
>274b	07					.byte	_end87-*
>274c	00					.byte	$00
>274d	16 1d					.word	NewHandler
>274f	4e 45 d7				.byte	$4e,$45,$d7
.2752					_end87:
>2752	0a					.byte	_end88-*
>2753	21					.byte	$21
>2754	6b 1a					.word	NextHandler
>2756	aa 1a					.word	NextEncoder
>2758	4e 45 58 d4				.byte	$4e,$45,$58,$d4
.275c					_end88:
>275c	07					.byte	_end89-*
>275d	00					.byte	$00
>275e	fe 15					.word	Nip
>2760	4e 49 d0				.byte	$4e,$49,$d0
.2763					_end89:
>2763	07					.byte	_end90-*
>2764	00					.byte	$00
>2765	53 14					.word	OneComplement
>2767	4e 4f d4				.byte	$4e,$4f,$d4
.276a					_end90:
>276a	06					.byte	_end91-*
>276b	00					.byte	$00
>276c	76 12					.word	LogOr
>276e	4f d2					.byte	$4f,$d2
.2770					_end91:
>2770	08					.byte	_end92-*
>2771	00					.byte	$00
>2772	e6 15					.word	Over
>2774	4f 56 45 d2				.byte	$4f,$56,$45,$d2
.2778					_end92:
>2778	0c					.byte	_end93-*
>2779	20					.byte	$20
>277a	5c 1b					.word	RepeatHandler
>277c	5f 1b					.word	RepeatEncoder
>277e	52 45 50 45 41 d4			.byte	$52,$45,$50,$45,$41,$d4
.2784					_end93:
>2784	07					.byte	_end94-*
>2785	00					.byte	$00
>2786	d2 14					.word	RandomNumber
>2788	52 4e c4				.byte	$52,$4e,$c4
.278b					_end94:
>278b	07					.byte	_end95-*
>278c	00					.byte	$00
>278d	03 16					.word	Rot
>278f	52 4f d4				.byte	$52,$4f,$d4
.2792					_end95:
>2792	07					.byte	_end96-*
>2793	00					.byte	$00
>2794	ca 1f					.word	RunProgram
>2796	52 55 ce				.byte	$52,$55,$ce
.2799					_end96:
>2799	07					.byte	_end97-*
>279a	00					.byte	$00
>279b	7e 14					.word	SignTOS
>279d	53 47 ce				.byte	$53,$47,$ce
.27a0					_end97:
>27a0	08					.byte	_end98-*
>27a1	00					.byte	$00
>27a2	0e 20					.word	StopCode
>27a4	53 54 4f d0				.byte	$53,$54,$4f,$d0
.27a8					_end98:
>27a8	08					.byte	_end99-*
>27a9	00					.byte	$00
>27aa	d3 15					.word	Swap
>27ac	53 57 41 d0				.byte	$53,$57,$41,$d0
.27b0					_end99:
>27b0	07					.byte	_end100-*
>27b1	00					.byte	$00
>27b2	de 1f					.word	Call6502
>27b4	53 59 d3				.byte	$53,$59,$d3
.27b7					_end100:
>27b7	0d					.byte	_end101-*
>27b8	00					.byte	$00
>27b9	6b 22					.word	IntToString
>27bb	54 4f 2e 53 54 52 49 4e			.byte	$54,$4f,$2e,$53,$54,$52,$49,$4e,$c7
>27c3	c7
.27c4					_end101:
>27c4	0b					.byte	_end102-*
>27c5	21					.byte	$21
>27c6	6c 1b					.word	UntilHandler
>27c8	6f 1b					.word	UntilEncoder
>27ca	55 4e 54 49 cc				.byte	$55,$4e,$54,$49,$cc
.27cf					_end102:
>27cf	09					.byte	_end103-*
>27d0	00					.byte	$00
>27d1	19 20					.word	VlistCode
>27d3	56 4c 49 53 d4				.byte	$56,$4c,$49,$53,$d4
.27d8					_end103:
>27d8	0a					.byte	_end104-*
>27d9	40					.byte	$40
>27da	6a 1d					.word	BreakCmd
>27dc	58 42 52 45 41 cb			.byte	$58,$42,$52,$45,$41,$cb
.27e2					_end104:
>27e2	09					.byte	_end105-*
>27e3	00					.byte	$00
>27e4	64 1d					.word	ExitDump
>27e6	58 44 55 4d d0				.byte	$58,$44,$55,$4d,$d0
.27eb					_end105:
>27eb	07					.byte	_end106-*
>27ec	00					.byte	$00
>27ed	69 12					.word	Xor
>27ef	58 4f d2				.byte	$58,$4f,$d2
.27f2					_end106:
>27f2	08					.byte	_end107-*
>27f3	00					.byte	$00
>27f4	b5 20					.word	System_Save
>27f6	53 41 56 c5				.byte	$53,$41,$56,$c5
.27fa					_end107:
>27fa	08					.byte	_end108-*
>27fb	00					.byte	$00
>27fc	d3 20					.word	System_Load
>27fe	4c 4f 41 c4				.byte	$4c,$4f,$41,$c4
.2802					_end108:
>2802	0d					.byte	_end109-*
>2803	11					.byte	$11
>2804	71 23					.word	IndexHandler
>2806	80 23					.word	IndexHandlerDecode
>2808	24 24 49 4e 44 45 d8			.byte	$24,$24,$49,$4e,$44,$45,$d8
.280f					_end109:
>280f	00					.byte	0

;******  Return to file: kernel.asm


;******  Processing file: code/enctest.asm


;******  Return to file: kernel.asm

>3fff	ff						.byte 	$FF
.4000					ProgramMemory:

;******  End of listing
