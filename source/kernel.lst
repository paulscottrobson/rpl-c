
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -q -c -o kernel.prg -L kernel.lst -l kernel.lbl kernel.asm
; Mon Jan 06 19:16:11 2020

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: kernel.asm

=$1000					FlatBuild = $1000 							; code starts here.
=$3000					FreeMemory = $3000 							; compiled code etc/ here

;******  Processing file: data.asm

.0000					Next:
>0000							.fill 	6
=3					IP = Next+3 								; the IP which points to the current instruction
.0006					tos:
>0006							.word 	?
.0008					temp1:
>0008							.word 	?
.000a					temp2:
>000a							.word 	?
.000c					temp3:
>000c							.word 	?
.000e					temp4:
>000e							.word 	?
.0010					SignCount:
>0010							.byte 	?
=$102					stack2Low = $102
=$101					stack2High = $101
=$104					stack3Low = $104
=$103					stack3High = $103

;******  Return to file: kernel.asm

.1000	a2 ff		ldx #$ff			ldx 		#$FF 					; reset the stack
.1002	9a		txs				txs
.1003	a2 d9		ldx #$d9			ldx			#BootCode & $FF 		; boot address
.1005	a0 16		ldy #$16			ldy 		#BootCode >>8
.1007	20 0d 10	jsr $100d			jsr 		InitialiseCoreCode 		; initialise the NEXT routine at $00
.100a	4c 00 00	jmp $0000			jmp 		Next

;******  Processing file: core.src

.100d					InitialiseCoreCode:
.100d	a9 e8		lda #$e8			lda 	#$E8 					; Copy INX INX 			4 cycles when run
.100f	85 00		sta $00				sta 	Next
.1011	85 01		sta $01				sta 	Next+1
.1013	a9 7c		lda #$7c			lda 	#$7C 					; Copy JMP ($aaaa,x) 	6 cycles when run
.1015	85 02		sta $02				sta 	Next+2
.1017	86 03		stx $03				stx 	Next+3 					; set the indirect address (IP)
.1019	84 04		sty $04				sty 	Next+4
.101b	a2 01		ldx #$01			ldx 	#1 						; set up to run from provided word.
.101d	60		rts				rts								; (2 INX skip offset and line#)
.101e					Literal2Byte:
.101e	a5 06		lda $06				lda 	TOS
.1020	48		pha				pha
.1021	a5 07		lda $07				lda 	TOS+1
.1023	48		pha				pha
.1024	e8		inx				inx  							; point X to the word
.1025	e8		inx				inx
.1026	8a		txa				txa 							; copy into Y
.1027	a8		tay				tay
.1028	b1 03		lda ($03),y			lda 	(IP),y 					; read it. the LSB
.102a	85 06		sta $06				sta 	TOS
.102c	c8		iny				iny 							; read and push the MSB
.102d	b1 03		lda ($03),y			lda 	(IP),y
.102f	85 07		sta $07				sta 	TOS+1
.1031	4c 00 00	jmp $0000			jmp 	Next

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/binary.src

.1034					Add:
.1034	7a		ply				ply
.1035	68		pla				pla
.1036	18		clc				clc
.1037	65 06		adc $06				adc 	TOS
.1039	85 06		sta $06				sta 	TOS
.103b	98		tya				tya
.103c	65 07		adc $07				adc 	TOS+1
.103e	85 07		sta $07				sta 	TOS+1
.1040	4c 00 00	jmp $0000			jmp 	Next
.1043					Subtract:
.1043	7a		ply				ply
.1044	68		pla				pla
.1045	38		sec				sec
.1046	49 ff		eor #$ff			eor 	#$FF
.1048	65 06		adc $06				adc 	TOS
.104a	85 06		sta $06				sta 	TOS
.104c	98		tya				tya
.104d	49 ff		eor #$ff			eor 	#$FF
.104f	65 07		adc $07				adc 	TOS+1
.1051	85 07		sta $07				sta 	TOS+1
.1053	4c 00 00	jmp $0000			jmp 	Next
.1056					And:
.1056	68		pla				pla
.1057	25 07		and $07				and 	TOS+1
.1059	85 07		sta $07				sta 	TOS+1
.105b	68		pla				pla
.105c	25 06		and $06				and 	TOS
.105e	85 06		sta $06				sta 	TOS
.1060	4c 00 00	jmp $0000			jmp 	Next
.1063					Xor:
.1063	68		pla				pla
.1064	45 07		eor $07				eor 	TOS+1
.1066	85 07		sta $07				sta 	TOS+1
.1068	68		pla				pla
.1069	45 06		eor $06				eor 	TOS
.106b	85 06		sta $06				sta 	TOS
.106d	4c 00 00	jmp $0000			jmp 	Next
.1070					LogOr:
.1070	68		pla				pla
.1071	05 07		ora $07				ora 	TOS+1
.1073	85 07		sta $07				sta 	TOS+1
.1075	68		pla				pla
.1076	05 06		ora $06				ora 	TOS
.1078	85 06		sta $06				sta 	TOS
.107a	4c 00 00	jmp $0000			jmp 	Next

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/compare.src

.107d					CheckEqual:
.107d	86 08		stx $08				stx 	temp1
.107f	ba		tsx				tsx
.1080	a5 06		lda $06				lda 	TOS
.1082	5d 02 01	eor $0102,x			eor 	Stack2Low,x
.1085	d0 14		bne $109b			bne	 	CompareFalse
.1087	a5 07		lda $07				lda 	TOS+1
.1089	5d 01 01	eor $0101,x			eor 	Stack2High,x
.108c	d0 0d		bne $109b			bne 	CompareFalse
.108e					CompareTrue:
.108e	a6 08		ldx $08				ldx 	temp1
.1090	68		pla				pla
.1091	68		pla				pla
.1092	a9 01		lda #$01			lda 	#1
.1094	85 06		sta $06				sta 	TOS
.1096	64 07		stz $07				stz 	TOS+1
.1098	4c 00 00	jmp $0000			jmp 	Next
.109b					CompareFalse:
.109b	a6 08		ldx $08				ldx 	temp1
.109d	68		pla				pla
.109e	68		pla				pla
.109f	64 06		stz $06				stz 	TOS
.10a1	64 07		stz $07				stz 	TOS+1
.10a3	4c 00 00	jmp $0000			jmp 	Next
.10a6					CheckLess:
.10a6	18		clc				clc
.10a7	86 08		stx $08				stx 	temp1
.10a9	ba		tsx				tsx
.10aa	a5 06		lda $06				lda 	TOS
.10ac	fd 02 01	sbc $0102,x			sbc 	Stack2Low,x
.10af	a5 07		lda $07				lda 	TOS+1
.10b1	fd 01 01	sbc $0101,x			sbc 	Stack2High,x
.10b4	50 02		bvc $10b8			bvc 	_CLNoFlip
.10b6	49 80		eor #$80			eor 	#$80
.10b8					_CLNoFlip:
.10b8	0a		asl a				asl 	a
.10b9	b0 e0		bcs $109b			bcs 	CompareFalse
.10bb	80 d1		bra $108e			bra 	CompareTrue
.10bd					CheckGreater:
.10bd	18		clc				clc
.10be	86 08		stx $08				stx 	temp1
.10c0	ba		tsx				tsx
.10c1	bd 02 01	lda $0102,x			lda 	Stack2Low,x
.10c4	e5 06		sbc $06				sbc 	TOS
.10c6	bd 01 01	lda $0101,x			lda 	Stack2High,x
.10c9	e5 07		sbc $07				sbc 	TOS+1
.10cb	50 02		bvc $10cf			bvc 	_CGNoFlip
.10cd	49 80		eor #$80			eor 	#$80
.10cf					_CGNoFlip:
.10cf	0a		asl a				asl 	a
.10d0	b0 c9		bcs $109b			bcs 	CompareFalse
.10d2	80 ba		bra $108e			bra 	CompareTrue
.10d4					Minimum:
.10d4	a9 00		lda #$00			lda 	#0
.10d6	80 02		bra $10da			bra 	MinMaxCode
.10d8					Maximum:
.10d8	a9 80		lda #$80			lda 	#$80
.10da					MinMaxCode:
.10da	85 09		sta $09				sta 	temp1+1
.10dc	86 08		stx $08				stx 	temp1
.10de	ba		tsx				tsx
.10df	38		sec				sec
.10e0	a5 06		lda $06				lda 	TOS
.10e2	fd 02 01	sbc $0102,x			sbc 	Stack2Low,x
.10e5	a5 07		lda $07				lda 	TOS+1
.10e7	fd 01 01	sbc $0101,x			sbc 	Stack2High,x
.10ea	50 02		bvc $10ee			bvc 	_MMNoFlip
.10ec	49 80		eor #$80			eor 	#$80
.10ee					_MMNoFlip:
.10ee	45 09		eor $09				eor 	temp1+1
.10f0	30 0a		bmi $10fc			bmi 	_MMNoCopy
.10f2	bd 02 01	lda $0102,x			lda 	Stack2Low,x
.10f5	85 06		sta $06				sta 	TOS
.10f7	bd 01 01	lda $0101,x			lda 	Stack2High,x
.10fa	85 07		sta $07				sta 	TOS+1
.10fc					_MMNoCopy:
.10fc	a6 08		ldx $08				ldx 	temp1
.10fe	68		pla				pla
.10ff	68		pla				pla
.1100	4c 00 00	jmp $0000			jmp 	Next

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/divide.src

.1103					Divide16x16:
.1103	86 0a		stx $0a				stx 	temp2
.1105	ba		tsx				tsx
.1106	20 29 11	jsr $1129			jsr 	IntegerDivide
.1109	68		pla				pla
.110a	85 07		sta $07				sta 	TOS+1
.110c	68		pla				pla
.110d	85 06		sta $06				sta 	TOS
.110f	a6 0a		ldx $0a				ldx 	temp2
.1111	4c 00 00	jmp $0000			jmp 	Next
.1114					Modulus16x16:
.1114	86 0a		stx $0a				stx 	temp2
.1116	ba		tsx				tsx
.1117	20 29 11	jsr $1129			jsr 	IntegerDivide
.111a	a6 0a		ldx $0a				ldx 	temp2
.111c	68		pla				pla
.111d	68		pla				pla
.111e	a5 08		lda $08				lda 	temp1
.1120	85 06		sta $06				sta 	TOS
.1122	a5 09		lda $09				lda 	temp1+1
.1124	85 07		sta $07				sta 	TOS+1
.1126	4c 00 00	jmp $0000			jmp 	Next
.1129					IntegerDivide:
.1129	a5 06		lda $06				lda 	TOS 				; check for division by zero.
.112b	05 07		ora $07				ora 	TOS+1
.112d	d0 14		bne $1143			bne 	_BFDOkay
>112f	ff						.byte 	$FF
.1130	80 fe		bra $1130	_w1:	bra 	_w1
>1132	44 49 56 49 53 49 4f 4e				.text 	"DIVISION BY ZERO",0
>113a	20 42 59 20 5a 45 52 4f 00
.1143					_BFDOkay:
.1143	64 08		stz $08				stz 	temp1 						; Q/Dividend/Left in +0
.1145	64 09		stz $09				stz 	temp1+1 					; M/Divisor/Right in +2
.1147	64 10		stz $10				stz 	SignCount 					; Count of signs.
.1149	20 84 11	jsr $1184			jsr 	CheckIntegerNegate 			; negate 2nd (and bump sign count)
.114c	20 9e 11	jsr $119e			jsr 	CheckTOSNegate 				; negate TOS (and bump sign count)
.114f	5a		phy				phy 								; Y is the counter
.1150	a0 10		ldy #$10			ldy 	#16 						; 16 iterations of the loop.
.1152					_BFDLoop:
.1152	1e 02 01	asl $0102,x			asl 	Stack2Low,x 				; shift AQ left.
.1155	3e 01 01	rol $0101,x			rol 	Stack2High,x
.1158	26 08		rol $08				rol 	temp1
.115a	26 09		rol $09				rol 	temp1+1
.115c	38		sec				sec
.115d	a5 08		lda $08				lda 	temp1+0 					; Calculate A-M on stack.
.115f	e5 06		sbc $06				sbc 	TOS
.1161	48		pha				pha
.1162	a5 09		lda $09				lda 	temp1+1
.1164	e5 07		sbc $07				sbc 	TOS+1
.1166	90 0f		bcc $1177			bcc 	_BFDNoAdd
.1168	85 09		sta $09				sta 	temp1+1
.116a	68		pla				pla
.116b	85 08		sta $08				sta 	temp1+0
.116d	bd 02 01	lda $0102,x			lda 	Stack2Low,x 				; set Q bit 1.
.1170	09 01		ora #$01			ora 	#1
.1172	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.1175	80 01		bra $1178			bra 	_BFDNext
.1177					_BFDNoAdd:
.1177	68		pla				pla 								; Throw away the intermediate calculations
.1178					_BFDNext:
.1178	88		dey				dey
.1179	d0 d7		bne $1152			bne 	_BFDLoop
.117b	7a		ply				ply 								; restore Y
.117c	46 10		lsr $10				lsr 	SignCount 					; if sign count odd,
.117e	90 03		bcc $1183			bcc 	_BFDUnsigned 				; then the result is signed
.1180	20 8a 11	jsr $118a			jsr		IntegerNegateAlways 		; negate the result
.1183					_BFDUnsigned:
.1183	60		rts				rts
.1184					CheckIntegerNegate:
.1184	bd 01 01	lda $0101,x			lda 	Stack2High,x 				; is it -ve = MSB set ?
.1187	30 01		bmi $118a			bmi 	IntegerNegateAlways 		; if so negate it
.1189	60		rts				rts
.118a					IntegerNegateAlways:
.118a	e6 10		inc $10				inc 	SignCount 					; bump the count of signs
.118c	38		sec				sec 								; negate
.118d	a9 00		lda #$00			lda 	#0
.118f	fd 02 01	sbc $0102,x			sbc 	Stack2Low,x
.1192	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.1195	a9 00		lda #$00			lda 	#0
.1197	fd 01 01	sbc $0101,x			sbc 	Stack2High,x
.119a	9d 01 01	sta $0101,x			sta 	Stack2High,x
.119d	60		rts				rts
.119e					CheckTOSNegate:
.119e	a5 07		lda $07				lda 	TOS+1
.11a0	10 0f		bpl $11b1			bpl		CTNNoChange
.11a2	e6 10		inc $10				inc 	SignCount
.11a4					TOSNegateAlways:
.11a4	38		sec				sec
.11a5	a9 00		lda #$00			lda 	#0
.11a7	e5 06		sbc $06				sbc 	TOS
.11a9	85 06		sta $06				sta 	TOS
.11ab	a9 00		lda #$00			lda 	#0
.11ad	e5 07		sbc $07				sbc 	TOS+1
.11af	85 07		sta $07				sta 	TOS+1
.11b1					CTNNoChange:
.11b1	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/multiply.src

.11b2					Multiply16x16:
.11b2	86 08		stx $08				stx 	temp1
.11b4	ba		tsx				tsx
.11b5	bd 02 01	lda $0102,x			lda 	Stack2Low,x 				; 2nd value on stack to temp1
.11b8	85 0a		sta $0a				sta 	temp2
.11ba	bd 01 01	lda $0101,x			lda		Stack2High,x
.11bd	85 0b		sta $0b				sta 	temp2+1
.11bf	9e 02 01	stz $0102,x			stz 	Stack2Low,x 				; zero 2nd value on stack
.11c2	9e 01 01	stz $0101,x			stz 	Stack2High,x
.11c5					_MultLoop:
.11c5	46 0b		lsr $0b				lsr 	temp2+1 					; ror temp2 into C
.11c7	66 0a		ror $0a				ror 	temp2
.11c9	90 11		bcc $11dc			bcc 	_MultNoAdd
.11cb	18		clc				clc 								; add 1st to 2nd
.11cc	a5 06		lda $06				lda 	TOS
.11ce	7d 02 01	adc $0102,x			adc 	Stack2Low,x
.11d1	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.11d4	a5 07		lda $07				lda 	TOS+1
.11d6	7d 01 01	adc $0101,x			adc 	Stack2High,x
.11d9	9d 01 01	sta $0101,x			sta 	Stack2High,x
.11dc					_MultNoAdd:
.11dc	06 06		asl $06				asl 	TOS 						; shift 1st left
.11de	26 07		rol $07				rol 	TOS+1
.11e0	a5 0a		lda $0a				lda 	temp2	 					; until zero
.11e2	05 0b		ora $0b				ora 	temp2+1
.11e4	d0 df		bne $11c5			bne 	_MultLoop
.11e6	a6 08		ldx $08				ldx 	temp1 						; restore X load result
.11e8	68		pla				pla
.11e9	85 07		sta $07				sta 	TOS+1
.11eb	68		pla				pla
.11ec	85 06		sta $06				sta 	TOS
.11ee	4c 00 00	jmp $0000			jmp 	Next

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/unary.src

.11f1					Unary1Plus:
.11f1	e6 06		inc $06				inc 	TOS
.11f3	d0 02		bne $11f7			bne 	_U1PSkip
.11f5	e6 07		inc $07				inc 	TOS+1
.11f7					_U1PSkip:
.11f7	4c 00 00	jmp $0000			jmp 	Next
.11fa					Unary2Plus:
.11fa	18		clc				clc
.11fb	a5 06		lda $06				lda 	TOS
.11fd	69 02		adc #$02			adc 	#2
.11ff	85 06		sta $06				sta 	TOS
.1201	90 02		bcc $1205			bcc 	_U1PSkip
.1203	e6 07		inc $07				inc 	TOS+1
.1205					_U1PSkip:
.1205	4c 00 00	jmp $0000			jmp 	Next
.1208					Unary1Minus:
.1208	a5 06		lda $06				lda 	TOS
.120a	d0 02		bne $120e			bne 	_U1MSkip
.120c	c6 07		dec $07				dec 	TOS+1
.120e					_U1MSkip:
.120e	c6 06		dec $06				dec 	TOS
.1210	4c 00 00	jmp $0000			jmp 	Next
.1213					Unary2Minus:
.1213	38		sec				sec
.1214	a5 06		lda $06				lda 	TOS
.1216	e9 02		sbc #$02			sbc 	#2
.1218	85 06		sta $06				sta 	TOS
.121a	b0 02		bcs $121e			bcs 	_U1PSkip
.121c	c6 07		dec $07				dec 	TOS+1
.121e					_U1PSkip:
.121e	4c 00 00	jmp $0000			jmp 	Next
.1221					Absolute:
.1221	a5 07		lda $07				lda 	TOS+1
.1223	30 03		bmi $1228			bmi 	Negate
.1225	4c 00 00	jmp $0000			jmp 	Next
.1228					Negate:
.1228	38		sec				sec
.1229	a9 00		lda #$00			lda 	#0
.122b	e5 06		sbc $06				sbc 	TOS
.122d	85 06		sta $06				sta 	TOS
.122f	a9 00		lda #$00			lda 	#0
.1231	e5 07		sbc $07				sbc 	TOS+1
.1233	85 07		sta $07				sta 	TOS+1
.1235	4c 00 00	jmp $0000			jmp 	Next
.1238					OneComplement:
.1238	a5 06		lda $06				lda 	TOS
.123a	49 ff		eor #$ff			eor 	#$FF
.123c	85 06		sta $06				sta 	TOS
.123e	a5 07		lda $07				lda 	TOS+1
.1240	49 ff		eor #$ff			eor 	#$FF
.1242	85 07		sta $07				sta 	TOS+1
.1244	4c 00 00	jmp $0000			jmp 	Next
.1247					CheckMinus:
.1247	a5 07		lda $07				lda 	TOS+1
.1249	30 07		bmi $1252			bmi 	UnaryTrue
.124b					UnaryFalse:
.124b	64 06		stz $06				stz 	TOS
.124d	64 07		stz $07				stz 	TOS+1
.124f	4c 00 00	jmp $0000			jmp 	Next
.1252					UnaryTrue:
.1252	a9 01		lda #$01			lda 	#1
.1254	85 06		sta $06				sta 	TOS
.1256	64 07		stz $07				stz 	TOS+1
.1258	4c 00 00	jmp $0000			jmp 	Next
.125b					CheckZero:
.125b	a5 06		lda $06				lda 	TOS
.125d	05 07		ora $07				ora 	TOS+1
.125f	d0 ea		bne $124b			bne 	UnaryFalse
.1261	80 ef		bra $1252			bra 	UnaryTrue
.1263					ByteSwap:
.1263	a5 06		lda $06				lda 	TOS
.1265	a4 07		ldy $07				ldy 	TOS+1
.1267	85 07		sta $07				sta 	TOS+1
.1269	84 06		sty $06				sty 	TOS
.126b	4c 00 00	jmp $0000			jmp 	Next
.126e					Times2:
.126e	06 06		asl $06				asl 	TOS
.1270	26 07		rol $07				rol 	TOS+1
.1272	4c 00 00	jmp $0000			jmp 	Next
.1275					Times4:
.1275	06 06		asl $06				asl 	TOS
.1277	26 07		rol $07				rol 	TOS+1
.1279	06 06		asl $06				asl 	TOS
.127b	26 07		rol $07				rol 	TOS+1
.127d	4c 00 00	jmp $0000			jmp 	Next
.1280					Times16:
.1280	06 06		asl $06				asl 	TOS
.1282	26 07		rol $07				rol 	TOS+1
.1284	06 06		asl $06				asl 	TOS
.1286	26 07		rol $07				rol 	TOS+1
.1288	06 06		asl $06				asl 	TOS
.128a	26 07		rol $07				rol 	TOS+1
.128c	06 06		asl $06				asl 	TOS
.128e	26 07		rol $07				rol 	TOS+1
.1290	4c 00 00	jmp $0000			jmp 	Next
.1293					Divide2:
.1293	a5 07		lda $07				lda 	TOS+1
.1295	0a		asl a				asl 	a
.1296	66 07		ror $07				ror 	TOS+1
.1298	66 06		ror $06				ror 	TOS
.129a	4c 00 00	jmp $0000			jmp 	Next

;******  Return to file: kernel.asm


;******  Processing file: words/system/debug.src

.129d					ExitDump:
.129d	ba		tsx				tsx 								; save Data Stack in temp1
.129e	86 08		stx $08				stx 	temp1
.12a0	4c ff ff	jmp $ffff			jmp 	$FFFF 						; makes the X16-Emulator dump-exit.
.12a3					BreakCmd:
>12a3	ff						.byte 	$FF
.12a4	4c 00 00	jmp $0000			jmp 	Next

;******  Return to file: kernel.asm


;******  Processing file: words/system/miscellany.src

.12a7					Call6502:
.12a7	a5 06		lda $06				lda 	TOS 						; copy call address
.12a9	85 08		sta $08				sta 	temp1
.12ab	a5 07		lda $07				lda 	TOS+1
.12ad	85 09		sta $09				sta 	temp1+1
.12af	68		pla				pla
.12b0	85 07		sta $07				sta 	TOS+1
.12b2	68		pla				pla
.12b3	85 06		sta $06				sta 	TOS
.12b5	20 bb 12	jsr $12bb			jsr 	_CallTemp1 					; call it
.12b8	4c 00 00	jmp $0000			jmp 	Next
.12bb					_CallTemp1:
.12bb	6c 08 00	jmp ($0008)			jmp 	(temp1)

;******  Return to file: kernel.asm


;******  Processing file: words/system/number.src

.12be					ConvertToInteger:
.12be	64 0c		stz $0c				stz 	temp3 						; reset value
.12c0	64 0d		stz $0d				stz 	temp3+1
.12c2	64 08		stz $08				stz 	temp1 						; temp1 = 0 (decimal) 255 (hex)
.12c4	a0 00		ldy #$00			ldy 	#0 							; look at first character
.12c6	b1 06		lda ($06),y			lda 	(TOS),y
.12c8	c9 24		cmp #$24			cmp		#'$'						; if $ then skip it and set hex flag
.12ca	d0 03		bne $12cf			bne 	_CTILoop
.12cc	c6 08		dec $08				dec 	temp1
.12ce	c8		iny				iny
.12cf					_CTILoop:
.12cf	b1 06		lda ($06),y			lda 	(TOS),y 					; next digit
.12d1	29 7f		and #$7f			and 	#$7F 						; drop end of word flag
.12d3	38		sec				sec
.12d4	e9 30		sbc #$30			sbc 	#'0' 						; put in range '0'+
.12d6	90 55		bcc $132d			bcc 	_CTIFail 					; out of range.
.12d8	c9 0a		cmp #$0a			cmp 	#10 						; in 0-9 ?
.12da	90 0b		bcc $12e7			bcc 	_CTILegal
.12dc	c9 11		cmp #$11			cmp 	#'A'-'0'					; between 9 and A ?
.12de	90 4d		bcc $132d			bcc 	_CTIFail
.12e0	38		sec				sec
.12e1	e9 07		sbc #$07			sbc 	#7 							; hex adjust
.12e3	c9 10		cmp #$10			cmp 	#16 						; out of range ?
.12e5	b0 46		bcs $132d			bcs 	_CTIFail
.12e7					_CTILegal:
.12e7	85 09		sta $09				sta 	temp1+1 					; save digit value.
.12e9	06 0c		asl $0c				asl 	temp3
.12eb	26 0d		rol $0d				rol 	temp3+1
.12ed	a5 0c		lda $0c				lda 	temp3 						; copy x2 into temp2
.12ef	85 0a		sta $0a				sta 	temp2
.12f1	a5 0d		lda $0d				lda 	temp3+1
.12f3	85 0b		sta $0b				sta 	temp2+1
.12f5	06 0c		asl $0c				asl 	temp3
.12f7	26 0d		rol $0d				rol 	temp3+1
.12f9	06 0c		asl $0c				asl 	temp3
.12fb	26 0d		rol $0d				rol 	temp3+1
.12fd	24 08		bit $08				bit 	temp1 						; hexadecimal
.12ff	10 06		bpl $1307			bpl 	_CTIDecimal
.1301	06 0c		asl $0c				asl 	temp3
.1303	26 0d		rol $0d				rol 	temp3+1
.1305	80 13		bra $131a			bra 	_CTIAddLoop
.1307					_CTIDecimal:
.1307	18		clc				clc 								; x 8 + x 2 = x 10
.1308	a5 0c		lda $0c				lda 	temp3
.130a	65 0a		adc $0a				adc 	temp2
.130c	85 0c		sta $0c				sta 	temp3
.130e	a5 0d		lda $0d				lda 	temp3+1
.1310	65 0b		adc $0b				adc 	temp2+1
.1312	85 0d		sta $0d				sta 	temp3+1
.1314	a5 09		lda $09				lda 	temp1+1 					; check digit 0-9
.1316	c9 0a		cmp #$0a			cmp 	#10
.1318	b0 13		bcs $132d			bcs 	_CTIFail
.131a					_CTIAddLoop:
.131a	18		clc				clc
.131b	a5 0c		lda $0c				lda 	temp3
.131d	65 09		adc $09				adc 	temp1+1
.131f	85 0c		sta $0c				sta 	temp3
.1321	90 02		bcc $1325			bcc 	_CTINoCarry
.1323	e6 0d		inc $0d				inc 	temp3+1
.1325					_CTINoCarry:
.1325	b1 06		lda ($06),y			lda 	(TOS),y 					; was this the last character
.1327	c8		iny				iny
.1328	0a		asl a				asl 	a
.1329	90 a4		bcc $12cf			bcc 	_CTILoop 					; no, go back.
.132b					_CTIOkay:
.132b	38		sec				sec
.132c	60		rts				rts
.132d					_CTIFail:
.132d	18		clc				clc
.132e	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/skipper.src

.132f					NextLine:
.132f	18		clc				clc 								; add (IP) to IP
.1330	a5 03		lda $03				lda 	IP
.1332	72 03		adc ($03)			adc 	(IP)
.1334	85 03		sta $03				sta 	IP
.1336	90 02		bcc $133a			bcc 	_NLNoCarry
.1338	e6 04		inc $04				inc 	IP+1
.133a					_NLNoCarry:
.133a	b2 03		lda ($03)			lda 	(IP)						; is there any following program
.133c	f0 05		beq $1343			beq 	_NLGoEnd
.133e	a2 03		ldx #$03			ldx 	#3 							; start 3 in
.1340	4c 02 00	jmp $0002			jmp 	Next+2 						; avoid the first two INXs
.1343					_NLGoEnd:
>1343	ff						.byte 	$FF
.1344	80 fe		bra $1344	_w1:	bra 	_w1
>1346	47 4f 54 4f 45 4e 44 3a				.text 	"GOTOEND:TODO",0
>134e	54 4f 44 4f 00
.1353					SkipComment:
.1353	e8		inx				inx									; (IP),X points to the length.
.1354	e8		inx				inx
.1355	8a		txa				txa
.1356	a8		tay				tay 								; put into Y
.1357	18		clc				clc
.1358	71 03		adc ($03),y			adc 	(IP),y 						; add the length to X
.135a	aa		tax				tax 								; put back in X
.135b	4c 02 00	jmp $0002			jmp 	Next+2 						; continue skipping the pre-increment.
.135e					DefineError:
>135e	ff						.byte 	$FF
.135f	80 fe		bra $135f	_w1:	bra 	_w1
>1361	44 45 46 49 4e 49 54 49				.text 	"DEFINITION?",0
>1369	4f 4e 3f 00

;******  Return to file: kernel.asm


;******  Processing file: words/data/literals.src

.136d					Constant0:
.136d	a5 06		lda $06				lda 	TOS
.136f	48		pha				pha
.1370	a5 07		lda $07				lda 	TOS+1
.1372	48		pha				pha
.1373	64 06		stz $06				stz 	TOS
.1375	64 07		stz $07				stz 	TOS+1
.1377	4c 00 00	jmp $0000			jmp 	Next
.137a					ConstantMinus1:
.137a	a5 06		lda $06				lda 	TOS
.137c	48		pha				pha
.137d	a5 07		lda $07				lda 	TOS+1
.137f	48		pha				pha
.1380	a9 ff		lda #$ff			lda 	#$FF
.1382	85 06		sta $06				sta 	TOS
.1384	85 07		sta $07				sta 	TOS+1
.1386	4c 00 00	jmp $0000			jmp 	Next
.1389					C1:
.1389	a0 01		ldy #$01			ldy 	#1
.138b	80 24		bra $13b1			bra 	Const1Byte
.138d					C2:
.138d	a0 02		ldy #$02			ldy 	#2
.138f	80 20		bra $13b1			bra 	Const1Byte
.1391					C3:
.1391	a0 03		ldy #$03			ldy 	#3
.1393	80 1c		bra $13b1			bra 	Const1Byte
.1395					C4:
.1395	a0 04		ldy #$04			ldy 	#4
.1397	80 18		bra $13b1			bra 	Const1Byte
.1399					C5:
.1399	a0 05		ldy #$05			ldy 	#5
.139b	80 14		bra $13b1			bra 	Const1Byte
.139d					C8:
.139d	a0 08		ldy #$08			ldy 	#8
.139f	80 10		bra $13b1			bra 	Const1Byte
.13a1					C10:
.13a1	a0 0a		ldy #$0a			ldy 	#10
.13a3	80 0c		bra $13b1			bra 	Const1Byte
.13a5					C15:
.13a5	a0 0f		ldy #$0f			ldy 	#15
.13a7	80 08		bra $13b1			bra 	Const1Byte
.13a9					C16:
.13a9	a0 10		ldy #$10			ldy 	#16
.13ab	80 04		bra $13b1			bra 	Const1Byte
.13ad					C24:
.13ad	a0 18		ldy #$18			ldy 	#24
.13af	80 00		bra $13b1			bra 	Const1Byte
.13b1					Const1Byte:
.13b1	a5 06		lda $06				lda 	TOS
.13b3	48		pha				pha
.13b4	a5 07		lda $07				lda 	TOS+1
.13b6	48		pha				pha
.13b7	84 06		sty $06				sty 	TOS
.13b9	64 07		stz $07				stz 	TOS+1
.13bb	4c 00 00	jmp $0000			jmp 	Next
.13be					C32:
.13be	a0 20		ldy #$20			ldy 	#32
.13c0	80 ef		bra $13b1			bra 	Const1Byte
.13c2					C48:
.13c2	a0 30		ldy #$30			ldy 	#48
.13c4	80 eb		bra $13b1			bra 	Const1Byte
.13c6					C50:
.13c6	a0 32		ldy #$32			ldy 	#50
.13c8	80 e7		bra $13b1			bra 	Const1Byte
.13ca					C63:
.13ca	a0 3f		ldy #$3f			ldy 	#63
.13cc	80 e3		bra $13b1			bra 	Const1Byte
.13ce					C64:
.13ce	a0 40		ldy #$40			ldy 	#64
.13d0	80 df		bra $13b1			bra 	Const1Byte
.13d2					C100:
.13d2	a0 64		ldy #$64			ldy 	#100
.13d4	80 db		bra $13b1			bra 	Const1Byte
.13d6					C127:
.13d6	a0 7f		ldy #$7f			ldy 	#127
.13d8	80 d7		bra $13b1			bra 	Const1Byte
.13da					C128:
.13da	a0 80		ldy #$80			ldy 	#128
.13dc	80 d3		bra $13b1			bra 	Const1Byte
.13de					C255:
.13de	a0 ff		ldy #$ff			ldy 	#255
.13e0	80 cf		bra $13b1			bra 	Const1Byte
.13e2					Const2Byte:
.13e2	85 06		sta $06				sta 	TOS
.13e4	84 07		sty $07				sty 	TOS+1
.13e6	4c 00 00	jmp $0000			jmp 	Next
.13e9					C256:
.13e9	a5 06		lda $06				lda 	TOS
.13eb	48		pha				pha
.13ec	a5 07		lda $07				lda 	TOS+1
.13ee	48		pha				pha
.13ef	a9 00		lda #$00			lda 	#(256) & $FF
.13f1	a0 01		ldy #$01			ldy 	#(256) >> 8
.13f3	80 ed		bra $13e2			bra 	Const2Byte
.13f5					C512:
.13f5	a5 06		lda $06				lda 	TOS
.13f7	48		pha				pha
.13f8	a5 07		lda $07				lda 	TOS+1
.13fa	48		pha				pha
.13fb	a9 00		lda #$00			lda 	#(512) & $FF
.13fd	a0 02		ldy #$02			ldy 	#(512) >> 8
.13ff	80 e1		bra $13e2			bra 	Const2Byte
.1401					C1024:
.1401	a5 06		lda $06				lda 	TOS
.1403	48		pha				pha
.1404	a5 07		lda $07				lda 	TOS+1
.1406	48		pha				pha
.1407	a9 00		lda #$00			lda 	#(1024) & $FF
.1409	a0 04		ldy #$04			ldy 	#(1024) >> 8
.140b	80 d5		bra $13e2			bra 	Const2Byte
.140d					C4096:
.140d	a5 06		lda $06				lda 	TOS
.140f	48		pha				pha
.1410	a5 07		lda $07				lda 	TOS+1
.1412	48		pha				pha
.1413	a9 00		lda #$00			lda 	#(4096) & $FF
.1415	a0 10		ldy #$10			ldy 	#(4096) >> 8
.1417	80 c9		bra $13e2			bra 	Const2Byte
.1419					C32767:
.1419	a5 06		lda $06				lda 	TOS
.141b	48		pha				pha
.141c	a5 07		lda $07				lda 	TOS+1
.141e	48		pha				pha
.141f	a9 ff		lda #$ff			lda 	#(32767) & $FF
.1421	a0 7f		ldy #$7f			ldy 	#(32767) >> 8
.1423	80 bd		bra $13e2			bra 	Const2Byte
.1425					C32768:
.1425	a5 06		lda $06				lda 	TOS
.1427	48		pha				pha
.1428	a5 07		lda $07				lda 	TOS+1
.142a	48		pha				pha
.142b	a9 00		lda #$00			lda 	#(32768) & $FF
.142d	a0 80		ldy #$80			ldy 	#(32768) >> 8
.142f	80 b1		bra $13e2			bra 	Const2Byte

;******  Return to file: kernel.asm


;******  Processing file: words/data/stack.src

.1431					Drop:
.1431	68		pla				pla
.1432	85 07		sta $07				sta 	TOS+1
.1434	68		pla				pla
.1435	85 06		sta $06				sta 	TOS
.1437	4c 00 00	jmp $0000			jmp 	Next
.143a					TestDup:
.143a	a5 06		lda $06				lda 	TOS
.143c	05 07		ora $07				ora 	TOS+1
.143e	d0 03		bne $1443			bne 	Dup
.1440	4c 00 00	jmp $0000			jmp 	Next
.1443					Dup:
.1443	a5 06		lda $06				lda 	TOS
.1445	48		pha				pha
.1446	a5 07		lda $07				lda 	TOS+1
.1448	48		pha				pha
.1449	4c 00 00	jmp $0000			jmp 	Next
.144c					Swap:
.144c	86 08		stx $08				stx 	temp1
.144e	7a		ply				ply
.144f	fa		plx				plx
.1450	a5 06		lda $06				lda 	TOS
.1452	48		pha				pha
.1453	a5 07		lda $07				lda 	TOS+1
.1455	48		pha				pha
.1456	86 06		stx $06				stx 	TOS
.1458	84 07		sty $07				sty 	TOS+1
.145a	a6 08		ldx $08				ldx 	temp1
.145c	4c 00 00	jmp $0000			jmp 	Next
.145f					Over:
.145f	a5 06		lda $06				lda 	TOS
.1461	48		pha				pha
.1462	a5 07		lda $07				lda 	TOS+1
.1464	48		pha				pha
.1465	86 08		stx $08				stx 	temp1
.1467	ba		tsx				tsx
.1468	bd 04 01	lda $0104,x			lda 	stack3low,x
.146b	85 06		sta $06				sta 	TOS
.146d	bd 03 01	lda $0103,x			lda 	stack3High,x
.1470	85 07		sta $07				sta 	TOS+1
.1472	a6 08		ldx $08				ldx 	temp1
.1474	4c 00 00	jmp $0000			jmp 	Next
.1477					Nip:
.1477	68		pla				pla
.1478	68		pla				pla
.1479	4c 00 00	jmp $0000			jmp 	Next
.147c					Rot:
.147c	86 08		stx $08				stx 	temp1
.147e	ba		tsx				tsx
.147f	bd 04 01	lda $0104,x			lda 	Stack3Low,x
.1482	a8		tay				tay
.1483	bd 02 01	lda $0102,x			lda 	Stack2Low,x
.1486	9d 04 01	sta $0104,x			sta 	Stack3Low,x
.1489	a5 06		lda $06				lda 	TOS
.148b	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.148e	84 06		sty $06				sty 	TOS
.1490	bd 03 01	lda $0103,x			lda 	Stack3High,x
.1493	a8		tay				tay
.1494	bd 01 01	lda $0101,x			lda 	Stack2High,x
.1497	9d 03 01	sta $0103,x			sta 	Stack3High,x
.149a	a5 07		lda $07				lda 	TOS+1
.149c	9d 01 01	sta $0101,x			sta 	Stack2High,x
.149f	84 07		sty $07				sty 	TOS+1
.14a1	a6 08		ldx $08				ldx 	temp1
.14a3	4c 00 00	jmp $0000			jmp 	Next

;******  Return to file: kernel.asm


;******  Processing file: words/data/memory.src

.14a6					ByteRead:
.14a6	b2 06		lda ($06)			lda 	(TOS)
.14a8	85 06		sta $06				sta 	TOS
.14aa	64 07		stz $07				stz 	TOS+1
.14ac	4c 00 00	jmp $0000			jmp 	Next
.14af					WordRead:
.14af	a0 01		ldy #$01			ldy 	#1
.14b1	b1 06		lda ($06),y			lda 	(TOS),y
.14b3	a8		tay				tay
.14b4	b2 06		lda ($06)			lda 	(TOS)
.14b6	85 06		sta $06				sta 	TOS
.14b8	84 07		sty $07				sty 	TOS+1
.14ba	4c 00 00	jmp $0000			jmp 	Next
.14bd					ByteWrite:
.14bd	68		pla				pla
.14be	68		pla				pla
.14bf	92 06		sta ($06)			sta 	(TOS)
.14c1	68		pla				pla
.14c2	85 07		sta $07				sta 	TOS+1
.14c4	68		pla				pla
.14c5	85 06		sta $06				sta 	TOS
.14c7	4c 00 00	jmp $0000			jmp 	Next
.14ca					WordWrite:
.14ca	68		pla				pla
.14cb	a0 01		ldy #$01			ldy 	#1
.14cd	91 06		sta ($06),y			sta 	(TOS),y
.14cf	68		pla				pla
.14d0	92 06		sta ($06)			sta 	(TOS)
.14d2	68		pla				pla
.14d3	85 07		sta $07				sta 	TOS+1
.14d5	68		pla				pla
.14d6	85 06		sta $06				sta 	TOS
.14d8	4c 00 00	jmp $0000			jmp 	Next
.14db					WordAdd:
.14db	7a		ply				ply
.14dc	68		pla				pla
.14dd	18		clc				clc
.14de	72 06		adc ($06)			adc 	(TOS)
.14e0	92 06		sta ($06)			sta 	(TOS)
.14e2	98		tya				tya
.14e3	a0 01		ldy #$01			ldy 	#1
.14e5	71 06		adc ($06),y			adc 	(TOS),y
.14e7	91 06		sta ($06),y			sta 	(TOS),y
.14e9	68		pla				pla
.14ea	85 07		sta $07				sta 	TOS+1
.14ec	68		pla				pla
.14ed	85 06		sta $06				sta 	TOS
.14ef	4c 00 00	jmp $0000			jmp 	Next

;******  Return to file: kernel.asm

.14f2					Dictionary:

;******  Processing file: generated/dictionary.inc

>14f2	05					.byte	_end1-*
>14f3	00					.byte	$00
>14f4	ca 14					.word	WordWrite
>14f6	a1					.byte	$a1
.14f7					_end1:
>14f7	0d					.byte	_end2-*
>14f8	40					.byte	$40
>14f9	53 13					.word	SkipComment
>14fb	24 24 43 4f 4d 4d 45 4e			.byte	$24,$24,$43,$4f,$4d,$4d,$45,$4e,$d4
>1503	d4
.1504					_end2:
>1504	0c					.byte	_end3-*
>1505	40					.byte	$40
>1506	5e 13					.word	DefineError
>1508	24 24 44 45 46 49 4e c5			.byte	$24,$24,$44,$45,$46,$49,$4e,$c5
.1510					_end3:
>1510	0d					.byte	_end4-*
>1511	40					.byte	$40
>1512	1e 10					.word	Literal2Byte
>1514	24 24 4c 49 54 45 52 41			.byte	$24,$24,$4c,$49,$54,$45,$52,$41,$cc
>151c	cc
.151d					_end4:
>151d	05					.byte	_end5-*
>151e	00					.byte	$00
>151f	b2 11					.word	Multiply16x16
>1521	aa					.byte	$aa
.1522					_end5:
>1522	05					.byte	_end6-*
>1523	00					.byte	$00
>1524	34 10					.word	Add
>1526	ab					.byte	$ab
.1527					_end6:
>1527	06					.byte	_end7-*
>1528	00					.byte	$00
>1529	db 14					.word	WordAdd
>152b	2b a1					.byte	$2b,$a1
.152d					_end7:
>152d	05					.byte	_end8-*
>152e	00					.byte	$00
>152f	43 10					.word	Subtract
>1531	ad					.byte	$ad
.1532					_end8:
>1532	06					.byte	_end9-*
>1533	00					.byte	$00
>1534	7a 13					.word	ConstantMinus1
>1536	2d b1					.byte	$2d,$b1
.1538					_end9:
>1538	05					.byte	_end10-*
>1539	00					.byte	$00
>153a	03 11					.word	Divide16x16
>153c	af					.byte	$af
.153d					_end10:
>153d	05					.byte	_end11-*
>153e	00					.byte	$00
>153f	6d 13					.word	Constant0
>1541	b0					.byte	$b0
.1542					_end11:
>1542	06					.byte	_end12-*
>1543	00					.byte	$00
>1544	47 12					.word	CheckMinus
>1546	30 bc					.byte	$30,$bc
.1548					_end12:
>1548	06					.byte	_end13-*
>1549	00					.byte	$00
>154a	5b 12					.word	CheckZero
>154c	30 bd					.byte	$30,$bd
.154e					_end13:
>154e	05					.byte	_end14-*
>154f	00					.byte	$00
>1550	89 13					.word	C1
>1552	b1					.byte	$b1
.1553					_end14:
>1553	06					.byte	_end15-*
>1554	00					.byte	$00
>1555	f1 11					.word	Unary1Plus
>1557	31 ab					.byte	$31,$ab
.1559					_end15:
>1559	06					.byte	_end16-*
>155a	00					.byte	$00
>155b	08 12					.word	Unary1Minus
>155d	31 ad					.byte	$31,$ad
.155f					_end16:
>155f	06					.byte	_end17-*
>1560	00					.byte	$00
>1561	a1 13					.word	C10
>1563	31 b0					.byte	$31,$b0
.1565					_end17:
>1565	07					.byte	_end18-*
>1566	00					.byte	$00
>1567	d2 13					.word	C100
>1569	31 30 b0				.byte	$31,$30,$b0
.156c					_end18:
>156c	08					.byte	_end19-*
>156d	00					.byte	$00
>156e	01 14					.word	C1024
>1570	31 30 32 b4				.byte	$31,$30,$32,$b4
.1574					_end19:
>1574	07					.byte	_end20-*
>1575	00					.byte	$00
>1576	d6 13					.word	C127
>1578	31 32 b7				.byte	$31,$32,$b7
.157b					_end20:
>157b	07					.byte	_end21-*
>157c	00					.byte	$00
>157d	da 13					.word	C128
>157f	31 32 b8				.byte	$31,$32,$b8
.1582					_end21:
>1582	06					.byte	_end22-*
>1583	00					.byte	$00
>1584	a5 13					.word	C15
>1586	31 b5					.byte	$31,$b5
.1588					_end22:
>1588	06					.byte	_end23-*
>1589	00					.byte	$00
>158a	a9 13					.word	C16
>158c	31 b6					.byte	$31,$b6
.158e					_end23:
>158e	07					.byte	_end24-*
>158f	00					.byte	$00
>1590	80 12					.word	Times16
>1592	31 36 aa				.byte	$31,$36,$aa
.1595					_end24:
>1595	05					.byte	_end25-*
>1596	00					.byte	$00
>1597	8d 13					.word	C2
>1599	b2					.byte	$b2
.159a					_end25:
>159a	06					.byte	_end26-*
>159b	00					.byte	$00
>159c	6e 12					.word	Times2
>159e	32 aa					.byte	$32,$aa
.15a0					_end26:
>15a0	06					.byte	_end27-*
>15a1	00					.byte	$00
>15a2	fa 11					.word	Unary2Plus
>15a4	32 ab					.byte	$32,$ab
.15a6					_end27:
>15a6	06					.byte	_end28-*
>15a7	00					.byte	$00
>15a8	13 12					.word	Unary2Minus
>15aa	32 ad					.byte	$32,$ad
.15ac					_end28:
>15ac	06					.byte	_end29-*
>15ad	00					.byte	$00
>15ae	93 12					.word	Divide2
>15b0	32 af					.byte	$32,$af
.15b2					_end29:
>15b2	06					.byte	_end30-*
>15b3	00					.byte	$00
>15b4	ad 13					.word	C24
>15b6	32 b4					.byte	$32,$b4
.15b8					_end30:
>15b8	07					.byte	_end31-*
>15b9	00					.byte	$00
>15ba	de 13					.word	C255
>15bc	32 35 b5				.byte	$32,$35,$b5
.15bf					_end31:
>15bf	07					.byte	_end32-*
>15c0	00					.byte	$00
>15c1	e9 13					.word	C256
>15c3	32 35 b6				.byte	$32,$35,$b6
.15c6					_end32:
>15c6	05					.byte	_end33-*
>15c7	00					.byte	$00
>15c8	91 13					.word	C3
>15ca	b3					.byte	$b3
.15cb					_end33:
>15cb	06					.byte	_end34-*
>15cc	00					.byte	$00
>15cd	be 13					.word	C32
>15cf	33 b2					.byte	$33,$b2
.15d1					_end34:
>15d1	09					.byte	_end35-*
>15d2	00					.byte	$00
>15d3	19 14					.word	C32767
>15d5	33 32 37 36 b7				.byte	$33,$32,$37,$36,$b7
.15da					_end35:
>15da	09					.byte	_end36-*
>15db	00					.byte	$00
>15dc	25 14					.word	C32768
>15de	33 32 37 36 b8				.byte	$33,$32,$37,$36,$b8
.15e3					_end36:
>15e3	05					.byte	_end37-*
>15e4	00					.byte	$00
>15e5	95 13					.word	C4
>15e7	b4					.byte	$b4
.15e8					_end37:
>15e8	06					.byte	_end38-*
>15e9	00					.byte	$00
>15ea	75 12					.word	Times4
>15ec	34 aa					.byte	$34,$aa
.15ee					_end38:
>15ee	06					.byte	_end39-*
>15ef	00					.byte	$00
>15f0	c6 13					.word	C50
>15f2	34 b0					.byte	$34,$b0
.15f4					_end39:
>15f4	08					.byte	_end40-*
>15f5	00					.byte	$00
>15f6	0d 14					.word	C4096
>15f8	34 30 39 b6				.byte	$34,$30,$39,$b6
.15fc					_end40:
>15fc	06					.byte	_end41-*
>15fd	00					.byte	$00
>15fe	c2 13					.word	C48
>1600	34 b8					.byte	$34,$b8
.1602					_end41:
>1602	05					.byte	_end42-*
>1603	00					.byte	$00
>1604	99 13					.word	C5
>1606	b5					.byte	$b5
.1607					_end42:
>1607	07					.byte	_end43-*
>1608	00					.byte	$00
>1609	f5 13					.word	C512
>160b	35 31 b2				.byte	$35,$31,$b2
.160e					_end43:
>160e	06					.byte	_end44-*
>160f	00					.byte	$00
>1610	ca 13					.word	C63
>1612	36 b3					.byte	$36,$b3
.1614					_end44:
>1614	06					.byte	_end45-*
>1615	00					.byte	$00
>1616	ce 13					.word	C64
>1618	36 b4					.byte	$36,$b4
.161a					_end45:
>161a	05					.byte	_end46-*
>161b	00					.byte	$00
>161c	9d 13					.word	C8
>161e	b8					.byte	$b8
.161f					_end46:
>161f	05					.byte	_end47-*
>1620	00					.byte	$00
>1621	a6 10					.word	CheckLess
>1623	bc					.byte	$bc
.1624					_end47:
>1624	05					.byte	_end48-*
>1625	00					.byte	$00
>1626	7d 10					.word	CheckEqual
>1628	bd					.byte	$bd
.1629					_end48:
>1629	05					.byte	_end49-*
>162a	00					.byte	$00
>162b	bd 10					.word	CheckGreater
>162d	be					.byte	$be
.162e					_end49:
>162e	08					.byte	_end50-*
>162f	00					.byte	$00
>1630	3a 14					.word	TestDup
>1632	3f 44 55 d0				.byte	$3f,$44,$55,$d0
.1636					_end50:
>1636	05					.byte	_end51-*
>1637	00					.byte	$00
>1638	af 14					.word	WordRead
>163a	c0					.byte	$c0
.163b					_end51:
>163b	07					.byte	_end52-*
>163c	00					.byte	$00
>163d	21 12					.word	Absolute
>163f	41 42 d3				.byte	$41,$42,$d3
.1642					_end52:
>1642	07					.byte	_end53-*
>1643	00					.byte	$00
>1644	56 10					.word	And
>1646	41 4e c4				.byte	$41,$4e,$c4
.1649					_end53:
>1649	09					.byte	_end54-*
>164a	00					.byte	$00
>164b	63 12					.word	ByteSwap
>164d	42 53 57 41 d0				.byte	$42,$53,$57,$41,$d0
.1652					_end54:
>1652	06					.byte	_end55-*
>1653	00					.byte	$00
>1654	bd 14					.word	ByteWrite
>1656	43 a1					.byte	$43,$a1
.1658					_end55:
>1658	06					.byte	_end56-*
>1659	00					.byte	$00
>165a	a6 14					.word	ByteRead
>165c	43 c0					.byte	$43,$c0
.165e					_end56:
>165e	08					.byte	_end57-*
>165f	00					.byte	$00
>1660	31 14					.word	Drop
>1662	44 52 4f d0				.byte	$44,$52,$4f,$d0
.1666					_end57:
>1666	07					.byte	_end58-*
>1667	00					.byte	$00
>1668	43 14					.word	Dup
>166a	44 55 d0				.byte	$44,$55,$d0
.166d					_end58:
>166d	07					.byte	_end59-*
>166e	00					.byte	$00
>166f	d8 10					.word	Maximum
>1671	4d 41 d8				.byte	$4d,$41,$d8
.1674					_end59:
>1674	07					.byte	_end60-*
>1675	00					.byte	$00
>1676	d4 10					.word	Minimum
>1678	4d 49 ce				.byte	$4d,$49,$ce
.167b					_end60:
>167b	07					.byte	_end61-*
>167c	00					.byte	$00
>167d	14 11					.word	Modulus16x16
>167f	4d 4f c4				.byte	$4d,$4f,$c4
.1682					_end61:
>1682	0a					.byte	_end62-*
>1683	00					.byte	$00
>1684	28 12					.word	Negate
>1686	4e 45 47 41 54 c5			.byte	$4e,$45,$47,$41,$54,$c5
.168c					_end62:
>168c	07					.byte	_end63-*
>168d	00					.byte	$00
>168e	77 14					.word	Nip
>1690	4e 49 d0				.byte	$4e,$49,$d0
.1693					_end63:
>1693	07					.byte	_end64-*
>1694	00					.byte	$00
>1695	38 12					.word	OneComplement
>1697	4e 4f d4				.byte	$4e,$4f,$d4
.169a					_end64:
>169a	06					.byte	_end65-*
>169b	00					.byte	$00
>169c	70 10					.word	LogOr
>169e	4f d2					.byte	$4f,$d2
.16a0					_end65:
>16a0	08					.byte	_end66-*
>16a1	00					.byte	$00
>16a2	5f 14					.word	Over
>16a4	4f 56 45 d2				.byte	$4f,$56,$45,$d2
.16a8					_end66:
>16a8	07					.byte	_end67-*
>16a9	00					.byte	$00
>16aa	7c 14					.word	Rot
>16ac	52 4f d4				.byte	$52,$4f,$d4
.16af					_end67:
>16af	08					.byte	_end68-*
>16b0	00					.byte	$00
>16b1	4c 14					.word	Swap
>16b3	53 57 41 d0				.byte	$53,$57,$41,$d0
.16b7					_end68:
>16b7	07					.byte	_end69-*
>16b8	00					.byte	$00
>16b9	a7 12					.word	Call6502
>16bb	53 59 d3				.byte	$53,$59,$d3
.16be					_end69:
>16be	0a					.byte	_end70-*
>16bf	40					.byte	$40
>16c0	a3 12					.word	BreakCmd
>16c2	58 42 52 45 41 cb			.byte	$58,$42,$52,$45,$41,$cb
.16c8					_end70:
>16c8	09					.byte	_end71-*
>16c9	00					.byte	$00
>16ca	9d 12					.word	ExitDump
>16cc	58 44 55 4d d0				.byte	$58,$44,$55,$4d,$d0
.16d1					_end71:
>16d1	07					.byte	_end72-*
>16d2	00					.byte	$00
>16d3	63 10					.word	Xor
>16d5	58 4f d2				.byte	$58,$4f,$d2
.16d8					_end72:
>16d8	00					.byte	0

;******  Return to file: kernel.asm

.16d9					BootCode:
>16d9	1b						.byte 		Line20-BootCode
>16da	0a 00						.word 		10
>16dc	1e 10						.word 		Literal2Byte
>16de	cd ab						.word 		$ABCD
>16e0	53 13						.word 		SkipComment
>16e2	04 41 42 43					.text 		4,"ABC"
>16e6	1e 10						.word 		Literal2Byte
>16e8	45 33						.word 		$3345
>16ea	1e 10						.word 		Literal2Byte
>16ec	34 22						.word 		$2234
>16ee	1e 10						.word 		Literal2Byte
>16f0	23 11						.word 		$1123
>16f2	2f 13						.word 		NextLine
>16f4	0d				Line20:	.byte 		EndOfProgram-Line20
>16f5	14 00						.word 		20
>16f7	7c 14						.word 		Rot
>16f9	1e 10						.word 		Literal2Byte
>16fb	ef cd						.word 		$CDEF
>16fd	9d 12						.word 		ExitDump
>16ff	2f 13						.word 		NextLine
.1701					EndOfProgram:
>1701	00						.byte 		0

;******  End of listing
