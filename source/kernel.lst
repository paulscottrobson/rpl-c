
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -q -c -D encode=1 -o kernel_nocode.prg -L kernel.lst -l kernel.lbl kernel.asm
; Mon Jan 13 08:55:17 2020

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=1					encode=1

;******  Processing input file: kernel.asm

=$1000					RplBuild = $1000 							; code starts here.

;******  Processing file: data.asm

.0000					NextCode:
>0000							.fill 	5
=3					IP = NextCode+3 							; the IP which points to the current instruction
.0005					rsp:
>0005							.byte 	?
.0006					tos:
>0006							.word 	?
.0008					srcPtr:
>0008							.word 	?
.000a					bufPtr:
>000a							.word 	?
.000c					matchPtr:
>000c							.word 	?
.000e					nextFreeMem:
>000e							.word 	?
.0010					temp1:
>0010							.word 	?
.0012					temp2:
>0012							.word 	?
.0014					temp3:
>0014							.word 	?
.0016					temp4:
>0016							.word 	?
.0018					listPtr:
>0018							.word 	?
.001a					SignCount:
>001a							.byte 	?
.001b					RandomSeed:
>001b							.word 	?
.001d					ListCount:
>001d							.byte 	?
.001e					ListLowest:
>001e							.word 	?
=$102					stack2Low = $102							; access other stack members following tsx
=$101					stack2High = $101							; (which requires saving X, not on the stack !)
=$104					stack3Low = $104
=$103					stack3High = $103
=$600					azVariables = $600 							; 26 x 2 variables occupying 52 bytes * PAGE BOUNDARY *
=16					hashTableSize = 16 							; hash tables for variables.
=$640					hashTable = $640 							; hash tables start here * ALL ON ONE PAGE *
=$810					textBuffer = $810 							; buffer for text.
=$700					returnStack = $700							; return stack (1 page)
=$700					returnStackLow = returnStack
=1856					returnStackHigh = returnStack+$40
=1920					returnStackX = returnStack+$80
=$80					NumberStackBase = $80 						; number stack down from here.
=$910					encodeBuffer = $910 						; buffer for encoded program
=0					COL_BLACK = 0
=1					COL_RED = 1
=2					COL_GREEN = 2
=3					COL_YELLOW = 3
=4					COL_BLUE = 4
=5					COL_MAGENTA = 5
=6					COL_CYAN = 6
=7					COL_WHITE = 7
=8					COL_RVS = 8
=2					CTH_LineNo = COL_Green
=6					CTH_Keyword = COL_Cyan
=11					CTH_Comment = COL_Yellow+COL_Rvs
=7					CTH_Definition = COL_White
=5					CTH_String = COL_Magenta
=3					CTH_Call = COL_Yellow

;******  Return to file: kernel.asm

.1000	a2 ff		ldx #$ff			ldx 	#$FF 						; reset the stack
.1002	9a		txs				txs
.1003	20 e1 10	jsr $10e1			jsr 	ExternInitialise
.1006	a9 26		lda #$26			lda 	#BootMsg & $FF
.1008	a0 10		ldy #$10			ldy 	#BootMsg >> 8
.100a	20 d1 11	jsr $11d1			jsr 	EXPrintString
.100d					WarmStartBlankStack:
.100d	a2 80		ldx #$80			ldx 	#NumberStackBase
.100f	9a		txs				txs
.1010	4c 01 23	jmp $2301			jmp 	EncodeTest
.1013					WarmStart:
.1013	a9 03		lda #$03			lda 	#COL_Yellow
.1015	20 18 11	jsr $1118			jsr 	ExternColour
.1018	20 3b 11	jsr $113b			jsr 	ExternInput
.101b	a9 06		lda #$06			lda 	#COL_Cyan
.101d	20 18 11	jsr $1118			jsr 	ExternColour
.1020	4c 7f 1c	jmp $1c7f			jmp 	RunProgram
.1023					ErrorHandler:
>1023	ff						.byte 	$FF
.1024	a2 5e		ldx #$5e			ldx 	#$5E
.1026					BootMsg:
>1026	2a 2a 2a 20 52 50 4c 2f				.text 	"*** RPL/C INTERPRETER ***",13,13
>102e	43 20 49 4e 54 45 52 50 52 45 54 45 52 20 2a 2a
>103e	2a 0d 0d
>1041	57 52 49 54 54 45 4e 20				.text	"WRITTEN BY PAUL ROBSON 2020",13,13
>1049	42 59 20 50 41 55 4c 20 52 4f 42 53 4f 4e 20 32
>1059	30 32 30 0d 0d
>105e	42 55 49 4c 44 3a 20				.text 	"BUILD: "

;******  Processing file: generated/timestamp.inc

>1065	5b 32 30 2d 30 31 2d 31			.text	"[20-01-13 08:55]"
>106d	33 20 30 38 3a 35 35 5d

;******  Return to file: kernel.asm

>1075	0d 0d 00					.byte 	13,13,0

;******  Processing file: core.src

.1078					InitialiseCoreCode:
.1078	a9 e8		lda #$e8			lda 	#$E8 					; Copy INX INX 			4 cycles when run
.107a	85 00		sta $00				sta 	NextCode
.107c	85 01		sta $01				sta 	NextCode+1
.107e	a9 7c		lda #$7c			lda 	#$7C 					; Copy JMP ($aaaa,x) 	6 cycles when run
.1080	85 02		sta $02				sta 	NextCode+2
.1082	86 03		stx $03				stx 	NextCode+3 				; set the indirect address (IP)
.1084	84 04		sty $04				sty 	NextCode+4
.1086	a2 01		ldx #$01			ldx 	#1 						; set up to run from provided word.
.1088	60		rts				rts								; (2 INX skip offset and line#)
.1089					Literal2Byte:
.1089	a5 06		lda $06				lda 	TOS
.108b	48		pha				pha
.108c	a5 07		lda $07				lda 	TOS+1
.108e	48		pha				pha
.108f	e8		inx				inx  							; point X to the word
.1090	e8		inx				inx
.1091	8a		txa				txa 							; copy into Y
.1092	a8		tay				tay
.1093	b1 03		lda ($03),y			lda 	(IP),y 					; read it. the LSB
.1095	85 06		sta $06				sta 	TOS
.1097	c8		iny				iny 							; read and push the MSB
.1098	b1 03		lda ($03),y			lda 	(IP),y
.109a	85 07		sta $07				sta 	TOS+1
.109c	4c 00 00	jmp $0000			jmp 	NextCode
.109f					Literal2ByteDecode:
.109f	a9 06		lda #$06			lda 	#CTH_Keyword
.10a1	20 c3 1b	jsr $1bc3			jsr 	DecodeWriteBuffer
.10a4	b1 08		lda ($08),y			lda 	(srcPtr),y
.10a6	aa		tax				tax
.10a7	c8		iny				iny
.10a8	b1 08		lda ($08),y			lda 	(srcPtr),y
.10aa	a8		tay				tay
.10ab	8a		txa				txa
.10ac	38		sec				sec 							; output signed
.10ad	20 e5 1b	jsr $1be5			jsr 	DecodeYAToBuffer
.10b0	60		rts				rts
.10b1					LiteralString:
.10b1	a5 06		lda $06				lda 	TOS
.10b3	48		pha				pha
.10b4	a5 07		lda $07				lda 	TOS+1
.10b6	48		pha				pha
.10b7	e8		inx				inx
.10b8	e8		inx				inx 							; skip over current word
.10b9	8a		txa				txa 							; add to IP + 1 to give string address
.10ba	a8		tay				tay 							; put in Y
.10bb	38		sec				sec 							; make that TOS
.10bc	65 03		adc $03				adc 	IP
.10be	85 06		sta $06				sta 	TOS
.10c0	a5 04		lda $04				lda 	IP+1
.10c2	69 00		adc #$00			adc 	#0
.10c4	85 07		sta $07				sta 	TOS+1
.10c6	8a		txa				txa 							; add data length to X
.10c7	18		clc				clc
.10c8	71 03		adc ($03),y			adc 	(IP),y
.10ca	aa		tax				tax
.10cb	ca		dex				dex
.10cc	ca		dex				dex
.10cd	4c 00 00	jmp $0000			jmp 	NextCode
.10d0					LiteralStringDecoder:
.10d0	a9 05		lda #$05			lda 	#CTH_String
.10d2	20 c3 1b	jsr $1bc3			jsr 	DecodeWriteBuffer
.10d5	a9 22		lda #$22			lda 	#'"'
.10d7	20 c3 1b	jsr $1bc3			jsr 	DecodeWriteBuffer
.10da	20 cc 1b	jsr $1bcc			jsr 	DecodeOutputData
.10dd	20 c3 1b	jsr $1bc3			jsr 	DecodeWriteBuffer
.10e0	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: extern.asm

.10e1					ExternInitialise:
.10e1	a9 90		lda #$90			lda 	#144 						; set colour
.10e3	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.10e6	a9 01		lda #$01			lda 	#$01
.10e8	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.10eb	a9 0e		lda #$0e			lda 	#14							; lower case
.10ed	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.10f0	a9 93		lda #$93			lda 	#147 						; clear screen
.10f2	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.10f5	a9 07		lda #$07			lda 	#COL_WHITE 					; white text.
.10f7	4c 18 11	jmp $1118			jmp 	ExternColour
.10fa					ExternCheckBreak:
.10fa	da		phx				phx 								; make sure we keep XY
.10fb	5a		phy				phy
.10fc	20 e1 ff	jsr $ffe1			jsr 	$FFE1						; STOP check on CBM KERNAL
.10ff	f0 03		beq $1104			beq		_ECBExit 					; stopped
.1101	7a		ply				ply 								; restore and exit.
.1102	fa		plx				plx
.1103	60		rts				rts
.1104					_ECBExit:
.1104	20 23 10	jsr $1023			jsr 	ErrorHandler
>1107	45 53 43 41 50 45 00				.text 	"ESCAPE",0
.110e					ExternPrint:
.110e	48		pha				pha
.110f	da		phx				phx
.1110	5a		phy				phy
.1111	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.1114	7a		ply				ply
.1115	fa		plx				plx
.1116	68		pla				pla
.1117	60		rts				rts
.1118					ExternColour:
.1118	48		pha				pha
.1119	da		phx				phx
.111a	48		pha				pha
.111b	29 08		and #$08			and 	#8
.111d	0a		asl a				asl 	a
.111e	0a		asl a				asl 	a
.111f	0a		asl a				asl 	a
.1120	0a		asl a				asl 	a
.1121	49 92		eor #$92			eor 	#$92
.1123	20 0e 11	jsr $110e			jsr 	ExternPrint
.1126	68		pla				pla
.1127	29 07		and #$07			and 	#7
.1129	aa		tax				tax
.112a	bd 33 11	lda $1133,x			lda 	_ECTable,x
.112d	20 0e 11	jsr $110e			jsr 	ExternPrint
.1130	fa		plx				plx
.1131	68		pla				pla
.1132	60		rts				rts
.1133					_ECTable:
>1133	90						.byte 	144
>1134	1c						.byte 	28
>1135	1e						.byte 	30
>1136	9e						.byte 	158
>1137	1f						.byte 	31
>1138	9c						.byte 	156
>1139	9f						.byte 	159
>113a	05						.byte 	5
.113b					ExternInput:
.113b	a9 10		lda #$10			lda 	#(textBuffer & $FF)
.113d	85 14		sta $14				sta 	temp3
.113f	a9 08		lda #$08			lda 	#(textBuffer >> 8)
.1141	85 15		sta $15				sta 	temp3+1
.1143	20 cf ff	jsr $ffcf	_EIRead:jsr 	$FFCF
.1146	29 7f		and #$7f			and 	#$7F
.1148	c9 0d		cmp #$0d			cmp 	#13
.114a	f0 0a		beq $1156			beq 	_EIExit
.114c	92 14		sta ($14)			sta 	(temp3)
.114e	e6 14		inc $14				inc 	temp3
.1150	d0 f1		bne $1143			bne 	_EIRead
.1152	e6 15		inc $15				inc 	temp3+1
.1154	80 ed		bra $1143			bra 	_EIRead
.1156	a9 00		lda #$00	_EIExit:lda 	#0
.1158	92 14		sta ($14)			sta 	(temp3)
.115a	a9 0d		lda #$0d			lda 	#13
.115c	20 0e 11	jsr $110e			jsr 	ExternPrint
.115f	60		rts				rts
.1160					ExternSave:
.1160	da		phx				phx
.1161	5a		phy				phy
.1162	85 12		sta $12				sta 	temp2 						; save start
.1164	84 13		sty $13				sty 	temp2+1
.1166	20 c8 11	jsr $11c8			jsr 	EXGetLength 				; get length of file into A
.1169	a6 14		ldx $14				ldx 	temp3
.116b	a4 15		ldy $15				ldy 	temp3+1
.116d	20 bd ff	jsr $ffbd			jsr 	$FFBD 						; set name
.1170	a9 01		lda #$01			lda 	#1
.1172	a2 08		ldx #$08			ldx 	#8	 						; device #8
.1174	a0 00		ldy #$00			ldy 	#0
.1176	20 ba ff	jsr $ffba			jsr 	$FFBA 						; set LFS
.1179	a6 10		ldx $10				ldx 	temp1 						; end address
.117b	a4 11		ldy $11				ldy 	temp1+1
.117d	a9 12		lda #$12			lda 	#temp2
.117f	20 d8 ff	jsr $ffd8			jsr 	$FFD8 						; save
.1182	b0 03		bcs $1187			bcs 	_ESSave
.1184	7a		ply				ply
.1185	fa		plx				plx
.1186	60		rts				rts
.1187					_ESSave:
.1187	20 23 10	jsr $1023			jsr 	ErrorHandler
>118a	53 41 56 45 20 46 41 49				.text 	"SAVE FAILED",0
>1192	4c 45 44 00
.1196					ExternLoad:
.1196	da		phx				phx 								; save XY
.1197	5a		phy				phy
.1198	48		pha				pha 								; save target
.1199	5a		phy				phy
.119a	20 c8 11	jsr $11c8			jsr 	EXGetLength 				; get length of file into A
.119d	a6 14		ldx $14				ldx 	temp3
.119f	a4 15		ldy $15				ldy 	temp3+1
.11a1	20 bd ff	jsr $ffbd			jsr 	$FFBD 						; set name
.11a4	a9 01		lda #$01			lda 	#1
.11a6	a2 08		ldx #$08			ldx 	#8	 						; device #8
.11a8	a0 00		ldy #$00			ldy 	#0
.11aa	20 ba ff	jsr $ffba			jsr 	$FFBA 						; set LFS
.11ad	7a		ply				ply 								; restore target to YX and call load
.11ae	fa		plx				plx
.11af	a9 00		lda #$00			lda 	#0 							; load command
.11b1	20 d5 ff	jsr $ffd5			jsr 	$FFD5
.11b4	b0 03		bcs $11b9			bcs 	_ESLoad
.11b6	7a		ply				ply
.11b7	fa		plx				plx
.11b8	60		rts				rts
.11b9					_ESLoad:
.11b9	20 23 10	jsr $1023			jsr 	ErrorHandler
>11bc	4c 4f 41 44 20 46 41 49				.text 	"LOAD FAILED",0
>11c4	4c 45 44 00
.11c8					EXGetLength:
.11c8	b2 14		lda ($14)			lda 	(temp3) 					; get name length
.11ca	e6 14		inc $14				inc 	temp3 						; bump ptr past it
.11cc	d0 02		bne $11d0			bne 	_EXGLExit
.11ce	e6 15		inc $15				inc 	temp3+1
.11d0					_EXGLExit:
.11d0	60		rts				rts
.11d1					EXPrintString:
.11d1	48		pha				pha
.11d2	5a		phy				phy
.11d3	84 11		sty $11				sty 	temp1+1
.11d5	85 10		sta $10				sta 	temp1
.11d7	a0 00		ldy #$00			ldy 	#0
.11d9					_EXPSLoop:
.11d9	b1 10		lda ($10),y			lda 	(temp1),y
.11db	f0 08		beq $11e5			beq 	_EXPSExit
.11dd	29 7f		and #$7f			and 	#$7F
.11df	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.11e2	c8		iny				iny
.11e3	80 f4		bra $11d9			bra 	_EXPSLoop
.11e5					_EXPSExit:
.11e5	7a		ply				ply
.11e6	68		pla				pla
.11e7	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/binary.src

.11e8					Add:
.11e8	7a		ply				ply
.11e9	68		pla				pla
.11ea	18		clc				clc
.11eb	65 06		adc $06				adc 	TOS
.11ed	85 06		sta $06				sta 	TOS
.11ef	98		tya				tya
.11f0	65 07		adc $07				adc 	TOS+1
.11f2	85 07		sta $07				sta 	TOS+1
.11f4	4c 00 00	jmp $0000			jmp 	NextCode
.11f7					Subtract:
.11f7	7a		ply				ply
.11f8	68		pla				pla
.11f9	38		sec				sec
.11fa	49 ff		eor #$ff			eor 	#$FF
.11fc	65 06		adc $06				adc 	TOS
.11fe	85 06		sta $06				sta 	TOS
.1200	98		tya				tya
.1201	49 ff		eor #$ff			eor 	#$FF
.1203	65 07		adc $07				adc 	TOS+1
.1205	85 07		sta $07				sta 	TOS+1
.1207	4c 00 00	jmp $0000			jmp 	NextCode
.120a					And:
.120a	68		pla				pla
.120b	25 07		and $07				and 	TOS+1
.120d	85 07		sta $07				sta 	TOS+1
.120f	68		pla				pla
.1210	25 06		and $06				and 	TOS
.1212	85 06		sta $06				sta 	TOS
.1214	4c 00 00	jmp $0000			jmp 	NextCode
.1217					Xor:
.1217	68		pla				pla
.1218	45 07		eor $07				eor 	TOS+1
.121a	85 07		sta $07				sta 	TOS+1
.121c	68		pla				pla
.121d	45 06		eor $06				eor 	TOS
.121f	85 06		sta $06				sta 	TOS
.1221	4c 00 00	jmp $0000			jmp 	NextCode
.1224					LogOr:
.1224	68		pla				pla
.1225	05 07		ora $07				ora 	TOS+1
.1227	85 07		sta $07				sta 	TOS+1
.1229	68		pla				pla
.122a	05 06		ora $06				ora 	TOS
.122c	85 06		sta $06				sta 	TOS
.122e	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/compare.src

.1231					CheckNotEqual:
.1231	38		sec				sec
.1232	80 01		bra $1235			bra 	CECode
.1234					CheckEqual:
.1234	18		clc				clc
.1235					CECode:
.1235	86 10		stx $10				stx 	temp1
.1237	ba		tsx				tsx
.1238	08		php				php
.1239	a5 06		lda $06				lda 	TOS
.123b	5d 02 01	eor $0102,x			eor 	Stack2Low,x
.123e	d0 17		bne $1257			bne	 	CompareFalse
.1240	a5 07		lda $07				lda 	TOS+1
.1242	5d 01 01	eor $0101,x			eor 	Stack2High,x
.1245	d0 10		bne $1257			bne 	CompareFalse
.1247					CompareTrue:
.1247	a6 10		ldx $10				ldx 	temp1
.1249	28		plp				plp
.124a	b0 10		bcs $125c			bcs		CompareFalse2
.124c					CompareTrue2:
.124c	68		pla				pla
.124d	68		pla				pla
.124e	a9 ff		lda #$ff			lda 	#$FF
.1250	85 06		sta $06				sta 	TOS
.1252	85 07		sta $07				sta 	TOS+1
.1254	4c 00 00	jmp $0000			jmp 	NextCode
.1257					CompareFalse:
.1257	a6 10		ldx $10				ldx 	temp1
.1259	28		plp				plp
.125a	b0 f0		bcs $124c			bcs		CompareTrue2
.125c					CompareFalse2:
.125c	68		pla				pla
.125d	68		pla				pla
.125e	64 06		stz $06				stz 	TOS
.1260	64 07		stz $07				stz 	TOS+1
.1262	4c 00 00	jmp $0000			jmp 	NextCode
.1265					CheckGreaterEq:
.1265	38		sec				sec
.1266	80 01		bra $1269			bra		CLCode
.1268					CheckLess:
.1268	18		clc				clc
.1269	86 10		stx $10		CLCode:	stx 	temp1
.126b	ba		tsx				tsx
.126c	08		php				php
.126d	18		clc				clc
.126e	a5 06		lda $06				lda 	TOS
.1270	fd 02 01	sbc $0102,x			sbc 	Stack2Low,x
.1273	a5 07		lda $07				lda 	TOS+1
.1275	fd 01 01	sbc $0101,x			sbc 	Stack2High,x
.1278	50 02		bvc $127c			bvc 	_CLNoFlip
.127a	49 80		eor #$80			eor 	#$80
.127c					_CLNoFlip:
.127c	0a		asl a				asl 	a
.127d	b0 d8		bcs $1257			bcs 	CompareFalse
.127f	80 c6		bra $1247			bra 	CompareTrue
.1281					CheckLessEq:
.1281	38		sec				sec
.1282	80 01		bra $1285			bra		CGCode
.1284					CheckGreater:
.1284	18		clc				clc
.1285					CGCode:
.1285	86 10		stx $10				stx 	temp1
.1287	ba		tsx				tsx
.1288	08		php				php
.1289	18		clc				clc
.128a	bd 02 01	lda $0102,x			lda 	Stack2Low,x
.128d	e5 06		sbc $06				sbc 	TOS
.128f	bd 01 01	lda $0101,x			lda 	Stack2High,x
.1292	e5 07		sbc $07				sbc 	TOS+1
.1294	50 02		bvc $1298			bvc 	_CGNoFlip
.1296	49 80		eor #$80			eor 	#$80
.1298					_CGNoFlip:
.1298	0a		asl a				asl 	a
.1299	b0 bc		bcs $1257			bcs 	CompareFalse
.129b	80 aa		bra $1247			bra 	CompareTrue
.129d					Minimum:
.129d	a9 00		lda #$00			lda 	#0
.129f	80 02		bra $12a3			bra 	MinMaxCode
.12a1					Maximum:
.12a1	a9 80		lda #$80			lda 	#$80
.12a3					MinMaxCode:
.12a3	85 11		sta $11				sta 	temp1+1
.12a5	86 10		stx $10				stx 	temp1
.12a7	ba		tsx				tsx
.12a8	38		sec				sec
.12a9	a5 06		lda $06				lda 	TOS
.12ab	fd 02 01	sbc $0102,x			sbc 	Stack2Low,x
.12ae	a5 07		lda $07				lda 	TOS+1
.12b0	fd 01 01	sbc $0101,x			sbc 	Stack2High,x
.12b3	50 02		bvc $12b7			bvc 	_MMNoFlip
.12b5	49 80		eor #$80			eor 	#$80
.12b7					_MMNoFlip:
.12b7	45 11		eor $11				eor 	temp1+1
.12b9	30 0a		bmi $12c5			bmi 	_MMNoCopy
.12bb	bd 02 01	lda $0102,x			lda 	Stack2Low,x
.12be	85 06		sta $06				sta 	TOS
.12c0	bd 01 01	lda $0101,x			lda 	Stack2High,x
.12c3	85 07		sta $07				sta 	TOS+1
.12c5					_MMNoCopy:
.12c5	a6 10		ldx $10				ldx 	temp1
.12c7	68		pla				pla
.12c8	68		pla				pla
.12c9	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/divide.src

.12cc					Divide16x16:
.12cc	86 12		stx $12				stx 	temp2
.12ce	ba		tsx				tsx
.12cf	20 f2 12	jsr $12f2			jsr 	IntegerDivide
.12d2	68		pla				pla
.12d3	85 07		sta $07				sta 	TOS+1
.12d5	68		pla				pla
.12d6	85 06		sta $06				sta 	TOS
.12d8	a6 12		ldx $12				ldx 	temp2
.12da	4c 00 00	jmp $0000			jmp 	NextCode
.12dd					Modulus16x16:
.12dd	86 12		stx $12				stx 	temp2
.12df	ba		tsx				tsx
.12e0	20 f2 12	jsr $12f2			jsr 	IntegerDivide
.12e3	a6 12		ldx $12				ldx 	temp2
.12e5	68		pla				pla
.12e6	68		pla				pla
.12e7	a5 10		lda $10				lda 	temp1
.12e9	85 06		sta $06				sta 	TOS
.12eb	a5 11		lda $11				lda 	temp1+1
.12ed	85 07		sta $07				sta 	TOS+1
.12ef	4c 00 00	jmp $0000			jmp 	NextCode
.12f2					IntegerDivide:
.12f2	a5 06		lda $06				lda 	TOS 				; check for division by zero.
.12f4	05 07		ora $07				ora 	TOS+1
.12f6	d0 14		bne $130c			bne 	_BFDOkay
.12f8	20 23 10	jsr $1023			jsr 	ErrorHandler
>12fb	44 49 56 49 53 49 4f 4e				.text 	"DIVISION BY ZERO",0
>1303	20 42 59 20 5a 45 52 4f 00
.130c					_BFDOkay:
.130c	64 10		stz $10				stz 	temp1 						; Q/Dividend/Left in +0
.130e	64 11		stz $11				stz 	temp1+1 					; M/Divisor/Right in +2
.1310	64 1a		stz $1a				stz 	SignCount 					; Count of signs.
.1312	20 4d 13	jsr $134d			jsr 	CheckIntegerNegate 			; negate 2nd (and bump sign count)
.1315	20 67 13	jsr $1367			jsr 	CheckTOSNegate 				; negate TOS (and bump sign count)
.1318	5a		phy				phy 								; Y is the counter
.1319	a0 10		ldy #$10			ldy 	#16 						; 16 iterations of the loop.
.131b					_BFDLoop:
.131b	1e 02 01	asl $0102,x			asl 	Stack2Low,x 				; shift AQ left.
.131e	3e 01 01	rol $0101,x			rol 	Stack2High,x
.1321	26 10		rol $10				rol 	temp1
.1323	26 11		rol $11				rol 	temp1+1
.1325	38		sec				sec
.1326	a5 10		lda $10				lda 	temp1+0 					; Calculate A-M on stack.
.1328	e5 06		sbc $06				sbc 	TOS
.132a	48		pha				pha
.132b	a5 11		lda $11				lda 	temp1+1
.132d	e5 07		sbc $07				sbc 	TOS+1
.132f	90 0f		bcc $1340			bcc 	_BFDNoAdd
.1331	85 11		sta $11				sta 	temp1+1
.1333	68		pla				pla
.1334	85 10		sta $10				sta 	temp1+0
.1336	bd 02 01	lda $0102,x			lda 	Stack2Low,x 				; set Q bit 1.
.1339	09 01		ora #$01			ora 	#1
.133b	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.133e	80 01		bra $1341			bra 	_BFDNext
.1340					_BFDNoAdd:
.1340	68		pla				pla 								; Throw away the intermediate calculations
.1341					_BFDNext:
.1341	88		dey				dey
.1342	d0 d7		bne $131b			bne 	_BFDLoop
.1344	7a		ply				ply 								; restore Y
.1345	46 1a		lsr $1a				lsr 	SignCount 					; if sign count odd,
.1347	90 03		bcc $134c			bcc 	_BFDUnsigned 				; then the result is signed
.1349	20 53 13	jsr $1353			jsr		IntegerNegateAlways 		; negate the result
.134c					_BFDUnsigned:
.134c	60		rts				rts
.134d					CheckIntegerNegate:
.134d	bd 01 01	lda $0101,x			lda 	Stack2High,x 				; is it -ve = MSB set ?
.1350	30 01		bmi $1353			bmi 	IntegerNegateAlways 		; if so negate it
.1352	60		rts				rts
.1353					IntegerNegateAlways:
.1353	e6 1a		inc $1a				inc 	SignCount 					; bump the count of signs
.1355	38		sec				sec 								; negate
.1356	a9 00		lda #$00			lda 	#0
.1358	fd 02 01	sbc $0102,x			sbc 	Stack2Low,x
.135b	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.135e	a9 00		lda #$00			lda 	#0
.1360	fd 01 01	sbc $0101,x			sbc 	Stack2High,x
.1363	9d 01 01	sta $0101,x			sta 	Stack2High,x
.1366	60		rts				rts
.1367					CheckTOSNegate:
.1367	a5 07		lda $07				lda 	TOS+1
.1369	10 0f		bpl $137a			bpl		CTNNoChange
.136b	e6 1a		inc $1a				inc 	SignCount
.136d					TOSNegateAlways:
.136d	38		sec				sec
.136e	a9 00		lda #$00			lda 	#0
.1370	e5 06		sbc $06				sbc 	TOS
.1372	85 06		sta $06				sta 	TOS
.1374	a9 00		lda #$00			lda 	#0
.1376	e5 07		sbc $07				sbc 	TOS+1
.1378	85 07		sta $07				sta 	TOS+1
.137a					CTNNoChange:
.137a	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/multiply.src

.137b					Multiply16x16:
.137b	86 10		stx $10				stx 	temp1
.137d	ba		tsx				tsx
.137e	bd 02 01	lda $0102,x			lda 	Stack2Low,x 				; 2nd value on stack to temp1
.1381	85 12		sta $12				sta 	temp2
.1383	bd 01 01	lda $0101,x			lda		Stack2High,x
.1386	85 13		sta $13				sta 	temp2+1
.1388	9e 02 01	stz $0102,x			stz 	Stack2Low,x 				; zero 2nd value on stack
.138b	9e 01 01	stz $0101,x			stz 	Stack2High,x
.138e					_MultLoop:
.138e	46 13		lsr $13				lsr 	temp2+1 					; ror temp2 into C
.1390	66 12		ror $12				ror 	temp2
.1392	90 11		bcc $13a5			bcc 	_MultNoAdd
.1394	18		clc				clc 								; add 1st to 2nd
.1395	a5 06		lda $06				lda 	TOS
.1397	7d 02 01	adc $0102,x			adc 	Stack2Low,x
.139a	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.139d	a5 07		lda $07				lda 	TOS+1
.139f	7d 01 01	adc $0101,x			adc 	Stack2High,x
.13a2	9d 01 01	sta $0101,x			sta 	Stack2High,x
.13a5					_MultNoAdd:
.13a5	06 06		asl $06				asl 	TOS 						; shift 1st left
.13a7	26 07		rol $07				rol 	TOS+1
.13a9	a5 12		lda $12				lda 	temp2	 					; until zero
.13ab	05 13		ora $13				ora 	temp2+1
.13ad	d0 df		bne $138e			bne 	_MultLoop
.13af	a6 10		ldx $10				ldx 	temp1 						; restore X load result
.13b1	68		pla				pla
.13b2	85 07		sta $07				sta 	TOS+1
.13b4	68		pla				pla
.13b5	85 06		sta $06				sta 	TOS
.13b7	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/unary.src

.13ba					Unary1Plus:
.13ba	e6 06		inc $06				inc 	TOS
.13bc	d0 02		bne $13c0			bne 	_U1PSkip
.13be	e6 07		inc $07				inc 	TOS+1
.13c0					_U1PSkip:
.13c0	4c 00 00	jmp $0000			jmp 	NextCode
.13c3					Unary2Plus:
.13c3	18		clc				clc
.13c4	a5 06		lda $06				lda 	TOS
.13c6	69 02		adc #$02			adc 	#2
.13c8	85 06		sta $06				sta 	TOS
.13ca	90 02		bcc $13ce			bcc 	_U1PSkip
.13cc	e6 07		inc $07				inc 	TOS+1
.13ce					_U1PSkip:
.13ce	4c 00 00	jmp $0000			jmp 	NextCode
.13d1					Unary1Minus:
.13d1	a5 06		lda $06				lda 	TOS
.13d3	d0 02		bne $13d7			bne 	_U1MSkip
.13d5	c6 07		dec $07				dec 	TOS+1
.13d7					_U1MSkip:
.13d7	c6 06		dec $06				dec 	TOS
.13d9	4c 00 00	jmp $0000			jmp 	NextCode
.13dc					Unary2Minus:
.13dc	38		sec				sec
.13dd	a5 06		lda $06				lda 	TOS
.13df	e9 02		sbc #$02			sbc 	#2
.13e1	85 06		sta $06				sta 	TOS
.13e3	b0 02		bcs $13e7			bcs 	_U1PSkip
.13e5	c6 07		dec $07				dec 	TOS+1
.13e7					_U1PSkip:
.13e7	4c 00 00	jmp $0000			jmp 	NextCode
.13ea					Absolute:
.13ea	a5 07		lda $07				lda 	TOS+1
.13ec	30 03		bmi $13f1			bmi 	Negate
.13ee	4c 00 00	jmp $0000			jmp 	NextCode
.13f1					Negate:
.13f1	38		sec				sec
.13f2	a9 00		lda #$00			lda 	#0
.13f4	e5 06		sbc $06				sbc 	TOS
.13f6	85 06		sta $06				sta 	TOS
.13f8	a9 00		lda #$00			lda 	#0
.13fa	e5 07		sbc $07				sbc 	TOS+1
.13fc	85 07		sta $07				sta 	TOS+1
.13fe	4c 00 00	jmp $0000			jmp 	NextCode
.1401					OneComplement:
.1401	a5 06		lda $06				lda 	TOS
.1403	49 ff		eor #$ff			eor 	#$FF
.1405	85 06		sta $06				sta 	TOS
.1407	a5 07		lda $07				lda 	TOS+1
.1409	49 ff		eor #$ff			eor 	#$FF
.140b	85 07		sta $07				sta 	TOS+1
.140d	4c 00 00	jmp $0000			jmp 	NextCode
.1410					CheckMinus:
.1410	a5 07		lda $07				lda 	TOS+1
.1412	30 07		bmi $141b			bmi 	UnaryTrue
.1414					UnaryFalse:
.1414	64 06		stz $06				stz 	TOS
.1416	64 07		stz $07				stz 	TOS+1
.1418	4c 00 00	jmp $0000			jmp 	NextCode
.141b					UnaryTrue:
.141b	a9 ff		lda #$ff			lda 	#$FF
.141d	85 06		sta $06				sta 	TOS
.141f	85 07		sta $07				sta 	TOS+1
.1421	4c 00 00	jmp $0000			jmp 	NextCode
.1424					CheckZero:
.1424	a5 06		lda $06				lda 	TOS
.1426	05 07		ora $07				ora 	TOS+1
.1428	d0 ea		bne $1414			bne 	UnaryFalse
.142a	80 ef		bra $141b			bra 	UnaryTrue
.142c					SignTOS:
.142c	a5 07		lda $07				lda 	TOS+1
.142e	30 eb		bmi $141b			bmi		UnaryTrue
.1430	05 06		ora $06				ora 	TOS
.1432	f0 e0		beq $1414			beq 	UnaryFalse
.1434	a9 01		lda #$01			lda 	#1
.1436	85 06		sta $06				sta 	TOS
.1438	64 07		stz $07				stz		TOS+1
.143a	4c 00 00	jmp $0000			jmp 	NextCode
.143d					ByteSwap:
.143d	a5 06		lda $06				lda 	TOS
.143f	a4 07		ldy $07				ldy 	TOS+1
.1441	85 07		sta $07				sta 	TOS+1
.1443	84 06		sty $06				sty 	TOS
.1445	4c 00 00	jmp $0000			jmp 	NextCode
.1448					Times16:
.1448	06 06		asl $06				asl 	TOS
.144a	26 07		rol $07				rol 	TOS+1
.144c					Times8:
.144c	06 06		asl $06				asl 	TOS
.144e	26 07		rol $07				rol 	TOS+1
.1450					Times4:
.1450	06 06		asl $06				asl 	TOS
.1452	26 07		rol $07				rol 	TOS+1
.1454					Times2:
.1454	06 06		asl $06				asl 	TOS
.1456	26 07		rol $07				rol 	TOS+1
.1458	4c 00 00	jmp $0000			jmp 	NextCode
.145b					Divide16:
.145b	46 07		lsr $07				lsr 	TOS+1
.145d	66 06		ror $06				ror 	TOS
.145f					Divide8:
.145f	46 07		lsr $07				lsr 	TOS+1
.1461	66 06		ror $06				ror 	TOS
.1463					Divide4:
.1463	46 07		lsr $07				lsr 	TOS+1
.1465	66 06		ror $06				ror 	TOS
.1467					Divide2:
.1467	46 07		lsr $07				lsr 	TOS+1
.1469	66 06		ror $06				ror 	TOS
.146b	4c 00 00	jmp $0000			jmp 	NextCode
.146e					Times256:
.146e	a5 06		lda $06				lda 	TOS
.1470	85 07		sta $07				sta 	TOS+1
.1472	64 06		stz $06				stz 	TOS
.1474	4c 00 00	jmp $0000			jmp 	NextCode
.1477					Divide256:
.1477	a5 07		lda $07				lda 	TOS+1
.1479	85 06		sta $06				sta 	TOS
.147b	64 07		stz $07				stz 	TOS+1
.147d	4c 00 00	jmp $0000			jmp 	NextCode
.1480					RandomNumber:
.1480	a5 06		lda $06				lda 	TOS
.1482	48		pha				pha
.1483	a5 07		lda $07				lda 	TOS+1
.1485	48		pha				pha
.1486	a5 1b		lda $1b				lda 	randomSeed
.1488	05 1c		ora $1c				ora 	randomSeed+1
.148a	d0 08		bne $1494			bne 	_RH_NoInit
.148c	a9 7c		lda #$7c			lda 	#$7C
.148e	85 1b		sta $1b				sta 	randomSeed
.1490	a9 a1		lda #$a1			lda 	#$A1
.1492	85 1c		sta $1c				sta 	randomSeed+1
.1494					_RH_NoInit:
.1494	a5 1b		lda $1b				lda 	randomSeed
.1496	4a		lsr a		        lsr		a
.1497	26 1c		rol $1c		        rol 	randomSeed+1
.1499	90 02		bcc $149d	        bcc 	_RH_NoEor
.149b	49 b4		eor #$b4	        eor 	#$B4
.149d					_RH_NoEor:
.149d	85 1b		sta $1b		        sta 	randomSeed
.149f	45 1c		eor $1c		        eor 	randomSeed+1
.14a1	85 07		sta $07		        sta 	TOS+1
.14a3	a5 1b		lda $1b		        lda 	randomSeed
.14a5	85 06		sta $06		        sta 	TOS
.14a7	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/data/literals.src

.14aa					Constant0:
.14aa	a5 06		lda $06				lda 	TOS
.14ac	48		pha				pha
.14ad	a5 07		lda $07				lda 	TOS+1
.14af	48		pha				pha
.14b0	64 06		stz $06				stz 	TOS
.14b2	64 07		stz $07				stz 	TOS+1
.14b4	4c 00 00	jmp $0000			jmp 	NextCode
.14b7					ConstantMinus1:
.14b7	a5 06		lda $06				lda 	TOS
.14b9	48		pha				pha
.14ba	a5 07		lda $07				lda 	TOS+1
.14bc	48		pha				pha
.14bd	a9 ff		lda #$ff			lda 	#$FF
.14bf	85 06		sta $06				sta 	TOS
.14c1	85 07		sta $07				sta 	TOS+1
.14c3	4c 00 00	jmp $0000			jmp 	NextCode
.14c6					C1:
.14c6	a0 01		ldy #$01			ldy 	#1
.14c8	80 24		bra $14ee			bra 	Const1Byte
.14ca					C2:
.14ca	a0 02		ldy #$02			ldy 	#2
.14cc	80 20		bra $14ee			bra 	Const1Byte
.14ce					C3:
.14ce	a0 03		ldy #$03			ldy 	#3
.14d0	80 1c		bra $14ee			bra 	Const1Byte
.14d2					C4:
.14d2	a0 04		ldy #$04			ldy 	#4
.14d4	80 18		bra $14ee			bra 	Const1Byte
.14d6					C5:
.14d6	a0 05		ldy #$05			ldy 	#5
.14d8	80 14		bra $14ee			bra 	Const1Byte
.14da					C8:
.14da	a0 08		ldy #$08			ldy 	#8
.14dc	80 10		bra $14ee			bra 	Const1Byte
.14de					C10:
.14de	a0 0a		ldy #$0a			ldy 	#10
.14e0	80 0c		bra $14ee			bra 	Const1Byte
.14e2					C15:
.14e2	a0 0f		ldy #$0f			ldy 	#15
.14e4	80 08		bra $14ee			bra 	Const1Byte
.14e6					C16:
.14e6	a0 10		ldy #$10			ldy 	#16
.14e8	80 04		bra $14ee			bra 	Const1Byte
.14ea					C24:
.14ea	a0 18		ldy #$18			ldy 	#24
.14ec	80 00		bra $14ee			bra 	Const1Byte
.14ee					Const1Byte:
.14ee	a5 06		lda $06				lda 	TOS
.14f0	48		pha				pha
.14f1	a5 07		lda $07				lda 	TOS+1
.14f3	48		pha				pha
.14f4	84 06		sty $06				sty 	TOS
.14f6	64 07		stz $07				stz 	TOS+1
.14f8	4c 00 00	jmp $0000			jmp 	NextCode
.14fb					C32:
.14fb	a0 20		ldy #$20			ldy 	#32
.14fd	80 ef		bra $14ee			bra 	Const1Byte
.14ff					C63:
.14ff	a0 3f		ldy #$3f			ldy 	#63
.1501	80 eb		bra $14ee			bra 	Const1Byte
.1503					C64:
.1503	a0 40		ldy #$40			ldy 	#64
.1505	80 e7		bra $14ee			bra 	Const1Byte
.1507					C100:
.1507	a0 64		ldy #$64			ldy 	#100
.1509	80 e3		bra $14ee			bra 	Const1Byte
.150b					C127:
.150b	a0 7f		ldy #$7f			ldy 	#127
.150d	80 df		bra $14ee			bra 	Const1Byte
.150f					C128:
.150f	a0 80		ldy #$80			ldy 	#128
.1511	80 db		bra $14ee			bra 	Const1Byte
.1513					C255:
.1513	a0 ff		ldy #$ff			ldy 	#255
.1515	80 d7		bra $14ee			bra 	Const1Byte
.1517					Const2Byte:
.1517	85 06		sta $06				sta 	TOS
.1519	84 07		sty $07				sty 	TOS+1
.151b	4c 00 00	jmp $0000			jmp 	NextCode
.151e					C256:
.151e	a5 06		lda $06				lda 	TOS
.1520	48		pha				pha
.1521	a5 07		lda $07				lda 	TOS+1
.1523	48		pha				pha
.1524	a9 00		lda #$00			lda 	#(256) & $FF
.1526	a0 01		ldy #$01			ldy 	#(256) >> 8
.1528	80 ed		bra $1517			bra 	Const2Byte
.152a					C512:
.152a	a5 06		lda $06				lda 	TOS
.152c	48		pha				pha
.152d	a5 07		lda $07				lda 	TOS+1
.152f	48		pha				pha
.1530	a9 00		lda #$00			lda 	#(512) & $FF
.1532	a0 02		ldy #$02			ldy 	#(512) >> 8
.1534	80 e1		bra $1517			bra 	Const2Byte
.1536					C1024:
.1536	a5 06		lda $06				lda 	TOS
.1538	48		pha				pha
.1539	a5 07		lda $07				lda 	TOS+1
.153b	48		pha				pha
.153c	a9 00		lda #$00			lda 	#(1024) & $FF
.153e	a0 04		ldy #$04			ldy 	#(1024) >> 8
.1540	80 d5		bra $1517			bra 	Const2Byte
.1542					C4096:
.1542	a5 06		lda $06				lda 	TOS
.1544	48		pha				pha
.1545	a5 07		lda $07				lda 	TOS+1
.1547	48		pha				pha
.1548	a9 00		lda #$00			lda 	#(4096) & $FF
.154a	a0 10		ldy #$10			ldy 	#(4096) >> 8
.154c	80 c9		bra $1517			bra 	Const2Byte
.154e					C32767:
.154e	a5 06		lda $06				lda 	TOS
.1550	48		pha				pha
.1551	a5 07		lda $07				lda 	TOS+1
.1553	48		pha				pha
.1554	a9 ff		lda #$ff			lda 	#(32767) & $FF
.1556	a0 7f		ldy #$7f			ldy 	#(32767) >> 8
.1558	80 bd		bra $1517			bra 	Const2Byte
.155a					C32768:
.155a	a5 06		lda $06				lda 	TOS
.155c	48		pha				pha
.155d	a5 07		lda $07				lda 	TOS+1
.155f	48		pha				pha
.1560	a9 00		lda #$00			lda 	#(32768) & $FF
.1562	a0 80		ldy #$80			ldy 	#(32768) >> 8
.1564	80 b1		bra $1517			bra 	Const2Byte

;******  Return to file: kernel.asm


;******  Processing file: words/data/stack.src

.1566					Drop:
.1566	68		pla				pla
.1567	85 07		sta $07				sta 	TOS+1
.1569	68		pla				pla
.156a	85 06		sta $06				sta 	TOS
.156c	4c 00 00	jmp $0000			jmp 	NextCode
.156f					TestDup:
.156f	a5 06		lda $06				lda 	TOS
.1571	05 07		ora $07				ora 	TOS+1
.1573	d0 03		bne $1578			bne 	Dup
.1575	4c 00 00	jmp $0000			jmp 	NextCode
.1578					Dup:
.1578	a5 06		lda $06				lda 	TOS
.157a	48		pha				pha
.157b	a5 07		lda $07				lda 	TOS+1
.157d	48		pha				pha
.157e	4c 00 00	jmp $0000			jmp 	NextCode
.1581					Swap:
.1581	86 10		stx $10				stx 	temp1
.1583	7a		ply				ply
.1584	fa		plx				plx
.1585	a5 06		lda $06				lda 	TOS
.1587	48		pha				pha
.1588	a5 07		lda $07				lda 	TOS+1
.158a	48		pha				pha
.158b	86 06		stx $06				stx 	TOS
.158d	84 07		sty $07				sty 	TOS+1
.158f	a6 10		ldx $10				ldx 	temp1
.1591	4c 00 00	jmp $0000			jmp 	NextCode
.1594					Over:
.1594	a5 06		lda $06				lda 	TOS
.1596	48		pha				pha
.1597	a5 07		lda $07				lda 	TOS+1
.1599	48		pha				pha
.159a	86 10		stx $10				stx 	temp1
.159c	ba		tsx				tsx
.159d	bd 04 01	lda $0104,x			lda 	stack3low,x
.15a0	85 06		sta $06				sta 	TOS
.15a2	bd 03 01	lda $0103,x			lda 	stack3High,x
.15a5	85 07		sta $07				sta 	TOS+1
.15a7	a6 10		ldx $10				ldx 	temp1
.15a9	4c 00 00	jmp $0000			jmp 	NextCode
.15ac					Nip:
.15ac	68		pla				pla
.15ad	68		pla				pla
.15ae	4c 00 00	jmp $0000			jmp 	NextCode
.15b1					Rot:
.15b1	86 10		stx $10				stx 	temp1
.15b3	ba		tsx				tsx
.15b4	bd 04 01	lda $0104,x			lda 	Stack3Low,x
.15b7	a8		tay				tay
.15b8	bd 02 01	lda $0102,x			lda 	Stack2Low,x
.15bb	9d 04 01	sta $0104,x			sta 	Stack3Low,x
.15be	a5 06		lda $06				lda 	TOS
.15c0	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.15c3	84 06		sty $06				sty 	TOS
.15c5	bd 03 01	lda $0103,x			lda 	Stack3High,x
.15c8	a8		tay				tay
.15c9	bd 01 01	lda $0101,x			lda 	Stack2High,x
.15cc	9d 03 01	sta $0103,x			sta 	Stack3High,x
.15cf	a5 07		lda $07				lda 	TOS+1
.15d1	9d 01 01	sta $0101,x			sta 	Stack2High,x
.15d4	84 07		sty $07				sty 	TOS+1
.15d6	a6 10		ldx $10				ldx 	temp1
.15d8	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/data/memory.src

.15db					ByteRead:
.15db	b2 06		lda ($06)			lda 	(TOS)
.15dd	85 06		sta $06				sta 	TOS
.15df	64 07		stz $07				stz 	TOS+1
.15e1	4c 00 00	jmp $0000			jmp 	NextCode
.15e4					WordRead:
.15e4	a0 01		ldy #$01			ldy 	#1
.15e6	b1 06		lda ($06),y			lda 	(TOS),y
.15e8	a8		tay				tay
.15e9	b2 06		lda ($06)			lda 	(TOS)
.15eb	85 06		sta $06				sta 	TOS
.15ed	84 07		sty $07				sty 	TOS+1
.15ef	4c 00 00	jmp $0000			jmp 	NextCode
.15f2					ByteWrite:
.15f2	68		pla				pla
.15f3	68		pla				pla
.15f4	92 06		sta ($06)			sta 	(TOS)
.15f6	68		pla				pla
.15f7	85 07		sta $07				sta 	TOS+1
.15f9	68		pla				pla
.15fa	85 06		sta $06				sta 	TOS
.15fc	4c 00 00	jmp $0000			jmp 	NextCode
.15ff					WordWrite:
.15ff	68		pla				pla
.1600	a0 01		ldy #$01			ldy 	#1
.1602	91 06		sta ($06),y			sta 	(TOS),y
.1604	68		pla				pla
.1605	92 06		sta ($06)			sta 	(TOS)
.1607	68		pla				pla
.1608	85 07		sta $07				sta 	TOS+1
.160a	68		pla				pla
.160b	85 06		sta $06				sta 	TOS
.160d	4c 00 00	jmp $0000			jmp 	NextCode
.1610					WordAdd:
.1610	7a		ply				ply
.1611	68		pla				pla
.1612	18		clc				clc
.1613	72 06		adc ($06)			adc 	(TOS)
.1615	92 06		sta ($06)			sta 	(TOS)
.1617	98		tya				tya
.1618	a0 01		ldy #$01			ldy 	#1
.161a	71 06		adc ($06),y			adc 	(TOS),y
.161c	91 06		sta ($06),y			sta 	(TOS),y
.161e	68		pla				pla
.161f	85 07		sta $07				sta 	TOS+1
.1621	68		pla				pla
.1622	85 06		sta $06				sta 	TOS
.1624	4c 00 00	jmp $0000			jmp 	NextCode
.1627					AllocateMemory:
.1627	a5 06		lda $06				lda 	TOS 						; save memory required on stack.
.1629	48		pha				pha
.162a	a5 07		lda $07				lda 	TOS+1
.162c	48		pha				pha
.162d	a5 0e		lda $0e				lda 	nextFreeMem 				; copy free mem address to TOS
.162f	85 06		sta $06				sta 	TOS
.1631	a5 0f		lda $0f				lda 	nextFreeMem+1
.1633	85 07		sta $07				sta 	TOS+1
.1635	7a		ply				ply 								; advance the free ram pointer
.1636	68		pla				pla
.1637	20 c0 1a	jsr $1ac0			jsr 	AdvanceFreeMem
.163a	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/encode/encode.src

.163d					EncodeProgram:
.163d	48		pha				pha 								; save registers.
.163e	da		phx				phx
.163f	5a		phy				phy
.1640	84 09		sty $09				sty 	srcPtr+1					; save source pointer.
.1642	85 08		sta $08				sta		srcPtr
.1644	20 24 18	jsr $1824			jsr 	EncodeTrimTrailingSpaces 	; remove trailing spaces.
.1647	a9 03		lda #$03			lda 	#3 							; reset the encode Buffer
.1649	8d 10 09	sta $0910			sta 	encodeBuffer 				; this is also the write ptr/offset
.164c	9c 11 09	stz $0911			stz 	encodeBuffer+1 				; the line number
.164f	9c 12 09	stz $0912			stz 	encodeBuffer+2 				; which is initially zero.
.1652	b2 08		lda ($08)			lda 	(srcPtr) 					; check if first character is digit
.1654	20 cf 17	jsr $17cf			jsr 	CheckIsDigit
.1657	90 09		bcc $1662			bcc 	_EPNoLineNumber 			; if so there is a line number
.1659	20 f1 17	jsr $17f1			jsr 	EncodeGetConstant 			; extract that constant from the source
.165c	8d 11 09	sta $0911			sta 	encodeBuffer+1 				; that is the line number
.165f	8c 12 09	sty $0912			sty 	encodeBuffer+2
.1662					_EPNoLineNumber:
.1662					EncodeLoop:
.1662	20 16 18	jsr $1816			jsr 	EncSkipSpaces 				; skip over spaces
.1665	b2 08		lda ($08)			lda 	(srcPtr) 					; reached end ?
.1667	d0 0b		bne $1674			bne 	_EPNotEnd
.1669					_EPEndEncode:
.1669	a9 a9		lda #$a9			lda 	#NextLine & $FF 			; compile $$nextline to mark eol
.166b	a0 1d		ldy #$1d			ldy 	#NextLine >> 8
.166d	20 b6 17	jsr $17b6			jsr 	EncodeWriteWord
.1670	7a		ply				ply									; restore and exit.
.1671	fa		plx				plx
.1672	68		pla				pla
.1673	60		rts				rts
.1674					_EPNotEnd:
.1674	b2 08		lda ($08)			lda 	(srcPtr)
.1676	c9 22		cmp #$22			cmp 	#'"'						; is it a quoted string or comment ?
.1678	f0 04		beq $167e			beq 	_EPIsComStr
.167a	c9 27		cmp #$27			cmp 	#"'"
.167c	d0 05		bne $1683			bne 	_EPNotComStr
.167e					_EPIsComStr:
.167e	20 0d 17	jsr $170d			jsr 	EncodeCommentString
.1681	80 df		bra $1662			bra 	EncodeLoop
.1683					_EPNotComStr:
.1683	38		sec				sec
.1684	20 03 18	jsr $1803			jsr 	EncSetBit7Word
.1687	20 3d 18	jsr $183d			jsr 	EncodeSearchDictionary		; look it up
.168a	90 44		bcc $16d0			bcc 	_EPNotInDictionary
.168c	85 10		sta $10				sta 	temp1 						; save dictionary record address
.168e	84 11		sty $11				sty 	temp1+1
.1690	a0 01		ldy #$01			ldy 	#1
.1692	b1 10		lda ($10),y			lda 	(temp1),y 					; check if has an encode bit
.1694	29 20		and #$20			and 	#$20
.1696	d0 12		bne $16aa			bne 	_EPEncodeRoutine 			; if so, do special routine.
.1698	a0 02		ldy #$02			ldy 	#2 							; write out the routine address
.169a	b1 10		lda ($10),y			lda 	(temp1),y
.169c	20 c0 17	jsr $17c0			jsr 	EncodeWriteByte
.169f	c8		iny				iny
.16a0	b1 10		lda ($10),y			lda 	(temp1),y
.16a2	20 c0 17	jsr $17c0			jsr 	EncodeWriteByte
.16a5	20 db 17	jsr $17db			jsr 	EncodeMoveNextWord 			; advance to the next and loop
.16a8	80 b8		bra $1662			bra 	EncodeLoop
.16aa					_EPEncodeRoutine:
.16aa	a0 01		ldy #$01			ldy 	#1							; get type bit
.16ac	b1 10		lda ($10),y			lda 	(temp1),y
.16ae	a0 04		ldy #$04			ldy 	#4							; encoder here if no decoder
.16b0	29 10		and #$10			and 	#$10 						; but decoder comes first
.16b2	f0 02		beq $16b6			beq 	_EPENoDecoder
.16b4	c8		iny				iny 								; so if it exists, adjust for it.
.16b5	c8		iny				iny
.16b6					_EPENoDecoder:
.16b6	b1 10		lda ($10),y			lda 	(temp1),y 					; copy exec addr to temp2
.16b8	85 12		sta $12				sta 	temp2
.16ba	c8		iny				iny
.16bb	b1 10		lda ($10),y			lda 	(temp1),y
.16bd	85 13		sta $13				sta 	temp2+1
.16bf	48		pha				pha 								; call routine preserving state
.16c0	da		phx				phx
.16c1	5a		phy				phy
.16c2	20 cd 16	jsr $16cd			jsr 	_EPECallTemp2
.16c5	7a		ply				ply
.16c6	fa		plx				plx
.16c7	68		pla				pla
.16c8	20 db 17	jsr $17db			jsr 	EncodeMoveNextWord 			; advance to the next and loop
.16cb	80 95		bra $1662			bra 	EncodeLoop
.16cd					_EPECallTemp2:
.16cd	6c 12 00	jmp ($0012)			jmp 	(temp2)
.16d0					_EPNotInDictionary:
.16d0	20 68 17	jsr $1768			jsr 	EncodeSearchUserDefined 	; are there any user defined routines
.16d3	90 19		bcc $16ee			bcc 	_EPNotDefined
.16d5	48		pha				pha
.16d6	a9 47		lda #$47			lda	 	#CallHandler & $FF 			; write code call handler
.16d8	20 c0 17	jsr $17c0			jsr 	EncodeWriteByte
.16db	a9 19		lda #$19			lda	 	#CallHandler >> 8
.16dd	20 c0 17	jsr $17c0			jsr 	EncodeWriteByte 			; write line number
.16e0	68		pla				pla
.16e1	20 c0 17	jsr $17c0			jsr 	EncodeWriteByte
.16e4	98		tya				tya
.16e5	20 c0 17	jsr $17c0			jsr 	EncodeWriteByte
.16e8	20 db 17	jsr $17db			jsr 	EncodeMoveNextWord 			; advance to the next and loop
.16eb	4c 62 16	jmp $1662			jmp 	EncodeLoop
.16ee					_EPNotDefined:
.16ee	b2 08		lda ($08)			lda 	(srcPtr) 					; first character
.16f0	a9 89		lda #$89			lda 	#Literal2Byte & $FF 		; write out 2 byte literal
.16f2	a0 10		ldy #$10			ldy 	#Literal2Byte >> 8
.16f4	20 b6 17	jsr $17b6			jsr 	EncodeWriteWord
.16f7	20 f1 17	jsr $17f1			jsr 	EncodeGetConstant 			; extract that constant from the source
.16fa	90 06		bcc $1702			bcc 	_EPFail 					; if can't find one, that's us done.
.16fc	20 b6 17	jsr $17b6			jsr 	EncodeWriteWord 			; write out the encoded value.
.16ff	4c 62 16	jmp $1662			jmp 	EncodeLoop 					; and go round again.
.1702					_EPFail:
.1702	20 23 10	jsr $1023			jsr 	ErrorHandler
>1705	53 59 4e 54 41 58 3f 00				.text 	"SYNTAX?",0

;******  Return to file: kernel.asm


;******  Processing file: words/encode/comstr.src

.170d					EncodeCommentString:
.170d	b2 08		lda ($08)			lda 	(srcPtr) 					; get first character
.170f	64 10		stz $10				stz 	temp1 						; other terminator = EOL
.1711	aa		tax				tax 								; save in X
.1712	a9 c0		lda #$c0			lda 	#(SkipComment & $FF)		; get the routine to use
.1714	a0 1d		ldy #$1d			ldy 	#(SkipComment >> 8)
.1716	e0 27		cpx #$27			cpx 	#"'"
.1718	f0 06		beq $1720			beq 	_ECSGotCmd
.171a	86 10		stx $10				stx		temp1 						; other terminator = "
.171c	a9 b1		lda #$b1			lda 	#(LiteralString & $FF)
.171e	a0 10		ldy #$10			ldy 	#(LiteralString >> 8)
.1720					_ECSGotCmd:
.1720	20 b6 17	jsr $17b6			jsr 	EncodeWriteWord 			; write word out.
.1723	a9 01		lda #$01			lda 	#1 							; skip over ' or "
.1725	20 e7 17	jsr $17e7			jsr 	EncodeAddSrcPtr
.1728	e0 27		cpx #$27			cpx 	#"'"						; if ' then skip spaces
.172a	d0 03		bne $172f			bne 	_ECNoSkipSpaces
.172c	20 16 18	jsr $1816			jsr 	EncSkipSpaces
.172f					_ECNoSkipSpaces:
.172f	ae 10 09	ldx $0910			ldx 	encodeBuffer 				; keep offset to buffer in X.
.1732	a9 01		lda #$01			lda 	#1
.1734	20 c0 17	jsr $17c0			jsr 	EncodeWriteByte 			; write total length, so far 1.
.1737	a0 00		ldy #$00			ldy 	#0 							; for reading the actual text
.1739					_ECSCopyText:
.1739	b1 08		lda ($08),y			lda 	(srcPtr),y 					; get next
.173b	f0 18		beq $1755			beq 	_ECSEndOfLine 				; end of line ?
.173d	c5 10		cmp $10				cmp 	temp1						; is it the other terminator
.173f	f0 09		beq $174a			beq 	_ECSEndOfString 			; if so must be closing quote.
.1741	20 c0 17	jsr $17c0			jsr 	EncodeWriteByte 			; write the byte out
.1744	fe 10 09	inc $0910,x			inc 	encodeBuffer,x				; increase length
.1747	c8		iny				iny 								; next character
.1748	80 ef		bra $1739			bra 	_ECSCopyText
.174a					_ECSEndOfString:
.174a	c8		iny				iny 								; skip closing quote.
.174b	a9 00		lda #$00			lda 	#0 							; write out ASCIIZ
.174d	20 c0 17	jsr $17c0			jsr 	EncodeWriteByte
.1750	fe 10 09	inc $0910,x			inc 	encodeBuffer,x 				; fix the length up.
.1753	80 0e		bra $1763			bra 	_ECSComplete 				; and just patching up srcPtr to do.
.1755					_ECSEndOfLine:
.1755	a5 10		lda $10				lda 	temp1 						; missing closing quote
.1757	f0 0a		beq $1763			beq 	_ECSComplete 				; if we were doing a string.
.1759	20 23 10	jsr $1023			jsr 	ErrorHandler
>175c	51 55 4f 54 45 3f 00				.text 	"QUOTE?",0
.1763					_ECSComplete:
.1763	98		tya				tya									; skip over.
.1764	20 e7 17	jsr $17e7			jsr 	EncodeAddSrcPtr
.1767	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/encode/encdef.src

.1768					EncodeSearchUserDefined:
.1768	38		sec				sec 								; temp1 = srcPtr-6 because the
.1769	a5 08		lda $08				lda 	srcPtr				 		; name is 6 in (offset line# $$call len)
.176b	e9 06		sbc #$06			sbc		#6
.176d	85 10		sta $10				sta 	temp1
.176f	a5 09		lda $09				lda 	srcPtr+1
.1771	e9 00		sbc #$00			sbc 	#0
.1773	85 11		sta $11				sta 	temp1+1
.1775	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.1777	85 12		sta $12				sta 	0+(temp2)
.1779	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.177b	85 13		sta $13				sta 	1+(temp2)
.177d					_ESULoop:
.177d	b2 12		lda ($12)			lda 	(temp2) 					; reached the end (offset 0)
.177f	f0 33		beq $17b4			beq 	_ESUFail
.1781	a0 03		ldy #$03			ldy 	#3 							; check it is $$define
.1783	b1 12		lda ($12),y			lda 	(temp2),y
.1785	c9 e5		cmp #$e5			cmp 	#DefineCode & $FF
.1787	d0 1e		bne $17a7			bne 	_ESUNext
.1789	c8		iny				iny
.178a	b1 12		lda ($12),y			lda 	(temp2),y
.178c	c9 1d		cmp #$1d			cmp 	#DefineCode >> 8
.178e	d0 17		bne $17a7			bne 	_ESUNext
.1790	c8		iny				iny 								; skip length byte.
.1791					_ESUCompare:
.1791	c8		iny				iny
.1792	b1 12		lda ($12),y			lda 	(temp2),y
.1794	d1 10		cmp ($10),y			cmp 	(temp1),y
.1796	d0 0f		bne $17a7			bne 	_ESUNext
.1798	0a		asl a				asl 	a 							; bit 7 set => found it.
.1799	90 f6		bcc $1791			bcc 	_ESUCompare
.179b	a0 01		ldy #$01			ldy 	#1
.179d	b1 12		lda ($12),y			lda 	(temp2),y 					; read in the line number to YA
.179f	aa		tax				tax
.17a0	c8		iny				iny
.17a1	b1 12		lda ($12),y			lda 	(temp2),y
.17a3	a8		tay				tay
.17a4	8a		txa				txa
.17a5	38		sec				sec 								; return with carry set as found
.17a6	60		rts				rts
.17a7					_ESUNext:
.17a7	18		clc				clc
.17a8	a5 12		lda $12				lda 	temp2
.17aa	72 12		adc ($12)			adc 	(temp2)
.17ac	85 12		sta $12				sta 	temp2
.17ae	90 02		bcc $17b2			bcc 	_NoCarryAdv
.17b0	e6 13		inc $13				inc 	temp2+1
.17b2					_NoCarryAdv:
.17b2	80 c9		bra $177d			bra 	_ESULoop 					; and loop round
.17b4					_ESUFail:
.17b4	18		clc				clc
.17b5	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/encode/encutils.src

.17b6					EncodeWriteWord:
.17b6	48		pha				pha
.17b7	20 c0 17	jsr $17c0			jsr 	EncodeWriteByte
.17ba	98		tya				tya
.17bb	20 c0 17	jsr $17c0			jsr 	EncodeWriteByte
.17be	68		pla				pla
.17bf	60		rts				rts
.17c0					EncodeWriteByte:
.17c0	da		phx				phx
.17c1	ae 10 09	ldx $0910			ldx 	encodeBuffer
.17c4	9d 10 09	sta $0910,x			sta 	encodeBuffer,x
.17c7	9e 11 09	stz $0911,x			stz 	encodeBuffer+1,x
.17ca	ee 10 09	inc $0910			inc 	encodeBuffer
.17cd	fa		plx				plx
.17ce	60		rts				rts
.17cf					CheckIsDigit:
.17cf	c9 30		cmp #$30			cmp 	#"0"						; return CC if 0..9
.17d1	90 06		bcc $17d9			bcc 	_CIDFail
.17d3	c9 3a		cmp #$3a			cmp 	#"9"+1
.17d5	b0 02		bcs $17d9			bcs 	_CIDFail
.17d7	38		sec				sec
.17d8	60		rts				rts
.17d9					_CIDFail:
.17d9	18		clc				clc
.17da	60		rts				rts
.17db					EncodeMoveNextWord:
.17db	a0 ff		ldy #$ff			ldy 	#255 						; search forward
.17dd					_EPNWLoop:
.17dd	c8		iny				iny
.17de	b1 08		lda ($08),y			lda 	(srcPtr),y
.17e0	c9 21		cmp #$21			cmp 	#" "+1						; looking for <= space
.17e2	b0 f9		bcs $17dd			bcs 	_EPNWLoop
.17e4	98		tya				tya
.17e5	80 00		bra $17e7			bra 	EncodeAddSrcPtr
.17e7					EncodeAddSrcPtr:
.17e7	18		clc				clc 								; add offset
.17e8	65 08		adc $08				adc 	srcPtr
.17ea	85 08		sta $08				sta 	srcPtr
.17ec	90 02		bcc $17f0			bcc 	_EASPNoCarry
.17ee	e6 09		inc $09				inc 	srcPtr+1					; carry through
.17f0					_EASPNoCarry:
.17f0	60		rts				rts
.17f1					EncodeGetConstant:
.17f1	a5 08		lda $08				lda 	srcPtr 						; get source
.17f3	a4 09		ldy $09				ldy 	srcPtr+1
.17f5	20 1b 1d	jsr $1d1b			jsr 	ConvertToInteger 			; call converter
.17f8	90 08		bcc $1802			bcc 	_EGCExit
.17fa	20 e7 17	jsr $17e7			jsr 	EncodeAddSrcPtr 			; if passed add chars to src ptr
.17fd	a5 14		lda $14				lda 	temp3 						; get result into YA
.17ff	a4 15		ldy $15				ldy 	temp3+1
.1801	38		sec				sec 								; return CS
.1802					_EGCExit:
.1802	60		rts				rts
.1803					EncSetBit7Word:
.1803	08		php				php 								; save carry
.1804	a0 ff		ldy #$ff			ldy 	#255 						; scan forward for space/NULL
.1806					_ESB7Loop:
.1806	c8		iny				iny
.1807	b1 08		lda ($08),y			lda 	(srcPtr),y
.1809	c9 21		cmp #$21			cmp 	#" "+1 						; while > ' '
.180b	b0 f9		bcs $1806			bcs 	_ESB7Loop
.180d	88		dey				dey									; previous character
.180e	b1 08		lda ($08),y			lda 	(srcPtr),y 					; read it
.1810	0a		asl a				asl 	a 							; shift bit 7 out
.1811	28		plp				plp 								; restore carry
.1812	6a		ror a				ror 	a 							; shift it in
.1813	91 08		sta ($08),y			sta 	(srcPtr),y 					; write back and exit
.1815	60		rts				rts
.1816					EncSkipSpaces:
.1816	b2 08		lda ($08)			lda 	(srcPtr) 					; skip over spaces/ reached end
.1818	c9 20		cmp #$20			cmp 	#32
.181a	d0 07		bne $1823			bne 	_ESNotSpace
.181c	a9 01		lda #$01			lda 	#1
.181e	20 e7 17	jsr $17e7			jsr 	EncodeAddSrcPtr
.1821	80 f3		bra $1816			bra	 	EncSkipSpaces
.1823					_ESNotSpace:
.1823	60		rts				rts
.1824					EncodeTrimTrailingSpaces:
.1824	a0 ff		ldy #$ff			ldy 	#255 						; find EOS
.1826					_ETTFindEnd:
.1826	c8		iny				iny
.1827	b1 08		lda ($08),y			lda 	(srcPtr),y
.1829	d0 fb		bne $1826			bne 	_ETTFindEnd
.182b					_ETTRemoveSpace:
.182b	c0 00		cpy #$00			cpy 	#0 							; start of string
.182d	f0 0d		beq $183c			beq 	_ETTExit
.182f	88		dey				dey 								; previous character 1..32
.1830	b1 08		lda ($08),y			lda 	(srcPtr),y
.1832	c9 21		cmp #$21			cmp 	#32+1
.1834	b0 06		bcs $183c			bcs 	_ETTExit
.1836	a9 00		lda #$00			lda 	#0 							; erase it and go round again
.1838	91 08		sta ($08),y			sta 	(srcPtr),y
.183a	80 ef		bra $182b			bra 	_ETTRemoveSpace
.183c					_ETTExit:
.183c	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/encode/encsearch.src

.183d					EncodeSearchDictionary:
.183d	a9 e3		lda #$e3			lda 	#(Dictionary) & $FF
.183f	85 10		sta $10				sta 	0+(temp1)
.1841	a9 1f		lda #$1f			lda 	#(Dictionary) >> 8
.1843	85 11		sta $11				sta 	1+(temp1)
.1845					_ESDLoop:
.1845	b2 10		lda ($10)			lda 	(temp1) 					; end of dictionary return with CC.
.1847	18		clc				clc
.1848	f0 46		beq $1890			beq 	_ESDExit
.184a	a0 01		ldy #$01			ldy 	#1 							; get control bits, get offset to name.
.184c	b1 10		lda ($10),y			lda 	(temp1),y
.184e	4a		lsr a				lsr 	a 							; encode/decode bits move to 0,1
.184f	4a		lsr a				lsr 	a
.1850	4a		lsr a				lsr 	a
.1851	4a		lsr a				lsr 	a
.1852	c8		iny				iny 								; Y = 2
.1853	4a		lsr a				lsr 	a
.1854	90 01		bcc $1857			bcc 	_ESDNotDec
.1856	c8		iny				iny
.1857					_ESDNotDec:
.1857	4a		lsr a				lsr 	a
.1858	90 01		bcc $185b			bcc 	_ESDNotInc
.185a	c8		iny				iny
.185b					_ESDNotInc:
.185b	98		tya				tya
.185c	0a		asl a				asl 	a 							; A is now 4,6,8 offset to name.
.185d	a8		tay				tay
.185e	b1 10		lda ($10),y			lda 	(temp1),y 					; quick check of first character
.1860	d2 08		cmp ($08)			cmp 	(srcPtr)
.1862	d0 1f		bne $1883			bne 	_ESDNext 					; do not match, go to next
.1864	98		tya				tya 								; make temp2 point to the name in
.1865	18		clc				clc 								; the dictionary.
.1866	65 10		adc $10				adc 	temp1
.1868	85 12		sta $12				sta 	temp2
.186a	a5 11		lda $11				lda 	temp1+1
.186c	69 00		adc #$00			adc 	#0
.186e	85 13		sta $13				sta 	temp2+1
.1870	a0 ff		ldy #$ff			ldy 	#255 						; now start matching up.
.1872					_ESDCompare:
.1872	c8		iny				iny
.1873	b1 08		lda ($08),y			lda 	(srcPtr),y
.1875	d1 12		cmp ($12),y			cmp 	(temp2),y
.1877	d0 0a		bne $1883			bne 	_ESDNext
.1879	0a		asl a				asl 	a
.187a	90 f6		bcc $1872			bcc 	_ESDCompare
.187c	a5 10		lda $10				lda 	temp1 						; return address in YA and carry set.
.187e	a4 11		ldy $11				ldy 	temp1+1
.1880	38		sec				sec
.1881	80 0d		bra $1890			bra 	_ESDExit
.1883					_ESDNext:
.1883	18		clc				clc
.1884	a5 10		lda $10				lda 	temp1
.1886	72 10		adc ($10)			adc 	(temp1)
.1888	85 10		sta $10				sta 	temp1
.188a	90 b9		bcc $1845			bcc 	_ESDLoop
.188c	e6 11		inc $11				inc 	temp1+1
.188e	80 b5		bra $1845			bra 	_ESDLoop
.1890					_ESDExit:
.1890	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/structures/fornext.src

.1891					ForHandler:
.1891	e6 05		inc $05				inc 	rsp 						; bump the RSP
.1893	a4 05		ldy $05				ldy 	rsp 						; get return stack and push TOS/$FF on it.
.1895	c0 40		cpy #$40			cpy 	#$40 						; overflow
.1897	f0 18		beq $18b1			beq 	_FHOverflow
.1899	a5 07		lda $07				lda 	TOS+1
.189b	99 40 07	sta $0740,y			sta 	returnStackHigh,y
.189e	a5 06		lda $06				lda 	TOS
.18a0	99 00 07	sta $0700,y			sta 	returnStackLow,y
.18a3	a9 ff		lda #$ff			lda 	#$FF
.18a5	99 80 07	sta $0780,y			sta 	returnStackX,y
.18a8	68		pla				pla
.18a9	85 07		sta $07				sta 	TOS+1
.18ab	68		pla				pla
.18ac	85 06		sta $06				sta 	TOS
.18ae	4c 00 00	jmp $0000			jmp 	NextCode
.18b1					_FHOverflow:
.18b1	20 23 10	jsr $1023			jsr 	ErrorHandler
>18b4	46 4f 52 20 53 54 41 43				.text 	"FOR STACK?",0
>18bc	4b 3f 00
.18bf					NextHandler:
.18bf	da		phx				phx
.18c0	a6 05		ldx $05				ldx 	rsp 						; get current stack ptr
.18c2	bd 80 07	lda $0780,x			lda 	returnStackX,x 				; check it's a FOR Loop
.18c5	c9 ff		cmp #$ff			cmp 	#$FF
.18c7	d0 21		bne $18ea			bne 	NHNoFor
.18c9	bd 00 07	lda $0700,x			lda 	returnStackLow,x 			; decrement the count
.18cc	d0 03		bne $18d1			bne 	_NHNoBorrow
.18ce	de 40 07	dec $0740,x			dec 	returnStackHigh,x
.18d1					_NHNoBorrow:
.18d1	de 00 07	dec $0700,x			dec 	returnStackLow,x
.18d4	bd 00 07	lda $0700,x			lda 	returnStackLow,x 			; have we reached the end ?
.18d7	1d 40 07	ora $0740,x			ora 	returnStackHigh,x
.18da	fa		plx				plx 								; restore X and re-test
.18db	09 00		ora #$00			ora 	#0
.18dd	f0 05		beq $18e4			beq 	_NHComplete 				; if so then complete, else loop.
.18df	e8		inx				inx 								; advance to branch
.18e0	e8		inx				inx
.18e1	4c 3d 19	jmp $193d			jmp 	BranchAlways
.18e4					_NHComplete:
.18e4	e8		inx				inx 								; skip over the branch quantity
.18e5	c6 05		dec $05				dec 	rsp 						; drop the indx
.18e7	4c 00 00	jmp $0000			jmp 	NextCode
.18ea					NHNoFor:
.18ea	20 23 10	jsr $1023			jsr 	ErrorHandler
>18ed	4e 4f 20 46 4f 52 3f 00				.text 	"NO FOR?",0
.18f5					GetIndex:
.18f5	a4 05		ldy $05				ldy 	rsp 						; get current stack ptr
.18f7	b9 80 07	lda $0780,y			lda 	returnStackX,y 				; check it's a FOR Loop
.18fa	c9 ff		cmp #$ff			cmp 	#$FF
.18fc	d0 ec		bne $18ea			bne 	NHNoFor
.18fe	a5 06		lda $06				lda 	TOS
.1900	48		pha				pha
.1901	a5 07		lda $07				lda 	TOS+1
.1903	48		pha				pha
.1904	b9 00 07	lda $0700,y			lda 	returnStackLow,y 			; put counter-1 out
.1907	38		sec				sec
.1908	e9 01		sbc #$01			sbc 	#1
.190a	85 06		sta $06				sta 	TOS
.190c	b9 40 07	lda $0740,y			lda 	returnStackHigh,y
.190f	e9 00		sbc #$00			sbc 	#0
.1911	85 07		sta $07				sta 	TOS+1
.1913	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/structures/ifelseendif.src

.1916					IfHandler:
.1916	4c 25 19	jmp $1925			jmp 	BranchIfZero
.1919					ElseHandler:
.1919	4c 3b 19	jmp $193b			jmp 	BranchTestSucceedsNoPop
.191c					EndIfHandler:
.191c	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/structures/repeatuntil.src

.191f					RepeatHandler:
.191f	4c 00 00	jmp $0000			jmp 	NextCode
.1922					UntilHandler:
.1922	4c 25 19	jmp $1925			jmp 	BranchIfZero

;******  Return to file: kernel.asm


;******  Processing file: words/system/branch.src

.1925					BranchIfZero:
.1925	a5 06		lda $06				lda 	TOS 						; check TOS = 0
.1927	05 07		ora $07				ora 	TOS+1
.1929	f0 0a		beq $1935			beq 	BranchTestSucceeds
.192b					BranchTestFails:
.192b	68		pla				pla
.192c	85 07		sta $07				sta 	TOS+1
.192e	68		pla				pla
.192f	85 06		sta $06				sta 	TOS
.1931	e8		inx				inx 								; skip over the relative branch.
.1932	4c 00 00	jmp $0000			jmp 	NextCode
.1935					BranchTestSucceeds:
.1935	68		pla				pla
.1936	85 07		sta $07				sta 	TOS+1
.1938	68		pla				pla
.1939	85 06		sta $06				sta 	TOS
.193b					BranchTestSucceedsNoPop:
.193b	e8		inx				inx 								; advance by two, to the offset
.193c	e8		inx				inx
.193d					BranchAlways:
.193d	8a		txa				txa 								; A = Y = position
.193e	a8		tay				tay 								; (IP),Y now points to the branch target
.193f	b1 03		lda ($03),y			lda 	(IP),y 						; adjust the position
.1941	aa		tax				tax 								; position back in this line.
.1942	ca		dex				dex
.1943	ca		dex				dex
.1944	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/system/callhandler.src

.1947					CallHandler:
.1947	e8		inx				inx									; bump X to the call address.
.1948	e8		inx				inx
.1949	e6 05		inc $05				inc 	rsp 						; bump the RSP (first time to zero)
.194b	a4 05		ldy $05				ldy 	rsp 						; get return stack and push IP/X on it.
.194d	c0 40		cpy #$40			cpy 	#$40 						; overflow
.194f	f0 4b		beq $199c			beq 	_CHOverflow
.1951	a5 04		lda $04				lda 	IP+1
.1953	99 40 07	sta $0740,y			sta 	returnStackHigh,y
.1956	a5 03		lda $03				lda 	IP
.1958	99 00 07	sta $0700,y			sta 	returnStackLow,y
.195b	8a		txa				txa
.195c	99 80 07	sta $0780,y			sta 	returnStackX,y
.195f	8a		txa				txa 								; get the line number into temp1.
.1960	a8		tay				tay
.1961	b1 03		lda ($03),y			lda 	(IP),y
.1963	85 10		sta $10				sta 	temp1
.1965	c8		iny				iny
.1966	b1 03		lda ($03),y			lda 	(IP),y
.1968	85 11		sta $11				sta 	temp1+1
.196a	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.196c	85 03		sta $03				sta 	0+(IP)
.196e	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.1970	85 04		sta $04				sta 	1+(IP)
.1972	b2 03		lda ($03)			lda 	(IP)						; no program code ?
.1974	f0 17		beq $198d			beq 	_CHFail
.1976	a0 01		ldy #$01			ldy 	#1 							; Y = 1 throughout.
.1978					_CHSearch:
.1978	b1 03		lda ($03),y			lda 	(IP),y 						; check LSB of line number
.197a	c5 10		cmp $10				cmp 	temp1
.197c	f0 2d		beq $19ab			beq 	_CHFoundLSB
.197e					_CHSearchNext:
.197e	18		clc				clc
.197f	a5 03		lda $03				lda 	IP
.1981	72 03		adc ($03)			adc 	(IP)
.1983	85 03		sta $03				sta 	IP
.1985	90 02		bcc $1989			bcc 	_NoCarryAdv
.1987	e6 04		inc $04				inc 	IP+1
.1989					_NoCarryAdv:
.1989	b2 03		lda ($03)			lda 	(IP)						; check reached the end.
.198b	d0 eb		bne $1978			bne 	_CHSearch
.198d					_CHFail:
.198d	20 23 10	jsr $1023			jsr 	ErrorHandler
>1990	44 45 46 49 4e 49 54 49				.text 	"DEFINITION?",0
>1998	4f 4e 3f 00
.199c					_CHOverflow:
.199c	20 23 10	jsr $1023			jsr 	ErrorHandler
>199f	53 54 41 43 4b 44 45 50				.text 	"STACKDEPTH?",0
>19a7	54 48 3f 00
.19ab					_CHFoundLSB:
.19ab	c8		iny				iny 								; get MSB
.19ac	b1 03		lda ($03),y			lda 	(IP),y
.19ae	88		dey				dey
.19af	c5 11		cmp $11				cmp 	temp1+1 					; matches, if not contineu
.19b1	d0 cb		bne $197e			bne 	_CHSearchNext
.19b3	a0 03		ldy #$03			ldy 	#3	 						; check it begins with $$define
.19b5	b1 03		lda ($03),y			lda 	(IP),y
.19b7	c9 e5		cmp #$e5			cmp 	#DefineCode & $FF
.19b9	d0 d2		bne $198d			bne 	_CHFail
.19bb	c8		iny				iny
.19bc	b1 03		lda ($03),y			lda 	(IP),y
.19be	c9 1d		cmp #$1d			cmp 	#DefineCode >> 8
.19c0	d0 cb		bne $198d			bne 	_CHFail
.19c2	c8		iny				iny
.19c3	b1 03		lda ($03),y			lda 	(IP),y 						; this is the length of the define name
.19c5	18		clc				clc
.19c6	69 03		adc #$03			adc 	#5-2 						; $$define token, line number, offset - 2 for Next
.19c8	aa		tax				tax
.19c9	4c 00 00	jmp $0000			jmp 	NextCode
.19cc					ReturnHandler:
.19cc	a4 05		ldy $05				ldy 	rsp 						; get rsp
.19ce	30 15		bmi $19e5			bmi 	_RHUnderflow 				; if -ve underflowed
.19d0	c6 05		dec $05				dec 	rsp 						; decrement rsp
.19d2	b9 40 07	lda $0740,y			lda 	returnStackHigh,y 			; restore IP/X
.19d5	85 04		sta $04				sta 	IP+1
.19d7	b9 00 07	lda $0700,y			lda 	returnStackLow,y
.19da	85 03		sta $03				sta 	IP
.19dc	b9 80 07	lda $0780,y			lda 	returnStackX,y
.19df	aa		tax				tax
.19e0	f0 0e		beq $19f0			beq 	_RHInLoop 					; this means you have done :something for ; next
.19e2	4c 00 00	jmp $0000			jmp 	NextCode
.19e5					_RHUnderflow:
.19e5	20 23 10	jsr $1023			jsr 	ErrorHandler
>19e8	52 45 54 55 52 4e 3f 00				.text 	"RETURN?",0
.19f0					_RHInLoop:
.19f0	20 23 10	jsr $1023			jsr 	ErrorHandler
>19f3	52 45 54 55 52 4e 20 49				.text 	"RETURN IN LOOP?",0
>19fb	4e 20 4c 4f 4f 50 3f 00
.1a03					CallHandlerDecode:
.1a03	a9 03		lda #$03			lda 	#CTH_Call					; space
.1a05	20 c3 1b	jsr $1bc3			jsr 	DecodeWriteBuffer
.1a08	b1 08		lda ($08),y			lda 	(srcPtr),y 					; get line number into YA
.1a0a	aa		tax				tax
.1a0b	c8		iny				iny
.1a0c	b1 08		lda ($08),y			lda 	(srcPtr),y
.1a0e	a8		tay				tay
.1a0f	8a		txa				txa
.1a10	20 4d 1a	jsr $1a4d			jsr 	FindLine 					; try to locate that line.
.1a13	b0 11		bcs $1a26			bcs 	_CHDFound 					; if found .....
.1a15					_CHDLineOnly:
.1a15	48		pha				pha
.1a16	a9 3c		lda #$3c			lda 	#"<"
.1a18	20 c3 1b	jsr $1bc3			jsr 	DecodeWriteBuffer
.1a1b	68		pla				pla
.1a1c	18		clc				clc 								; output unsigned
.1a1d	20 e5 1b	jsr $1be5			jsr 	DecodeYAToBuffer
.1a20	a9 3e		lda #$3e			lda 	#">"
.1a22	20 c3 1b	jsr $1bc3			jsr 	DecodeWriteBuffer
.1a25	60		rts				rts
.1a26					_CHDFound:
.1a26	48		pha				pha 								; save YA
.1a27	5a		phy				phy
.1a28	a0 03		ldy #$03			ldy 	#3 							; check first is $$define
.1a2a	b1 10		lda ($10),y			lda 	(temp1),y
.1a2c	c9 e5		cmp #$e5			cmp 	#DefineCode & 255
.1a2e	d0 07		bne $1a37			bne 	_CHDNoDefine
.1a30	c8		iny				iny
.1a31	b1 10		lda ($10),y			lda 	(temp1),y
.1a33	c9 1d		cmp #$1d			cmp 	#DefineCode >> 8
.1a35	f0 04		beq $1a3b			beq 	_CHDFoundDefine
.1a37					_CHDNoDefine:
.1a37	7a		ply				ply									; restore the line number and print it in <>
.1a38	68		pla				pla
.1a39	80 da		bra $1a15			bra 	_CHDLineOnly
.1a3b					_CHDFoundDefine:
.1a3b	68		pla				pla 								; throw saved line number.
.1a3c	68		pla				pla
.1a3d	a0 05		ldy #$05			ldy 	#5 							; 3,4 $$define 5 length, name has bit 7 set at end
.1a3f					_CHDOutName:
.1a3f	c8		iny				iny 								; next
.1a40	b1 10		lda ($10),y			lda 	(temp1),y 					; print char no bit 7
.1a42	48		pha				pha
.1a43	29 7f		and #$7f			and 	#$7F
.1a45	20 c3 1b	jsr $1bc3			jsr 	DecodeWriteBuffer
.1a48	68		pla				pla
.1a49	0a		asl a				asl 	a 							; bit 7 to carry
.1a4a	90 f3		bcc $1a3f			bcc 	_CHDOutName
.1a4c	60		rts				rts
.1a4d					FindLine:
.1a4d	48		pha				pha 								; save registers
.1a4e	da		phx				phx
.1a4f	5a		phy				phy
.1a50	85 12		sta $12				sta 	temp2 						; temp2 = target line#
.1a52	84 13		sty $13				sty 	temp2+1
.1a54	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.1a56	85 10		sta $10				sta 	0+(temp1)
.1a58	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.1a5a	85 11		sta $11				sta 	1+(temp1)
.1a5c					_FLLoop:
.1a5c	b2 10		lda ($10)			lda 	(temp1) 					; found end ?
.1a5e	18		clc				clc									; if so exit with CC.
.1a5f	f0 1d		beq $1a7e			beq 	_FLExit
.1a61	a0 01		ldy #$01			ldy 	#1 							; check line # match
.1a63	b1 10		lda ($10),y			lda 	(temp1),y
.1a65	c5 12		cmp $12				cmp 	temp2
.1a67	d0 08		bne $1a71			bne 	_FLNext
.1a69	c8		iny				iny
.1a6a	b1 10		lda ($10),y			lda 	(temp1),y
.1a6c	c5 13		cmp $13				cmp 	temp2+1
.1a6e	38		sec				sec 								; if so exit with CS
.1a6f	f0 0d		beq $1a7e			beq 	_FLExit
.1a71					_FLNext:
.1a71	18		clc				clc
.1a72	a5 10		lda $10				lda 	temp1
.1a74	72 10		adc ($10)			adc 	(temp1)
.1a76	85 10		sta $10				sta 	temp1
.1a78	90 02		bcc $1a7c			bcc 	_NoCarryAdv
.1a7a	e6 11		inc $11				inc 	temp1+1
.1a7c					_NoCarryAdv:
.1a7c	80 de		bra $1a5c			bra 	_FLLoop 					; keep looking.
.1a7e					_FLExit:
.1a7e	7a		ply				ply
.1a7f	fa		plx				plx
.1a80	68		pla				pla
.1a81	60		rts				rts
.1a82	18		clc				clc
.1a83	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/clrnew.src

.1a84					NewHandler:
.1a84	9c 00 40	stz $4000			stz 	ProgramMemory 				; Make the first offset zero.
.1a87	20 93 1a	jsr $1a93			jsr 	ClearVariableSpace 			; clear variables, reset pointers
.1a8a	4c 00 00	jmp $0000			jmp 	NextCode
.1a8d					ClrHandler:
.1a8d	20 93 1a	jsr $1a93			jsr 	ClearVariableSpace 			; clear variables, reset pointers
.1a90	4c 00 00	jmp $0000			jmp 	NextCode
.1a93					ClearVariableSpace:
.1a93	a9 ff		lda #$ff			lda 	#$FF 						; empty return stack
.1a95	85 05		sta $05				sta 	rsp
.1a97	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.1a99	85 0e		sta $0e				sta 	0+(nextFreeMem)
.1a9b	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.1a9d	85 0f		sta $0f				sta 	1+(nextFreeMem)
.1a9f	a0 1f		ldy #$1f			ldy 	#hashTableSize*2-1 			; erase the hash table (used for variables)
.1aa1					_CVSHashClear:
.1aa1	a9 00		lda #$00			lda 	#0 							; all the first record pointers are $00
.1aa3	99 40 06	sta $0640,y			sta 	hashTable,y
.1aa6	88		dey				dey
.1aa7	10 f8		bpl $1aa1			bpl 	_CVSHashClear
.1aa9					_CVSFindEnd:
.1aa9	18		clc				clc
.1aaa	a5 0e		lda $0e				lda 	nextFreeMem
.1aac	72 0e		adc ($0e)			adc 	(nextFreeMem)
.1aae	85 0e		sta $0e				sta 	nextFreeMem
.1ab0	90 02		bcc $1ab4			bcc 	_NoCarryAdv
.1ab2	e6 0f		inc $0f				inc 	nextFreeMem+1
.1ab4					_NoCarryAdv:
.1ab4	b2 0e		lda ($0e)			lda 	(nextFreeMem)
.1ab6	d0 f1		bne $1aa9			bne 	_CVSFindEnd
.1ab8	a9 08		lda #$08			lda 	#8 							; this puts a gap in, more for clarity than anything.
.1aba	a0 00		ldy #$00			ldy 	#0
.1abc	20 c0 1a	jsr $1ac0			jsr 	AdvanceFreeMem				; we need +1 because the previous code leaves the
.1abf	60		rts				rts 								; free mem pointer pointing to the last zero offset
.1ac0					AdvanceFreeMem:
.1ac0	18		clc				clc
.1ac1	65 0e		adc $0e				adc 	nextFreeMem
.1ac3	85 0e		sta $0e				sta 	nextFreeMem
.1ac5	98		tya				tya
.1ac6	65 0f		adc $0f				adc 	nextFreeMem+1
.1ac8	85 0f		sta $0f				sta 	nextFreeMem+1
.1aca	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/debug.src

.1acb					ExitDump:
.1acb	ba		tsx				tsx 								; save Data Stack in temp1
.1acc	86 10		stx $10				stx 	temp1
.1ace	4c ff ff	jmp $ffff			jmp 	$FFFF 						; makes the X16-Emulator dump-exit.
.1ad1					BreakCmd:
>1ad1	ff						.byte 	$FF
.1ad2	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/system/decode.src

.1ad5					DecodeLineIntoBufPtr:
.1ad5	48		pha				pha
.1ad6	da		phx				phx
.1ad7	5a		phy				phy
.1ad8	85 08		sta $08				sta 	srcPtr 						; save the source line.
.1ada	84 09		sty $09				sty 	srcPtr+1
.1adc	90 1b		bcc $1af9			bcc 	_DecodeNoLineNumber
.1ade	a0 01		ldy #$01			ldy 	#1 							; get line # to YA
.1ae0	b1 08		lda ($08),y			lda 	(srcPtr),y
.1ae2	aa		tax				tax
.1ae3	c8		iny				iny
.1ae4	b1 08		lda ($08),y			lda 	(srcPtr),y
.1ae6	a8		tay				tay
.1ae7	8a		txa				txa
.1ae8	18		clc				clc
.1ae9	20 e5 1b	jsr $1be5			jsr 	DecodeYAToBuffer 			; convert to string in buffer
.1aec	aa		tax				tax 								; count in X
.1aed					_DecodeLineSpace:
.1aed	e0 05		cpx #$05			cpx 	#5
.1aef	f0 08		beq $1af9			beq 	_DecodeNoLineNumber
.1af1	a9 20		lda #$20			lda 	#" " 						; pad to 5 spaces
.1af3	20 c3 1b	jsr $1bc3			jsr 	DecodeWriteBuffer
.1af6	e8		inx				inx
.1af7	80 f4		bra $1aed			bra 	_DecodeLineSpace
.1af9					_DecodeNoLineNumber:
.1af9	a0 03		ldy #$03			ldy 	#3 							; initial position.
.1afb					_DecodeLoop:
.1afb	b1 08		lda ($08),y			lda 	(srcPtr),y 					; copy the current character to temp1
.1afd	85 10		sta $10				sta 	temp1 						; must be an execution address.
.1aff	c8		iny				iny
.1b00	b1 08		lda ($08),y			lda 	(srcPtr),y
.1b02	85 11		sta $11				sta 	temp1+1
.1b04	c8		iny				iny 								; y points to the byte after it.
.1b05	a5 10		lda $10				lda 	temp1
.1b07	c9 a9		cmp #$a9			cmp 	#NextLine & $FF
.1b09	d0 06		bne $1b11			bne 	_DecodeNotEOL
.1b0b	a5 11		lda $11				lda 	temp1+1
.1b0d	c9 1d		cmp #$1d			cmp 	#NextLine >> 8
.1b0f	f0 0b		beq $1b1c			beq 	_DecodeEOL
.1b11					_DecodeNotEOL:
.1b11	20 24 1b	jsr $1b24			jsr 	IdentifyCodeWord
.1b14	20 6e 1b	jsr $1b6e			jsr 	DecodeFoundWord
.1b17	20 58 1b	jsr $1b58			jsr 	AdvanceToNext 				; advance to next entry in the line.
.1b1a	80 df		bra $1afb			bra 	_DecodeLoop 				; and go round again
.1b1c					_DecodeEOL:
.1b1c	a9 00		lda #$00			lda 	#0
.1b1e	92 0a		sta ($0a)			sta 	(bufPtr)
.1b20	7a		ply				ply 								; restore registers and exit
.1b21	fa		plx				plx
.1b22	68		pla				pla
.1b23	60		rts				rts
.1b24					IdentifyCodeWord:
.1b24	5a		phy				phy 								; save current position on the stack.
.1b25	a9 e3		lda #$e3			lda 	#(Dictionary) & $FF
.1b27	85 0c		sta $0c				sta 	0+(matchPtr)
.1b29	a9 1f		lda #$1f			lda 	#(Dictionary) >> 8
.1b2b	85 0d		sta $0d				sta 	1+(matchPtr)
.1b2d					_DecodeIdentify:
.1b2d	a0 02		ldy #$02			ldy 	#2 							; have we found a match ?
.1b2f	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.1b31	c5 10		cmp $10				cmp 	temp1
.1b33	d0 07		bne $1b3c			bne 	_DecodeIdNext
.1b35	c8		iny				iny
.1b36	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.1b38	c5 11		cmp $11				cmp 	temp1+1
.1b3a	f0 1a		beq $1b56			beq 	_DecodeIdFound
.1b3c					_DecodeIdNext:
.1b3c	18		clc				clc
.1b3d	b2 0c		lda ($0c)			lda 	(matchPtr)
.1b3f	f0 0a		beq $1b4b			beq 	_DecodeIdIssue
.1b41	65 0c		adc $0c				adc 	matchPtr
.1b43	85 0c		sta $0c				sta 	matchPtr
.1b45	90 e6		bcc $1b2d			bcc 	_DecodeIdentify
.1b47	e6 0d		inc $0d				inc 	matchPtr+1
.1b49	80 e2		bra $1b2d			bra 	_DecodeIdentify
.1b4b					_DecodeIdIssue:
.1b4b	20 23 10	jsr $1023			jsr 	ErrorHandler
>1b4e	44 45 43 4f 44 45 3f 00				.text 	"DECODE?",0
.1b56					_DecodeIdFound:
.1b56	7a		ply				ply 								; restore position.
.1b57	60		rts				rts
.1b58					AdvanceToNext:
.1b58	5a		phy				phy 								; get the parameter count from bits 0-1 of the type byte
.1b59	a0 01		ldy #$01			ldy 	#1
.1b5b	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.1b5d	29 03		and #$03			and 	#3 							; bits 0-1.
.1b5f	7a		ply				ply
.1b60	c9 03		cmp #$03			cmp 	#3 							; is it n-bytes e.g. specified by the next byte
.1b62	d0 02		bne $1b66			bne 	_ATN012
.1b64	b1 08		lda ($08),y			lda 	(srcPtr),y 					; if so, use that byte as the overall length.
.1b66					_ATN012:
.1b66	85 12		sta $12				sta 	temp2 						; now add that to Y
.1b68	98		tya				tya
.1b69	18		clc				clc
.1b6a	65 12		adc $12				adc 	temp2
.1b6c	a8		tay				tay
.1b6d	60		rts				rts
.1b6e					DecodeFoundWord:
.1b6e	5a		phy				phy 								; save current position
.1b6f	84 12		sty $12				sty		temp2 						; put it in temp2 as well.
.1b71	a0 01		ldy #$01			ldy 	#1 							; get the type byte
.1b73	b1 0c		lda ($0c),y			lda 	(matchPtr),y 				; is there a special decoder check (bit 4 set) ?
.1b75	29 10		and #$10			and 	#$10
.1b77	d0 0e		bne $1b87			bne 	_DFWSpecialDecoder
.1b79	b1 0c		lda ($0c),y			lda 	(matchPtr),y 				; reget it.
.1b7b	30 08		bmi $1b85			bmi 	_DFWExit 					; if hidden word (bit 7 set)
.1b7d	a9 06		lda #$06			lda 	#CTH_Keyword				; output a space to the buffer
.1b7f	20 c3 1b	jsr $1bc3			jsr 	DecodeWriteBuffer
.1b82	20 a0 1b	jsr $1ba0			jsr 	DecodeCurrentWord 			; expand that.
.1b85					_DFWExit:
.1b85	7a		ply				ply 								; restore current position
.1b86	60		rts				rts
.1b87					_DFWSpecialDecoder:
.1b87	a0 04		ldy #$04			ldy 	#4 							; the decode word address is at offset 4,5
.1b89	b1 0c		lda ($0c),y			lda 	(matchPtr),y 				; copy this into temp2
.1b8b	85 12		sta $12				sta 	temp2
.1b8d	c8		iny				iny
.1b8e	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.1b90	85 13		sta $13				sta 	temp2+1
.1b92	7a		ply				ply 	 							; restore current position into Y
.1b93	48		pha				pha 								; save registers
.1b94	da		phx				phx
.1b95	5a		phy				phy
.1b96	20 9d 1b	jsr $1b9d			jsr 	_DFWCallDecoder				; call the decoder routine
.1b99	7a		ply				ply 								; restore registers and exit
.1b9a	fa		plx				plx
.1b9b	68		pla				pla
.1b9c	60		rts				rts
.1b9d					_DFWCallDecoder:
.1b9d	6c 12 00	jmp ($0012)			jmp 	(temp2)
.1ba0					DecodeCurrentWord:
.1ba0	5a		phy				phy
.1ba1	a0 01		ldy #$01			ldy 	#1 							; read type byte
.1ba3	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.1ba5	a0 04		ldy #$04			ldy 	#4 							; original offset
.1ba7	4a		lsr a				lsr 	a 							; encoder/decoder bits in 0-1
.1ba8	4a		lsr a				lsr 	a 							; add 2 to Y for each encoder/decoder
.1ba9	4a		lsr a				lsr 	a 							; bit set.
.1baa	4a		lsr a				lsr 	a
.1bab	4a		lsr a				lsr 	a 							; decoder bit
.1bac	90 02		bcc $1bb0			bcc 	_DWBNoDec
.1bae	c8		iny				iny
.1baf	c8		iny				iny
.1bb0					_DWBNoDec:
.1bb0	4a		lsr a				lsr 	a
.1bb1	90 02		bcc $1bb5			bcc 	_DWBNoEnc
.1bb3	c8		iny				iny
.1bb4	c8		iny				iny
.1bb5					_DWBNoEnc:
.1bb5					_DWBWordOut:
.1bb5	b1 0c		lda ($0c),y			lda 	(matchPtr),y 				; output until bit 7 set.
.1bb7	48		pha				pha
.1bb8	29 7f		and #$7f			and 	#$7F
.1bba	20 c3 1b	jsr $1bc3			jsr		DecodeWriteBuffer
.1bbd	c8		iny				iny
.1bbe	68		pla				pla
.1bbf	10 f4		bpl $1bb5			bpl 	_DWBWordOut
.1bc1	7a		ply				ply 								; restore Y and exit
.1bc2	60		rts				rts
.1bc3					DecodeWriteBuffer:
.1bc3	92 0a		sta ($0a)			sta 	(bufPtr)
.1bc5	e6 0a		inc $0a				inc 	bufPtr
.1bc7	d0 02		bne $1bcb			bne 	_DWBNoCarry
.1bc9	e6 0b		inc $0b				inc 	bufPtr+1
.1bcb					_DWBNoCarry:
.1bcb	60		rts				rts
.1bcc					DecodeOutputData:
.1bcc	48		pha				pha
.1bcd	da		phx				phx
.1bce	5a		phy				phy
.1bcf	b1 08		lda ($08),y			lda 	(srcPtr),y 					; length + 1
.1bd1	aa		tax				tax
.1bd2					_DODLoop:
.1bd2	ca		dex				dex 								; done it all ?
.1bd3	f0 0c		beq $1be1			beq		_DODExit
.1bd5	c8		iny				iny 								; output next character
.1bd6	b1 08		lda ($08),y			lda 	(srcPtr),y
.1bd8	29 7f		and #$7f			and 	#$7F
.1bda	f0 f6		beq $1bd2			beq 	_DODLoop 					; don't print NULL
.1bdc	20 c3 1b	jsr $1bc3			jsr 	DecodeWriteBuffer
.1bdf	80 f1		bra $1bd2			bra 	_DODLoop
.1be1					_DODExit:
.1be1	7a		ply				ply
.1be2	fa		plx				plx
.1be3	68		pla				pla
.1be4	60		rts				rts
.1be5					DecodeYAToBuffer:
.1be5	da		phx				phx
.1be6	5a		phy				phy
.1be7	48		pha				pha
.1be8	a5 0a		lda $0a				lda 	bufPtr 						; copy bufPtr to temp2
.1bea	85 12		sta $12				sta 	temp2
.1bec	a5 0b		lda $0b				lda 	bufPtr+1
.1bee	85 13		sta $13				sta 	temp2+1
.1bf0	68		pla				pla
.1bf1	20 25 1e	jsr $1e25			jsr 	ConvertToStringMain 		; convert YA to string there
.1bf4	aa		tax				tax 								; chars output to X
.1bf5	18		clc				clc
.1bf6	65 0a		adc $0a				adc 	bufPtr 						; add to buffer pointer
.1bf8	85 0a		sta $0a				sta 	bufPtr
.1bfa	90 02		bcc $1bfe			bcc 	_DYABNoCarry
.1bfc	e6 0b		inc $0b				inc 	bufPtr+1
.1bfe					_DYABNoCarry:
.1bfe	8a		txa				txa 								; count in A
.1bff	7a		ply				ply									; restore and exit.
.1c00	fa		plx				plx
.1c01	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/list.src

.1c02					ListCode:
.1c02	64 1e		stz $1e				stz 	ListLowest 					; zero lowest line#
.1c04	64 1f		stz $1f				stz 	ListLowest+1
.1c06	a9 14		lda #$14			lda 	#20 						; show max 20 after lowest line
.1c08	85 1d		sta $1d				sta 	ListCount
.1c0a	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.1c0c	85 18		sta $18				sta 	0+(listPtr)
.1c0e	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.1c10	85 19		sta $19				sta 	1+(listPtr)
.1c12	86 10		stx $10				stx 	temp1						; S->A
.1c14	ba		tsx				tsx
.1c15	8a		txa				txa
.1c16	a6 10		ldx $10				ldx 	temp1
.1c18	c9 80		cmp #$80			cmp 	#NumberStackBase
.1c1a	f0 0e		beq $1c2a			beq 	_LCLoop
.1c1c	a5 06		lda $06				lda 	TOS 						; copy TOS to lowest
.1c1e	85 1e		sta $1e				sta 	ListLowest
.1c20	a5 07		lda $07				lda 	TOS+1
.1c22	85 1f		sta $1f				sta 	ListLowest+1
.1c24	68		pla				pla
.1c25	85 07		sta $07				sta 	TOS+1
.1c27	68		pla				pla
.1c28	85 06		sta $06				sta 	TOS
.1c2a					_LCLoop:
.1c2a	b2 18		lda ($18)			lda 	(listPtr)					; reached end ?
.1c2c	f0 4e		beq $1c7c			beq 	_LCExit
.1c2e	a0 01		ldy #$01			ldy 	#1							; >= list lowest
.1c30	b1 18		lda ($18),y			lda 	(listPtr),y
.1c32	c5 1e		cmp $1e				cmp 	ListLowest
.1c34	c8		iny				iny
.1c35	b1 18		lda ($18),y			lda 	(listPtr),y
.1c37	e5 1f		sbc $1f				sbc 	ListLowest+1
.1c39	90 34		bcc $1c6f			bcc 	_LCNext
.1c3b	a9 10		lda #$10			lda 	#(textBuffer) & $FF
.1c3d	85 0a		sta $0a				sta 	0+(bufPtr)
.1c3f	a9 08		lda #$08			lda 	#(textBuffer) >> 8
.1c41	85 0b		sta $0b				sta 	1+(bufPtr)
.1c43	a5 18		lda $18				lda 	listPtr 					; output the line.
.1c45	a4 19		ldy $19				ldy 	listPtr+1
.1c47	38		sec				sec
.1c48	20 d5 1a	jsr $1ad5			jsr 	DecodeLineIntoBufPtr
.1c4b	a9 02		lda #$02			lda 	#CTH_LineNo
.1c4d	20 18 11	jsr $1118			jsr 	ExternColour
.1c50	a0 ff		ldy #$ff			ldy 	#255
.1c52					_LCLoop2:
.1c52	c8		iny				iny
.1c53	b9 10 08	lda $0810,y			lda 	textBuffer,y
.1c56	f0 0e		beq $1c66			beq 	_LCEnd
.1c58	c9 20		cmp #$20			cmp 	#32
.1c5a	b0 05		bcs $1c61			bcs 	_LCPrint
.1c5c	20 18 11	jsr $1118			jsr 	ExternColour
.1c5f	a9 20		lda #$20			lda 	#32
.1c61					_LCPrint:
.1c61	20 0e 11	jsr $110e			jsr 	ExternPrint
.1c64	80 ec		bra $1c52			bra 	_LCLoop2
.1c66	a9 0d		lda #$0d	_LCEnd:	lda 	#13 						; new line
.1c68	20 0e 11	jsr $110e			jsr 	ExternPrint
.1c6b	c6 1d		dec $1d				dec 	ListCount					; done all the lines allowed
.1c6d	f0 0d		beq $1c7c			beq 	_LCExit
.1c6f					_LCNext:
.1c6f	18		clc				clc
.1c70	a5 18		lda $18				lda 	listPtr
.1c72	72 18		adc ($18)			adc 	(listPtr)
.1c74	85 18		sta $18				sta 	listPtr
.1c76	90 02		bcc $1c7a			bcc 	_NoCarryAdv
.1c78	e6 19		inc $19				inc 	listPtr+1
.1c7a					_NoCarryAdv:
.1c7a	80 ae		bra $1c2a			bra 	_LCLoop 					; go round again.
.1c7c					_LCExit:
.1c7c	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/system/miscellany.src

.1c7f					RunProgram:
.1c7f	a2 80		ldx #$80			ldx 	#NumberStackBase
.1c81	9a		txs				txs
.1c82	20 93 1a	jsr $1a93			jsr 	ClearVariableSpace 			; clear variables etc.
.1c85	a2 00		ldx #$00			ldx		#ProgramMemory & $FF		; boot address
.1c87	a0 40		ldy #$40			ldy 	#ProgramMemory >>8
.1c89	20 78 10	jsr $1078			jsr 	InitialiseCoreCode 			; initialise the NEXT routine at $00
.1c8c	4c 00 00	jmp $0000			jmp 	NextCode
.1c8f					Call6502:
.1c8f	a5 06		lda $06				lda 	TOS 						; copy call address
.1c91	85 10		sta $10				sta 	temp1
.1c93	a5 07		lda $07				lda 	TOS+1
.1c95	85 11		sta $11				sta 	temp1+1
.1c97	68		pla				pla
.1c98	85 07		sta $07				sta 	TOS+1
.1c9a	68		pla				pla
.1c9b	85 06		sta $06				sta 	TOS
.1c9d	20 a3 1c	jsr $1ca3			jsr 	_CallTemp1 					; call it
.1ca0	4c 00 00	jmp $0000			jmp 	NextCode
.1ca3					_CallTemp1:
.1ca3	6c 10 00	jmp ($0010)			jmp 	(temp1)
.1ca6					AssertCode:
.1ca6	a5 06		lda $06				lda 	TOS 						; TOS = 0
.1ca8	05 07		ora $07				ora 	TOS+1
.1caa	f0 09		beq $1cb5			beq 	_ASFail 					; if zero fail
.1cac	68		pla				pla
.1cad	85 07		sta $07				sta 	TOS+1
.1caf	68		pla				pla
.1cb0	85 06		sta $06				sta 	TOS
.1cb2	4c 00 00	jmp $0000			jmp 	NextCode
.1cb5					_ASFail:
.1cb5	20 23 10	jsr $1023			jsr 	ErrorHandler
>1cb8	41 53 53 45 52 54 00				.text 	"ASSERT",0
.1cbf					StopCode:
.1cbf	20 23 10	jsr $1023			jsr 	ErrorHandler
>1cc2	53 54 4f 50 00					.text 	"STOP",0
.1cc7					EndProgram:
.1cc7	4c 13 10	jmp $1013			jmp 	WarmStart
.1cca					VlistCode:
.1cca	a9 e3		lda #$e3			lda 	#(Dictionary) & $FF
.1ccc	85 10		sta $10				sta 	0+(temp1)
.1cce	a9 1f		lda #$1f			lda 	#(Dictionary) >> 8
.1cd0	85 11		sta $11				sta 	1+(temp1)
.1cd2	a0 01		ldy #$01	_VLLoop:ldy 	#1							; type byte
.1cd4	b1 10		lda ($10),y			lda 	(temp1),y
.1cd6	a0 04		ldy #$04			ldy 	#4 							; Y = 4
.1cd8	4a		lsr a				lsr 	a 							; shift bits 4 and 5 to 0,1
.1cd9	4a		lsr a				lsr 	a
.1cda	4a		lsr a				lsr		a
.1cdb	4a		lsr a				lsr 	a
.1cdc	4a		lsr a				lsr 	a 							; add those bits in
.1cdd	90 02		bcc $1ce1			bcc 	_VLNoDec
.1cdf	c8		iny				iny
.1ce0	c8		iny				iny
.1ce1					_VLNoDec:
.1ce1	4a		lsr a				lsr 	a
.1ce2	90 02		bcc $1ce6			bcc 	_VLNoEnc
.1ce4	c8		iny				iny
.1ce5	c8		iny				iny
.1ce6					_VLNoEnc:
.1ce6	b1 10		lda ($10),y			lda 	(temp1),y 					; remove $$ words
.1ce8	c9 24		cmp #$24			cmp 	#"$"
.1cea	d0 06		bne $1cf2			bne 	_VLPrint
.1cec	c8		iny				iny
.1ced	51 10		eor ($10),y			eor 	(temp1),y
.1cef	f0 13		beq $1d04			beq 	_VLNext
.1cf1	88		dey				dey
.1cf2					_VLPrint:
.1cf2	b1 10		lda ($10),y			lda 	(temp1),y
.1cf4	48		pha				pha
.1cf5	c8		iny				iny
.1cf6	29 7f		and #$7f			and 	#$7F
.1cf8	20 0e 11	jsr $110e			jsr 	ExternPrint
.1cfb	68		pla				pla
.1cfc	0a		asl a				asl 	a
.1cfd	90 f3		bcc $1cf2			bcc 	_VLPrint
.1cff	a9 20		lda #$20			lda 	#32
.1d01	20 0e 11	jsr $110e			jsr 	ExternPrint
.1d04					_VLNext:
.1d04	18		clc				clc 								; go to next
.1d05	b2 10		lda ($10)			lda 	(temp1)
.1d07	65 10		adc $10				adc 	temp1
.1d09	85 10		sta $10				sta 	temp1
.1d0b	90 02		bcc $1d0f			bcc 	_VLNoCarry
.1d0d	e6 11		inc $11				inc 	temp1+1
.1d0f					_VLNoCarry:
.1d0f	b2 10		lda ($10)			lda 	(temp1)
.1d11	d0 bf		bne $1cd2			bne 	_VLLoop
.1d13	a9 0d		lda #$0d			lda 	#13
.1d15	20 0e 11	jsr $110e			jsr 	ExternPrint
.1d18	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/system/toint.src

.1d1b					ConvertToInteger:
.1d1b	84 17		sty $17				sty 	temp4+1
.1d1d	85 16		sta $16				sta 	temp4
.1d1f	64 14		stz $14				stz 	temp3 						; reset value
.1d21	64 15		stz $15				stz 	temp3+1
.1d23	64 10		stz $10				stz 	temp1 						; temp1 = 0 (decimal) 255 (hex)
.1d25	a0 00		ldy #$00			ldy 	#0 							; look at first character
.1d27	b1 16		lda ($16),y			lda 	(temp4),y
.1d29	49 2d		eor #$2d			eor 	#"-"						; zero if '-'
.1d2b	85 11		sta $11				sta 	temp1+1 					; save this in temp1+1
.1d2d	d0 01		bne $1d30			bne 	_CTINotMinus
.1d2f	c8		iny				iny									; skip -
.1d30					_CTINotMinus:
.1d30	b1 16		lda ($16),y			lda 	(temp4),y
.1d32	c9 24		cmp #$24			cmp		#'$'						; if $ then skip it and set hex flag
.1d34	d0 03		bne $1d39			bne 	_CTILoop
.1d36	c6 10		dec $10				dec 	temp1
.1d38	c8		iny				iny
.1d39					_CTILoop:
.1d39	b1 16		lda ($16),y			lda 	(temp4),y 					; next digit
.1d3b	29 7f		and #$7f			and 	#$7F 						; drop end of word flag
.1d3d	38		sec				sec
.1d3e	e9 30		sbc #$30			sbc 	#'0' 						; put in range '0'+
.1d40	90 65		bcc $1da7			bcc 	_CTIFail 					; out of range.
.1d42	c9 0a		cmp #$0a			cmp 	#10 						; in 0-9 ?
.1d44	90 0b		bcc $1d51			bcc 	_CTILegal
.1d46	c9 11		cmp #$11			cmp 	#'A'-'0'					; between 9 and A ?
.1d48	90 5d		bcc $1da7			bcc 	_CTIFail
.1d4a	38		sec				sec
.1d4b	e9 07		sbc #$07			sbc 	#7 							; hex adjust
.1d4d	c9 10		cmp #$10			cmp 	#16 						; out of range ?
.1d4f	b0 56		bcs $1da7			bcs 	_CTIFail
.1d51					_CTILegal:
.1d51	48		pha				pha 								; save digit value.
.1d52	06 14		asl $14				asl 	temp3
.1d54	26 15		rol $15				rol 	temp3+1
.1d56	a5 14		lda $14				lda 	temp3 						; copy x2 into temp2
.1d58	85 12		sta $12				sta 	temp2
.1d5a	a5 15		lda $15				lda 	temp3+1
.1d5c	85 13		sta $13				sta 	temp2+1
.1d5e	06 14		asl $14				asl 	temp3
.1d60	26 15		rol $15				rol 	temp3+1
.1d62	06 14		asl $14				asl 	temp3
.1d64	26 15		rol $15				rol 	temp3+1
.1d66	24 10		bit $10				bit 	temp1 						; hexadecimal
.1d68	10 07		bpl $1d71			bpl 	_CTIDecimal
.1d6a	06 14		asl $14				asl 	temp3
.1d6c	26 15		rol $15				rol 	temp3+1
.1d6e	68		pla				pla 								; get digit back
.1d6f	80 12		bra $1d83			bra 	_CTIAddLoop
.1d71					_CTIDecimal:
.1d71	18		clc				clc 								; x 8 + x 2 = x 10
.1d72	a5 14		lda $14				lda 	temp3
.1d74	65 12		adc $12				adc 	temp2
.1d76	85 14		sta $14				sta 	temp3
.1d78	a5 15		lda $15				lda 	temp3+1
.1d7a	65 13		adc $13				adc 	temp2+1
.1d7c	85 15		sta $15				sta 	temp3+1
.1d7e	68		pla				pla 								; check digit 0-9
.1d7f	c9 0a		cmp #$0a			cmp 	#10
.1d81	b0 24		bcs $1da7			bcs 	_CTIFail
.1d83					_CTIAddLoop:
.1d83	18		clc				clc
.1d84	65 14		adc $14				adc 	temp3
.1d86	85 14		sta $14				sta 	temp3
.1d88	90 02		bcc $1d8c			bcc 	_CTINoCarry
.1d8a	e6 15		inc $15				inc 	temp3+1
.1d8c					_CTINoCarry:
.1d8c	c8		iny				iny
.1d8d	b1 16		lda ($16),y			lda 	(temp4),y 					; was this the last character
.1d8f	c9 21		cmp #$21			cmp 	#32+1
.1d91	b0 a6		bcs $1d39			bcs 	_CTILoop 					; no, go back.
.1d93	a5 11		lda $11				lda 	temp1+1 					; was it - ?
.1d95	d0 0d		bne $1da4			bne 	_CTIOkay
.1d97	38		sec				sec
.1d98	a9 00		lda #$00			lda 	#0 							; negate temp3.
.1d9a	e5 14		sbc $14				sbc 	temp3
.1d9c	85 14		sta $14				sta 	temp3
.1d9e	a9 00		lda #$00			lda 	#0
.1da0	e5 15		sbc $15				sbc 	temp3+1
.1da2	85 15		sta $15				sta 	temp3+1
.1da4					_CTIOkay:
.1da4	98		tya				tya
.1da5	38		sec				sec
.1da6	60		rts				rts
.1da7					_CTIFail:
.1da7	18		clc				clc
.1da8	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/skipper.src

.1da9					NextLine:
.1da9	18		clc				clc
.1daa	a5 03		lda $03				lda 	IP
.1dac	72 03		adc ($03)			adc 	(IP)
.1dae	85 03		sta $03				sta 	IP
.1db0	90 02		bcc $1db4			bcc 	_NoCarryAdv
.1db2	e6 04		inc $04				inc 	IP+1
.1db4					_NoCarryAdv:
.1db4	b2 03		lda ($03)			lda 	(IP)						; is there any following program ?
.1db6	f0 05		beq $1dbd			beq 	_NLGoEnd
.1db8	a2 01		ldx #$01			ldx 	#1 							; start 3 in (-2 for Next)
.1dba	4c 00 00	jmp $0000			jmp 	NextCode
.1dbd					_NLGoEnd:
.1dbd	4c 13 10	jmp $1013			jmp 	WarmStart
.1dc0					SkipComment:
.1dc0	e8		inx				inx									; (IP),X points to the length.
.1dc1	e8		inx				inx
.1dc2	8a		txa				txa
.1dc3	a8		tay				tay 								; put into Y
.1dc4	18		clc				clc
.1dc5	71 03		adc ($03),y			adc 	(IP),y 						; add the length to X
.1dc7	aa		tax				tax 								; put back in X
.1dc8	ca		dex				dex
.1dc9	ca		dex				dex
.1dca	4c 00 00	jmp $0000			jmp 	NextCode
.1dcd					CommentDecoder:
.1dcd	a9 06		lda #$06			lda 	#CTH_Keyword
.1dcf	20 c3 1b	jsr $1bc3			jsr 	DecodeWriteBuffer
.1dd2	a9 27		lda #$27			lda 	#"'"
.1dd4	20 c3 1b	jsr $1bc3			jsr 	DecodeWriteBuffer
.1dd7	a9 0b		lda #$0b			lda 	#CTH_Comment
.1dd9	20 c3 1b	jsr $1bc3			jsr 	DecodeWriteBuffer
.1ddc	20 cc 1b	jsr $1bcc			jsr 	DecodeOutputData
.1ddf	a9 20		lda #$20			lda 	#32
.1de1	20 c3 1b	jsr $1bc3			jsr 	DecodeWriteBuffer
.1de4	60		rts				rts
.1de5					DefineCode:
.1de5	20 23 10	jsr $1023			jsr 	ErrorHandler
>1de8	44 45 46 49 4e 49 54 49				.text 	"DEFINITION?",0
>1df0	4f 4e 3f 00
.1df4					DefineDecoder:
.1df4	a9 07		lda #$07			lda 	#CTH_Definition
.1df6	20 c3 1b	jsr $1bc3			jsr 	DecodeWriteBuffer
.1df9	a9 3a		lda #$3a			lda 	#":"
.1dfb	20 c3 1b	jsr $1bc3			jsr 	DecodeWriteBuffer
.1dfe	20 cc 1b	jsr $1bcc			jsr 	DecodeOutputData
.1e01	a9 20		lda #$20			lda 	#32
.1e03	20 c3 1b	jsr $1bc3			jsr 	DecodeWriteBuffer
.1e06	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/tostr.src

.1e07					IntToString:
.1e07	a9 10		lda #$10			lda 	#(textBuffer) & $FF
.1e09	85 12		sta $12				sta 	0+(temp2)
.1e0b	a9 08		lda #$08			lda 	#(textBuffer) >> 8
.1e0d	85 13		sta $13				sta 	1+(temp2)
.1e0f	a5 06		lda $06				lda 	TOS 						; value in YA
.1e11	a4 07		ldy $07				ldy 	TOS+1
.1e13	20 21 1e	jsr $1e21			jsr 	ConvertToString
.1e16	a9 10		lda #$10			lda 	#(textBuffer) & $FF
.1e18	85 06		sta $06				sta 	0+(TOS)
.1e1a	a9 08		lda #$08			lda 	#(textBuffer) >> 8
.1e1c	85 07		sta $07				sta 	1+(TOS)
.1e1e	4c 00 00	jmp $0000			jmp 	NextCode
.1e21					ConvertToString:
.1e21	38		sec				sec
.1e22	80 01		bra $1e25			bra 	ConvertToStringMain
.1e24					ConvertToStringUnsigned:
.1e24	18		clc				clc
.1e25					ConvertToStringMain:
.1e25	da		phx				phx									; save XY
.1e26	5a		phy				phy
.1e27	64 1a		stz $1a				stz 	SignCount 					; this is zero suppression
.1e29	85 10		sta $10				sta 	temp1 						; save YA in temp1
.1e2b	84 11		sty $11				sty 	temp1+1
.1e2d	a0 00		ldy #$00			ldy 	#0 							; index to result.
.1e2f	90 16		bcc $1e47			bcc 	_CTSUnsigned 				; if carry clear do not adjust for -
.1e31	a5 11		lda $11				lda 	temp1+1 					; is it negative
.1e33	10 12		bpl $1e47			bpl 	_CTSUnsigned
.1e35	a9 2d		lda #$2d			lda 	#"-"						; output - sign
.1e37	91 12		sta ($12),y			sta 	(temp2),y
.1e39	c8		iny				iny
.1e3a	38		sec				sec 								; negate temp1
.1e3b	a9 00		lda #$00			lda 	#0
.1e3d	e5 10		sbc $10				sbc 	temp1
.1e3f	85 10		sta $10				sta 	temp1
.1e41	a9 00		lda #$00			lda 	#0
.1e43	e5 11		sbc $11				sbc 	temp1+1
.1e45	85 11		sta $11				sta 	temp1+1
.1e47					_CTSUnsigned:
.1e47	a2 00		ldx #$00			ldx 	#0 							; index into subtraction table
.1e49					_CTSLoop:
.1e49	a9 2f		lda #$2f			lda 	#"0"-1						; set the digit to '0' code.
.1e4b	91 12		sta ($12),y			sta 	(temp2),y
.1e4d					_CTSSubLoop:
.1e4d	b1 12		lda ($12),y			lda 	(temp2),y 					; bump the count
.1e4f	1a		inc a				inc 	a
.1e50	91 12		sta ($12),y			sta 	(temp2),y
.1e52	38		sec				sec 								; do subtraction saving interim result
.1e53	a5 10		lda $10				lda 	temp1
.1e55	fd 88 1e	sbc $1e88,x			sbc 	_CTSTable,x
.1e58	48		pha				pha
.1e59	a5 11		lda $11				lda 	temp1+1
.1e5b	fd 89 1e	sbc $1e89,x			sbc 	_CTSTable+1,x
.1e5e	90 07		bcc $1e67			bcc 	_CTSCantSubtract 			; end of subtraction.
.1e60	85 11		sta $11				sta 	temp1+1 					; save result back
.1e62	68		pla				pla
.1e63	85 10		sta $10				sta 	temp1
.1e65	80 e6		bra $1e4d			bra 	_CTSSubLoop
.1e67					_CTSCantSubtract:
.1e67	68		pla				pla 								; throw away interim
.1e68	e8		inx				inx 								; next subtractor
.1e69	e8		inx				inx
.1e6a	b1 12		lda ($12),y			lda 	(temp2),y 					; update leading zero
.1e6c	49 30		eor #$30			eor 	#"0"
.1e6e	05 1a		ora $1a				ora 	SignCount
.1e70	85 1a		sta $1a				sta 	SignCount
.1e72	f0 01		beq $1e75			beq		_CTSLZ 						; if all zeros so far suppress.
.1e74	c8		iny				iny 								; next character
.1e75					_CTSLZ:
.1e75	e0 08		cpx #$08			cpx 	#_CTSTableEnd-_CTSTable 	; done them all ?
.1e77	d0 d0		bne $1e49			bne 	_CTSLoop
.1e79					_CTSComplete:
.1e79	a5 10		lda $10				lda		temp1 						; get remainder 0-9
.1e7b	09 30		ora #$30			ora 	#48 						; ASCII
.1e7d	91 12		sta ($12),y			sta 	(temp2),y					; write out
.1e7f	c8		iny				iny
.1e80	a9 00		lda #$00			lda 	#0							; make ASCIIZ
.1e82	91 12		sta ($12),y			sta 	(temp2),y
.1e84	98		tya				tya 								; size in A
.1e85	7a		ply				ply									; pull and exit.
.1e86	fa		plx				plx
.1e87	60		rts				rts
.1e88					_CTSTable:
>1e88	10 27 e8 03 64 00 0a 00				.word 	10000,1000,100,10 			; subtractors, this is a simple version.
.1e90					_CTSTableEnd:

;******  Return to file: kernel.asm


;******  Processing file: words/system/varhandlers.src

.1e90					VarAddressHandler:
.1e90	18		clc				clc 								; find variable, error if it doesn't exist.
.1e91	20 e2 1e	jsr $1ee2			jsr 	VariableFind
.1e94	a5 06		lda $06				lda 	TOS
.1e96	48		pha				pha
.1e97	a5 07		lda $07				lda 	TOS+1
.1e99	48		pha				pha
.1e9a	a5 10		lda $10				lda 	temp1 						; the address is the new value
.1e9c	85 06		sta $06				sta 	TOS
.1e9e	a5 11		lda $11				lda		temp1+1
.1ea0	85 07		sta $07				sta 	TOS+1
.1ea2	4c 00 00	jmp $0000			jmp 	NextCode
.1ea5					VarAddrHandlerDecode:
.1ea5	a9 26		lda #$26			lda 	#"&"
.1ea7	4c 90 1f	jmp $1f90			jmp 	VarHandlerDecode
.1eaa					VarReadHandler:
.1eaa	18		clc				clc 								; find variable, error if it doesn't exist.
.1eab	20 e2 1e	jsr $1ee2			jsr 	VariableFind
.1eae	a5 06		lda $06				lda 	TOS
.1eb0	48		pha				pha
.1eb1	a5 07		lda $07				lda 	TOS+1
.1eb3	48		pha				pha
.1eb4	b2 10		lda ($10)			lda 	(temp1)						; read variable address to TOS
.1eb6	85 06		sta $06				sta 	TOS
.1eb8	a0 01		ldy #$01			ldy 	#1
.1eba	b1 10		lda ($10),y			lda 	(temp1),y
.1ebc	85 07		sta $07				sta 	TOS+1
.1ebe	4c 00 00	jmp $0000			jmp 	NextCode
.1ec1					VarReadHandlerDecode:
.1ec1	a9 40		lda #$40			lda 	#"@"
.1ec3	4c 90 1f	jmp $1f90			jmp 	VarHandlerDecode
.1ec6					VarWriteHandler:
.1ec6	38		sec				sec 								; find variable, create it if it doesn't exist.
.1ec7	20 e2 1e	jsr $1ee2			jsr 	VariableFind
.1eca	a5 06		lda $06				lda 	TOS 						; write TOS to that address.
.1ecc	92 10		sta ($10)			sta 	(temp1)
.1ece	a5 07		lda $07				lda 	TOS+1
.1ed0	a0 01		ldy #$01			ldy 	#1
.1ed2	91 10		sta ($10),y			sta 	(temp1),y
.1ed4	68		pla				pla
.1ed5	85 07		sta $07				sta 	TOS+1
.1ed7	68		pla				pla
.1ed8	85 06		sta $06				sta 	TOS
.1eda	4c 00 00	jmp $0000			jmp 	NextCode
.1edd					VarWriteHandlerDecode:
.1edd	a9 21		lda #$21			lda 	#"!"
.1edf	4c 90 1f	jmp $1f90			jmp 	VarHandlerDecode
.1ee2					VariableFind:
.1ee2	08		php				php 								; save autocreate flag.
.1ee3	e8		inx				inx 								; advance to/over the variable name.
.1ee4	e8		inx				inx
.1ee5	8a		txa				txa 								; put in Y
.1ee6	a8		tay				tay
.1ee7	b1 03		lda ($03),y			lda 	(IP),y 						; copy name word into temp2
.1ee9	85 12		sta $12				sta 	temp2
.1eeb	c8		iny				iny
.1eec	b1 03		lda ($03),y			lda 	(IP),y
.1eee	85 13		sta $13				sta 	temp2+1
.1ef0	c9 1b		cmp #$1b			cmp 	#27 						; check for A-Z
.1ef2	b0 0f		bcs $1f03			bcs 	_VFLong
.1ef4	a5 13		lda $13				lda 	temp2+1
.1ef6	d0 0b		bne $1f03			bne 	_VFLong
.1ef8	a5 12		lda $12				lda 	temp2						; this is the index
.1efa	0a		asl a				asl 	a 							; double it
.1efb	85 10		sta $10				sta 	temp1
.1efd	a9 06		lda #$06			lda 	#azVariables >> 8			; set the MSB
.1eff	85 11		sta $11				sta 	temp1+1
.1f01	28		plp				plp 								; throw creation flag, it always exists.
.1f02	60		rts				rts
.1f03					_VFLong:
.1f03	a5 12		lda $12				lda 	temp2 						; built a hash table index into temp3/temp4
.1f05	6a		ror a				ror 	a
.1f06	6a		ror a				ror 	a
.1f07	6a		ror a				ror 	a
.1f08	6a		ror a				ror 	a
.1f09	45 12		eor $12				eor 	temp2
.1f0b	45 13		eor $13				eor 	temp2+1
.1f0d	29 0f		and #$0f			and 	#(hashTableSize-1)			; force into range
.1f0f	0a		asl a				asl 	a
.1f10	69 40		adc #$40			adc 	#hashTable & $FF 			; make an address of the head => temp1/3
.1f12	85 10		sta $10				sta 	temp1
.1f14	85 14		sta $14				sta 	temp3
.1f16	a9 06		lda #$06			lda 	#hashTable >> 8
.1f18	85 11		sta $11				sta 	temp1+1
.1f1a	85 15		sta $15				sta 	temp3+1
.1f1c					_VFSearch:
.1f1c	a0 01		ldy #$01			ldy 	#1							; read MSB of first record
.1f1e	b1 10		lda ($10),y			lda 	(temp1),y
.1f20	f0 23		beq $1f45			beq 	_VFNotFound 				; is MSB is zero, can't be a variable record
.1f22	a8		tay				tay 								; follow the link through.
.1f23	b2 10		lda ($10)			lda 	(temp1)
.1f25	85 10		sta $10				sta 	temp1
.1f27	84 11		sty $11				sty 	temp1+1
.1f29	a0 04		ldy #$04			ldy 	#4							; check if the name matches
.1f2b	b1 10		lda ($10),y			lda 	(temp1),y
.1f2d	c5 12		cmp $12				cmp 	temp2
.1f2f	d0 eb		bne $1f1c			bne 	_VFSearch 					; if it doesn't, follow the next link.
.1f31	c8		iny				iny 								; same for 2nd byte of name
.1f32	b1 10		lda ($10),y			lda 	(temp1),y
.1f34	c5 13		cmp $13				cmp 	temp2+1
.1f36	d0 e4		bne $1f1c			bne 	_VFSearch
.1f38	18		clc				clc
.1f39	a5 10		lda $10				lda 	temp1 						; make temp1 point to the data at offset 2
.1f3b	69 02		adc #$02			adc 	#2
.1f3d	85 10		sta $10				sta 	temp1
.1f3f	90 02		bcc $1f43			bcc 	_VFNoPage1
.1f41	e6 11		inc $11				inc 	temp1+1
.1f43					_VFNoPage1:
.1f43	28		plp				plp 								; don't need to worry about creation flag
.1f44	60		rts				rts
.1f45					_VFNotFound:
.1f45	28		plp				plp 								; was carry set, e.g. create a new record if not found ?
.1f46	b0 0d		bcs $1f55			bcs 	_VFCreate
.1f48	20 23 10	jsr $1023			jsr 	ErrorHandler
>1f4b	56 41 52 49 41 42 4c 45				.text 	"VARIABLE?",0
>1f53	3f 00
.1f55					_VFCreate:
.1f55	a0 01		ldy #$01			ldy 	#1
.1f57	b2 14		lda ($14)			lda 	(temp3) 					; copy the head link to the first 2 bytes
.1f59	92 0e		sta ($0e)			sta 	(nextFreeMem)
.1f5b	b1 14		lda ($14),y			lda 	(temp3),y
.1f5d	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.1f5f	c8		iny				iny
.1f60	a9 00		lda #$00			lda 	#0	 						; write zero initialised data out.
.1f62	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.1f64	c8		iny				iny
.1f65	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.1f67	c8		iny				iny
.1f68	a5 12		lda $12				lda 	temp2 						; copy the name out
.1f6a	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.1f6c	c8		iny				iny
.1f6d	a5 13		lda $13				lda 	temp2+1
.1f6f	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.1f71	a0 01		ldy #$01			ldy 	#1
.1f73	a5 0e		lda $0e				lda 	nextFreeMem 				; update the head link
.1f75	92 14		sta ($14)			sta 	(temp3)
.1f77	a5 0f		lda $0f				lda 	nextFreeMem+1
.1f79	91 14		sta ($14),y			sta 	(temp3),y
.1f7b	18		clc				clc
.1f7c	a5 0e		lda $0e				lda 	nextFreeMem 				; put nextFreeMem+2 in temp1 (data pointer)
.1f7e	69 02		adc #$02			adc 	#2
.1f80	85 10		sta $10				sta 	temp1
.1f82	a5 0f		lda $0f				lda 	nextFreeMem+1
.1f84	69 00		adc #$00			adc 	#0
.1f86	85 11		sta $11				sta 	temp1+1
.1f88	a9 06		lda #$06			lda 	#6							; shift freemem pointer up 6
.1f8a	a0 00		ldy #$00			ldy 	#0
.1f8c	20 c0 1a	jsr $1ac0			jsr 	AdvanceFreeMem
.1f8f	60		rts				rts
.1f90					VarHandlerDecode:
.1f90	48		pha				pha 								; save, leading space
.1f91	a9 20		lda #$20			lda 	#" "
.1f93	20 c3 1b	jsr $1bc3			jsr 	DecodeWriteBuffer
.1f96	68		pla				pla 								; restore and write type
.1f97	20 c3 1b	jsr $1bc3			jsr 	DecodeWriteBuffer
.1f9a	b1 08		lda ($08),y			lda 	(srcPtr),y 					; copy to temp1
.1f9c	85 10		sta $10				sta 	temp1
.1f9e	c8		iny				iny
.1f9f	b1 08		lda ($08),y			lda 	(srcPtr),y
.1fa1	85 11		sta $11				sta 	temp1+1
.1fa3	a5 10		lda $10				lda 	temp1 						; output the first character
.1fa5	29 1f		and #$1f			and 	#31
.1fa7	20 d2 1f	jsr $1fd2			jsr 	VHOutVarChar
.1faa	a2 05		ldx #$05			ldx 	#5 							; divide temp1 by 32
.1fac					_VHDShift:
.1fac	46 11		lsr $11				lsr 	temp1+1
.1fae	66 10		ror $10				ror 	temp1
.1fb0	ca		dex				dex
.1fb1	d0 f9		bne $1fac			bne 	_VHDShift
.1fb3	a2 ff		ldx #$ff			ldx 	#255 						; now divide that by 40 by repeated subtraction.
.1fb5					_VHDDiv40:
.1fb5	e8		inx				inx
.1fb6	38		sec				sec
.1fb7	a5 10		lda $10				lda 	temp1
.1fb9	e9 28		sbc #$28			sbc 	#40
.1fbb	a8		tay				tay
.1fbc	a5 11		lda $11				lda 	temp1+1
.1fbe	e9 00		sbc #$00			sbc 	#0
.1fc0	90 06		bcc $1fc8			bcc 	_VHDivDone
.1fc2	85 11		sta $11				sta 	temp1+1
.1fc4	84 10		sty $10				sty 	temp1
.1fc6	80 ed		bra $1fb5			bra 	_VHDDiv40
.1fc8					_VHDivDone:
.1fc8	a5 10		lda $10				lda 	temp1 						; remainder
.1fca	20 d2 1f	jsr $1fd2			jsr 	VHOutVarChar
.1fcd	8a		txa				txa
.1fce	20 d2 1f	jsr $1fd2			jsr 	VHOutVarChar 				; and result.
.1fd1	60		rts				rts
.1fd2					VHOutVarChar:
.1fd2	c9 00		cmp #$00			cmp 	#0
.1fd4	f0 0c		beq $1fe2			beq 	_VHOExit
.1fd6	18		clc				clc
.1fd7	69 40		adc #$40			adc 	#64 						; 65-90 A-Z 91-100 0-9
.1fd9	c9 5b		cmp #$5b			cmp 	#91 						; convert back ?
.1fdb	90 02		bcc $1fdf			bcc 	_VHOOut
.1fdd	e9 2b		sbc #$2b			sbc 	#91-48 						; adjust to digit
.1fdf					_VHOOut:
.1fdf	20 c3 1b	jsr $1bc3			jsr 	DecodeWriteBuffer
.1fe2					_VHOExit:
.1fe2	60		rts				rts

;******  Return to file: kernel.asm

.1fe3					Dictionary:

;******  Processing file: generated/dictionary.inc

>1fe3	05					.byte	_end1-*
>1fe4	00					.byte	$00
>1fe5	ff 15					.word	WordWrite
>1fe7	a1					.byte	$a1
.1fe8					_end1:
>1fe8	10					.byte	_end2-*
>1fe9	52					.byte	$52
>1fea	c6 1e					.word	VarWriteHandler
>1fec	dd 1e					.word	VarWriteHandlerDecode
>1fee	24 24 21 48 41 4e 44 4c			.byte	$24,$24,$21,$48,$41,$4e,$44,$4c,$45,$d2
>1ff6	45 d2
.1ff8					_end2:
>1ff8	10					.byte	_end3-*
>1ff9	52					.byte	$52
>1ffa	90 1e					.word	VarAddressHandler
>1ffc	a5 1e					.word	VarAddrHandlerDecode
>1ffe	24 24 26 48 41 4e 44 4c			.byte	$24,$24,$26,$48,$41,$4e,$44,$4c,$45,$d2
>2006	45 d2
.2008					_end3:
>2008	10					.byte	_end4-*
>2009	52					.byte	$52
>200a	aa 1e					.word	VarReadHandler
>200c	c1 1e					.word	VarReadHandlerDecode
>200e	24 24 40 48 41 4e 44 4c			.byte	$24,$24,$40,$48,$41,$4e,$44,$4c,$45,$d2
>2016	45 d2
.2018					_end4:
>2018	0c					.byte	_end5-*
>2019	52					.byte	$52
>201a	47 19					.word	CallHandler
>201c	03 1a					.word	CallHandlerDecode
>201e	24 24 43 41 4c cc			.byte	$24,$24,$43,$41,$4c,$cc
.2024					_end5:
>2024	0f					.byte	_end6-*
>2025	53					.byte	$53
>2026	c0 1d					.word	SkipComment
>2028	cd 1d					.word	CommentDecoder
>202a	24 24 43 4f 4d 4d 45 4e			.byte	$24,$24,$43,$4f,$4d,$4d,$45,$4e,$d4
>2032	d4
.2033					_end6:
>2033	0e					.byte	_end7-*
>2034	53					.byte	$53
>2035	e5 1d					.word	DefineCode
>2037	f4 1d					.word	DefineDecoder
>2039	24 24 44 45 46 49 4e c5			.byte	$24,$24,$44,$45,$46,$49,$4e,$c5
.2041					_end7:
>2041	0f					.byte	_end8-*
>2042	52					.byte	$52
>2043	89 10					.word	Literal2Byte
>2045	9f 10					.word	Literal2ByteDecode
>2047	24 24 4c 49 54 45 52 41			.byte	$24,$24,$4c,$49,$54,$45,$52,$41,$cc
>204f	cc
.2050					_end8:
>2050	0e					.byte	_end9-*
>2051	80					.byte	$80
>2052	a9 1d					.word	NextLine
>2054	24 24 4e 45 58 54 4c 49			.byte	$24,$24,$4e,$45,$58,$54,$4c,$49,$4e,$c5
>205c	4e c5
.205e					_end9:
>205e	0e					.byte	_end10-*
>205f	53					.byte	$53
>2060	b1 10					.word	LiteralString
>2062	d0 10					.word	LiteralStringDecoder
>2064	24 24 53 54 52 49 4e c7			.byte	$24,$24,$53,$54,$52,$49,$4e,$c7
.206c					_end10:
>206c	05					.byte	_end11-*
>206d	00					.byte	$00
>206e	7b 13					.word	Multiply16x16
>2070	aa					.byte	$aa
.2071					_end11:
>2071	05					.byte	_end12-*
>2072	00					.byte	$00
>2073	e8 11					.word	Add
>2075	ab					.byte	$ab
.2076					_end12:
>2076	06					.byte	_end13-*
>2077	00					.byte	$00
>2078	10 16					.word	WordAdd
>207a	2b a1					.byte	$2b,$a1
.207c					_end13:
>207c	05					.byte	_end14-*
>207d	00					.byte	$00
>207e	f7 11					.word	Subtract
>2080	ad					.byte	$ad
.2081					_end14:
>2081	06					.byte	_end15-*
>2082	00					.byte	$00
>2083	b7 14					.word	ConstantMinus1
>2085	2d b1					.byte	$2d,$b1
.2087					_end15:
>2087	05					.byte	_end16-*
>2088	00					.byte	$00
>2089	cc 12					.word	Divide16x16
>208b	af					.byte	$af
.208c					_end16:
>208c	05					.byte	_end17-*
>208d	00					.byte	$00
>208e	aa 14					.word	Constant0
>2090	b0					.byte	$b0
.2091					_end17:
>2091	06					.byte	_end18-*
>2092	00					.byte	$00
>2093	10 14					.word	CheckMinus
>2095	30 bc					.byte	$30,$bc
.2097					_end18:
>2097	06					.byte	_end19-*
>2098	00					.byte	$00
>2099	24 14					.word	CheckZero
>209b	30 bd					.byte	$30,$bd
.209d					_end19:
>209d	05					.byte	_end20-*
>209e	00					.byte	$00
>209f	c6 14					.word	C1
>20a1	b1					.byte	$b1
.20a2					_end20:
>20a2	06					.byte	_end21-*
>20a3	00					.byte	$00
>20a4	ba 13					.word	Unary1Plus
>20a6	31 ab					.byte	$31,$ab
.20a8					_end21:
>20a8	06					.byte	_end22-*
>20a9	00					.byte	$00
>20aa	d1 13					.word	Unary1Minus
>20ac	31 ad					.byte	$31,$ad
.20ae					_end22:
>20ae	06					.byte	_end23-*
>20af	00					.byte	$00
>20b0	de 14					.word	C10
>20b2	31 b0					.byte	$31,$b0
.20b4					_end23:
>20b4	07					.byte	_end24-*
>20b5	00					.byte	$00
>20b6	07 15					.word	C100
>20b8	31 30 b0				.byte	$31,$30,$b0
.20bb					_end24:
>20bb	08					.byte	_end25-*
>20bc	00					.byte	$00
>20bd	36 15					.word	C1024
>20bf	31 30 32 b4				.byte	$31,$30,$32,$b4
.20c3					_end25:
>20c3	07					.byte	_end26-*
>20c4	00					.byte	$00
>20c5	0b 15					.word	C127
>20c7	31 32 b7				.byte	$31,$32,$b7
.20ca					_end26:
>20ca	07					.byte	_end27-*
>20cb	00					.byte	$00
>20cc	0f 15					.word	C128
>20ce	31 32 b8				.byte	$31,$32,$b8
.20d1					_end27:
>20d1	06					.byte	_end28-*
>20d2	00					.byte	$00
>20d3	e2 14					.word	C15
>20d5	31 b5					.byte	$31,$b5
.20d7					_end28:
>20d7	06					.byte	_end29-*
>20d8	00					.byte	$00
>20d9	e6 14					.word	C16
>20db	31 b6					.byte	$31,$b6
.20dd					_end29:
>20dd	07					.byte	_end30-*
>20de	00					.byte	$00
>20df	48 14					.word	Times16
>20e1	31 36 aa				.byte	$31,$36,$aa
.20e4					_end30:
>20e4	07					.byte	_end31-*
>20e5	00					.byte	$00
>20e6	5b 14					.word	Divide16
>20e8	31 36 af				.byte	$31,$36,$af
.20eb					_end31:
>20eb	05					.byte	_end32-*
>20ec	00					.byte	$00
>20ed	ca 14					.word	C2
>20ef	b2					.byte	$b2
.20f0					_end32:
>20f0	06					.byte	_end33-*
>20f1	00					.byte	$00
>20f2	54 14					.word	Times2
>20f4	32 aa					.byte	$32,$aa
.20f6					_end33:
>20f6	06					.byte	_end34-*
>20f7	00					.byte	$00
>20f8	c3 13					.word	Unary2Plus
>20fa	32 ab					.byte	$32,$ab
.20fc					_end34:
>20fc	06					.byte	_end35-*
>20fd	00					.byte	$00
>20fe	dc 13					.word	Unary2Minus
>2100	32 ad					.byte	$32,$ad
.2102					_end35:
>2102	06					.byte	_end36-*
>2103	00					.byte	$00
>2104	67 14					.word	Divide2
>2106	32 af					.byte	$32,$af
.2108					_end36:
>2108	06					.byte	_end37-*
>2109	00					.byte	$00
>210a	ea 14					.word	C24
>210c	32 b4					.byte	$32,$b4
.210e					_end37:
>210e	07					.byte	_end38-*
>210f	00					.byte	$00
>2110	13 15					.word	C255
>2112	32 35 b5				.byte	$32,$35,$b5
.2115					_end38:
>2115	07					.byte	_end39-*
>2116	00					.byte	$00
>2117	1e 15					.word	C256
>2119	32 35 b6				.byte	$32,$35,$b6
.211c					_end39:
>211c	08					.byte	_end40-*
>211d	00					.byte	$00
>211e	6e 14					.word	Times256
>2120	32 35 36 aa				.byte	$32,$35,$36,$aa
.2124					_end40:
>2124	08					.byte	_end41-*
>2125	00					.byte	$00
>2126	77 14					.word	Divide256
>2128	32 35 36 af				.byte	$32,$35,$36,$af
.212c					_end41:
>212c	05					.byte	_end42-*
>212d	00					.byte	$00
>212e	ce 14					.word	C3
>2130	b3					.byte	$b3
.2131					_end42:
>2131	06					.byte	_end43-*
>2132	00					.byte	$00
>2133	fb 14					.word	C32
>2135	33 b2					.byte	$33,$b2
.2137					_end43:
>2137	09					.byte	_end44-*
>2138	00					.byte	$00
>2139	4e 15					.word	C32767
>213b	33 32 37 36 b7				.byte	$33,$32,$37,$36,$b7
.2140					_end44:
>2140	09					.byte	_end45-*
>2141	00					.byte	$00
>2142	5a 15					.word	C32768
>2144	33 32 37 36 b8				.byte	$33,$32,$37,$36,$b8
.2149					_end45:
>2149	05					.byte	_end46-*
>214a	00					.byte	$00
>214b	d2 14					.word	C4
>214d	b4					.byte	$b4
.214e					_end46:
>214e	06					.byte	_end47-*
>214f	00					.byte	$00
>2150	50 14					.word	Times4
>2152	34 aa					.byte	$34,$aa
.2154					_end47:
>2154	06					.byte	_end48-*
>2155	00					.byte	$00
>2156	63 14					.word	Divide4
>2158	34 af					.byte	$34,$af
.215a					_end48:
>215a	08					.byte	_end49-*
>215b	00					.byte	$00
>215c	42 15					.word	C4096
>215e	34 30 39 b6				.byte	$34,$30,$39,$b6
.2162					_end49:
>2162	05					.byte	_end50-*
>2163	00					.byte	$00
>2164	d6 14					.word	C5
>2166	b5					.byte	$b5
.2167					_end50:
>2167	07					.byte	_end51-*
>2168	00					.byte	$00
>2169	2a 15					.word	C512
>216b	35 31 b2				.byte	$35,$31,$b2
.216e					_end51:
>216e	06					.byte	_end52-*
>216f	00					.byte	$00
>2170	ff 14					.word	C63
>2172	36 b3					.byte	$36,$b3
.2174					_end52:
>2174	06					.byte	_end53-*
>2175	00					.byte	$00
>2176	03 15					.word	C64
>2178	36 b4					.byte	$36,$b4
.217a					_end53:
>217a	05					.byte	_end54-*
>217b	00					.byte	$00
>217c	da 14					.word	C8
>217e	b8					.byte	$b8
.217f					_end54:
>217f	06					.byte	_end55-*
>2180	00					.byte	$00
>2181	4c 14					.word	Times8
>2183	38 aa					.byte	$38,$aa
.2185					_end55:
>2185	06					.byte	_end56-*
>2186	00					.byte	$00
>2187	5f 14					.word	Divide8
>2189	38 af					.byte	$38,$af
.218b					_end56:
>218b	05					.byte	_end57-*
>218c	40					.byte	$40
>218d	cc 19					.word	ReturnHandler
>218f	bb					.byte	$bb
.2190					_end57:
>2190	05					.byte	_end58-*
>2191	00					.byte	$00
>2192	68 12					.word	CheckLess
>2194	bc					.byte	$bc
.2195					_end58:
>2195	06					.byte	_end59-*
>2196	00					.byte	$00
>2197	81 12					.word	CheckLessEq
>2199	3c bd					.byte	$3c,$bd
.219b					_end59:
>219b	06					.byte	_end60-*
>219c	00					.byte	$00
>219d	31 12					.word	CheckNotEqual
>219f	3c be					.byte	$3c,$be
.21a1					_end60:
>21a1	05					.byte	_end61-*
>21a2	00					.byte	$00
>21a3	34 12					.word	CheckEqual
>21a5	bd					.byte	$bd
.21a6					_end61:
>21a6	05					.byte	_end62-*
>21a7	00					.byte	$00
>21a8	84 12					.word	CheckGreater
>21aa	be					.byte	$be
.21ab					_end62:
>21ab	06					.byte	_end63-*
>21ac	00					.byte	$00
>21ad	65 12					.word	CheckGreaterEq
>21af	3e bd					.byte	$3e,$bd
.21b1					_end63:
>21b1	08					.byte	_end64-*
>21b2	00					.byte	$00
>21b3	6f 15					.word	TestDup
>21b5	3f 44 55 d0				.byte	$3f,$44,$55,$d0
.21b9					_end64:
>21b9	05					.byte	_end65-*
>21ba	00					.byte	$00
>21bb	e4 15					.word	WordRead
>21bd	c0					.byte	$c0
.21be					_end65:
>21be	07					.byte	_end66-*
>21bf	00					.byte	$00
>21c0	ea 13					.word	Absolute
>21c2	41 42 d3				.byte	$41,$42,$d3
.21c5					_end66:
>21c5	09					.byte	_end67-*
>21c6	00					.byte	$00
>21c7	27 16					.word	AllocateMemory
>21c9	41 4c 4c 4f c3				.byte	$41,$4c,$4c,$4f,$c3
.21ce					_end67:
>21ce	07					.byte	_end68-*
>21cf	00					.byte	$00
>21d0	0a 12					.word	And
>21d2	41 4e c4				.byte	$41,$4e,$c4
.21d5					_end68:
>21d5	0a					.byte	_end69-*
>21d6	00					.byte	$00
>21d7	a6 1c					.word	AssertCode
>21d9	41 53 53 45 52 d4			.byte	$41,$53,$53,$45,$52,$d4
.21df					_end69:
>21df	09					.byte	_end70-*
>21e0	00					.byte	$00
>21e1	3d 14					.word	ByteSwap
>21e3	42 53 57 41 d0				.byte	$42,$53,$57,$41,$d0
.21e8					_end70:
>21e8	06					.byte	_end71-*
>21e9	00					.byte	$00
>21ea	f2 15					.word	ByteWrite
>21ec	43 a1					.byte	$43,$a1
.21ee					_end71:
>21ee	06					.byte	_end72-*
>21ef	00					.byte	$00
>21f0	db 15					.word	ByteRead
>21f2	43 c0					.byte	$43,$c0
.21f4					_end72:
>21f4	07					.byte	_end73-*
>21f5	00					.byte	$00
>21f6	8d 1a					.word	ClrHandler
>21f8	43 4c d2				.byte	$43,$4c,$d2
.21fb					_end73:
>21fb	08					.byte	_end74-*
>21fc	00					.byte	$00
>21fd	66 15					.word	Drop
>21ff	44 52 4f d0				.byte	$44,$52,$4f,$d0
.2203					_end74:
>2203	07					.byte	_end75-*
>2204	00					.byte	$00
>2205	78 15					.word	Dup
>2207	44 55 d0				.byte	$44,$55,$d0
.220a					_end75:
>220a	08					.byte	_end76-*
>220b	01					.byte	$01
>220c	19 19					.word	ElseHandler
>220e	45 4c 53 c5				.byte	$45,$4c,$53,$c5
.2212					_end76:
>2212	07					.byte	_end77-*
>2213	00					.byte	$00
>2214	c7 1c					.word	EndProgram
>2216	45 4e c4				.byte	$45,$4e,$c4
.2219					_end77:
>2219	09					.byte	_end78-*
>221a	00					.byte	$00
>221b	1c 19					.word	EndIfHandler
>221d	45 4e 44 49 c6				.byte	$45,$4e,$44,$49,$c6
.2222					_end78:
>2222	07					.byte	_end79-*
>2223	00					.byte	$00
>2224	91 18					.word	ForHandler
>2226	46 4f d2				.byte	$46,$4f,$d2
.2229					_end79:
>2229	06					.byte	_end80-*
>222a	01					.byte	$01
>222b	16 19					.word	IfHandler
>222d	49 c6					.byte	$49,$c6
.222f					_end80:
>222f	09					.byte	_end81-*
>2230	00					.byte	$00
>2231	f5 18					.word	GetIndex
>2233	49 4e 44 45 d8				.byte	$49,$4e,$44,$45,$d8
.2238					_end81:
>2238	08					.byte	_end82-*
>2239	00					.byte	$00
>223a	02 1c					.word	ListCode
>223c	4c 49 53 d4				.byte	$4c,$49,$53,$d4
.2240					_end82:
>2240	07					.byte	_end83-*
>2241	00					.byte	$00
>2242	a1 12					.word	Maximum
>2244	4d 41 d8				.byte	$4d,$41,$d8
.2247					_end83:
>2247	07					.byte	_end84-*
>2248	00					.byte	$00
>2249	9d 12					.word	Minimum
>224b	4d 49 ce				.byte	$4d,$49,$ce
.224e					_end84:
>224e	07					.byte	_end85-*
>224f	00					.byte	$00
>2250	dd 12					.word	Modulus16x16
>2252	4d 4f c4				.byte	$4d,$4f,$c4
.2255					_end85:
>2255	0a					.byte	_end86-*
>2256	00					.byte	$00
>2257	f1 13					.word	Negate
>2259	4e 45 47 41 54 c5			.byte	$4e,$45,$47,$41,$54,$c5
.225f					_end86:
>225f	07					.byte	_end87-*
>2260	00					.byte	$00
>2261	84 1a					.word	NewHandler
>2263	4e 45 d7				.byte	$4e,$45,$d7
.2266					_end87:
>2266	08					.byte	_end88-*
>2267	01					.byte	$01
>2268	bf 18					.word	NextHandler
>226a	4e 45 58 d4				.byte	$4e,$45,$58,$d4
.226e					_end88:
>226e	07					.byte	_end89-*
>226f	00					.byte	$00
>2270	ac 15					.word	Nip
>2272	4e 49 d0				.byte	$4e,$49,$d0
.2275					_end89:
>2275	07					.byte	_end90-*
>2276	00					.byte	$00
>2277	01 14					.word	OneComplement
>2279	4e 4f d4				.byte	$4e,$4f,$d4
.227c					_end90:
>227c	06					.byte	_end91-*
>227d	00					.byte	$00
>227e	24 12					.word	LogOr
>2280	4f d2					.byte	$4f,$d2
.2282					_end91:
>2282	08					.byte	_end92-*
>2283	00					.byte	$00
>2284	94 15					.word	Over
>2286	4f 56 45 d2				.byte	$4f,$56,$45,$d2
.228a					_end92:
>228a	0a					.byte	_end93-*
>228b	00					.byte	$00
>228c	1f 19					.word	RepeatHandler
>228e	52 45 50 45 41 d4			.byte	$52,$45,$50,$45,$41,$d4
.2294					_end93:
>2294	07					.byte	_end94-*
>2295	00					.byte	$00
>2296	80 14					.word	RandomNumber
>2298	52 4e c4				.byte	$52,$4e,$c4
.229b					_end94:
>229b	07					.byte	_end95-*
>229c	00					.byte	$00
>229d	b1 15					.word	Rot
>229f	52 4f d4				.byte	$52,$4f,$d4
.22a2					_end95:
>22a2	07					.byte	_end96-*
>22a3	00					.byte	$00
>22a4	7f 1c					.word	RunProgram
>22a6	52 55 ce				.byte	$52,$55,$ce
.22a9					_end96:
>22a9	07					.byte	_end97-*
>22aa	00					.byte	$00
>22ab	2c 14					.word	SignTOS
>22ad	53 47 ce				.byte	$53,$47,$ce
.22b0					_end97:
>22b0	08					.byte	_end98-*
>22b1	00					.byte	$00
>22b2	bf 1c					.word	StopCode
>22b4	53 54 4f d0				.byte	$53,$54,$4f,$d0
.22b8					_end98:
>22b8	08					.byte	_end99-*
>22b9	00					.byte	$00
>22ba	81 15					.word	Swap
>22bc	53 57 41 d0				.byte	$53,$57,$41,$d0
.22c0					_end99:
>22c0	07					.byte	_end100-*
>22c1	00					.byte	$00
>22c2	8f 1c					.word	Call6502
>22c4	53 59 d3				.byte	$53,$59,$d3
.22c7					_end100:
>22c7	0d					.byte	_end101-*
>22c8	00					.byte	$00
>22c9	07 1e					.word	IntToString
>22cb	54 4f 2e 53 54 52 49 4e			.byte	$54,$4f,$2e,$53,$54,$52,$49,$4e,$c7
>22d3	c7
.22d4					_end101:
>22d4	09					.byte	_end102-*
>22d5	01					.byte	$01
>22d6	22 19					.word	UntilHandler
>22d8	55 4e 54 49 cc				.byte	$55,$4e,$54,$49,$cc
.22dd					_end102:
>22dd	09					.byte	_end103-*
>22de	00					.byte	$00
>22df	ca 1c					.word	VlistCode
>22e1	56 4c 49 53 d4				.byte	$56,$4c,$49,$53,$d4
.22e6					_end103:
>22e6	0a					.byte	_end104-*
>22e7	40					.byte	$40
>22e8	d1 1a					.word	BreakCmd
>22ea	58 42 52 45 41 cb			.byte	$58,$42,$52,$45,$41,$cb
.22f0					_end104:
>22f0	09					.byte	_end105-*
>22f1	00					.byte	$00
>22f2	cb 1a					.word	ExitDump
>22f4	58 44 55 4d d0				.byte	$58,$44,$55,$4d,$d0
.22f9					_end105:
>22f9	07					.byte	_end106-*
>22fa	00					.byte	$00
>22fb	17 12					.word	Xor
>22fd	58 4f d2				.byte	$58,$4f,$d2
.2300					_end106:
>2300	00					.byte	0

;******  Return to file: kernel.asm

.2301					EncodeTest:
.2301	a9 1b		lda #$1b			lda 	#(EncodeTestLine & $FF)
.2303	a0 23		ldy #$23			ldy 	#(EncodeTestLine >> 8)
.2305	20 3d 16	jsr $163d			jsr 	EncodeProgram
.2308	a9 10		lda #$10			lda 	#(textBuffer) & $FF
.230a	85 0a		sta $0a				sta 	0+(bufPtr)
.230c	a9 08		lda #$08			lda 	#(textBuffer) >> 8
.230e	85 0b		sta $0b				sta 	1+(bufPtr)
.2310	a0 09		ldy #$09			ldy 	#encodeBuffer>>8
.2312	a9 10		lda #$10			lda 	#encodeBuffer & $FF
.2314	38		sec				sec
.2315	20 d5 1a	jsr $1ad5			jsr 	DecodeLineIntoBufPtr
.2318	4c ff ff	jmp $ffff			jmp 	$FFFF
.231b					EncodeTestLine:

;******  Processing file: generated/edtext.inc

>231b	36 31 34 37 39 20 43 56			.byte $36,$31,$34,$37,$39,$20,$43,$56,$20,$31,$35,$33,$32,$31,$20,$22,$59,$38,$35,$4a,$42,$35,$4d,$22,$20,$32,$37,$39,$39,$34,$20,$32,$38,$32,$37,$35,$20,$58,$4e,$4b,$45,$4f,$5a,$35,$20,$22,$4a,$33,$4b,$45,$41,$58,$22,$20,$32,$34,$39,$30,$37,$20,$32,$31,$30,$39,$20,$2d,$31,$30,$34,$34,$32,$20,$42,$53,$57,$41,$50,$20,$2d,$32,$39,$37,$37,$20,$3b,$20,$48,$52,$4d,$4d,$55,$5a,$20,$43,$56,$20,$22,$44,$51,$34,$22,$20,$2d,$33,$32,$36,$35,$30,$20,$22,$4d,$30,$33,$57,$51,$4f,$51,$22,$20,$22,$48,$4a,$49,$43,$22,$20,$43,$56,$20,$22,$22,$20,$2d,$31,$37,$32,$35,$32,$20,$33,$32,$37,$36,$37,$20,$22,$55,$4d,$34,$4e,$47,$4d,$38,$45,$22,$20,$2d,$31,$30,$32,$36,$32,$20,$2d,$31,$35,$38,$34,$30,$20,$22,$51,$39,$4d,$42,$47,$55,$5a,$43,$36,$22,$20,$22,$46,$59,$38,$35,$42,$22,$20,$30,$20,$2d,$31,$30,$30,$37,$39,$20,$35,$38,$36,$34,$20,$2d,$31,$20,$22,$4c,$32,$41,$49,$57,$36,$51,$22,$20,$58,$4e,$4b,$45,$4f,$5a,$35,$20,$20,$00
>2323	20 31 35 33 32 31 20 22 59 38 35 4a 42 35 4d 22
>2333	20 32 37 39 39 34 20 32 38 32 37 35 20 58 4e 4b
>2343	45 4f 5a 35 20 22 4a 33 4b 45 41 58 22 20 32 34
>2353	39 30 37 20 32 31 30 39 20 2d 31 30 34 34 32 20
>2363	42 53 57 41 50 20 2d 32 39 37 37 20 3b 20 48 52
>2373	4d 4d 55 5a 20 43 56 20 22 44 51 34 22 20 2d 33
>2383	32 36 35 30 20 22 4d 30 33 57 51 4f 51 22 20 22
>2393	48 4a 49 43 22 20 43 56 20 22 22 20 2d 31 37 32
>23a3	35 32 20 33 32 37 36 37 20 22 55 4d 34 4e 47 4d
>23b3	38 45 22 20 2d 31 30 32 36 32 20 2d 31 35 38 34
>23c3	30 20 22 51 39 4d 42 47 55 5a 43 36 22 20 22 46
>23d3	59 38 35 42 22 20 30 20 2d 31 30 30 37 39 20 35
>23e3	38 36 34 20 2d 31 20 22 4c 32 41 49 57 36 51 22
>23f3	20 58 4e 4b 45 4f 5a 35 20 20 00

;******  Return to file: kernel.asm

>3fff	ff						.byte 	$FF
.4000					ProgramMemory:

;******  End of listing
