
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -q -c -D encode=1 -o kernel_nocode.prg -L kernel.lst -l kernel.lbl kernel.asm
; Sat Jan 11 17:14:50 2020

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=1					encode=1

;******  Processing input file: kernel.asm

=$1000					RplBuild = $1000 							; code starts here.

;******  Processing file: data.asm

.0000					Next:
>0000							.fill 	5
=3					IP = Next+3 								; the IP which points to the current instruction
.0005					rsp:
>0005							.byte 	?
.0006					tos:
>0006							.word 	?
.0008					srcPtr:
>0008							.word 	?
.000a					bufPtr:
>000a							.word 	?
.000c					matchPtr:
>000c							.word 	?
.000e					nextFreeMem:
>000e							.word 	?
.0010					temp1:
>0010							.word 	?
.0012					temp2:
>0012							.word 	?
.0014					temp3:
>0014							.word 	?
.0016					temp4:
>0016							.word 	?
.0018					listPtr:
>0018							.word 	?
.001a					SignCount:
>001a							.byte 	?
.001b					RandomSeed:
>001b							.word 	?
.001d					ListCount:
>001d							.byte 	?
.001e					ListLowest:
>001e							.word 	?
=$102					stack2Low = $102							; access other stack members following tsx
=$101					stack2High = $101							; (which requires saving X, not on the stack !)
=$104					stack3Low = $104
=$103					stack3High = $103
=$600					azVariables = $600 							; 26 x 2 variables occupying 52 bytes * PAGE BOUNDARY *
=16					hashTableSize = 16 							; hash tables for variables.
=$640					hashTable = $640 							; hash tables start here * ALL ON ONE PAGE *
=$810					textBuffer = $810 							; buffer for text.
=$700					returnStack = $700							; return stack (1 page)
=$700					returnStackLow = returnStack
=1856					returnStackHigh = returnStack+$40
=1920					returnStackX = returnStack+$80
=$80					NumberStackBase = $80 						; number stack down from here.
=$910					encodeBuffer = $910 						; buffer for encoded program
=0					COL_BLACK = 0
=1					COL_RED = 1
=2					COL_GREEN = 2
=3					COL_YELLOW = 3
=4					COL_BLUE = 4
=5					COL_MAGENTA = 5
=6					COL_CYAN = 6
=7					COL_WHITE = 7
=8					COL_RVS = 8
=2					CTH_LineNo = COL_Green
=6					CTH_Keyword = COL_Cyan
=11					CTH_Comment = COL_Yellow+COL_Rvs
=7					CTH_Definition = COL_White
=5					CTH_String = COL_Magenta
=3					CTH_Call = COL_Yellow

;******  Return to file: kernel.asm

.1000	a2 ff		ldx #$ff			ldx 	#$FF 						; reset the stack
.1002	9a		txs				txs
.1003	20 df 10	jsr $10df			jsr 	ExternInitialise
.1006	a9 26		lda #$26			lda 	#BootMsg & $FF
.1008	a0 10		ldy #$10			ldy 	#BootMsg >> 8
.100a	20 cf 11	jsr $11cf			jsr 	EXPrintString
.100d					WarmStartBlankStack:
.100d	a2 80		ldx #$80			ldx 	#NumberStackBase
.100f	9a		txs				txs
.1010	4c b3 22	jmp $22b3			jmp 	EncodeTest
.1013					WarmStart:
.1013	a9 03		lda #$03			lda 	#COL_Yellow
.1015	20 16 11	jsr $1116			jsr 	ExternColour
.1018	20 39 11	jsr $1139			jsr 	ExternInput
.101b	a9 06		lda #$06			lda 	#COL_Cyan
.101d	20 16 11	jsr $1116			jsr 	ExternColour
.1020	4c 33 1c	jmp $1c33			jmp 	RunProgram
.1023					ErrorHandler:
>1023	ff						.byte 	$FF
.1024	a2 5e		ldx #$5e			ldx 	#$5E
.1026					BootMsg:
>1026	2a 2a 2a 20 52 50 4c 2f				.text 	"*** RPL/C INTERPRETER ***",13,13
>102e	43 20 49 4e 54 45 52 50 52 45 54 45 52 20 2a 2a
>103e	2a 0d 0d
>1041	57 52 49 54 54 45 4e 20				.text	"WRITTEN BY PAUL ROBSON 2020",13,13
>1049	42 59 20 50 41 55 4c 20 52 4f 42 53 4f 4e 20 32
>1059	30 32 30 0d 0d
>105e	42 55 49 4c 44 3a 20				.text 	"BUILD: "

;******  Processing file: generated/timestamp.inc

>1065	5b 32 30 2d 30 31 2d 31			.text	"[20-01-11 17:14]"
>106d	31 20 31 37 3a 31 34 5d

;******  Return to file: kernel.asm

>1075	0d 0d 00					.byte 	13,13,0

;******  Processing file: core.src

.1078					InitialiseCoreCode:
.1078	a9 e8		lda #$e8			lda 	#$E8 					; Copy INX INX 			4 cycles when run
.107a	85 00		sta $00				sta 	Next
.107c	85 01		sta $01				sta 	Next+1
.107e	a9 7c		lda #$7c			lda 	#$7C 					; Copy JMP ($aaaa,x) 	6 cycles when run
.1080	85 02		sta $02				sta 	Next+2
.1082	86 03		stx $03				stx 	Next+3 					; set the indirect address (IP)
.1084	84 04		sty $04				sty 	Next+4
.1086	a2 01		ldx #$01			ldx 	#1 						; set up to run from provided word.
.1088	60		rts				rts								; (2 INX skip offset and line#)
.1089					Literal2Byte:
.1089	a5 06		lda $06				lda 	TOS
.108b	48		pha				pha
.108c	a5 07		lda $07				lda 	TOS+1
.108e	48		pha				pha
.108f	e8		inx				inx  							; point X to the word
.1090	e8		inx				inx
.1091	8a		txa				txa 							; copy into Y
.1092	a8		tay				tay
.1093	b1 03		lda ($03),y			lda 	(IP),y 					; read it. the LSB
.1095	85 06		sta $06				sta 	TOS
.1097	c8		iny				iny 							; read and push the MSB
.1098	b1 03		lda ($03),y			lda 	(IP),y
.109a	85 07		sta $07				sta 	TOS+1
.109c	4c 00 00	jmp $0000			jmp 	Next
.109f					Literal2ByteDecode:
.109f	a9 06		lda #$06			lda 	#CTH_Keyword
.10a1	20 77 1b	jsr $1b77			jsr 	DecodeWriteBuffer
.10a4	b1 08		lda ($08),y			lda 	(srcPtr),y
.10a6	aa		tax				tax
.10a7	c8		iny				iny
.10a8	b1 08		lda ($08),y			lda 	(srcPtr),y
.10aa	a8		tay				tay
.10ab	8a		txa				txa
.10ac	38		sec				sec 							; output signed
.10ad	20 99 1b	jsr $1b99			jsr 	DecodeYAToBuffer
.10b0	60		rts				rts
.10b1					LiteralString:
.10b1	a5 06		lda $06				lda 	TOS
.10b3	48		pha				pha
.10b4	a5 07		lda $07				lda 	TOS+1
.10b6	48		pha				pha
.10b7	e8		inx				inx
.10b8	e8		inx				inx 							; skip over current word
.10b9	8a		txa				txa 							; add to IP + 1 to give string address
.10ba	a8		tay				tay 							; put in Y
.10bb	38		sec				sec 							; make that TOS
.10bc	65 03		adc $03				adc 	IP
.10be	85 06		sta $06				sta 	TOS
.10c0	a5 04		lda $04				lda 	IP+1
.10c2	69 00		adc #$00			adc 	#0
.10c4	85 07		sta $07				sta 	TOS+1
.10c6	8a		txa				txa 							; add data length to X
.10c7	18		clc				clc
.10c8	71 03		adc ($03),y			adc 	(IP),y
.10ca	aa		tax				tax
.10cb	4c 02 00	jmp $0002			jmp 	Next+2 					; jump without pre-increment
.10ce					LiteralStringDecoder:
.10ce	a9 05		lda #$05			lda 	#CTH_String
.10d0	20 77 1b	jsr $1b77			jsr 	DecodeWriteBuffer
.10d3	a9 22		lda #$22			lda 	#'"'
.10d5	20 77 1b	jsr $1b77			jsr 	DecodeWriteBuffer
.10d8	20 80 1b	jsr $1b80			jsr 	DecodeOutputData
.10db	20 77 1b	jsr $1b77			jsr 	DecodeWriteBuffer
.10de	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: extern.asm

.10df					ExternInitialise:
.10df	a9 90		lda #$90			lda 	#144 						; set colour
.10e1	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.10e4	a9 01		lda #$01			lda 	#$01
.10e6	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.10e9	a9 0e		lda #$0e			lda 	#14							; lower case
.10eb	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.10ee	a9 93		lda #$93			lda 	#147 						; clear screen
.10f0	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.10f3	a9 07		lda #$07			lda 	#COL_WHITE 					; white text.
.10f5	4c 16 11	jmp $1116			jmp 	ExternColour
.10f8					ExternCheckBreak:
.10f8	da		phx				phx 								; make sure we keep XY
.10f9	5a		phy				phy
.10fa	20 e1 ff	jsr $ffe1			jsr 	$FFE1						; STOP check on CBM KERNAL
.10fd	f0 03		beq $1102			beq		_ECBExit 					; stopped
.10ff	7a		ply				ply 								; restore and exit.
.1100	fa		plx				plx
.1101	60		rts				rts
.1102					_ECBExit:
.1102	20 23 10	jsr $1023			jsr 	ErrorHandler
>1105	45 53 43 41 50 45 00				.text 	"ESCAPE",0
.110c					ExternPrint:
.110c	48		pha				pha
.110d	da		phx				phx
.110e	5a		phy				phy
.110f	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.1112	7a		ply				ply
.1113	fa		plx				plx
.1114	68		pla				pla
.1115	60		rts				rts
.1116					ExternColour:
.1116	48		pha				pha
.1117	da		phx				phx
.1118	48		pha				pha
.1119	29 08		and #$08			and 	#8
.111b	0a		asl a				asl 	a
.111c	0a		asl a				asl 	a
.111d	0a		asl a				asl 	a
.111e	0a		asl a				asl 	a
.111f	49 92		eor #$92			eor 	#$92
.1121	20 0c 11	jsr $110c			jsr 	ExternPrint
.1124	68		pla				pla
.1125	29 07		and #$07			and 	#7
.1127	aa		tax				tax
.1128	bd 31 11	lda $1131,x			lda 	_ECTable,x
.112b	20 0c 11	jsr $110c			jsr 	ExternPrint
.112e	fa		plx				plx
.112f	68		pla				pla
.1130	60		rts				rts
.1131					_ECTable:
>1131	90						.byte 	144
>1132	1c						.byte 	28
>1133	1e						.byte 	30
>1134	9e						.byte 	158
>1135	1f						.byte 	31
>1136	9c						.byte 	156
>1137	9f						.byte 	159
>1138	05						.byte 	5
.1139					ExternInput:
.1139	a9 10		lda #$10			lda 	#(textBuffer & $FF)
.113b	85 14		sta $14				sta 	temp3
.113d	a9 08		lda #$08			lda 	#(textBuffer >> 8)
.113f	85 15		sta $15				sta 	temp3+1
.1141	20 cf ff	jsr $ffcf	_EIRead:jsr 	$FFCF
.1144	29 7f		and #$7f			and 	#$7F
.1146	c9 0d		cmp #$0d			cmp 	#13
.1148	f0 0a		beq $1154			beq 	_EIExit
.114a	92 14		sta ($14)			sta 	(temp3)
.114c	e6 14		inc $14				inc 	temp3
.114e	d0 f1		bne $1141			bne 	_EIRead
.1150	e6 15		inc $15				inc 	temp3+1
.1152	80 ed		bra $1141			bra 	_EIRead
.1154	a9 00		lda #$00	_EIExit:lda 	#0
.1156	92 14		sta ($14)			sta 	(temp3)
.1158	a9 0d		lda #$0d			lda 	#13
.115a	20 0c 11	jsr $110c			jsr 	ExternPrint
.115d	60		rts				rts
.115e					ExternSave:
.115e	da		phx				phx
.115f	5a		phy				phy
.1160	85 12		sta $12				sta 	temp2 						; save start
.1162	84 13		sty $13				sty 	temp2+1
.1164	20 c6 11	jsr $11c6			jsr 	EXGetLength 				; get length of file into A
.1167	a6 14		ldx $14				ldx 	temp3
.1169	a4 15		ldy $15				ldy 	temp3+1
.116b	20 bd ff	jsr $ffbd			jsr 	$FFBD 						; set name
.116e	a9 01		lda #$01			lda 	#1
.1170	a2 08		ldx #$08			ldx 	#8	 						; device #8
.1172	a0 00		ldy #$00			ldy 	#0
.1174	20 ba ff	jsr $ffba			jsr 	$FFBA 						; set LFS
.1177	a6 10		ldx $10				ldx 	temp1 						; end address
.1179	a4 11		ldy $11				ldy 	temp1+1
.117b	a9 12		lda #$12			lda 	#temp2
.117d	20 d8 ff	jsr $ffd8			jsr 	$FFD8 						; save
.1180	b0 03		bcs $1185			bcs 	_ESSave
.1182	7a		ply				ply
.1183	fa		plx				plx
.1184	60		rts				rts
.1185					_ESSave:
.1185	20 23 10	jsr $1023			jsr 	ErrorHandler
>1188	53 41 56 45 20 46 41 49				.text 	"SAVE FAILED",0
>1190	4c 45 44 00
.1194					ExternLoad:
.1194	da		phx				phx 								; save XY
.1195	5a		phy				phy
.1196	48		pha				pha 								; save target
.1197	5a		phy				phy
.1198	20 c6 11	jsr $11c6			jsr 	EXGetLength 				; get length of file into A
.119b	a6 14		ldx $14				ldx 	temp3
.119d	a4 15		ldy $15				ldy 	temp3+1
.119f	20 bd ff	jsr $ffbd			jsr 	$FFBD 						; set name
.11a2	a9 01		lda #$01			lda 	#1
.11a4	a2 08		ldx #$08			ldx 	#8	 						; device #8
.11a6	a0 00		ldy #$00			ldy 	#0
.11a8	20 ba ff	jsr $ffba			jsr 	$FFBA 						; set LFS
.11ab	7a		ply				ply 								; restore target to YX and call load
.11ac	fa		plx				plx
.11ad	a9 00		lda #$00			lda 	#0 							; load command
.11af	20 d5 ff	jsr $ffd5			jsr 	$FFD5
.11b2	b0 03		bcs $11b7			bcs 	_ESLoad
.11b4	7a		ply				ply
.11b5	fa		plx				plx
.11b6	60		rts				rts
.11b7					_ESLoad:
.11b7	20 23 10	jsr $1023			jsr 	ErrorHandler
>11ba	4c 4f 41 44 20 46 41 49				.text 	"LOAD FAILED",0
>11c2	4c 45 44 00
.11c6					EXGetLength:
.11c6	b2 14		lda ($14)			lda 	(temp3) 					; get name length
.11c8	e6 14		inc $14				inc 	temp3 						; bump ptr past it
.11ca	d0 02		bne $11ce			bne 	_EXGLExit
.11cc	e6 15		inc $15				inc 	temp3+1
.11ce					_EXGLExit:
.11ce	60		rts				rts
.11cf					EXPrintString:
.11cf	48		pha				pha
.11d0	5a		phy				phy
.11d1	84 11		sty $11				sty 	temp1+1
.11d3	85 10		sta $10				sta 	temp1
.11d5	a0 00		ldy #$00			ldy 	#0
.11d7					_EXPSLoop:
.11d7	b1 10		lda ($10),y			lda 	(temp1),y
.11d9	f0 08		beq $11e3			beq 	_EXPSExit
.11db	29 7f		and #$7f			and 	#$7F
.11dd	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.11e0	c8		iny				iny
.11e1	80 f4		bra $11d7			bra 	_EXPSLoop
.11e3					_EXPSExit:
.11e3	7a		ply				ply
.11e4	68		pla				pla
.11e5	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/binary.src

.11e6					Add:
.11e6	7a		ply				ply
.11e7	68		pla				pla
.11e8	18		clc				clc
.11e9	65 06		adc $06				adc 	TOS
.11eb	85 06		sta $06				sta 	TOS
.11ed	98		tya				tya
.11ee	65 07		adc $07				adc 	TOS+1
.11f0	85 07		sta $07				sta 	TOS+1
.11f2	4c 00 00	jmp $0000			jmp 	Next
.11f5					Subtract:
.11f5	7a		ply				ply
.11f6	68		pla				pla
.11f7	38		sec				sec
.11f8	49 ff		eor #$ff			eor 	#$FF
.11fa	65 06		adc $06				adc 	TOS
.11fc	85 06		sta $06				sta 	TOS
.11fe	98		tya				tya
.11ff	49 ff		eor #$ff			eor 	#$FF
.1201	65 07		adc $07				adc 	TOS+1
.1203	85 07		sta $07				sta 	TOS+1
.1205	4c 00 00	jmp $0000			jmp 	Next
.1208					And:
.1208	68		pla				pla
.1209	25 07		and $07				and 	TOS+1
.120b	85 07		sta $07				sta 	TOS+1
.120d	68		pla				pla
.120e	25 06		and $06				and 	TOS
.1210	85 06		sta $06				sta 	TOS
.1212	4c 00 00	jmp $0000			jmp 	Next
.1215					Xor:
.1215	68		pla				pla
.1216	45 07		eor $07				eor 	TOS+1
.1218	85 07		sta $07				sta 	TOS+1
.121a	68		pla				pla
.121b	45 06		eor $06				eor 	TOS
.121d	85 06		sta $06				sta 	TOS
.121f	4c 00 00	jmp $0000			jmp 	Next
.1222					LogOr:
.1222	68		pla				pla
.1223	05 07		ora $07				ora 	TOS+1
.1225	85 07		sta $07				sta 	TOS+1
.1227	68		pla				pla
.1228	05 06		ora $06				ora 	TOS
.122a	85 06		sta $06				sta 	TOS
.122c	4c 00 00	jmp $0000			jmp 	Next

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/compare.src

.122f					CheckNotEqual:
.122f	38		sec				sec
.1230	80 01		bra $1233			bra 	CECode
.1232					CheckEqual:
.1232	18		clc				clc
.1233					CECode:
.1233	86 10		stx $10				stx 	temp1
.1235	ba		tsx				tsx
.1236	08		php				php
.1237	a5 06		lda $06				lda 	TOS
.1239	5d 02 01	eor $0102,x			eor 	Stack2Low,x
.123c	d0 17		bne $1255			bne	 	CompareFalse
.123e	a5 07		lda $07				lda 	TOS+1
.1240	5d 01 01	eor $0101,x			eor 	Stack2High,x
.1243	d0 10		bne $1255			bne 	CompareFalse
.1245					CompareTrue:
.1245	a6 10		ldx $10				ldx 	temp1
.1247	28		plp				plp
.1248	b0 10		bcs $125a			bcs		CompareFalse2
.124a					CompareTrue2:
.124a	68		pla				pla
.124b	68		pla				pla
.124c	a9 ff		lda #$ff			lda 	#$FF
.124e	85 06		sta $06				sta 	TOS
.1250	85 07		sta $07				sta 	TOS+1
.1252	4c 00 00	jmp $0000			jmp 	Next
.1255					CompareFalse:
.1255	a6 10		ldx $10				ldx 	temp1
.1257	28		plp				plp
.1258	b0 f0		bcs $124a			bcs		CompareTrue2
.125a					CompareFalse2:
.125a	68		pla				pla
.125b	68		pla				pla
.125c	64 06		stz $06				stz 	TOS
.125e	64 07		stz $07				stz 	TOS+1
.1260	4c 00 00	jmp $0000			jmp 	Next
.1263					CheckGreaterEq:
.1263	38		sec				sec
.1264	80 01		bra $1267			bra		CLCode
.1266					CheckLess:
.1266	18		clc				clc
.1267	86 10		stx $10		CLCode:	stx 	temp1
.1269	ba		tsx				tsx
.126a	08		php				php
.126b	18		clc				clc
.126c	a5 06		lda $06				lda 	TOS
.126e	fd 02 01	sbc $0102,x			sbc 	Stack2Low,x
.1271	a5 07		lda $07				lda 	TOS+1
.1273	fd 01 01	sbc $0101,x			sbc 	Stack2High,x
.1276	50 02		bvc $127a			bvc 	_CLNoFlip
.1278	49 80		eor #$80			eor 	#$80
.127a					_CLNoFlip:
.127a	0a		asl a				asl 	a
.127b	b0 d8		bcs $1255			bcs 	CompareFalse
.127d	80 c6		bra $1245			bra 	CompareTrue
.127f					CheckLessEq:
.127f	38		sec				sec
.1280	80 01		bra $1283			bra		CGCode
.1282					CheckGreater:
.1282	18		clc				clc
.1283					CGCode:
.1283	86 10		stx $10				stx 	temp1
.1285	ba		tsx				tsx
.1286	08		php				php
.1287	18		clc				clc
.1288	bd 02 01	lda $0102,x			lda 	Stack2Low,x
.128b	e5 06		sbc $06				sbc 	TOS
.128d	bd 01 01	lda $0101,x			lda 	Stack2High,x
.1290	e5 07		sbc $07				sbc 	TOS+1
.1292	50 02		bvc $1296			bvc 	_CGNoFlip
.1294	49 80		eor #$80			eor 	#$80
.1296					_CGNoFlip:
.1296	0a		asl a				asl 	a
.1297	b0 bc		bcs $1255			bcs 	CompareFalse
.1299	80 aa		bra $1245			bra 	CompareTrue
.129b					Minimum:
.129b	a9 00		lda #$00			lda 	#0
.129d	80 02		bra $12a1			bra 	MinMaxCode
.129f					Maximum:
.129f	a9 80		lda #$80			lda 	#$80
.12a1					MinMaxCode:
.12a1	85 11		sta $11				sta 	temp1+1
.12a3	86 10		stx $10				stx 	temp1
.12a5	ba		tsx				tsx
.12a6	38		sec				sec
.12a7	a5 06		lda $06				lda 	TOS
.12a9	fd 02 01	sbc $0102,x			sbc 	Stack2Low,x
.12ac	a5 07		lda $07				lda 	TOS+1
.12ae	fd 01 01	sbc $0101,x			sbc 	Stack2High,x
.12b1	50 02		bvc $12b5			bvc 	_MMNoFlip
.12b3	49 80		eor #$80			eor 	#$80
.12b5					_MMNoFlip:
.12b5	45 11		eor $11				eor 	temp1+1
.12b7	30 0a		bmi $12c3			bmi 	_MMNoCopy
.12b9	bd 02 01	lda $0102,x			lda 	Stack2Low,x
.12bc	85 06		sta $06				sta 	TOS
.12be	bd 01 01	lda $0101,x			lda 	Stack2High,x
.12c1	85 07		sta $07				sta 	TOS+1
.12c3					_MMNoCopy:
.12c3	a6 10		ldx $10				ldx 	temp1
.12c5	68		pla				pla
.12c6	68		pla				pla
.12c7	4c 00 00	jmp $0000			jmp 	Next

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/divide.src

.12ca					Divide16x16:
.12ca	86 12		stx $12				stx 	temp2
.12cc	ba		tsx				tsx
.12cd	20 f0 12	jsr $12f0			jsr 	IntegerDivide
.12d0	68		pla				pla
.12d1	85 07		sta $07				sta 	TOS+1
.12d3	68		pla				pla
.12d4	85 06		sta $06				sta 	TOS
.12d6	a6 12		ldx $12				ldx 	temp2
.12d8	4c 00 00	jmp $0000			jmp 	Next
.12db					Modulus16x16:
.12db	86 12		stx $12				stx 	temp2
.12dd	ba		tsx				tsx
.12de	20 f0 12	jsr $12f0			jsr 	IntegerDivide
.12e1	a6 12		ldx $12				ldx 	temp2
.12e3	68		pla				pla
.12e4	68		pla				pla
.12e5	a5 10		lda $10				lda 	temp1
.12e7	85 06		sta $06				sta 	TOS
.12e9	a5 11		lda $11				lda 	temp1+1
.12eb	85 07		sta $07				sta 	TOS+1
.12ed	4c 00 00	jmp $0000			jmp 	Next
.12f0					IntegerDivide:
.12f0	a5 06		lda $06				lda 	TOS 				; check for division by zero.
.12f2	05 07		ora $07				ora 	TOS+1
.12f4	d0 14		bne $130a			bne 	_BFDOkay
.12f6	20 23 10	jsr $1023			jsr 	ErrorHandler
>12f9	44 49 56 49 53 49 4f 4e				.text 	"DIVISION BY ZERO",0
>1301	20 42 59 20 5a 45 52 4f 00
.130a					_BFDOkay:
.130a	64 10		stz $10				stz 	temp1 						; Q/Dividend/Left in +0
.130c	64 11		stz $11				stz 	temp1+1 					; M/Divisor/Right in +2
.130e	64 1a		stz $1a				stz 	SignCount 					; Count of signs.
.1310	20 4b 13	jsr $134b			jsr 	CheckIntegerNegate 			; negate 2nd (and bump sign count)
.1313	20 65 13	jsr $1365			jsr 	CheckTOSNegate 				; negate TOS (and bump sign count)
.1316	5a		phy				phy 								; Y is the counter
.1317	a0 10		ldy #$10			ldy 	#16 						; 16 iterations of the loop.
.1319					_BFDLoop:
.1319	1e 02 01	asl $0102,x			asl 	Stack2Low,x 				; shift AQ left.
.131c	3e 01 01	rol $0101,x			rol 	Stack2High,x
.131f	26 10		rol $10				rol 	temp1
.1321	26 11		rol $11				rol 	temp1+1
.1323	38		sec				sec
.1324	a5 10		lda $10				lda 	temp1+0 					; Calculate A-M on stack.
.1326	e5 06		sbc $06				sbc 	TOS
.1328	48		pha				pha
.1329	a5 11		lda $11				lda 	temp1+1
.132b	e5 07		sbc $07				sbc 	TOS+1
.132d	90 0f		bcc $133e			bcc 	_BFDNoAdd
.132f	85 11		sta $11				sta 	temp1+1
.1331	68		pla				pla
.1332	85 10		sta $10				sta 	temp1+0
.1334	bd 02 01	lda $0102,x			lda 	Stack2Low,x 				; set Q bit 1.
.1337	09 01		ora #$01			ora 	#1
.1339	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.133c	80 01		bra $133f			bra 	_BFDNext
.133e					_BFDNoAdd:
.133e	68		pla				pla 								; Throw away the intermediate calculations
.133f					_BFDNext:
.133f	88		dey				dey
.1340	d0 d7		bne $1319			bne 	_BFDLoop
.1342	7a		ply				ply 								; restore Y
.1343	46 1a		lsr $1a				lsr 	SignCount 					; if sign count odd,
.1345	90 03		bcc $134a			bcc 	_BFDUnsigned 				; then the result is signed
.1347	20 51 13	jsr $1351			jsr		IntegerNegateAlways 		; negate the result
.134a					_BFDUnsigned:
.134a	60		rts				rts
.134b					CheckIntegerNegate:
.134b	bd 01 01	lda $0101,x			lda 	Stack2High,x 				; is it -ve = MSB set ?
.134e	30 01		bmi $1351			bmi 	IntegerNegateAlways 		; if so negate it
.1350	60		rts				rts
.1351					IntegerNegateAlways:
.1351	e6 1a		inc $1a				inc 	SignCount 					; bump the count of signs
.1353	38		sec				sec 								; negate
.1354	a9 00		lda #$00			lda 	#0
.1356	fd 02 01	sbc $0102,x			sbc 	Stack2Low,x
.1359	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.135c	a9 00		lda #$00			lda 	#0
.135e	fd 01 01	sbc $0101,x			sbc 	Stack2High,x
.1361	9d 01 01	sta $0101,x			sta 	Stack2High,x
.1364	60		rts				rts
.1365					CheckTOSNegate:
.1365	a5 07		lda $07				lda 	TOS+1
.1367	10 0f		bpl $1378			bpl		CTNNoChange
.1369	e6 1a		inc $1a				inc 	SignCount
.136b					TOSNegateAlways:
.136b	38		sec				sec
.136c	a9 00		lda #$00			lda 	#0
.136e	e5 06		sbc $06				sbc 	TOS
.1370	85 06		sta $06				sta 	TOS
.1372	a9 00		lda #$00			lda 	#0
.1374	e5 07		sbc $07				sbc 	TOS+1
.1376	85 07		sta $07				sta 	TOS+1
.1378					CTNNoChange:
.1378	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/multiply.src

.1379					Multiply16x16:
.1379	86 10		stx $10				stx 	temp1
.137b	ba		tsx				tsx
.137c	bd 02 01	lda $0102,x			lda 	Stack2Low,x 				; 2nd value on stack to temp1
.137f	85 12		sta $12				sta 	temp2
.1381	bd 01 01	lda $0101,x			lda		Stack2High,x
.1384	85 13		sta $13				sta 	temp2+1
.1386	9e 02 01	stz $0102,x			stz 	Stack2Low,x 				; zero 2nd value on stack
.1389	9e 01 01	stz $0101,x			stz 	Stack2High,x
.138c					_MultLoop:
.138c	46 13		lsr $13				lsr 	temp2+1 					; ror temp2 into C
.138e	66 12		ror $12				ror 	temp2
.1390	90 11		bcc $13a3			bcc 	_MultNoAdd
.1392	18		clc				clc 								; add 1st to 2nd
.1393	a5 06		lda $06				lda 	TOS
.1395	7d 02 01	adc $0102,x			adc 	Stack2Low,x
.1398	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.139b	a5 07		lda $07				lda 	TOS+1
.139d	7d 01 01	adc $0101,x			adc 	Stack2High,x
.13a0	9d 01 01	sta $0101,x			sta 	Stack2High,x
.13a3					_MultNoAdd:
.13a3	06 06		asl $06				asl 	TOS 						; shift 1st left
.13a5	26 07		rol $07				rol 	TOS+1
.13a7	a5 12		lda $12				lda 	temp2	 					; until zero
.13a9	05 13		ora $13				ora 	temp2+1
.13ab	d0 df		bne $138c			bne 	_MultLoop
.13ad	a6 10		ldx $10				ldx 	temp1 						; restore X load result
.13af	68		pla				pla
.13b0	85 07		sta $07				sta 	TOS+1
.13b2	68		pla				pla
.13b3	85 06		sta $06				sta 	TOS
.13b5	4c 00 00	jmp $0000			jmp 	Next

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/unary.src

.13b8					Unary1Plus:
.13b8	e6 06		inc $06				inc 	TOS
.13ba	d0 02		bne $13be			bne 	_U1PSkip
.13bc	e6 07		inc $07				inc 	TOS+1
.13be					_U1PSkip:
.13be	4c 00 00	jmp $0000			jmp 	Next
.13c1					Unary2Plus:
.13c1	18		clc				clc
.13c2	a5 06		lda $06				lda 	TOS
.13c4	69 02		adc #$02			adc 	#2
.13c6	85 06		sta $06				sta 	TOS
.13c8	90 02		bcc $13cc			bcc 	_U1PSkip
.13ca	e6 07		inc $07				inc 	TOS+1
.13cc					_U1PSkip:
.13cc	4c 00 00	jmp $0000			jmp 	Next
.13cf					Unary1Minus:
.13cf	a5 06		lda $06				lda 	TOS
.13d1	d0 02		bne $13d5			bne 	_U1MSkip
.13d3	c6 07		dec $07				dec 	TOS+1
.13d5					_U1MSkip:
.13d5	c6 06		dec $06				dec 	TOS
.13d7	4c 00 00	jmp $0000			jmp 	Next
.13da					Unary2Minus:
.13da	38		sec				sec
.13db	a5 06		lda $06				lda 	TOS
.13dd	e9 02		sbc #$02			sbc 	#2
.13df	85 06		sta $06				sta 	TOS
.13e1	b0 02		bcs $13e5			bcs 	_U1PSkip
.13e3	c6 07		dec $07				dec 	TOS+1
.13e5					_U1PSkip:
.13e5	4c 00 00	jmp $0000			jmp 	Next
.13e8					Absolute:
.13e8	a5 07		lda $07				lda 	TOS+1
.13ea	30 03		bmi $13ef			bmi 	Negate
.13ec	4c 00 00	jmp $0000			jmp 	Next
.13ef					Negate:
.13ef	38		sec				sec
.13f0	a9 00		lda #$00			lda 	#0
.13f2	e5 06		sbc $06				sbc 	TOS
.13f4	85 06		sta $06				sta 	TOS
.13f6	a9 00		lda #$00			lda 	#0
.13f8	e5 07		sbc $07				sbc 	TOS+1
.13fa	85 07		sta $07				sta 	TOS+1
.13fc	4c 00 00	jmp $0000			jmp 	Next
.13ff					OneComplement:
.13ff	a5 06		lda $06				lda 	TOS
.1401	49 ff		eor #$ff			eor 	#$FF
.1403	85 06		sta $06				sta 	TOS
.1405	a5 07		lda $07				lda 	TOS+1
.1407	49 ff		eor #$ff			eor 	#$FF
.1409	85 07		sta $07				sta 	TOS+1
.140b	4c 00 00	jmp $0000			jmp 	Next
.140e					CheckMinus:
.140e	a5 07		lda $07				lda 	TOS+1
.1410	30 07		bmi $1419			bmi 	UnaryTrue
.1412					UnaryFalse:
.1412	64 06		stz $06				stz 	TOS
.1414	64 07		stz $07				stz 	TOS+1
.1416	4c 00 00	jmp $0000			jmp 	Next
.1419					UnaryTrue:
.1419	a9 ff		lda #$ff			lda 	#$FF
.141b	85 06		sta $06				sta 	TOS
.141d	85 07		sta $07				sta 	TOS+1
.141f	4c 00 00	jmp $0000			jmp 	Next
.1422					CheckZero:
.1422	a5 06		lda $06				lda 	TOS
.1424	05 07		ora $07				ora 	TOS+1
.1426	d0 ea		bne $1412			bne 	UnaryFalse
.1428	80 ef		bra $1419			bra 	UnaryTrue
.142a					SignTOS:
.142a	a5 07		lda $07				lda 	TOS+1
.142c	30 eb		bmi $1419			bmi		UnaryTrue
.142e	05 06		ora $06				ora 	TOS
.1430	f0 e0		beq $1412			beq 	UnaryFalse
.1432	a9 01		lda #$01			lda 	#1
.1434	85 06		sta $06				sta 	TOS
.1436	64 07		stz $07				stz		TOS+1
.1438	4c 00 00	jmp $0000			jmp 	Next
.143b					ByteSwap:
.143b	a5 06		lda $06				lda 	TOS
.143d	a4 07		ldy $07				ldy 	TOS+1
.143f	85 07		sta $07				sta 	TOS+1
.1441	84 06		sty $06				sty 	TOS
.1443	4c 00 00	jmp $0000			jmp 	Next
.1446					Times16:
.1446	06 06		asl $06				asl 	TOS
.1448	26 07		rol $07				rol 	TOS+1
.144a					Times8:
.144a	06 06		asl $06				asl 	TOS
.144c	26 07		rol $07				rol 	TOS+1
.144e					Times4:
.144e	06 06		asl $06				asl 	TOS
.1450	26 07		rol $07				rol 	TOS+1
.1452					Times2:
.1452	06 06		asl $06				asl 	TOS
.1454	26 07		rol $07				rol 	TOS+1
.1456	4c 00 00	jmp $0000			jmp 	Next
.1459					Divide16:
.1459	46 07		lsr $07				lsr 	TOS+1
.145b	66 06		ror $06				ror 	TOS
.145d					Divide8:
.145d	46 07		lsr $07				lsr 	TOS+1
.145f	66 06		ror $06				ror 	TOS
.1461					Divide4:
.1461	46 07		lsr $07				lsr 	TOS+1
.1463	66 06		ror $06				ror 	TOS
.1465					Divide2:
.1465	46 07		lsr $07				lsr 	TOS+1
.1467	66 06		ror $06				ror 	TOS
.1469	4c 00 00	jmp $0000			jmp 	Next
.146c					Times256:
.146c	a5 06		lda $06				lda 	TOS
.146e	85 07		sta $07				sta 	TOS+1
.1470	64 06		stz $06				stz 	TOS
.1472	4c 00 00	jmp $0000			jmp 	Next
.1475					Divide256:
.1475	a5 07		lda $07				lda 	TOS+1
.1477	85 06		sta $06				sta 	TOS
.1479	64 07		stz $07				stz 	TOS+1
.147b	4c 00 00	jmp $0000			jmp 	Next
.147e					RandomNumber:
.147e	a5 06		lda $06				lda 	TOS
.1480	48		pha				pha
.1481	a5 07		lda $07				lda 	TOS+1
.1483	48		pha				pha
.1484	a5 1b		lda $1b				lda 	randomSeed
.1486	05 1c		ora $1c				ora 	randomSeed+1
.1488	d0 08		bne $1492			bne 	_RH_NoInit
.148a	a9 7c		lda #$7c			lda 	#$7C
.148c	85 1b		sta $1b				sta 	randomSeed
.148e	a9 a1		lda #$a1			lda 	#$A1
.1490	85 1c		sta $1c				sta 	randomSeed+1
.1492					_RH_NoInit:
.1492	a5 1b		lda $1b				lda 	randomSeed
.1494	4a		lsr a		        lsr		a
.1495	26 1c		rol $1c		        rol 	randomSeed+1
.1497	90 02		bcc $149b	        bcc 	_RH_NoEor
.1499	49 b4		eor #$b4	        eor 	#$B4
.149b					_RH_NoEor:
.149b	85 1b		sta $1b		        sta 	randomSeed
.149d	45 1c		eor $1c		        eor 	randomSeed+1
.149f	85 07		sta $07		        sta 	TOS+1
.14a1	a5 1b		lda $1b		        lda 	randomSeed
.14a3	85 06		sta $06		        sta 	TOS
.14a5	4c 00 00	jmp $0000			jmp 	Next

;******  Return to file: kernel.asm


;******  Processing file: words/data/literals.src

.14a8					Constant0:
.14a8	a5 06		lda $06				lda 	TOS
.14aa	48		pha				pha
.14ab	a5 07		lda $07				lda 	TOS+1
.14ad	48		pha				pha
.14ae	64 06		stz $06				stz 	TOS
.14b0	64 07		stz $07				stz 	TOS+1
.14b2	4c 00 00	jmp $0000			jmp 	Next
.14b5					ConstantMinus1:
.14b5	a5 06		lda $06				lda 	TOS
.14b7	48		pha				pha
.14b8	a5 07		lda $07				lda 	TOS+1
.14ba	48		pha				pha
.14bb	a9 ff		lda #$ff			lda 	#$FF
.14bd	85 06		sta $06				sta 	TOS
.14bf	85 07		sta $07				sta 	TOS+1
.14c1	4c 00 00	jmp $0000			jmp 	Next
.14c4					C1:
.14c4	a0 01		ldy #$01			ldy 	#1
.14c6	80 24		bra $14ec			bra 	Const1Byte
.14c8					C2:
.14c8	a0 02		ldy #$02			ldy 	#2
.14ca	80 20		bra $14ec			bra 	Const1Byte
.14cc					C3:
.14cc	a0 03		ldy #$03			ldy 	#3
.14ce	80 1c		bra $14ec			bra 	Const1Byte
.14d0					C4:
.14d0	a0 04		ldy #$04			ldy 	#4
.14d2	80 18		bra $14ec			bra 	Const1Byte
.14d4					C5:
.14d4	a0 05		ldy #$05			ldy 	#5
.14d6	80 14		bra $14ec			bra 	Const1Byte
.14d8					C8:
.14d8	a0 08		ldy #$08			ldy 	#8
.14da	80 10		bra $14ec			bra 	Const1Byte
.14dc					C10:
.14dc	a0 0a		ldy #$0a			ldy 	#10
.14de	80 0c		bra $14ec			bra 	Const1Byte
.14e0					C15:
.14e0	a0 0f		ldy #$0f			ldy 	#15
.14e2	80 08		bra $14ec			bra 	Const1Byte
.14e4					C16:
.14e4	a0 10		ldy #$10			ldy 	#16
.14e6	80 04		bra $14ec			bra 	Const1Byte
.14e8					C24:
.14e8	a0 18		ldy #$18			ldy 	#24
.14ea	80 00		bra $14ec			bra 	Const1Byte
.14ec					Const1Byte:
.14ec	a5 06		lda $06				lda 	TOS
.14ee	48		pha				pha
.14ef	a5 07		lda $07				lda 	TOS+1
.14f1	48		pha				pha
.14f2	84 06		sty $06				sty 	TOS
.14f4	64 07		stz $07				stz 	TOS+1
.14f6	4c 00 00	jmp $0000			jmp 	Next
.14f9					C32:
.14f9	a0 20		ldy #$20			ldy 	#32
.14fb	80 ef		bra $14ec			bra 	Const1Byte
.14fd					C63:
.14fd	a0 3f		ldy #$3f			ldy 	#63
.14ff	80 eb		bra $14ec			bra 	Const1Byte
.1501					C64:
.1501	a0 40		ldy #$40			ldy 	#64
.1503	80 e7		bra $14ec			bra 	Const1Byte
.1505					C100:
.1505	a0 64		ldy #$64			ldy 	#100
.1507	80 e3		bra $14ec			bra 	Const1Byte
.1509					C127:
.1509	a0 7f		ldy #$7f			ldy 	#127
.150b	80 df		bra $14ec			bra 	Const1Byte
.150d					C128:
.150d	a0 80		ldy #$80			ldy 	#128
.150f	80 db		bra $14ec			bra 	Const1Byte
.1511					C255:
.1511	a0 ff		ldy #$ff			ldy 	#255
.1513	80 d7		bra $14ec			bra 	Const1Byte
.1515					Const2Byte:
.1515	85 06		sta $06				sta 	TOS
.1517	84 07		sty $07				sty 	TOS+1
.1519	4c 00 00	jmp $0000			jmp 	Next
.151c					C256:
.151c	a5 06		lda $06				lda 	TOS
.151e	48		pha				pha
.151f	a5 07		lda $07				lda 	TOS+1
.1521	48		pha				pha
.1522	a9 00		lda #$00			lda 	#(256) & $FF
.1524	a0 01		ldy #$01			ldy 	#(256) >> 8
.1526	80 ed		bra $1515			bra 	Const2Byte
.1528					C512:
.1528	a5 06		lda $06				lda 	TOS
.152a	48		pha				pha
.152b	a5 07		lda $07				lda 	TOS+1
.152d	48		pha				pha
.152e	a9 00		lda #$00			lda 	#(512) & $FF
.1530	a0 02		ldy #$02			ldy 	#(512) >> 8
.1532	80 e1		bra $1515			bra 	Const2Byte
.1534					C1024:
.1534	a5 06		lda $06				lda 	TOS
.1536	48		pha				pha
.1537	a5 07		lda $07				lda 	TOS+1
.1539	48		pha				pha
.153a	a9 00		lda #$00			lda 	#(1024) & $FF
.153c	a0 04		ldy #$04			ldy 	#(1024) >> 8
.153e	80 d5		bra $1515			bra 	Const2Byte
.1540					C4096:
.1540	a5 06		lda $06				lda 	TOS
.1542	48		pha				pha
.1543	a5 07		lda $07				lda 	TOS+1
.1545	48		pha				pha
.1546	a9 00		lda #$00			lda 	#(4096) & $FF
.1548	a0 10		ldy #$10			ldy 	#(4096) >> 8
.154a	80 c9		bra $1515			bra 	Const2Byte
.154c					C32767:
.154c	a5 06		lda $06				lda 	TOS
.154e	48		pha				pha
.154f	a5 07		lda $07				lda 	TOS+1
.1551	48		pha				pha
.1552	a9 ff		lda #$ff			lda 	#(32767) & $FF
.1554	a0 7f		ldy #$7f			ldy 	#(32767) >> 8
.1556	80 bd		bra $1515			bra 	Const2Byte
.1558					C32768:
.1558	a5 06		lda $06				lda 	TOS
.155a	48		pha				pha
.155b	a5 07		lda $07				lda 	TOS+1
.155d	48		pha				pha
.155e	a9 00		lda #$00			lda 	#(32768) & $FF
.1560	a0 80		ldy #$80			ldy 	#(32768) >> 8
.1562	80 b1		bra $1515			bra 	Const2Byte

;******  Return to file: kernel.asm


;******  Processing file: words/data/stack.src

.1564					Drop:
.1564	68		pla				pla
.1565	85 07		sta $07				sta 	TOS+1
.1567	68		pla				pla
.1568	85 06		sta $06				sta 	TOS
.156a	4c 00 00	jmp $0000			jmp 	Next
.156d					TestDup:
.156d	a5 06		lda $06				lda 	TOS
.156f	05 07		ora $07				ora 	TOS+1
.1571	d0 03		bne $1576			bne 	Dup
.1573	4c 00 00	jmp $0000			jmp 	Next
.1576					Dup:
.1576	a5 06		lda $06				lda 	TOS
.1578	48		pha				pha
.1579	a5 07		lda $07				lda 	TOS+1
.157b	48		pha				pha
.157c	4c 00 00	jmp $0000			jmp 	Next
.157f					Swap:
.157f	86 10		stx $10				stx 	temp1
.1581	7a		ply				ply
.1582	fa		plx				plx
.1583	a5 06		lda $06				lda 	TOS
.1585	48		pha				pha
.1586	a5 07		lda $07				lda 	TOS+1
.1588	48		pha				pha
.1589	86 06		stx $06				stx 	TOS
.158b	84 07		sty $07				sty 	TOS+1
.158d	a6 10		ldx $10				ldx 	temp1
.158f	4c 00 00	jmp $0000			jmp 	Next
.1592					Over:
.1592	a5 06		lda $06				lda 	TOS
.1594	48		pha				pha
.1595	a5 07		lda $07				lda 	TOS+1
.1597	48		pha				pha
.1598	86 10		stx $10				stx 	temp1
.159a	ba		tsx				tsx
.159b	bd 04 01	lda $0104,x			lda 	stack3low,x
.159e	85 06		sta $06				sta 	TOS
.15a0	bd 03 01	lda $0103,x			lda 	stack3High,x
.15a3	85 07		sta $07				sta 	TOS+1
.15a5	a6 10		ldx $10				ldx 	temp1
.15a7	4c 00 00	jmp $0000			jmp 	Next
.15aa					Nip:
.15aa	68		pla				pla
.15ab	68		pla				pla
.15ac	4c 00 00	jmp $0000			jmp 	Next
.15af					Rot:
.15af	86 10		stx $10				stx 	temp1
.15b1	ba		tsx				tsx
.15b2	bd 04 01	lda $0104,x			lda 	Stack3Low,x
.15b5	a8		tay				tay
.15b6	bd 02 01	lda $0102,x			lda 	Stack2Low,x
.15b9	9d 04 01	sta $0104,x			sta 	Stack3Low,x
.15bc	a5 06		lda $06				lda 	TOS
.15be	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.15c1	84 06		sty $06				sty 	TOS
.15c3	bd 03 01	lda $0103,x			lda 	Stack3High,x
.15c6	a8		tay				tay
.15c7	bd 01 01	lda $0101,x			lda 	Stack2High,x
.15ca	9d 03 01	sta $0103,x			sta 	Stack3High,x
.15cd	a5 07		lda $07				lda 	TOS+1
.15cf	9d 01 01	sta $0101,x			sta 	Stack2High,x
.15d2	84 07		sty $07				sty 	TOS+1
.15d4	a6 10		ldx $10				ldx 	temp1
.15d6	4c 00 00	jmp $0000			jmp 	Next

;******  Return to file: kernel.asm


;******  Processing file: words/data/memory.src

.15d9					ByteRead:
.15d9	b2 06		lda ($06)			lda 	(TOS)
.15db	85 06		sta $06				sta 	TOS
.15dd	64 07		stz $07				stz 	TOS+1
.15df	4c 00 00	jmp $0000			jmp 	Next
.15e2					WordRead:
.15e2	a0 01		ldy #$01			ldy 	#1
.15e4	b1 06		lda ($06),y			lda 	(TOS),y
.15e6	a8		tay				tay
.15e7	b2 06		lda ($06)			lda 	(TOS)
.15e9	85 06		sta $06				sta 	TOS
.15eb	84 07		sty $07				sty 	TOS+1
.15ed	4c 00 00	jmp $0000			jmp 	Next
.15f0					ByteWrite:
.15f0	68		pla				pla
.15f1	68		pla				pla
.15f2	92 06		sta ($06)			sta 	(TOS)
.15f4	68		pla				pla
.15f5	85 07		sta $07				sta 	TOS+1
.15f7	68		pla				pla
.15f8	85 06		sta $06				sta 	TOS
.15fa	4c 00 00	jmp $0000			jmp 	Next
.15fd					WordWrite:
.15fd	68		pla				pla
.15fe	a0 01		ldy #$01			ldy 	#1
.1600	91 06		sta ($06),y			sta 	(TOS),y
.1602	68		pla				pla
.1603	92 06		sta ($06)			sta 	(TOS)
.1605	68		pla				pla
.1606	85 07		sta $07				sta 	TOS+1
.1608	68		pla				pla
.1609	85 06		sta $06				sta 	TOS
.160b	4c 00 00	jmp $0000			jmp 	Next
.160e					WordAdd:
.160e	7a		ply				ply
.160f	68		pla				pla
.1610	18		clc				clc
.1611	72 06		adc ($06)			adc 	(TOS)
.1613	92 06		sta ($06)			sta 	(TOS)
.1615	98		tya				tya
.1616	a0 01		ldy #$01			ldy 	#1
.1618	71 06		adc ($06),y			adc 	(TOS),y
.161a	91 06		sta ($06),y			sta 	(TOS),y
.161c	68		pla				pla
.161d	85 07		sta $07				sta 	TOS+1
.161f	68		pla				pla
.1620	85 06		sta $06				sta 	TOS
.1622	4c 00 00	jmp $0000			jmp 	Next
.1625					AllocateMemory:
.1625	a5 06		lda $06				lda 	TOS 						; save memory required on stack.
.1627	48		pha				pha
.1628	a5 07		lda $07				lda 	TOS+1
.162a	48		pha				pha
.162b	a5 0e		lda $0e				lda 	nextFreeMem 				; copy free mem address to TOS
.162d	85 06		sta $06				sta 	TOS
.162f	a5 0f		lda $0f				lda 	nextFreeMem+1
.1631	85 07		sta $07				sta 	TOS+1
.1633	7a		ply				ply 								; advance the free ram pointer
.1634	68		pla				pla
.1635	20 74 1a	jsr $1a74			jsr 	AdvanceFreeMem
.1638	4c 00 00	jmp $0000			jmp 	Next 						; and continue

;******  Return to file: kernel.asm


;******  Processing file: words/encode/encode.src

.163b					EncodeProgram:
.163b	48		pha				pha 								; save registers.
.163c	da		phx				phx
.163d	5a		phy				phy
.163e	84 09		sty $09				sty 	srcPtr+1					; save source pointer.
.1640	85 08		sta $08				sta		srcPtr
.1642	a9 03		lda #$03			lda 	#3 							; reset the encode Buffer
.1644	8d 10 09	sta $0910			sta 	encodeBuffer 				; this is also the write ptr/offset
.1647	9c 11 09	stz $0911			stz 	encodeBuffer+1 				; the line number
.164a	9c 12 09	stz $0912			stz 	encodeBuffer+2 				; which is initially zero.
.164d	b2 08		lda ($08)			lda 	(srcPtr) 					; check if first character is digit
.164f	20 ad 17	jsr $17ad			jsr 	CheckIsDigit
.1652	90 09		bcc $165d			bcc 	_EPNoLineNumber 			; if so there is a line number
.1654	20 cf 17	jsr $17cf			jsr 	EncodeGetConstant 			; extract that constant from the source
.1657	8d 11 09	sta $0911			sta 	encodeBuffer+1 				; that is the line number
.165a	8c 12 09	sty $0912			sty 	encodeBuffer+2
.165d					_EPNoLineNumber:
.165d					EncodeLoop:
.165d	b2 08		lda ($08)			lda 	(srcPtr) 					; skip over spaces/ reached end
.165f	f0 0b		beq $166c			beq 	_EPEndEncode
.1661	c9 20		cmp #$20			cmp 	#32
.1663	d0 12		bne $1677			bne 	_EPNotSpace
.1665	a9 01		lda #$01			lda 	#1
.1667	20 c5 17	jsr $17c5			jsr 	EncodeAddSrcPtr
.166a	80 f1		bra $165d			bra	 	EncodeLoop
.166c					_EPEndEncode:
.166c	a9 5d		lda #$5d			lda 	#NextLine & $FF 			; compile $$nextline to mark eol
.166e	a0 1d		ldy #$1d			ldy 	#NextLine >> 8
.1670	20 94 17	jsr $1794			jsr 	EncodeWriteWord
.1673	7a		ply				ply									; restore and exit.
.1674	fa		plx				plx
.1675	68		pla				pla
.1676	60		rts				rts
.1677					_EPNotSpace:
.1677	b2 08		lda ($08)			lda 	(srcPtr)
.1679	c9 22		cmp #$22			cmp 	#'"'						; is it a quoted string or comment ?
.167b	f0 04		beq $1681			beq 	_EPIsComStr
.167d	c9 27		cmp #$27			cmp 	#"'"
.167f	d0 05		bne $1686			bne 	_EPNotComStr
.1681					_EPIsComStr:
.1681	20 f1 16	jsr $16f1			jsr 	EncodeCommentString
.1684	80 d7		bra $165d			bra 	EncodeLoop
.1686					_EPNotComStr:
.1686	38		sec				sec
.1687	20 e0 17	jsr $17e0			jsr 	EncSetBit7Word
.168a	20 f3 17	jsr $17f3			jsr 	EncodeSearchDictionary		; look it up
.168d	90 44		bcc $16d3			bcc 	_EPNotInDictionary
.168f	85 10		sta $10				sta 	temp1 						; save dictionary record address
.1691	84 11		sty $11				sty 	temp1+1
.1693	a0 01		ldy #$01			ldy 	#1
.1695	b1 10		lda ($10),y			lda 	(temp1),y 					; check if has an encode bit
.1697	29 20		and #$20			and 	#$20
.1699	d0 12		bne $16ad			bne 	_EPEncodeRoutine 			; if so, do special routine.
.169b	a0 02		ldy #$02			ldy 	#2 							; write out the routine address
.169d	b1 10		lda ($10),y			lda 	(temp1),y
.169f	20 9e 17	jsr $179e			jsr 	EncodeWriteByte
.16a2	c8		iny				iny
.16a3	b1 10		lda ($10),y			lda 	(temp1),y
.16a5	20 9e 17	jsr $179e			jsr 	EncodeWriteByte
.16a8	20 b9 17	jsr $17b9			jsr 	EncodeMoveNextWord 			; advance to the next and loop
.16ab	80 b0		bra $165d			bra 	EncodeLoop
.16ad					_EPEncodeRoutine:
.16ad	a0 01		ldy #$01			ldy 	#1							; get type bit
.16af	b1 10		lda ($10),y			lda 	(temp1),y
.16b1	a0 04		ldy #$04			ldy 	#4							; encoder here if no decoder
.16b3	29 10		and #$10			and 	#$10 						; but decoder comes first
.16b5	f0 02		beq $16b9			beq 	_EPENoDecoder
.16b7	c8		iny				iny 								; so if it exists, adjust for it.
.16b8	c8		iny				iny
.16b9					_EPENoDecoder:
.16b9	b1 10		lda ($10),y			lda 	(temp1),y 					; copy exec addr to temp2
.16bb	85 12		sta $12				sta 	temp2
.16bd	c8		iny				iny
.16be	b1 10		lda ($10),y			lda 	(temp1),y
.16c0	85 13		sta $13				sta 	temp2+1
.16c2	48		pha				pha 								; call routine preserving state
.16c3	da		phx				phx
.16c4	5a		phy				phy
.16c5	20 d0 16	jsr $16d0			jsr 	_EPECallTemp2
.16c8	7a		ply				ply
.16c9	fa		plx				plx
.16ca	68		pla				pla
.16cb	20 b9 17	jsr $17b9			jsr 	EncodeMoveNextWord 			; advance to the next and loop
.16ce	80 8d		bra $165d			bra 	EncodeLoop
.16d0					_EPECallTemp2:
.16d0	6c 12 00	jmp ($0012)			jmp 	(temp2)
.16d3					_EPNotInDictionary:
.16d3	20 46 17	jsr $1746			jsr 	EncodeSearchUserDefined 	; are there any user defined routines
.16d6	90 19		bcc $16f1			bcc 	_EPNotDefined
.16d8	48		pha				pha
.16d9	a9 fb		lda #$fb			lda	 	#CallHandler & $FF 			; write code call handler
.16db	20 9e 17	jsr $179e			jsr 	EncodeWriteByte
.16de	a9 18		lda #$18			lda	 	#CallHandler >> 8
.16e0	20 9e 17	jsr $179e			jsr 	EncodeWriteByte 			; write line number
.16e3	68		pla				pla
.16e4	20 9e 17	jsr $179e			jsr 	EncodeWriteByte
.16e7	98		tya				tya
.16e8	20 9e 17	jsr $179e			jsr 	EncodeWriteByte
.16eb	20 b9 17	jsr $17b9			jsr 	EncodeMoveNextWord 			; advance to the next and loop
.16ee	4c 5d 16	jmp $165d			jmp 	EncodeLoop
.16f1					_EPNotDefined:

;******  Return to file: kernel.asm


;******  Processing file: words/encode/comstr.src

.16f1					EncodeCommentString:
.16f1	b2 08		lda ($08)			lda 	(srcPtr) 					; get first character
.16f3	64 10		stz $10				stz 	temp1 						; other terminator = EOL
.16f5	aa		tax				tax 								; save in X
.16f6	a9 74		lda #$74			lda 	#(SkipComment & $FF)		; get the routine to use
.16f8	a0 1d		ldy #$1d			ldy 	#(SkipComment >> 8)
.16fa	e0 27		cpx #$27			cpx 	#"'"
.16fc	f0 06		beq $1704			beq 	_ECSGotCmd
.16fe	86 10		stx $10				stx		temp1 						; other terminator = "
.1700	a9 b1		lda #$b1			lda 	#(LiteralString & $FF)
.1702	a0 10		ldy #$10			ldy 	#(LiteralString >> 8)
.1704					_ECSGotCmd:
.1704	20 94 17	jsr $1794			jsr 	EncodeWriteWord 			; write word out.
.1707	ae 10 09	ldx $0910			ldx 	encodeBuffer 				; keep offset to buffer in X.
.170a	a9 01		lda #$01			lda 	#1
.170c	20 9e 17	jsr $179e			jsr 	EncodeWriteByte 			; write total length, so far 1.
.170f	a0 01		ldy #$01			ldy 	#1 							; for reading the actual text
.1711					_ECSCopyText:
.1711	b1 08		lda ($08),y			lda 	(srcPtr),y 					; get next
.1713	f0 18		beq $172d			beq 	_ECSEndOfLine 				; end of line ?
.1715	c5 10		cmp $10				cmp 	temp1						; is it the other terminator
.1717	f0 09		beq $1722			beq 	_ECSEndOfString 			; if so must be closing quote.
.1719	20 9e 17	jsr $179e			jsr 	EncodeWriteByte 			; write the byte out
.171c	fe 10 09	inc $0910,x			inc 	encodeBuffer,x				; increase length
.171f	c8		iny				iny 								; next character
.1720	80 ef		bra $1711			bra 	_ECSCopyText
.1722					_ECSEndOfString:
.1722	c8		iny				iny 								; skip closing quote.
.1723	a9 00		lda #$00			lda 	#0 							; write out ASCIIZ
.1725	20 9e 17	jsr $179e			jsr 	EncodeWriteByte
.1728	fe 10 09	inc $0910,x			inc 	encodeBuffer,x 				; fix the length up.
.172b	80 0e		bra $173b			bra 	_ECSComplete 				; and just patching up srcPtr to do.
.172d					_ECSEndOfLine:
.172d	a5 10		lda $10				lda 	temp1 						; missing closing quote
.172f	f0 0a		beq $173b			beq 	_ECSComplete 				; if we were doing a string.
.1731	20 23 10	jsr $1023			jsr 	ErrorHandler
>1734	51 55 4f 54 45 3f 00				.text 	"QUOTE?",0
.173b					_ECSComplete:
.173b	98		tya				tya
.173c	18		clc				clc
.173d	65 08		adc $08				adc 	srcPtr
.173f	85 08		sta $08				sta 	srcPtr
.1741	90 02		bcc $1745			bcc 	_ECSExit
.1743	e6 09		inc $09				inc 	srcPtr+1
.1745					_ECSExit:
.1745	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/encode/encdef.src

.1746					EncodeSearchUserDefined:
.1746	38		sec				sec 								; temp1 = srcPtr-6 because the
.1747	a5 08		lda $08				lda 	srcPtr				 		; name is 6 in (offset line# $$call len)
.1749	e9 06		sbc #$06			sbc		#6
.174b	85 10		sta $10				sta 	temp1
.174d	a5 09		lda $09				lda 	srcPtr+1
.174f	e9 00		sbc #$00			sbc 	#0
.1751	85 11		sta $11				sta 	temp1+1
.1753	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.1755	85 12		sta $12				sta 	0+(temp2)
.1757	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.1759	85 13		sta $13				sta 	1+(temp2)
.175b					_ESULoop:
.175b	b2 12		lda ($12)			lda 	(temp2) 					; reached the end (offset 0)
.175d	f0 33		beq $1792			beq 	_ESUFail
.175f	a0 03		ldy #$03			ldy 	#3 							; check it is $$define
.1761	b1 12		lda ($12),y			lda 	(temp2),y
.1763	c9 97		cmp #$97			cmp 	#DefineCode & $FF
.1765	d0 1e		bne $1785			bne 	_ESUNext
.1767	c8		iny				iny
.1768	b1 12		lda ($12),y			lda 	(temp2),y
.176a	c9 1d		cmp #$1d			cmp 	#DefineCode >> 8
.176c	d0 17		bne $1785			bne 	_ESUNext
.176e	c8		iny				iny 								; skip length byte.
.176f					_ESUCompare:
.176f	c8		iny				iny
.1770	b1 12		lda ($12),y			lda 	(temp2),y
.1772	d1 10		cmp ($10),y			cmp 	(temp1),y
.1774	d0 0f		bne $1785			bne 	_ESUNext
.1776	0a		asl a				asl 	a 							; bit 7 set => found it.
.1777	90 f6		bcc $176f			bcc 	_ESUCompare
.1779	a0 01		ldy #$01			ldy 	#1
.177b	b1 12		lda ($12),y			lda 	(temp2),y 					; read in the line number to YA
.177d	aa		tax				tax
.177e	c8		iny				iny
.177f	b1 12		lda ($12),y			lda 	(temp2),y
.1781	a8		tay				tay
.1782	8a		txa				txa
.1783	38		sec				sec 								; return with carry set as found
.1784	60		rts				rts
.1785					_ESUNext:
.1785	18		clc				clc
.1786	a5 12		lda $12				lda 	temp2
.1788	72 12		adc ($12)			adc 	(temp2)
.178a	85 12		sta $12				sta 	temp2
.178c	90 02		bcc $1790			bcc 	_NoCarryAdv
.178e	e6 13		inc $13				inc 	temp2+1
.1790					_NoCarryAdv:
.1790	80 c9		bra $175b			bra 	_ESULoop 					; and loop round
.1792					_ESUFail:
.1792	18		clc				clc
.1793	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/encode/encutils.src

.1794					EncodeWriteWord:
.1794	48		pha				pha
.1795	20 9e 17	jsr $179e			jsr 	EncodeWriteByte
.1798	98		tya				tya
.1799	20 9e 17	jsr $179e			jsr 	EncodeWriteByte
.179c	68		pla				pla
.179d	60		rts				rts
.179e					EncodeWriteByte:
.179e	da		phx				phx
.179f	ae 10 09	ldx $0910			ldx 	encodeBuffer
.17a2	9d 10 09	sta $0910,x			sta 	encodeBuffer,x
.17a5	9e 11 09	stz $0911,x			stz 	encodeBuffer+1,x
.17a8	ee 10 09	inc $0910			inc 	encodeBuffer
.17ab	fa		plx				plx
.17ac	60		rts				rts
.17ad					CheckIsDigit:
.17ad	c9 30		cmp #$30			cmp 	#"0"						; return CC if 0..9
.17af	90 06		bcc $17b7			bcc 	_CIDFail
.17b1	c9 3a		cmp #$3a			cmp 	#"9"+1
.17b3	b0 02		bcs $17b7			bcs 	_CIDFail
.17b5	38		sec				sec
.17b6	60		rts				rts
.17b7					_CIDFail:
.17b7	18		clc				clc
.17b8	60		rts				rts
.17b9					EncodeMoveNextWord:
.17b9	a0 ff		ldy #$ff			ldy 	#255 						; search forward
.17bb					_EPNWLoop:
.17bb	c8		iny				iny
.17bc	b1 08		lda ($08),y			lda 	(srcPtr),y
.17be	c9 21		cmp #$21			cmp 	#" "+1						; looking for <= space
.17c0	b0 f9		bcs $17bb			bcs 	_EPNWLoop
.17c2	98		tya				tya
.17c3	80 00		bra $17c5			bra 	EncodeAddSrcPtr
.17c5					EncodeAddSrcPtr:
.17c5	18		clc				clc 								; add offset
.17c6	65 08		adc $08				adc 	srcPtr
.17c8	85 08		sta $08				sta 	srcPtr
.17ca	90 02		bcc $17ce			bcc 	_EASPNoCarry
.17cc	e6 09		inc $09				inc 	srcPtr+1					; carry through
.17ce					_EASPNoCarry:
.17ce	60		rts				rts
.17cf					EncodeGetConstant:
.17cf	a5 08		lda $08				lda 	srcPtr 						; get source
.17d1	a4 09		ldy $09				ldy 	srcPtr+1
.17d3	20 cf 1c	jsr $1ccf			jsr 	ConvertToInteger 			; call converter
.17d6	90 07		bcc $17df			bcc 	_EGCExit
.17d8	20 c5 17	jsr $17c5			jsr 	EncodeAddSrcPtr 			; if passed add chars to src ptr
.17db	a5 14		lda $14				lda 	temp3 						; get result into YA
.17dd	a4 15		ldy $15				ldy 	temp3+1
.17df					_EGCExit:
.17df	60		rts				rts
.17e0					EncSetBit7Word:
.17e0	08		php				php 								; save carry
.17e1	a0 ff		ldy #$ff			ldy 	#255 						; scan forward for space/NULL
.17e3					_ESB7Loop:
.17e3	c8		iny				iny
.17e4	b1 08		lda ($08),y			lda 	(srcPtr),y
.17e6	c9 21		cmp #$21			cmp 	#" "+1 						; while > ' '
.17e8	b0 f9		bcs $17e3			bcs 	_ESB7Loop
.17ea	88		dey				dey									; previous character
.17eb	b1 08		lda ($08),y			lda 	(srcPtr),y 					; read it
.17ed	0a		asl a				asl 	a 							; shift bit 7 out
.17ee	28		plp				plp 								; restore carry
.17ef	6a		ror a				ror 	a 							; shift it in
.17f0	91 08		sta ($08),y			sta 	(srcPtr),y 					; write back and exit
.17f2	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/encode/encsearch.src

.17f3					EncodeSearchDictionary:
.17f3	a9 95		lda #$95			lda 	#(Dictionary) & $FF
.17f5	85 10		sta $10				sta 	0+(temp1)
.17f7	a9 1f		lda #$1f			lda 	#(Dictionary) >> 8
.17f9	85 11		sta $11				sta 	1+(temp1)
.17fb					_ESDLoop:
.17fb	b2 10		lda ($10)			lda 	(temp1) 					; end of dictionary return with CC.
.17fd	18		clc				clc
.17fe	f0 46		beq $1846			beq 	_ESDExit
.1800	a0 01		ldy #$01			ldy 	#1 							; get control bits, get offset to name.
.1802	b1 10		lda ($10),y			lda 	(temp1),y
.1804	4a		lsr a				lsr 	a 							; encode/decode bits move to 0,1
.1805	4a		lsr a				lsr 	a
.1806	4a		lsr a				lsr 	a
.1807	4a		lsr a				lsr 	a
.1808	c8		iny				iny 								; Y = 2
.1809	4a		lsr a				lsr 	a
.180a	90 01		bcc $180d			bcc 	_ESDNotDec
.180c	c8		iny				iny
.180d					_ESDNotDec:
.180d	4a		lsr a				lsr 	a
.180e	90 01		bcc $1811			bcc 	_ESDNotInc
.1810	c8		iny				iny
.1811					_ESDNotInc:
.1811	98		tya				tya
.1812	0a		asl a				asl 	a 							; A is now 4,6,8 offset to name.
.1813	a8		tay				tay
.1814	b1 10		lda ($10),y			lda 	(temp1),y 					; quick check of first character
.1816	d2 08		cmp ($08)			cmp 	(srcPtr)
.1818	d0 1f		bne $1839			bne 	_ESDNext 					; do not match, go to next
.181a	98		tya				tya 								; make temp2 point to the name in
.181b	18		clc				clc 								; the dictionary.
.181c	65 10		adc $10				adc 	temp1
.181e	85 12		sta $12				sta 	temp2
.1820	a5 11		lda $11				lda 	temp1+1
.1822	69 00		adc #$00			adc 	#0
.1824	85 13		sta $13				sta 	temp2+1
.1826	a0 ff		ldy #$ff			ldy 	#255 						; now start matching up.
.1828					_ESDCompare:
.1828	c8		iny				iny
.1829	b1 08		lda ($08),y			lda 	(srcPtr),y
.182b	d1 12		cmp ($12),y			cmp 	(temp2),y
.182d	d0 0a		bne $1839			bne 	_ESDNext
.182f	0a		asl a				asl 	a
.1830	90 f6		bcc $1828			bcc 	_ESDCompare
.1832	a5 10		lda $10				lda 	temp1 						; return address in YA and carry set.
.1834	a4 11		ldy $11				ldy 	temp1+1
.1836	38		sec				sec
.1837	80 0d		bra $1846			bra 	_ESDExit
.1839					_ESDNext:
.1839	18		clc				clc
.183a	a5 10		lda $10				lda 	temp1
.183c	72 10		adc ($10)			adc 	(temp1)
.183e	85 10		sta $10				sta 	temp1
.1840	90 b9		bcc $17fb			bcc 	_ESDLoop
.1842	e6 11		inc $11				inc 	temp1+1
.1844	80 b5		bra $17fb			bra 	_ESDLoop
.1846					_ESDExit:
.1846	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/structures/fornext.src

.1847					ForHandler:
.1847	e6 05		inc $05				inc 	rsp 						; bump the RSP
.1849	a4 05		ldy $05				ldy 	rsp 						; get return stack and push TOS/$FF on it.
.184b	c0 40		cpy #$40			cpy 	#$40 						; overflow
.184d	f0 18		beq $1867			beq 	_FHOverflow
.184f	a5 07		lda $07				lda 	TOS+1
.1851	99 40 07	sta $0740,y			sta 	returnStackHigh,y
.1854	a5 06		lda $06				lda 	TOS
.1856	99 00 07	sta $0700,y			sta 	returnStackLow,y
.1859	a9 ff		lda #$ff			lda 	#$FF
.185b	99 80 07	sta $0780,y			sta 	returnStackX,y
.185e	68		pla				pla
.185f	85 07		sta $07				sta 	TOS+1
.1861	68		pla				pla
.1862	85 06		sta $06				sta 	TOS
.1864	4c 00 00	jmp $0000			jmp 	Next
.1867					_FHOverflow:
.1867	20 23 10	jsr $1023			jsr 	ErrorHandler
>186a	46 4f 52 20 53 54 41 43				.text 	"FOR STACK?",0
>1872	4b 3f 00
.1875					NextHandler:
.1875	da		phx				phx
.1876	a6 05		ldx $05				ldx 	rsp 						; get current stack ptr
.1878	bd 80 07	lda $0780,x			lda 	returnStackX,x 				; check it's a FOR Loop
.187b	c9 ff		cmp #$ff			cmp 	#$FF
.187d	d0 21		bne $18a0			bne 	NHNoFor
.187f	bd 00 07	lda $0700,x			lda 	returnStackLow,x 			; decrement the count
.1882	d0 03		bne $1887			bne 	_NHNoBorrow
.1884	de 40 07	dec $0740,x			dec 	returnStackHigh,x
.1887					_NHNoBorrow:
.1887	de 00 07	dec $0700,x			dec 	returnStackLow,x
.188a	bd 00 07	lda $0700,x			lda 	returnStackLow,x 			; have we reached the end ?
.188d	1d 40 07	ora $0740,x			ora 	returnStackHigh,x
.1890	fa		plx				plx 								; restore X and re-test
.1891	09 00		ora #$00			ora 	#0
.1893	f0 05		beq $189a			beq 	_NHComplete 				; if so then complete, else loop.
.1895	e8		inx				inx 								; advance to branch
.1896	e8		inx				inx
.1897	4c f3 18	jmp $18f3			jmp 	BranchAlways
.189a					_NHComplete:
.189a	e8		inx				inx 								; skip over the branch quantity
.189b	c6 05		dec $05				dec 	rsp 						; drop the indx
.189d	4c 00 00	jmp $0000			jmp 	Next
.18a0					NHNoFor:
.18a0	20 23 10	jsr $1023			jsr 	ErrorHandler
>18a3	4e 4f 20 46 4f 52 3f 00				.text 	"NO FOR?",0
.18ab					GetIndex:
.18ab	a4 05		ldy $05				ldy 	rsp 						; get current stack ptr
.18ad	b9 80 07	lda $0780,y			lda 	returnStackX,y 				; check it's a FOR Loop
.18b0	c9 ff		cmp #$ff			cmp 	#$FF
.18b2	d0 ec		bne $18a0			bne 	NHNoFor
.18b4	a5 06		lda $06				lda 	TOS
.18b6	48		pha				pha
.18b7	a5 07		lda $07				lda 	TOS+1
.18b9	48		pha				pha
.18ba	b9 00 07	lda $0700,y			lda 	returnStackLow,y 			; put counter-1 out
.18bd	38		sec				sec
.18be	e9 01		sbc #$01			sbc 	#1
.18c0	85 06		sta $06				sta 	TOS
.18c2	b9 40 07	lda $0740,y			lda 	returnStackHigh,y
.18c5	e9 00		sbc #$00			sbc 	#0
.18c7	85 07		sta $07				sta 	TOS+1
.18c9	4c 00 00	jmp $0000			jmp 	Next

;******  Return to file: kernel.asm


;******  Processing file: words/structures/ifelseendif.src

.18cc					IfHandler:
.18cc	4c db 18	jmp $18db			jmp 	BranchIfZero
.18cf					ElseHandler:
.18cf	4c f1 18	jmp $18f1			jmp 	BranchTestSucceedsNoPop
.18d2					EndIfHandler:
.18d2	4c 00 00	jmp $0000			jmp 	Next

;******  Return to file: kernel.asm


;******  Processing file: words/structures/repeatuntil.src

.18d5					RepeatHandler:
.18d5	4c 00 00	jmp $0000			jmp 	Next
.18d8					UntilHandler:
.18d8	4c db 18	jmp $18db			jmp 	BranchIfZero

;******  Return to file: kernel.asm


;******  Processing file: words/system/branch.src

.18db					BranchIfZero:
.18db	a5 06		lda $06				lda 	TOS 						; check TOS = 0
.18dd	05 07		ora $07				ora 	TOS+1
.18df	f0 0a		beq $18eb			beq 	BranchTestSucceeds
.18e1					BranchTestFails:
.18e1	68		pla				pla
.18e2	85 07		sta $07				sta 	TOS+1
.18e4	68		pla				pla
.18e5	85 06		sta $06				sta 	TOS
.18e7	e8		inx				inx 								; skip over the relative branch.
.18e8	4c 00 00	jmp $0000			jmp 	Next
.18eb					BranchTestSucceeds:
.18eb	68		pla				pla
.18ec	85 07		sta $07				sta 	TOS+1
.18ee	68		pla				pla
.18ef	85 06		sta $06				sta 	TOS
.18f1					BranchTestSucceedsNoPop:
.18f1	e8		inx				inx 								; advance by two, to the offset
.18f2	e8		inx				inx
.18f3					BranchAlways:
.18f3	8a		txa				txa 								; A = Y = position
.18f4	a8		tay				tay 								; (IP),Y now points to the branch target
.18f5	b1 03		lda ($03),y			lda 	(IP),y 						; adjust the position
.18f7	aa		tax				tax 								; position back in this line.
.18f8	4c 02 00	jmp $0002			jmp 	Next+2 						; and continue

;******  Return to file: kernel.asm


;******  Processing file: words/system/callhandler.src

.18fb					CallHandler:
.18fb	e8		inx				inx									; bump X to the call address.
.18fc	e8		inx				inx
.18fd	e6 05		inc $05				inc 	rsp 						; bump the RSP (first time to zero)
.18ff	a4 05		ldy $05				ldy 	rsp 						; get return stack and push IP/X on it.
.1901	c0 40		cpy #$40			cpy 	#$40 						; overflow
.1903	f0 4b		beq $1950			beq 	_CHOverflow
.1905	a5 04		lda $04				lda 	IP+1
.1907	99 40 07	sta $0740,y			sta 	returnStackHigh,y
.190a	a5 03		lda $03				lda 	IP
.190c	99 00 07	sta $0700,y			sta 	returnStackLow,y
.190f	8a		txa				txa
.1910	99 80 07	sta $0780,y			sta 	returnStackX,y
.1913	8a		txa				txa 								; get the line number into temp1.
.1914	a8		tay				tay
.1915	b1 03		lda ($03),y			lda 	(IP),y
.1917	85 10		sta $10				sta 	temp1
.1919	c8		iny				iny
.191a	b1 03		lda ($03),y			lda 	(IP),y
.191c	85 11		sta $11				sta 	temp1+1
.191e	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.1920	85 03		sta $03				sta 	0+(IP)
.1922	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.1924	85 04		sta $04				sta 	1+(IP)
.1926	b2 03		lda ($03)			lda 	(IP)						; no program code ?
.1928	f0 17		beq $1941			beq 	_CHFail
.192a	a0 01		ldy #$01			ldy 	#1 							; Y = 1 throughout.
.192c					_CHSearch:
.192c	b1 03		lda ($03),y			lda 	(IP),y 						; check LSB of line number
.192e	c5 10		cmp $10				cmp 	temp1
.1930	f0 2d		beq $195f			beq 	_CHFoundLSB
.1932					_CHSearchNext:
.1932	18		clc				clc
.1933	a5 03		lda $03				lda 	IP
.1935	72 03		adc ($03)			adc 	(IP)
.1937	85 03		sta $03				sta 	IP
.1939	90 02		bcc $193d			bcc 	_NoCarryAdv
.193b	e6 04		inc $04				inc 	IP+1
.193d					_NoCarryAdv:
.193d	b2 03		lda ($03)			lda 	(IP)						; check reached the end.
.193f	d0 eb		bne $192c			bne 	_CHSearch
.1941					_CHFail:
.1941	20 23 10	jsr $1023			jsr 	ErrorHandler
>1944	44 45 46 49 4e 49 54 49				.text 	"DEFINITION?",0
>194c	4f 4e 3f 00
.1950					_CHOverflow:
.1950	20 23 10	jsr $1023			jsr 	ErrorHandler
>1953	53 54 41 43 4b 44 45 50				.text 	"STACKDEPTH?",0
>195b	54 48 3f 00
.195f					_CHFoundLSB:
.195f	c8		iny				iny 								; get MSB
.1960	b1 03		lda ($03),y			lda 	(IP),y
.1962	88		dey				dey
.1963	c5 11		cmp $11				cmp 	temp1+1 					; matches, if not contineu
.1965	d0 cb		bne $1932			bne 	_CHSearchNext
.1967	a0 03		ldy #$03			ldy 	#3	 						; check it begins with $$define
.1969	b1 03		lda ($03),y			lda 	(IP),y
.196b	c9 97		cmp #$97			cmp 	#DefineCode & $FF
.196d	d0 d2		bne $1941			bne 	_CHFail
.196f	c8		iny				iny
.1970	b1 03		lda ($03),y			lda 	(IP),y
.1972	c9 1d		cmp #$1d			cmp 	#DefineCode >> 8
.1974	d0 cb		bne $1941			bne 	_CHFail
.1976	c8		iny				iny
.1977	b1 03		lda ($03),y			lda 	(IP),y 						; this is the length of the define name
.1979	18		clc				clc
.197a	69 05		adc #$05			adc 	#5 							; $$define token, line number, offset
.197c	aa		tax				tax
.197d	4c 02 00	jmp $0002			jmp 	Next+2 						; and execute
.1980					ReturnHandler:
.1980	a4 05		ldy $05				ldy 	rsp 						; get rsp
.1982	30 15		bmi $1999			bmi 	_RHUnderflow 				; if -ve underflowed
.1984	c6 05		dec $05				dec 	rsp 						; decrement rsp
.1986	b9 40 07	lda $0740,y			lda 	returnStackHigh,y 			; restore IP/X
.1989	85 04		sta $04				sta 	IP+1
.198b	b9 00 07	lda $0700,y			lda 	returnStackLow,y
.198e	85 03		sta $03				sta 	IP
.1990	b9 80 07	lda $0780,y			lda 	returnStackX,y
.1993	aa		tax				tax
.1994	f0 0e		beq $19a4			beq 	_RHInLoop 					; this means you have done :something for ; next
.1996	4c 00 00	jmp $0000			jmp 	Next
.1999					_RHUnderflow:
.1999	20 23 10	jsr $1023			jsr 	ErrorHandler
>199c	52 45 54 55 52 4e 3f 00				.text 	"RETURN?",0
.19a4					_RHInLoop:
.19a4	20 23 10	jsr $1023			jsr 	ErrorHandler
>19a7	52 45 54 55 52 4e 20 49				.text 	"RETURN IN LOOP?",0
>19af	4e 20 4c 4f 4f 50 3f 00
.19b7					CallHandlerDecode:
.19b7	a9 03		lda #$03			lda 	#CTH_Call					; space
.19b9	20 77 1b	jsr $1b77			jsr 	DecodeWriteBuffer
.19bc	b1 08		lda ($08),y			lda 	(srcPtr),y 					; get line number into YA
.19be	aa		tax				tax
.19bf	c8		iny				iny
.19c0	b1 08		lda ($08),y			lda 	(srcPtr),y
.19c2	a8		tay				tay
.19c3	8a		txa				txa
.19c4	20 01 1a	jsr $1a01			jsr 	FindLine 					; try to locate that line.
.19c7	b0 11		bcs $19da			bcs 	_CHDFound 					; if found .....
.19c9					_CHDLineOnly:
.19c9	48		pha				pha
.19ca	a9 3c		lda #$3c			lda 	#"<"
.19cc	20 77 1b	jsr $1b77			jsr 	DecodeWriteBuffer
.19cf	68		pla				pla
.19d0	18		clc				clc 								; output unsigned
.19d1	20 99 1b	jsr $1b99			jsr 	DecodeYAToBuffer
.19d4	a9 3e		lda #$3e			lda 	#">"
.19d6	20 77 1b	jsr $1b77			jsr 	DecodeWriteBuffer
.19d9	60		rts				rts
.19da					_CHDFound:
.19da	48		pha				pha 								; save YA
.19db	5a		phy				phy
.19dc	a0 03		ldy #$03			ldy 	#3 							; check first is $$define
.19de	b1 10		lda ($10),y			lda 	(temp1),y
.19e0	c9 97		cmp #$97			cmp 	#DefineCode & 255
.19e2	d0 07		bne $19eb			bne 	_CHDNoDefine
.19e4	c8		iny				iny
.19e5	b1 10		lda ($10),y			lda 	(temp1),y
.19e7	c9 1d		cmp #$1d			cmp 	#DefineCode >> 8
.19e9	f0 04		beq $19ef			beq 	_CHDFoundDefine
.19eb					_CHDNoDefine:
.19eb	7a		ply				ply									; restore the line number and print it in <>
.19ec	68		pla				pla
.19ed	80 da		bra $19c9			bra 	_CHDLineOnly
.19ef					_CHDFoundDefine:
.19ef	68		pla				pla 								; throw saved line number.
.19f0	68		pla				pla
.19f1	a0 05		ldy #$05			ldy 	#5 							; 3,4 $$define 5 length, name has bit 7 set at end
.19f3					_CHDOutName:
.19f3	c8		iny				iny 								; next
.19f4	b1 10		lda ($10),y			lda 	(temp1),y 					; print char no bit 7
.19f6	48		pha				pha
.19f7	29 7f		and #$7f			and 	#$7F
.19f9	20 77 1b	jsr $1b77			jsr 	DecodeWriteBuffer
.19fc	68		pla				pla
.19fd	0a		asl a				asl 	a 							; bit 7 to carry
.19fe	90 f3		bcc $19f3			bcc 	_CHDOutName
.1a00	60		rts				rts
.1a01					FindLine:
.1a01	48		pha				pha 								; save registers
.1a02	da		phx				phx
.1a03	5a		phy				phy
.1a04	85 12		sta $12				sta 	temp2 						; temp2 = target line#
.1a06	84 13		sty $13				sty 	temp2+1
.1a08	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.1a0a	85 10		sta $10				sta 	0+(temp1)
.1a0c	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.1a0e	85 11		sta $11				sta 	1+(temp1)
.1a10					_FLLoop:
.1a10	b2 10		lda ($10)			lda 	(temp1) 					; found end ?
.1a12	18		clc				clc									; if so exit with CC.
.1a13	f0 1d		beq $1a32			beq 	_FLExit
.1a15	a0 01		ldy #$01			ldy 	#1 							; check line # match
.1a17	b1 10		lda ($10),y			lda 	(temp1),y
.1a19	c5 12		cmp $12				cmp 	temp2
.1a1b	d0 08		bne $1a25			bne 	_FLNext
.1a1d	c8		iny				iny
.1a1e	b1 10		lda ($10),y			lda 	(temp1),y
.1a20	c5 13		cmp $13				cmp 	temp2+1
.1a22	38		sec				sec 								; if so exit with CS
.1a23	f0 0d		beq $1a32			beq 	_FLExit
.1a25					_FLNext:
.1a25	18		clc				clc
.1a26	a5 10		lda $10				lda 	temp1
.1a28	72 10		adc ($10)			adc 	(temp1)
.1a2a	85 10		sta $10				sta 	temp1
.1a2c	90 02		bcc $1a30			bcc 	_NoCarryAdv
.1a2e	e6 11		inc $11				inc 	temp1+1
.1a30					_NoCarryAdv:
.1a30	80 de		bra $1a10			bra 	_FLLoop 					; keep looking.
.1a32					_FLExit:
.1a32	7a		ply				ply
.1a33	fa		plx				plx
.1a34	68		pla				pla
.1a35	60		rts				rts
.1a36	18		clc				clc
.1a37	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/clrnew.src

.1a38					NewHandler:
.1a38	9c 00 40	stz $4000			stz 	ProgramMemory 				; Make the first offset zero.
.1a3b	20 47 1a	jsr $1a47			jsr 	ClearVariableSpace 			; clear variables, reset pointers
.1a3e	4c 00 00	jmp $0000			jmp 	Next
.1a41					ClrHandler:
.1a41	20 47 1a	jsr $1a47			jsr 	ClearVariableSpace 			; clear variables, reset pointers
.1a44	4c 00 00	jmp $0000			jmp 	Next
.1a47					ClearVariableSpace:
.1a47	a9 ff		lda #$ff			lda 	#$FF 						; empty return stack
.1a49	85 05		sta $05				sta 	rsp
.1a4b	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.1a4d	85 0e		sta $0e				sta 	0+(nextFreeMem)
.1a4f	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.1a51	85 0f		sta $0f				sta 	1+(nextFreeMem)
.1a53	a0 1f		ldy #$1f			ldy 	#hashTableSize*2-1 			; erase the hash table (used for variables)
.1a55					_CVSHashClear:
.1a55	a9 00		lda #$00			lda 	#0 							; all the first record pointers are $00
.1a57	99 40 06	sta $0640,y			sta 	hashTable,y
.1a5a	88		dey				dey
.1a5b	10 f8		bpl $1a55			bpl 	_CVSHashClear
.1a5d					_CVSFindEnd:
.1a5d	18		clc				clc
.1a5e	a5 0e		lda $0e				lda 	nextFreeMem
.1a60	72 0e		adc ($0e)			adc 	(nextFreeMem)
.1a62	85 0e		sta $0e				sta 	nextFreeMem
.1a64	90 02		bcc $1a68			bcc 	_NoCarryAdv
.1a66	e6 0f		inc $0f				inc 	nextFreeMem+1
.1a68					_NoCarryAdv:
.1a68	b2 0e		lda ($0e)			lda 	(nextFreeMem)
.1a6a	d0 f1		bne $1a5d			bne 	_CVSFindEnd
.1a6c	a9 08		lda #$08			lda 	#8 							; this puts a gap in, more for clarity than anything.
.1a6e	a0 00		ldy #$00			ldy 	#0
.1a70	20 74 1a	jsr $1a74			jsr 	AdvanceFreeMem				; we need +1 because the previous code leaves the
.1a73	60		rts				rts 								; free mem pointer pointing to the last zero offset
.1a74					AdvanceFreeMem:
.1a74	18		clc				clc
.1a75	65 0e		adc $0e				adc 	nextFreeMem
.1a77	85 0e		sta $0e				sta 	nextFreeMem
.1a79	98		tya				tya
.1a7a	65 0f		adc $0f				adc 	nextFreeMem+1
.1a7c	85 0f		sta $0f				sta 	nextFreeMem+1
.1a7e	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/debug.src

.1a7f					ExitDump:
.1a7f	ba		tsx				tsx 								; save Data Stack in temp1
.1a80	86 10		stx $10				stx 	temp1
.1a82	4c ff ff	jmp $ffff			jmp 	$FFFF 						; makes the X16-Emulator dump-exit.
.1a85					BreakCmd:
>1a85	ff						.byte 	$FF
.1a86	4c 00 00	jmp $0000			jmp 	Next

;******  Return to file: kernel.asm


;******  Processing file: words/system/decode.src

.1a89					DecodeLineIntoBufPtr:
.1a89	48		pha				pha
.1a8a	da		phx				phx
.1a8b	5a		phy				phy
.1a8c	85 08		sta $08				sta 	srcPtr 						; save the source line.
.1a8e	84 09		sty $09				sty 	srcPtr+1
.1a90	90 1b		bcc $1aad			bcc 	_DecodeNoLineNumber
.1a92	a0 01		ldy #$01			ldy 	#1 							; get line # to YA
.1a94	b1 08		lda ($08),y			lda 	(srcPtr),y
.1a96	aa		tax				tax
.1a97	c8		iny				iny
.1a98	b1 08		lda ($08),y			lda 	(srcPtr),y
.1a9a	a8		tay				tay
.1a9b	8a		txa				txa
.1a9c	18		clc				clc
.1a9d	20 99 1b	jsr $1b99			jsr 	DecodeYAToBuffer 			; convert to string in buffer
.1aa0	aa		tax				tax 								; count in X
.1aa1					_DecodeLineSpace:
.1aa1	e0 05		cpx #$05			cpx 	#5
.1aa3	f0 08		beq $1aad			beq 	_DecodeNoLineNumber
.1aa5	a9 20		lda #$20			lda 	#" " 						; pad to 5 spaces
.1aa7	20 77 1b	jsr $1b77			jsr 	DecodeWriteBuffer
.1aaa	e8		inx				inx
.1aab	80 f4		bra $1aa1			bra 	_DecodeLineSpace
.1aad					_DecodeNoLineNumber:
.1aad	a0 03		ldy #$03			ldy 	#3 							; initial position.
.1aaf					_DecodeLoop:
.1aaf	b1 08		lda ($08),y			lda 	(srcPtr),y 					; copy the current character to temp1
.1ab1	85 10		sta $10				sta 	temp1 						; must be an execution address.
.1ab3	c8		iny				iny
.1ab4	b1 08		lda ($08),y			lda 	(srcPtr),y
.1ab6	85 11		sta $11				sta 	temp1+1
.1ab8	c8		iny				iny 								; y points to the byte after it.
.1ab9	a5 10		lda $10				lda 	temp1
.1abb	c9 5d		cmp #$5d			cmp 	#NextLine & $FF
.1abd	d0 06		bne $1ac5			bne 	_DecodeNotEOL
.1abf	a5 11		lda $11				lda 	temp1+1
.1ac1	c9 1d		cmp #$1d			cmp 	#NextLine >> 8
.1ac3	f0 0b		beq $1ad0			beq 	_DecodeEOL
.1ac5					_DecodeNotEOL:
.1ac5	20 d8 1a	jsr $1ad8			jsr 	IdentifyCodeWord
.1ac8	20 22 1b	jsr $1b22			jsr 	DecodeFoundWord
.1acb	20 0c 1b	jsr $1b0c			jsr 	AdvanceToNext 				; advance to next entry in the line.
.1ace	80 df		bra $1aaf			bra 	_DecodeLoop 				; and go round again
.1ad0					_DecodeEOL:
.1ad0	a9 00		lda #$00			lda 	#0
.1ad2	92 0a		sta ($0a)			sta 	(bufPtr)
.1ad4	7a		ply				ply 								; restore registers and exit
.1ad5	fa		plx				plx
.1ad6	68		pla				pla
.1ad7	60		rts				rts
.1ad8					IdentifyCodeWord:
.1ad8	5a		phy				phy 								; save current position on the stack.
.1ad9	a9 95		lda #$95			lda 	#(Dictionary) & $FF
.1adb	85 0c		sta $0c				sta 	0+(matchPtr)
.1add	a9 1f		lda #$1f			lda 	#(Dictionary) >> 8
.1adf	85 0d		sta $0d				sta 	1+(matchPtr)
.1ae1					_DecodeIdentify:
.1ae1	a0 02		ldy #$02			ldy 	#2 							; have we found a match ?
.1ae3	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.1ae5	c5 10		cmp $10				cmp 	temp1
.1ae7	d0 07		bne $1af0			bne 	_DecodeIdNext
.1ae9	c8		iny				iny
.1aea	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.1aec	c5 11		cmp $11				cmp 	temp1+1
.1aee	f0 1a		beq $1b0a			beq 	_DecodeIdFound
.1af0					_DecodeIdNext:
.1af0	18		clc				clc
.1af1	b2 0c		lda ($0c)			lda 	(matchPtr)
.1af3	f0 0a		beq $1aff			beq 	_DecodeIdIssue
.1af5	65 0c		adc $0c				adc 	matchPtr
.1af7	85 0c		sta $0c				sta 	matchPtr
.1af9	90 e6		bcc $1ae1			bcc 	_DecodeIdentify
.1afb	e6 0d		inc $0d				inc 	matchPtr+1
.1afd	80 e2		bra $1ae1			bra 	_DecodeIdentify
.1aff					_DecodeIdIssue:
.1aff	20 23 10	jsr $1023			jsr 	ErrorHandler
>1b02	44 45 43 4f 44 45 3f 00				.text 	"DECODE?",0
.1b0a					_DecodeIdFound:
.1b0a	7a		ply				ply 								; restore position.
.1b0b	60		rts				rts
.1b0c					AdvanceToNext:
.1b0c	5a		phy				phy 								; get the parameter count from bits 0-1 of the type byte
.1b0d	a0 01		ldy #$01			ldy 	#1
.1b0f	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.1b11	29 03		and #$03			and 	#3 							; bits 0-1.
.1b13	7a		ply				ply
.1b14	c9 03		cmp #$03			cmp 	#3 							; is it n-bytes e.g. specified by the next byte
.1b16	d0 02		bne $1b1a			bne 	_ATN012
.1b18	b1 08		lda ($08),y			lda 	(srcPtr),y 					; if so, use that byte as the overall length.
.1b1a					_ATN012:
.1b1a	85 12		sta $12				sta 	temp2 						; now add that to Y
.1b1c	98		tya				tya
.1b1d	18		clc				clc
.1b1e	65 12		adc $12				adc 	temp2
.1b20	a8		tay				tay
.1b21	60		rts				rts
.1b22					DecodeFoundWord:
.1b22	5a		phy				phy 								; save current position
.1b23	84 12		sty $12				sty		temp2 						; put it in temp2 as well.
.1b25	a0 01		ldy #$01			ldy 	#1 							; get the type byte
.1b27	b1 0c		lda ($0c),y			lda 	(matchPtr),y 				; is there a special decoder check (bit 4 set) ?
.1b29	29 10		and #$10			and 	#$10
.1b2b	d0 0e		bne $1b3b			bne 	_DFWSpecialDecoder
.1b2d	b1 0c		lda ($0c),y			lda 	(matchPtr),y 				; reget it.
.1b2f	30 08		bmi $1b39			bmi 	_DFWExit 					; if hidden word (bit 7 set)
.1b31	a9 06		lda #$06			lda 	#CTH_Keyword				; output a space to the buffer
.1b33	20 77 1b	jsr $1b77			jsr 	DecodeWriteBuffer
.1b36	20 54 1b	jsr $1b54			jsr 	DecodeCurrentWord 			; expand that.
.1b39					_DFWExit:
.1b39	7a		ply				ply 								; restore current position
.1b3a	60		rts				rts
.1b3b					_DFWSpecialDecoder:
.1b3b	a0 04		ldy #$04			ldy 	#4 							; the decode word address is at offset 4,5
.1b3d	b1 0c		lda ($0c),y			lda 	(matchPtr),y 				; copy this into temp2
.1b3f	85 12		sta $12				sta 	temp2
.1b41	c8		iny				iny
.1b42	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.1b44	85 13		sta $13				sta 	temp2+1
.1b46	7a		ply				ply 	 							; restore current position into Y
.1b47	48		pha				pha 								; save registers
.1b48	da		phx				phx
.1b49	5a		phy				phy
.1b4a	20 51 1b	jsr $1b51			jsr 	_DFWCallDecoder				; call the decoder routine
.1b4d	7a		ply				ply 								; restore registers and exit
.1b4e	fa		plx				plx
.1b4f	68		pla				pla
.1b50	60		rts				rts
.1b51					_DFWCallDecoder:
.1b51	6c 12 00	jmp ($0012)			jmp 	(temp2)
.1b54					DecodeCurrentWord:
.1b54	5a		phy				phy
.1b55	a0 01		ldy #$01			ldy 	#1 							; read type byte
.1b57	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.1b59	a0 04		ldy #$04			ldy 	#4 							; original offset
.1b5b	4a		lsr a				lsr 	a 							; encoder/decoder bits in 0-1
.1b5c	4a		lsr a				lsr 	a 							; add 2 to Y for each encoder/decoder
.1b5d	4a		lsr a				lsr 	a 							; bit set.
.1b5e	4a		lsr a				lsr 	a
.1b5f	4a		lsr a				lsr 	a 							; decoder bit
.1b60	90 02		bcc $1b64			bcc 	_DWBNoDec
.1b62	c8		iny				iny
.1b63	c8		iny				iny
.1b64					_DWBNoDec:
.1b64	4a		lsr a				lsr 	a
.1b65	90 02		bcc $1b69			bcc 	_DWBNoEnc
.1b67	c8		iny				iny
.1b68	c8		iny				iny
.1b69					_DWBNoEnc:
.1b69					_DWBWordOut:
.1b69	b1 0c		lda ($0c),y			lda 	(matchPtr),y 				; output until bit 7 set.
.1b6b	48		pha				pha
.1b6c	29 7f		and #$7f			and 	#$7F
.1b6e	20 77 1b	jsr $1b77			jsr		DecodeWriteBuffer
.1b71	c8		iny				iny
.1b72	68		pla				pla
.1b73	10 f4		bpl $1b69			bpl 	_DWBWordOut
.1b75	7a		ply				ply 								; restore Y and exit
.1b76	60		rts				rts
.1b77					DecodeWriteBuffer:
.1b77	92 0a		sta ($0a)			sta 	(bufPtr)
.1b79	e6 0a		inc $0a				inc 	bufPtr
.1b7b	d0 02		bne $1b7f			bne 	_DWBNoCarry
.1b7d	e6 0b		inc $0b				inc 	bufPtr+1
.1b7f					_DWBNoCarry:
.1b7f	60		rts				rts
.1b80					DecodeOutputData:
.1b80	48		pha				pha
.1b81	da		phx				phx
.1b82	5a		phy				phy
.1b83	b1 08		lda ($08),y			lda 	(srcPtr),y 					; length + 1
.1b85	aa		tax				tax
.1b86					_DODLoop:
.1b86	ca		dex				dex 								; done it all ?
.1b87	f0 0c		beq $1b95			beq		_DODExit
.1b89	c8		iny				iny 								; output next character
.1b8a	b1 08		lda ($08),y			lda 	(srcPtr),y
.1b8c	29 7f		and #$7f			and 	#$7F
.1b8e	f0 f6		beq $1b86			beq 	_DODLoop 					; don't print NULL
.1b90	20 77 1b	jsr $1b77			jsr 	DecodeWriteBuffer
.1b93	80 f1		bra $1b86			bra 	_DODLoop
.1b95					_DODExit:
.1b95	7a		ply				ply
.1b96	fa		plx				plx
.1b97	68		pla				pla
.1b98	60		rts				rts
.1b99					DecodeYAToBuffer:
.1b99	da		phx				phx
.1b9a	5a		phy				phy
.1b9b	48		pha				pha
.1b9c	a5 0a		lda $0a				lda 	bufPtr 						; copy bufPtr to temp2
.1b9e	85 12		sta $12				sta 	temp2
.1ba0	a5 0b		lda $0b				lda 	bufPtr+1
.1ba2	85 13		sta $13				sta 	temp2+1
.1ba4	68		pla				pla
.1ba5	20 d7 1d	jsr $1dd7			jsr 	ConvertToStringMain 		; convert YA to string there
.1ba8	aa		tax				tax 								; chars output to X
.1ba9	18		clc				clc
.1baa	65 0a		adc $0a				adc 	bufPtr 						; add to buffer pointer
.1bac	85 0a		sta $0a				sta 	bufPtr
.1bae	90 02		bcc $1bb2			bcc 	_DYABNoCarry
.1bb0	e6 0b		inc $0b				inc 	bufPtr+1
.1bb2					_DYABNoCarry:
.1bb2	8a		txa				txa 								; count in A
.1bb3	7a		ply				ply									; restore and exit.
.1bb4	fa		plx				plx
.1bb5	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/list.src

.1bb6					ListCode:
.1bb6	64 1e		stz $1e				stz 	ListLowest 					; zero lowest line#
.1bb8	64 1f		stz $1f				stz 	ListLowest+1
.1bba	a9 14		lda #$14			lda 	#20 						; show max 20 after lowest line
.1bbc	85 1d		sta $1d				sta 	ListCount
.1bbe	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.1bc0	85 18		sta $18				sta 	0+(listPtr)
.1bc2	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.1bc4	85 19		sta $19				sta 	1+(listPtr)
.1bc6	86 10		stx $10				stx 	temp1						; S->A
.1bc8	ba		tsx				tsx
.1bc9	8a		txa				txa
.1bca	a6 10		ldx $10				ldx 	temp1
.1bcc	c9 80		cmp #$80			cmp 	#NumberStackBase
.1bce	f0 0e		beq $1bde			beq 	_LCLoop
.1bd0	a5 06		lda $06				lda 	TOS 						; copy TOS to lowest
.1bd2	85 1e		sta $1e				sta 	ListLowest
.1bd4	a5 07		lda $07				lda 	TOS+1
.1bd6	85 1f		sta $1f				sta 	ListLowest+1
.1bd8	68		pla				pla
.1bd9	85 07		sta $07				sta 	TOS+1
.1bdb	68		pla				pla
.1bdc	85 06		sta $06				sta 	TOS
.1bde					_LCLoop:
.1bde	b2 18		lda ($18)			lda 	(listPtr)					; reached end ?
.1be0	f0 4e		beq $1c30			beq 	_LCExit
.1be2	a0 01		ldy #$01			ldy 	#1							; >= list lowest
.1be4	b1 18		lda ($18),y			lda 	(listPtr),y
.1be6	c5 1e		cmp $1e				cmp 	ListLowest
.1be8	c8		iny				iny
.1be9	b1 18		lda ($18),y			lda 	(listPtr),y
.1beb	e5 1f		sbc $1f				sbc 	ListLowest+1
.1bed	90 34		bcc $1c23			bcc 	_LCNext
.1bef	a9 10		lda #$10			lda 	#(textBuffer) & $FF
.1bf1	85 0a		sta $0a				sta 	0+(bufPtr)
.1bf3	a9 08		lda #$08			lda 	#(textBuffer) >> 8
.1bf5	85 0b		sta $0b				sta 	1+(bufPtr)
.1bf7	a5 18		lda $18				lda 	listPtr 					; output the line.
.1bf9	a4 19		ldy $19				ldy 	listPtr+1
.1bfb	38		sec				sec
.1bfc	20 89 1a	jsr $1a89			jsr 	DecodeLineIntoBufPtr
.1bff	a9 02		lda #$02			lda 	#CTH_LineNo
.1c01	20 16 11	jsr $1116			jsr 	ExternColour
.1c04	a0 ff		ldy #$ff			ldy 	#255
.1c06					_LCLoop2:
.1c06	c8		iny				iny
.1c07	b9 10 08	lda $0810,y			lda 	textBuffer,y
.1c0a	f0 0e		beq $1c1a			beq 	_LCEnd
.1c0c	c9 20		cmp #$20			cmp 	#32
.1c0e	b0 05		bcs $1c15			bcs 	_LCPrint
.1c10	20 16 11	jsr $1116			jsr 	ExternColour
.1c13	a9 20		lda #$20			lda 	#32
.1c15					_LCPrint:
.1c15	20 0c 11	jsr $110c			jsr 	ExternPrint
.1c18	80 ec		bra $1c06			bra 	_LCLoop2
.1c1a	a9 0d		lda #$0d	_LCEnd:	lda 	#13 						; new line
.1c1c	20 0c 11	jsr $110c			jsr 	ExternPrint
.1c1f	c6 1d		dec $1d				dec 	ListCount					; done all the lines allowed
.1c21	f0 0d		beq $1c30			beq 	_LCExit
.1c23					_LCNext:
.1c23	18		clc				clc
.1c24	a5 18		lda $18				lda 	listPtr
.1c26	72 18		adc ($18)			adc 	(listPtr)
.1c28	85 18		sta $18				sta 	listPtr
.1c2a	90 02		bcc $1c2e			bcc 	_NoCarryAdv
.1c2c	e6 19		inc $19				inc 	listPtr+1
.1c2e					_NoCarryAdv:
.1c2e	80 ae		bra $1bde			bra 	_LCLoop 					; go round again.
.1c30					_LCExit:
.1c30	4c 00 00	jmp $0000			jmp 	Next

;******  Return to file: kernel.asm


;******  Processing file: words/system/miscellany.src

.1c33					RunProgram:
.1c33	a2 80		ldx #$80			ldx 	#NumberStackBase
.1c35	9a		txs				txs
.1c36	20 47 1a	jsr $1a47			jsr 		ClearVariableSpace 		; clear variables etc.
.1c39	a2 00		ldx #$00			ldx			#ProgramMemory & $FF	; boot address
.1c3b	a0 40		ldy #$40			ldy 		#ProgramMemory >>8
.1c3d	20 78 10	jsr $1078			jsr 		InitialiseCoreCode 		; initialise the NEXT routine at $00
.1c40	4c 00 00	jmp $0000			jmp 		Next
.1c43					Call6502:
.1c43	a5 06		lda $06				lda 	TOS 						; copy call address
.1c45	85 10		sta $10				sta 	temp1
.1c47	a5 07		lda $07				lda 	TOS+1
.1c49	85 11		sta $11				sta 	temp1+1
.1c4b	68		pla				pla
.1c4c	85 07		sta $07				sta 	TOS+1
.1c4e	68		pla				pla
.1c4f	85 06		sta $06				sta 	TOS
.1c51	20 57 1c	jsr $1c57			jsr 	_CallTemp1 					; call it
.1c54	4c 00 00	jmp $0000			jmp 	Next
.1c57					_CallTemp1:
.1c57	6c 10 00	jmp ($0010)			jmp 	(temp1)
.1c5a					AssertCode:
.1c5a	a5 06		lda $06				lda 	TOS 						; TOS = 0
.1c5c	05 07		ora $07				ora 	TOS+1
.1c5e	f0 09		beq $1c69			beq 	_ASFail 					; if zero fail
.1c60	68		pla				pla
.1c61	85 07		sta $07				sta 	TOS+1
.1c63	68		pla				pla
.1c64	85 06		sta $06				sta 	TOS
.1c66	4c 00 00	jmp $0000			jmp 	Next
.1c69					_ASFail:
.1c69	20 23 10	jsr $1023			jsr 	ErrorHandler
>1c6c	41 53 53 45 52 54 00				.text 	"ASSERT",0
.1c73					StopCode:
.1c73	20 23 10	jsr $1023			jsr 	ErrorHandler
>1c76	53 54 4f 50 00					.text 	"STOP",0
.1c7b					EndProgram:
.1c7b	4c 13 10	jmp $1013			jmp 	WarmStart
.1c7e					VlistCode:
.1c7e	a9 95		lda #$95			lda 	#(Dictionary) & $FF
.1c80	85 10		sta $10				sta 	0+(temp1)
.1c82	a9 1f		lda #$1f			lda 	#(Dictionary) >> 8
.1c84	85 11		sta $11				sta 	1+(temp1)
.1c86	a0 01		ldy #$01	_VLLoop:ldy 	#1							; type byte
.1c88	b1 10		lda ($10),y			lda 	(temp1),y
.1c8a	a0 04		ldy #$04			ldy 	#4 							; Y = 4
.1c8c	4a		lsr a				lsr 	a 							; shift bits 4 and 5 to 0,1
.1c8d	4a		lsr a				lsr 	a
.1c8e	4a		lsr a				lsr		a
.1c8f	4a		lsr a				lsr 	a
.1c90	4a		lsr a				lsr 	a 							; add those bits in
.1c91	90 02		bcc $1c95			bcc 	_VLNoDec
.1c93	c8		iny				iny
.1c94	c8		iny				iny
.1c95					_VLNoDec:
.1c95	4a		lsr a				lsr 	a
.1c96	90 02		bcc $1c9a			bcc 	_VLNoEnc
.1c98	c8		iny				iny
.1c99	c8		iny				iny
.1c9a					_VLNoEnc:
.1c9a	b1 10		lda ($10),y			lda 	(temp1),y 					; remove $$ words
.1c9c	c9 24		cmp #$24			cmp 	#"$"
.1c9e	d0 06		bne $1ca6			bne 	_VLPrint
.1ca0	c8		iny				iny
.1ca1	51 10		eor ($10),y			eor 	(temp1),y
.1ca3	f0 13		beq $1cb8			beq 	_VLNext
.1ca5	88		dey				dey
.1ca6					_VLPrint:
.1ca6	b1 10		lda ($10),y			lda 	(temp1),y
.1ca8	48		pha				pha
.1ca9	c8		iny				iny
.1caa	29 7f		and #$7f			and 	#$7F
.1cac	20 0c 11	jsr $110c			jsr 	ExternPrint
.1caf	68		pla				pla
.1cb0	0a		asl a				asl 	a
.1cb1	90 f3		bcc $1ca6			bcc 	_VLPrint
.1cb3	a9 20		lda #$20			lda 	#32
.1cb5	20 0c 11	jsr $110c			jsr 	ExternPrint
.1cb8					_VLNext:
.1cb8	18		clc				clc 								; go to next
.1cb9	b2 10		lda ($10)			lda 	(temp1)
.1cbb	65 10		adc $10				adc 	temp1
.1cbd	85 10		sta $10				sta 	temp1
.1cbf	90 02		bcc $1cc3			bcc 	_VLNoCarry
.1cc1	e6 11		inc $11				inc 	temp1+1
.1cc3					_VLNoCarry:
.1cc3	b2 10		lda ($10)			lda 	(temp1)
.1cc5	d0 bf		bne $1c86			bne 	_VLLoop
.1cc7	a9 0d		lda #$0d			lda 	#13
.1cc9	20 0c 11	jsr $110c			jsr 	ExternPrint
.1ccc	4c 00 00	jmp $0000			jmp 	Next

;******  Return to file: kernel.asm


;******  Processing file: words/system/toint.src

.1ccf					ConvertToInteger:
.1ccf	84 17		sty $17				sty 	temp4+1
.1cd1	85 16		sta $16				sta 	temp4
.1cd3	64 14		stz $14				stz 	temp3 						; reset value
.1cd5	64 15		stz $15				stz 	temp3+1
.1cd7	64 10		stz $10				stz 	temp1 						; temp1 = 0 (decimal) 255 (hex)
.1cd9	a0 00		ldy #$00			ldy 	#0 							; look at first character
.1cdb	b1 16		lda ($16),y			lda 	(temp4),y
.1cdd	49 2d		eor #$2d			eor 	#"-"						; zero if '-'
.1cdf	85 11		sta $11				sta 	temp1+1 					; save this in temp1+1
.1ce1	d0 01		bne $1ce4			bne 	_CTINotMinus
.1ce3	c8		iny				iny									; skip -
.1ce4					_CTINotMinus:
.1ce4	b1 16		lda ($16),y			lda 	(temp4),y
.1ce6	c9 24		cmp #$24			cmp		#'$'						; if $ then skip it and set hex flag
.1ce8	d0 03		bne $1ced			bne 	_CTILoop
.1cea	c6 10		dec $10				dec 	temp1
.1cec	c8		iny				iny
.1ced					_CTILoop:
.1ced	b1 16		lda ($16),y			lda 	(temp4),y 					; next digit
.1cef	29 7f		and #$7f			and 	#$7F 						; drop end of word flag
.1cf1	38		sec				sec
.1cf2	e9 30		sbc #$30			sbc 	#'0' 						; put in range '0'+
.1cf4	90 65		bcc $1d5b			bcc 	_CTIFail 					; out of range.
.1cf6	c9 0a		cmp #$0a			cmp 	#10 						; in 0-9 ?
.1cf8	90 0b		bcc $1d05			bcc 	_CTILegal
.1cfa	c9 11		cmp #$11			cmp 	#'A'-'0'					; between 9 and A ?
.1cfc	90 5d		bcc $1d5b			bcc 	_CTIFail
.1cfe	38		sec				sec
.1cff	e9 07		sbc #$07			sbc 	#7 							; hex adjust
.1d01	c9 10		cmp #$10			cmp 	#16 						; out of range ?
.1d03	b0 56		bcs $1d5b			bcs 	_CTIFail
.1d05					_CTILegal:
.1d05	48		pha				pha 								; save digit value.
.1d06	06 14		asl $14				asl 	temp3
.1d08	26 15		rol $15				rol 	temp3+1
.1d0a	a5 14		lda $14				lda 	temp3 						; copy x2 into temp2
.1d0c	85 12		sta $12				sta 	temp2
.1d0e	a5 15		lda $15				lda 	temp3+1
.1d10	85 13		sta $13				sta 	temp2+1
.1d12	06 14		asl $14				asl 	temp3
.1d14	26 15		rol $15				rol 	temp3+1
.1d16	06 14		asl $14				asl 	temp3
.1d18	26 15		rol $15				rol 	temp3+1
.1d1a	24 10		bit $10				bit 	temp1 						; hexadecimal
.1d1c	10 07		bpl $1d25			bpl 	_CTIDecimal
.1d1e	06 14		asl $14				asl 	temp3
.1d20	26 15		rol $15				rol 	temp3+1
.1d22	68		pla				pla 								; get digit back
.1d23	80 12		bra $1d37			bra 	_CTIAddLoop
.1d25					_CTIDecimal:
.1d25	18		clc				clc 								; x 8 + x 2 = x 10
.1d26	a5 14		lda $14				lda 	temp3
.1d28	65 12		adc $12				adc 	temp2
.1d2a	85 14		sta $14				sta 	temp3
.1d2c	a5 15		lda $15				lda 	temp3+1
.1d2e	65 13		adc $13				adc 	temp2+1
.1d30	85 15		sta $15				sta 	temp3+1
.1d32	68		pla				pla 								; check digit 0-9
.1d33	c9 0a		cmp #$0a			cmp 	#10
.1d35	b0 24		bcs $1d5b			bcs 	_CTIFail
.1d37					_CTIAddLoop:
.1d37	18		clc				clc
.1d38	65 14		adc $14				adc 	temp3
.1d3a	85 14		sta $14				sta 	temp3
.1d3c	90 02		bcc $1d40			bcc 	_CTINoCarry
.1d3e	e6 15		inc $15				inc 	temp3+1
.1d40					_CTINoCarry:
.1d40	c8		iny				iny
.1d41	b1 16		lda ($16),y			lda 	(temp4),y 					; was this the last character
.1d43	c9 21		cmp #$21			cmp 	#32+1
.1d45	b0 a6		bcs $1ced			bcs 	_CTILoop 					; no, go back.
.1d47	a5 11		lda $11				lda 	temp1+1 					; was it - ?
.1d49	d0 0d		bne $1d58			bne 	_CTIOkay
.1d4b	38		sec				sec
.1d4c	a9 00		lda #$00			lda 	#0 							; negate temp3.
.1d4e	e5 14		sbc $14				sbc 	temp3
.1d50	85 14		sta $14				sta 	temp3
.1d52	a9 00		lda #$00			lda 	#0
.1d54	e5 15		sbc $15				sbc 	temp3+1
.1d56	85 15		sta $15				sta 	temp3+1
.1d58					_CTIOkay:
.1d58	98		tya				tya
.1d59	38		sec				sec
.1d5a	60		rts				rts
.1d5b					_CTIFail:
.1d5b	18		clc				clc
.1d5c	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/skipper.src

.1d5d					NextLine:
.1d5d	18		clc				clc
.1d5e	a5 03		lda $03				lda 	IP
.1d60	72 03		adc ($03)			adc 	(IP)
.1d62	85 03		sta $03				sta 	IP
.1d64	90 02		bcc $1d68			bcc 	_NoCarryAdv
.1d66	e6 04		inc $04				inc 	IP+1
.1d68					_NoCarryAdv:
.1d68	b2 03		lda ($03)			lda 	(IP)						; is there any following program ?
.1d6a	f0 05		beq $1d71			beq 	_NLGoEnd
.1d6c	a2 03		ldx #$03			ldx 	#3 							; start 3 in
.1d6e	4c 02 00	jmp $0002			jmp 	Next+2 						; avoid the first two INXs
.1d71					_NLGoEnd:
.1d71	4c 13 10	jmp $1013			jmp 	WarmStart
.1d74					SkipComment:
.1d74	e8		inx				inx									; (IP),X points to the length.
.1d75	e8		inx				inx
.1d76	8a		txa				txa
.1d77	a8		tay				tay 								; put into Y
.1d78	18		clc				clc
.1d79	71 03		adc ($03),y			adc 	(IP),y 						; add the length to X
.1d7b	aa		tax				tax 								; put back in X
.1d7c	4c 02 00	jmp $0002			jmp 	Next+2 						; continue skipping the pre-increment.
.1d7f					CommentDecoder:
.1d7f	a9 06		lda #$06			lda 	#CTH_Keyword
.1d81	20 77 1b	jsr $1b77			jsr 	DecodeWriteBuffer
.1d84	a9 27		lda #$27			lda 	#"'"
.1d86	20 77 1b	jsr $1b77			jsr 	DecodeWriteBuffer
.1d89	a9 0b		lda #$0b			lda 	#CTH_Comment
.1d8b	20 77 1b	jsr $1b77			jsr 	DecodeWriteBuffer
.1d8e	20 80 1b	jsr $1b80			jsr 	DecodeOutputData
.1d91	a9 20		lda #$20			lda 	#32
.1d93	20 77 1b	jsr $1b77			jsr 	DecodeWriteBuffer
.1d96	60		rts				rts
.1d97					DefineCode:
.1d97	20 23 10	jsr $1023			jsr 	ErrorHandler
>1d9a	44 45 46 49 4e 49 54 49				.text 	"DEFINITION?",0
>1da2	4f 4e 3f 00
.1da6					DefineDecoder:
.1da6	a9 07		lda #$07			lda 	#CTH_Definition
.1da8	20 77 1b	jsr $1b77			jsr 	DecodeWriteBuffer
.1dab	a9 3a		lda #$3a			lda 	#":"
.1dad	20 77 1b	jsr $1b77			jsr 	DecodeWriteBuffer
.1db0	20 80 1b	jsr $1b80			jsr 	DecodeOutputData
.1db3	a9 20		lda #$20			lda 	#32
.1db5	20 77 1b	jsr $1b77			jsr 	DecodeWriteBuffer
.1db8	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/tostr.src

.1db9					IntToString:
.1db9	a9 10		lda #$10			lda 	#(textBuffer) & $FF
.1dbb	85 12		sta $12				sta 	0+(temp2)
.1dbd	a9 08		lda #$08			lda 	#(textBuffer) >> 8
.1dbf	85 13		sta $13				sta 	1+(temp2)
.1dc1	a5 06		lda $06				lda 	TOS 						; value in YA
.1dc3	a4 07		ldy $07				ldy 	TOS+1
.1dc5	20 d3 1d	jsr $1dd3			jsr 	ConvertToString
.1dc8	a9 10		lda #$10			lda 	#(textBuffer) & $FF
.1dca	85 06		sta $06				sta 	0+(TOS)
.1dcc	a9 08		lda #$08			lda 	#(textBuffer) >> 8
.1dce	85 07		sta $07				sta 	1+(TOS)
.1dd0	4c 00 00	jmp $0000			jmp 	Next
.1dd3					ConvertToString:
.1dd3	38		sec				sec
.1dd4	80 01		bra $1dd7			bra 	ConvertToStringMain
.1dd6					ConvertToStringUnsigned:
.1dd6	18		clc				clc
.1dd7					ConvertToStringMain:
.1dd7	da		phx				phx									; save XY
.1dd8	5a		phy				phy
.1dd9	64 1a		stz $1a				stz 	SignCount 					; this is zero suppression
.1ddb	85 10		sta $10				sta 	temp1 						; save YA in temp1
.1ddd	84 11		sty $11				sty 	temp1+1
.1ddf	a0 00		ldy #$00			ldy 	#0 							; index to result.
.1de1	90 16		bcc $1df9			bcc 	_CTSUnsigned 				; if carry clear do not adjust for -
.1de3	a5 11		lda $11				lda 	temp1+1 					; is it negative
.1de5	10 12		bpl $1df9			bpl 	_CTSUnsigned
.1de7	a9 2d		lda #$2d			lda 	#"-"						; output - sign
.1de9	91 12		sta ($12),y			sta 	(temp2),y
.1deb	c8		iny				iny
.1dec	38		sec				sec 								; negate temp1
.1ded	a9 00		lda #$00			lda 	#0
.1def	e5 10		sbc $10				sbc 	temp1
.1df1	85 10		sta $10				sta 	temp1
.1df3	a9 00		lda #$00			lda 	#0
.1df5	e5 11		sbc $11				sbc 	temp1+1
.1df7	85 11		sta $11				sta 	temp1+1
.1df9					_CTSUnsigned:
.1df9	a2 00		ldx #$00			ldx 	#0 							; index into subtraction table
.1dfb					_CTSLoop:
.1dfb	a9 2f		lda #$2f			lda 	#"0"-1						; set the digit to '0' code.
.1dfd	91 12		sta ($12),y			sta 	(temp2),y
.1dff					_CTSSubLoop:
.1dff	b1 12		lda ($12),y			lda 	(temp2),y 					; bump the count
.1e01	1a		inc a				inc 	a
.1e02	91 12		sta ($12),y			sta 	(temp2),y
.1e04	38		sec				sec 								; do subtraction saving interim result
.1e05	a5 10		lda $10				lda 	temp1
.1e07	fd 3a 1e	sbc $1e3a,x			sbc 	_CTSTable,x
.1e0a	48		pha				pha
.1e0b	a5 11		lda $11				lda 	temp1+1
.1e0d	fd 3b 1e	sbc $1e3b,x			sbc 	_CTSTable+1,x
.1e10	90 07		bcc $1e19			bcc 	_CTSCantSubtract 			; end of subtraction.
.1e12	85 11		sta $11				sta 	temp1+1 					; save result back
.1e14	68		pla				pla
.1e15	85 10		sta $10				sta 	temp1
.1e17	80 e6		bra $1dff			bra 	_CTSSubLoop
.1e19					_CTSCantSubtract:
.1e19	68		pla				pla 								; throw away interim
.1e1a	e8		inx				inx 								; next subtractor
.1e1b	e8		inx				inx
.1e1c	b1 12		lda ($12),y			lda 	(temp2),y 					; update leading zero
.1e1e	49 30		eor #$30			eor 	#"0"
.1e20	05 1a		ora $1a				ora 	SignCount
.1e22	85 1a		sta $1a				sta 	SignCount
.1e24	f0 01		beq $1e27			beq		_CTSLZ 						; if all zeros so far suppress.
.1e26	c8		iny				iny 								; next character
.1e27					_CTSLZ:
.1e27	e0 08		cpx #$08			cpx 	#_CTSTableEnd-_CTSTable 	; done them all ?
.1e29	d0 d0		bne $1dfb			bne 	_CTSLoop
.1e2b					_CTSComplete:
.1e2b	a5 10		lda $10				lda		temp1 						; get remainder 0-9
.1e2d	09 30		ora #$30			ora 	#48 						; ASCII
.1e2f	91 12		sta ($12),y			sta 	(temp2),y					; write out
.1e31	c8		iny				iny
.1e32	a9 00		lda #$00			lda 	#0							; make ASCIIZ
.1e34	91 12		sta ($12),y			sta 	(temp2),y
.1e36	98		tya				tya 								; size in A
.1e37	7a		ply				ply									; pull and exit.
.1e38	fa		plx				plx
.1e39	60		rts				rts
.1e3a					_CTSTable:
>1e3a	10 27 e8 03 64 00 0a 00				.word 	10000,1000,100,10 			; subtractors, this is a simple version.
.1e42					_CTSTableEnd:

;******  Return to file: kernel.asm


;******  Processing file: words/system/varhandlers.src

.1e42					VarAddressHandler:
.1e42	18		clc				clc 								; find variable, error if it doesn't exist.
.1e43	20 94 1e	jsr $1e94			jsr 	VariableFind
.1e46	a5 06		lda $06				lda 	TOS
.1e48	48		pha				pha
.1e49	a5 07		lda $07				lda 	TOS+1
.1e4b	48		pha				pha
.1e4c	a5 10		lda $10				lda 	temp1 						; the address is the new value
.1e4e	85 06		sta $06				sta 	TOS
.1e50	a5 11		lda $11				lda		temp1+1
.1e52	85 07		sta $07				sta 	TOS+1
.1e54	4c 00 00	jmp $0000			jmp 	Next
.1e57					VarAddrHandlerDecode:
.1e57	a9 26		lda #$26			lda 	#"&"
.1e59	4c 42 1f	jmp $1f42			jmp 	VarHandlerDecode
.1e5c					VarReadHandler:
.1e5c	18		clc				clc 								; find variable, error if it doesn't exist.
.1e5d	20 94 1e	jsr $1e94			jsr 	VariableFind
.1e60	a5 06		lda $06				lda 	TOS
.1e62	48		pha				pha
.1e63	a5 07		lda $07				lda 	TOS+1
.1e65	48		pha				pha
.1e66	b2 10		lda ($10)			lda 	(temp1)						; read variable address to TOS
.1e68	85 06		sta $06				sta 	TOS
.1e6a	a0 01		ldy #$01			ldy 	#1
.1e6c	b1 10		lda ($10),y			lda 	(temp1),y
.1e6e	85 07		sta $07				sta 	TOS+1
.1e70	4c 00 00	jmp $0000			jmp 	Next
.1e73					VarReadHandlerDecode:
.1e73	a9 40		lda #$40			lda 	#"@"
.1e75	4c 42 1f	jmp $1f42			jmp 	VarHandlerDecode
.1e78					VarWriteHandler:
.1e78	38		sec				sec 								; find variable, create it if it doesn't exist.
.1e79	20 94 1e	jsr $1e94			jsr 	VariableFind
.1e7c	a5 06		lda $06				lda 	TOS 						; write TOS to that address.
.1e7e	92 10		sta ($10)			sta 	(temp1)
.1e80	a5 07		lda $07				lda 	TOS+1
.1e82	a0 01		ldy #$01			ldy 	#1
.1e84	91 10		sta ($10),y			sta 	(temp1),y
.1e86	68		pla				pla
.1e87	85 07		sta $07				sta 	TOS+1
.1e89	68		pla				pla
.1e8a	85 06		sta $06				sta 	TOS
.1e8c	4c 00 00	jmp $0000			jmp 	Next
.1e8f					VarWriteHandlerDecode:
.1e8f	a9 21		lda #$21			lda 	#"!"
.1e91	4c 42 1f	jmp $1f42			jmp 	VarHandlerDecode
.1e94					VariableFind:
.1e94	08		php				php 								; save autocreate flag.
.1e95	e8		inx				inx 								; advance to/over the variable name.
.1e96	e8		inx				inx
.1e97	8a		txa				txa 								; put in Y
.1e98	a8		tay				tay
.1e99	b1 03		lda ($03),y			lda 	(IP),y 						; copy name word into temp2
.1e9b	85 12		sta $12				sta 	temp2
.1e9d	c8		iny				iny
.1e9e	b1 03		lda ($03),y			lda 	(IP),y
.1ea0	85 13		sta $13				sta 	temp2+1
.1ea2	c9 1b		cmp #$1b			cmp 	#27 						; check for A-Z
.1ea4	b0 0f		bcs $1eb5			bcs 	_VFLong
.1ea6	a5 13		lda $13				lda 	temp2+1
.1ea8	d0 0b		bne $1eb5			bne 	_VFLong
.1eaa	a5 12		lda $12				lda 	temp2						; this is the index
.1eac	0a		asl a				asl 	a 							; double it
.1ead	85 10		sta $10				sta 	temp1
.1eaf	a9 06		lda #$06			lda 	#azVariables >> 8			; set the MSB
.1eb1	85 11		sta $11				sta 	temp1+1
.1eb3	28		plp				plp 								; throw creation flag, it always exists.
.1eb4	60		rts				rts
.1eb5					_VFLong:
.1eb5	a5 12		lda $12				lda 	temp2 						; built a hash table index into temp3/temp4
.1eb7	6a		ror a				ror 	a
.1eb8	6a		ror a				ror 	a
.1eb9	6a		ror a				ror 	a
.1eba	6a		ror a				ror 	a
.1ebb	45 12		eor $12				eor 	temp2
.1ebd	45 13		eor $13				eor 	temp2+1
.1ebf	29 0f		and #$0f			and 	#(hashTableSize-1)			; force into range
.1ec1	0a		asl a				asl 	a
.1ec2	69 40		adc #$40			adc 	#hashTable & $FF 			; make an address of the head => temp1/3
.1ec4	85 10		sta $10				sta 	temp1
.1ec6	85 14		sta $14				sta 	temp3
.1ec8	a9 06		lda #$06			lda 	#hashTable >> 8
.1eca	85 11		sta $11				sta 	temp1+1
.1ecc	85 15		sta $15				sta 	temp3+1
.1ece					_VFSearch:
.1ece	a0 01		ldy #$01			ldy 	#1							; read MSB of first record
.1ed0	b1 10		lda ($10),y			lda 	(temp1),y
.1ed2	f0 23		beq $1ef7			beq 	_VFNotFound 				; is MSB is zero, can't be a variable record
.1ed4	a8		tay				tay 								; follow the link through.
.1ed5	b2 10		lda ($10)			lda 	(temp1)
.1ed7	85 10		sta $10				sta 	temp1
.1ed9	84 11		sty $11				sty 	temp1+1
.1edb	a0 04		ldy #$04			ldy 	#4							; check if the name matches
.1edd	b1 10		lda ($10),y			lda 	(temp1),y
.1edf	c5 12		cmp $12				cmp 	temp2
.1ee1	d0 eb		bne $1ece			bne 	_VFSearch 					; if it doesn't, follow the next link.
.1ee3	c8		iny				iny 								; same for 2nd byte of name
.1ee4	b1 10		lda ($10),y			lda 	(temp1),y
.1ee6	c5 13		cmp $13				cmp 	temp2+1
.1ee8	d0 e4		bne $1ece			bne 	_VFSearch
.1eea	18		clc				clc
.1eeb	a5 10		lda $10				lda 	temp1 						; make temp1 point to the data at offset 2
.1eed	69 02		adc #$02			adc 	#2
.1eef	85 10		sta $10				sta 	temp1
.1ef1	90 02		bcc $1ef5			bcc 	_VFNoPage1
.1ef3	e6 11		inc $11				inc 	temp1+1
.1ef5					_VFNoPage1:
.1ef5	28		plp				plp 								; don't need to worry about creation flag
.1ef6	60		rts				rts
.1ef7					_VFNotFound:
.1ef7	28		plp				plp 								; was carry set, e.g. create a new record if not found ?
.1ef8	b0 0d		bcs $1f07			bcs 	_VFCreate
.1efa	20 23 10	jsr $1023			jsr 	ErrorHandler
>1efd	56 41 52 49 41 42 4c 45				.text 	"VARIABLE?",0
>1f05	3f 00
.1f07					_VFCreate:
.1f07	a0 01		ldy #$01			ldy 	#1
.1f09	b2 14		lda ($14)			lda 	(temp3) 					; copy the head link to the first 2 bytes
.1f0b	92 0e		sta ($0e)			sta 	(nextFreeMem)
.1f0d	b1 14		lda ($14),y			lda 	(temp3),y
.1f0f	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.1f11	c8		iny				iny
.1f12	a9 00		lda #$00			lda 	#0	 						; write zero initialised data out.
.1f14	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.1f16	c8		iny				iny
.1f17	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.1f19	c8		iny				iny
.1f1a	a5 12		lda $12				lda 	temp2 						; copy the name out
.1f1c	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.1f1e	c8		iny				iny
.1f1f	a5 13		lda $13				lda 	temp2+1
.1f21	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.1f23	a0 01		ldy #$01			ldy 	#1
.1f25	a5 0e		lda $0e				lda 	nextFreeMem 				; update the head link
.1f27	92 14		sta ($14)			sta 	(temp3)
.1f29	a5 0f		lda $0f				lda 	nextFreeMem+1
.1f2b	91 14		sta ($14),y			sta 	(temp3),y
.1f2d	18		clc				clc
.1f2e	a5 0e		lda $0e				lda 	nextFreeMem 				; put nextFreeMem+2 in temp1 (data pointer)
.1f30	69 02		adc #$02			adc 	#2
.1f32	85 10		sta $10				sta 	temp1
.1f34	a5 0f		lda $0f				lda 	nextFreeMem+1
.1f36	69 00		adc #$00			adc 	#0
.1f38	85 11		sta $11				sta 	temp1+1
.1f3a	a9 06		lda #$06			lda 	#6							; shift freemem pointer up 6
.1f3c	a0 00		ldy #$00			ldy 	#0
.1f3e	20 74 1a	jsr $1a74			jsr 	AdvanceFreeMem
.1f41	60		rts				rts
.1f42					VarHandlerDecode:
.1f42	48		pha				pha 								; save, leading space
.1f43	a9 20		lda #$20			lda 	#" "
.1f45	20 77 1b	jsr $1b77			jsr 	DecodeWriteBuffer
.1f48	68		pla				pla 								; restore and write type
.1f49	20 77 1b	jsr $1b77			jsr 	DecodeWriteBuffer
.1f4c	b1 08		lda ($08),y			lda 	(srcPtr),y 					; copy to temp1
.1f4e	85 10		sta $10				sta 	temp1
.1f50	c8		iny				iny
.1f51	b1 08		lda ($08),y			lda 	(srcPtr),y
.1f53	85 11		sta $11				sta 	temp1+1
.1f55	a5 10		lda $10				lda 	temp1 						; output the first character
.1f57	29 1f		and #$1f			and 	#31
.1f59	20 84 1f	jsr $1f84			jsr 	VHOutVarChar
.1f5c	a2 05		ldx #$05			ldx 	#5 							; divide temp1 by 32
.1f5e					_VHDShift:
.1f5e	46 11		lsr $11				lsr 	temp1+1
.1f60	66 10		ror $10				ror 	temp1
.1f62	ca		dex				dex
.1f63	d0 f9		bne $1f5e			bne 	_VHDShift
.1f65	a2 ff		ldx #$ff			ldx 	#255 						; now divide that by 40 by repeated subtraction.
.1f67					_VHDDiv40:
.1f67	e8		inx				inx
.1f68	38		sec				sec
.1f69	a5 10		lda $10				lda 	temp1
.1f6b	e9 28		sbc #$28			sbc 	#40
.1f6d	a8		tay				tay
.1f6e	a5 11		lda $11				lda 	temp1+1
.1f70	e9 00		sbc #$00			sbc 	#0
.1f72	90 06		bcc $1f7a			bcc 	_VHDivDone
.1f74	85 11		sta $11				sta 	temp1+1
.1f76	84 10		sty $10				sty 	temp1
.1f78	80 ed		bra $1f67			bra 	_VHDDiv40
.1f7a					_VHDivDone:
.1f7a	a5 10		lda $10				lda 	temp1 						; remainder
.1f7c	20 84 1f	jsr $1f84			jsr 	VHOutVarChar
.1f7f	8a		txa				txa
.1f80	20 84 1f	jsr $1f84			jsr 	VHOutVarChar 				; and result.
.1f83	60		rts				rts
.1f84					VHOutVarChar:
.1f84	c9 00		cmp #$00			cmp 	#0
.1f86	f0 0c		beq $1f94			beq 	_VHOExit
.1f88	18		clc				clc
.1f89	69 40		adc #$40			adc 	#64 						; 65-90 A-Z 91-100 0-9
.1f8b	c9 5b		cmp #$5b			cmp 	#91 						; convert back ?
.1f8d	90 02		bcc $1f91			bcc 	_VHOOut
.1f8f	e9 2b		sbc #$2b			sbc 	#91-48 						; adjust to digit
.1f91					_VHOOut:
.1f91	20 77 1b	jsr $1b77			jsr 	DecodeWriteBuffer
.1f94					_VHOExit:
.1f94	60		rts				rts

;******  Return to file: kernel.asm

.1f95					Dictionary:

;******  Processing file: generated/dictionary.inc

>1f95	05					.byte	_end1-*
>1f96	00					.byte	$00
>1f97	fd 15					.word	WordWrite
>1f99	a1					.byte	$a1
.1f9a					_end1:
>1f9a	10					.byte	_end2-*
>1f9b	52					.byte	$52
>1f9c	78 1e					.word	VarWriteHandler
>1f9e	8f 1e					.word	VarWriteHandlerDecode
>1fa0	24 24 21 48 41 4e 44 4c			.byte	$24,$24,$21,$48,$41,$4e,$44,$4c,$45,$d2
>1fa8	45 d2
.1faa					_end2:
>1faa	10					.byte	_end3-*
>1fab	52					.byte	$52
>1fac	42 1e					.word	VarAddressHandler
>1fae	57 1e					.word	VarAddrHandlerDecode
>1fb0	24 24 26 48 41 4e 44 4c			.byte	$24,$24,$26,$48,$41,$4e,$44,$4c,$45,$d2
>1fb8	45 d2
.1fba					_end3:
>1fba	10					.byte	_end4-*
>1fbb	52					.byte	$52
>1fbc	5c 1e					.word	VarReadHandler
>1fbe	73 1e					.word	VarReadHandlerDecode
>1fc0	24 24 40 48 41 4e 44 4c			.byte	$24,$24,$40,$48,$41,$4e,$44,$4c,$45,$d2
>1fc8	45 d2
.1fca					_end4:
>1fca	0c					.byte	_end5-*
>1fcb	52					.byte	$52
>1fcc	fb 18					.word	CallHandler
>1fce	b7 19					.word	CallHandlerDecode
>1fd0	24 24 43 41 4c cc			.byte	$24,$24,$43,$41,$4c,$cc
.1fd6					_end5:
>1fd6	0f					.byte	_end6-*
>1fd7	53					.byte	$53
>1fd8	74 1d					.word	SkipComment
>1fda	7f 1d					.word	CommentDecoder
>1fdc	24 24 43 4f 4d 4d 45 4e			.byte	$24,$24,$43,$4f,$4d,$4d,$45,$4e,$d4
>1fe4	d4
.1fe5					_end6:
>1fe5	0e					.byte	_end7-*
>1fe6	53					.byte	$53
>1fe7	97 1d					.word	DefineCode
>1fe9	a6 1d					.word	DefineDecoder
>1feb	24 24 44 45 46 49 4e c5			.byte	$24,$24,$44,$45,$46,$49,$4e,$c5
.1ff3					_end7:
>1ff3	0f					.byte	_end8-*
>1ff4	52					.byte	$52
>1ff5	89 10					.word	Literal2Byte
>1ff7	9f 10					.word	Literal2ByteDecode
>1ff9	24 24 4c 49 54 45 52 41			.byte	$24,$24,$4c,$49,$54,$45,$52,$41,$cc
>2001	cc
.2002					_end8:
>2002	0e					.byte	_end9-*
>2003	80					.byte	$80
>2004	5d 1d					.word	NextLine
>2006	24 24 4e 45 58 54 4c 49			.byte	$24,$24,$4e,$45,$58,$54,$4c,$49,$4e,$c5
>200e	4e c5
.2010					_end9:
>2010	0e					.byte	_end10-*
>2011	53					.byte	$53
>2012	b1 10					.word	LiteralString
>2014	ce 10					.word	LiteralStringDecoder
>2016	24 24 53 54 52 49 4e c7			.byte	$24,$24,$53,$54,$52,$49,$4e,$c7
.201e					_end10:
>201e	05					.byte	_end11-*
>201f	00					.byte	$00
>2020	79 13					.word	Multiply16x16
>2022	aa					.byte	$aa
.2023					_end11:
>2023	05					.byte	_end12-*
>2024	00					.byte	$00
>2025	e6 11					.word	Add
>2027	ab					.byte	$ab
.2028					_end12:
>2028	06					.byte	_end13-*
>2029	00					.byte	$00
>202a	0e 16					.word	WordAdd
>202c	2b a1					.byte	$2b,$a1
.202e					_end13:
>202e	05					.byte	_end14-*
>202f	00					.byte	$00
>2030	f5 11					.word	Subtract
>2032	ad					.byte	$ad
.2033					_end14:
>2033	06					.byte	_end15-*
>2034	00					.byte	$00
>2035	b5 14					.word	ConstantMinus1
>2037	2d b1					.byte	$2d,$b1
.2039					_end15:
>2039	05					.byte	_end16-*
>203a	00					.byte	$00
>203b	ca 12					.word	Divide16x16
>203d	af					.byte	$af
.203e					_end16:
>203e	05					.byte	_end17-*
>203f	00					.byte	$00
>2040	a8 14					.word	Constant0
>2042	b0					.byte	$b0
.2043					_end17:
>2043	06					.byte	_end18-*
>2044	00					.byte	$00
>2045	0e 14					.word	CheckMinus
>2047	30 bc					.byte	$30,$bc
.2049					_end18:
>2049	06					.byte	_end19-*
>204a	00					.byte	$00
>204b	22 14					.word	CheckZero
>204d	30 bd					.byte	$30,$bd
.204f					_end19:
>204f	05					.byte	_end20-*
>2050	00					.byte	$00
>2051	c4 14					.word	C1
>2053	b1					.byte	$b1
.2054					_end20:
>2054	06					.byte	_end21-*
>2055	00					.byte	$00
>2056	b8 13					.word	Unary1Plus
>2058	31 ab					.byte	$31,$ab
.205a					_end21:
>205a	06					.byte	_end22-*
>205b	00					.byte	$00
>205c	cf 13					.word	Unary1Minus
>205e	31 ad					.byte	$31,$ad
.2060					_end22:
>2060	06					.byte	_end23-*
>2061	00					.byte	$00
>2062	dc 14					.word	C10
>2064	31 b0					.byte	$31,$b0
.2066					_end23:
>2066	07					.byte	_end24-*
>2067	00					.byte	$00
>2068	05 15					.word	C100
>206a	31 30 b0				.byte	$31,$30,$b0
.206d					_end24:
>206d	08					.byte	_end25-*
>206e	00					.byte	$00
>206f	34 15					.word	C1024
>2071	31 30 32 b4				.byte	$31,$30,$32,$b4
.2075					_end25:
>2075	07					.byte	_end26-*
>2076	00					.byte	$00
>2077	09 15					.word	C127
>2079	31 32 b7				.byte	$31,$32,$b7
.207c					_end26:
>207c	07					.byte	_end27-*
>207d	00					.byte	$00
>207e	0d 15					.word	C128
>2080	31 32 b8				.byte	$31,$32,$b8
.2083					_end27:
>2083	06					.byte	_end28-*
>2084	00					.byte	$00
>2085	e0 14					.word	C15
>2087	31 b5					.byte	$31,$b5
.2089					_end28:
>2089	06					.byte	_end29-*
>208a	00					.byte	$00
>208b	e4 14					.word	C16
>208d	31 b6					.byte	$31,$b6
.208f					_end29:
>208f	07					.byte	_end30-*
>2090	00					.byte	$00
>2091	46 14					.word	Times16
>2093	31 36 aa				.byte	$31,$36,$aa
.2096					_end30:
>2096	07					.byte	_end31-*
>2097	00					.byte	$00
>2098	59 14					.word	Divide16
>209a	31 36 af				.byte	$31,$36,$af
.209d					_end31:
>209d	05					.byte	_end32-*
>209e	00					.byte	$00
>209f	c8 14					.word	C2
>20a1	b2					.byte	$b2
.20a2					_end32:
>20a2	06					.byte	_end33-*
>20a3	00					.byte	$00
>20a4	52 14					.word	Times2
>20a6	32 aa					.byte	$32,$aa
.20a8					_end33:
>20a8	06					.byte	_end34-*
>20a9	00					.byte	$00
>20aa	c1 13					.word	Unary2Plus
>20ac	32 ab					.byte	$32,$ab
.20ae					_end34:
>20ae	06					.byte	_end35-*
>20af	00					.byte	$00
>20b0	da 13					.word	Unary2Minus
>20b2	32 ad					.byte	$32,$ad
.20b4					_end35:
>20b4	06					.byte	_end36-*
>20b5	00					.byte	$00
>20b6	65 14					.word	Divide2
>20b8	32 af					.byte	$32,$af
.20ba					_end36:
>20ba	06					.byte	_end37-*
>20bb	00					.byte	$00
>20bc	e8 14					.word	C24
>20be	32 b4					.byte	$32,$b4
.20c0					_end37:
>20c0	07					.byte	_end38-*
>20c1	00					.byte	$00
>20c2	11 15					.word	C255
>20c4	32 35 b5				.byte	$32,$35,$b5
.20c7					_end38:
>20c7	07					.byte	_end39-*
>20c8	00					.byte	$00
>20c9	1c 15					.word	C256
>20cb	32 35 b6				.byte	$32,$35,$b6
.20ce					_end39:
>20ce	08					.byte	_end40-*
>20cf	00					.byte	$00
>20d0	6c 14					.word	Times256
>20d2	32 35 36 aa				.byte	$32,$35,$36,$aa
.20d6					_end40:
>20d6	08					.byte	_end41-*
>20d7	00					.byte	$00
>20d8	75 14					.word	Divide256
>20da	32 35 36 af				.byte	$32,$35,$36,$af
.20de					_end41:
>20de	05					.byte	_end42-*
>20df	00					.byte	$00
>20e0	cc 14					.word	C3
>20e2	b3					.byte	$b3
.20e3					_end42:
>20e3	06					.byte	_end43-*
>20e4	00					.byte	$00
>20e5	f9 14					.word	C32
>20e7	33 b2					.byte	$33,$b2
.20e9					_end43:
>20e9	09					.byte	_end44-*
>20ea	00					.byte	$00
>20eb	4c 15					.word	C32767
>20ed	33 32 37 36 b7				.byte	$33,$32,$37,$36,$b7
.20f2					_end44:
>20f2	09					.byte	_end45-*
>20f3	00					.byte	$00
>20f4	58 15					.word	C32768
>20f6	33 32 37 36 b8				.byte	$33,$32,$37,$36,$b8
.20fb					_end45:
>20fb	05					.byte	_end46-*
>20fc	00					.byte	$00
>20fd	d0 14					.word	C4
>20ff	b4					.byte	$b4
.2100					_end46:
>2100	06					.byte	_end47-*
>2101	00					.byte	$00
>2102	4e 14					.word	Times4
>2104	34 aa					.byte	$34,$aa
.2106					_end47:
>2106	06					.byte	_end48-*
>2107	00					.byte	$00
>2108	61 14					.word	Divide4
>210a	34 af					.byte	$34,$af
.210c					_end48:
>210c	08					.byte	_end49-*
>210d	00					.byte	$00
>210e	40 15					.word	C4096
>2110	34 30 39 b6				.byte	$34,$30,$39,$b6
.2114					_end49:
>2114	05					.byte	_end50-*
>2115	00					.byte	$00
>2116	d4 14					.word	C5
>2118	b5					.byte	$b5
.2119					_end50:
>2119	07					.byte	_end51-*
>211a	00					.byte	$00
>211b	28 15					.word	C512
>211d	35 31 b2				.byte	$35,$31,$b2
.2120					_end51:
>2120	06					.byte	_end52-*
>2121	00					.byte	$00
>2122	fd 14					.word	C63
>2124	36 b3					.byte	$36,$b3
.2126					_end52:
>2126	06					.byte	_end53-*
>2127	00					.byte	$00
>2128	01 15					.word	C64
>212a	36 b4					.byte	$36,$b4
.212c					_end53:
>212c	05					.byte	_end54-*
>212d	00					.byte	$00
>212e	d8 14					.word	C8
>2130	b8					.byte	$b8
.2131					_end54:
>2131	06					.byte	_end55-*
>2132	00					.byte	$00
>2133	4a 14					.word	Times8
>2135	38 aa					.byte	$38,$aa
.2137					_end55:
>2137	06					.byte	_end56-*
>2138	00					.byte	$00
>2139	5d 14					.word	Divide8
>213b	38 af					.byte	$38,$af
.213d					_end56:
>213d	05					.byte	_end57-*
>213e	40					.byte	$40
>213f	80 19					.word	ReturnHandler
>2141	bb					.byte	$bb
.2142					_end57:
>2142	05					.byte	_end58-*
>2143	00					.byte	$00
>2144	66 12					.word	CheckLess
>2146	bc					.byte	$bc
.2147					_end58:
>2147	06					.byte	_end59-*
>2148	00					.byte	$00
>2149	7f 12					.word	CheckLessEq
>214b	3c bd					.byte	$3c,$bd
.214d					_end59:
>214d	06					.byte	_end60-*
>214e	00					.byte	$00
>214f	2f 12					.word	CheckNotEqual
>2151	3c be					.byte	$3c,$be
.2153					_end60:
>2153	05					.byte	_end61-*
>2154	00					.byte	$00
>2155	32 12					.word	CheckEqual
>2157	bd					.byte	$bd
.2158					_end61:
>2158	05					.byte	_end62-*
>2159	00					.byte	$00
>215a	82 12					.word	CheckGreater
>215c	be					.byte	$be
.215d					_end62:
>215d	06					.byte	_end63-*
>215e	00					.byte	$00
>215f	63 12					.word	CheckGreaterEq
>2161	3e bd					.byte	$3e,$bd
.2163					_end63:
>2163	08					.byte	_end64-*
>2164	00					.byte	$00
>2165	6d 15					.word	TestDup
>2167	3f 44 55 d0				.byte	$3f,$44,$55,$d0
.216b					_end64:
>216b	05					.byte	_end65-*
>216c	00					.byte	$00
>216d	e2 15					.word	WordRead
>216f	c0					.byte	$c0
.2170					_end65:
>2170	07					.byte	_end66-*
>2171	00					.byte	$00
>2172	e8 13					.word	Absolute
>2174	41 42 d3				.byte	$41,$42,$d3
.2177					_end66:
>2177	09					.byte	_end67-*
>2178	00					.byte	$00
>2179	25 16					.word	AllocateMemory
>217b	41 4c 4c 4f c3				.byte	$41,$4c,$4c,$4f,$c3
.2180					_end67:
>2180	07					.byte	_end68-*
>2181	00					.byte	$00
>2182	08 12					.word	And
>2184	41 4e c4				.byte	$41,$4e,$c4
.2187					_end68:
>2187	0a					.byte	_end69-*
>2188	00					.byte	$00
>2189	5a 1c					.word	AssertCode
>218b	41 53 53 45 52 d4			.byte	$41,$53,$53,$45,$52,$d4
.2191					_end69:
>2191	09					.byte	_end70-*
>2192	00					.byte	$00
>2193	3b 14					.word	ByteSwap
>2195	42 53 57 41 d0				.byte	$42,$53,$57,$41,$d0
.219a					_end70:
>219a	06					.byte	_end71-*
>219b	00					.byte	$00
>219c	f0 15					.word	ByteWrite
>219e	43 a1					.byte	$43,$a1
.21a0					_end71:
>21a0	06					.byte	_end72-*
>21a1	00					.byte	$00
>21a2	d9 15					.word	ByteRead
>21a4	43 c0					.byte	$43,$c0
.21a6					_end72:
>21a6	07					.byte	_end73-*
>21a7	00					.byte	$00
>21a8	41 1a					.word	ClrHandler
>21aa	43 4c d2				.byte	$43,$4c,$d2
.21ad					_end73:
>21ad	08					.byte	_end74-*
>21ae	00					.byte	$00
>21af	64 15					.word	Drop
>21b1	44 52 4f d0				.byte	$44,$52,$4f,$d0
.21b5					_end74:
>21b5	07					.byte	_end75-*
>21b6	00					.byte	$00
>21b7	76 15					.word	Dup
>21b9	44 55 d0				.byte	$44,$55,$d0
.21bc					_end75:
>21bc	08					.byte	_end76-*
>21bd	01					.byte	$01
>21be	cf 18					.word	ElseHandler
>21c0	45 4c 53 c5				.byte	$45,$4c,$53,$c5
.21c4					_end76:
>21c4	07					.byte	_end77-*
>21c5	00					.byte	$00
>21c6	7b 1c					.word	EndProgram
>21c8	45 4e c4				.byte	$45,$4e,$c4
.21cb					_end77:
>21cb	09					.byte	_end78-*
>21cc	00					.byte	$00
>21cd	d2 18					.word	EndIfHandler
>21cf	45 4e 44 49 c6				.byte	$45,$4e,$44,$49,$c6
.21d4					_end78:
>21d4	07					.byte	_end79-*
>21d5	00					.byte	$00
>21d6	47 18					.word	ForHandler
>21d8	46 4f d2				.byte	$46,$4f,$d2
.21db					_end79:
>21db	06					.byte	_end80-*
>21dc	01					.byte	$01
>21dd	cc 18					.word	IfHandler
>21df	49 c6					.byte	$49,$c6
.21e1					_end80:
>21e1	09					.byte	_end81-*
>21e2	00					.byte	$00
>21e3	ab 18					.word	GetIndex
>21e5	49 4e 44 45 d8				.byte	$49,$4e,$44,$45,$d8
.21ea					_end81:
>21ea	08					.byte	_end82-*
>21eb	00					.byte	$00
>21ec	b6 1b					.word	ListCode
>21ee	4c 49 53 d4				.byte	$4c,$49,$53,$d4
.21f2					_end82:
>21f2	07					.byte	_end83-*
>21f3	00					.byte	$00
>21f4	9f 12					.word	Maximum
>21f6	4d 41 d8				.byte	$4d,$41,$d8
.21f9					_end83:
>21f9	07					.byte	_end84-*
>21fa	00					.byte	$00
>21fb	9b 12					.word	Minimum
>21fd	4d 49 ce				.byte	$4d,$49,$ce
.2200					_end84:
>2200	07					.byte	_end85-*
>2201	00					.byte	$00
>2202	db 12					.word	Modulus16x16
>2204	4d 4f c4				.byte	$4d,$4f,$c4
.2207					_end85:
>2207	0a					.byte	_end86-*
>2208	00					.byte	$00
>2209	ef 13					.word	Negate
>220b	4e 45 47 41 54 c5			.byte	$4e,$45,$47,$41,$54,$c5
.2211					_end86:
>2211	07					.byte	_end87-*
>2212	00					.byte	$00
>2213	38 1a					.word	NewHandler
>2215	4e 45 d7				.byte	$4e,$45,$d7
.2218					_end87:
>2218	08					.byte	_end88-*
>2219	01					.byte	$01
>221a	75 18					.word	NextHandler
>221c	4e 45 58 d4				.byte	$4e,$45,$58,$d4
.2220					_end88:
>2220	07					.byte	_end89-*
>2221	00					.byte	$00
>2222	aa 15					.word	Nip
>2224	4e 49 d0				.byte	$4e,$49,$d0
.2227					_end89:
>2227	07					.byte	_end90-*
>2228	00					.byte	$00
>2229	ff 13					.word	OneComplement
>222b	4e 4f d4				.byte	$4e,$4f,$d4
.222e					_end90:
>222e	06					.byte	_end91-*
>222f	00					.byte	$00
>2230	22 12					.word	LogOr
>2232	4f d2					.byte	$4f,$d2
.2234					_end91:
>2234	08					.byte	_end92-*
>2235	00					.byte	$00
>2236	92 15					.word	Over
>2238	4f 56 45 d2				.byte	$4f,$56,$45,$d2
.223c					_end92:
>223c	0a					.byte	_end93-*
>223d	00					.byte	$00
>223e	d5 18					.word	RepeatHandler
>2240	52 45 50 45 41 d4			.byte	$52,$45,$50,$45,$41,$d4
.2246					_end93:
>2246	07					.byte	_end94-*
>2247	00					.byte	$00
>2248	7e 14					.word	RandomNumber
>224a	52 4e c4				.byte	$52,$4e,$c4
.224d					_end94:
>224d	07					.byte	_end95-*
>224e	00					.byte	$00
>224f	af 15					.word	Rot
>2251	52 4f d4				.byte	$52,$4f,$d4
.2254					_end95:
>2254	07					.byte	_end96-*
>2255	00					.byte	$00
>2256	33 1c					.word	RunProgram
>2258	52 55 ce				.byte	$52,$55,$ce
.225b					_end96:
>225b	07					.byte	_end97-*
>225c	00					.byte	$00
>225d	2a 14					.word	SignTOS
>225f	53 47 ce				.byte	$53,$47,$ce
.2262					_end97:
>2262	08					.byte	_end98-*
>2263	00					.byte	$00
>2264	73 1c					.word	StopCode
>2266	53 54 4f d0				.byte	$53,$54,$4f,$d0
.226a					_end98:
>226a	08					.byte	_end99-*
>226b	00					.byte	$00
>226c	7f 15					.word	Swap
>226e	53 57 41 d0				.byte	$53,$57,$41,$d0
.2272					_end99:
>2272	07					.byte	_end100-*
>2273	00					.byte	$00
>2274	43 1c					.word	Call6502
>2276	53 59 d3				.byte	$53,$59,$d3
.2279					_end100:
>2279	0d					.byte	_end101-*
>227a	00					.byte	$00
>227b	b9 1d					.word	IntToString
>227d	54 4f 2e 53 54 52 49 4e			.byte	$54,$4f,$2e,$53,$54,$52,$49,$4e,$c7
>2285	c7
.2286					_end101:
>2286	09					.byte	_end102-*
>2287	01					.byte	$01
>2288	d8 18					.word	UntilHandler
>228a	55 4e 54 49 cc				.byte	$55,$4e,$54,$49,$cc
.228f					_end102:
>228f	09					.byte	_end103-*
>2290	00					.byte	$00
>2291	7e 1c					.word	VlistCode
>2293	56 4c 49 53 d4				.byte	$56,$4c,$49,$53,$d4
.2298					_end103:
>2298	0a					.byte	_end104-*
>2299	40					.byte	$40
>229a	85 1a					.word	BreakCmd
>229c	58 42 52 45 41 cb			.byte	$58,$42,$52,$45,$41,$cb
.22a2					_end104:
>22a2	09					.byte	_end105-*
>22a3	00					.byte	$00
>22a4	7f 1a					.word	ExitDump
>22a6	58 44 55 4d d0				.byte	$58,$44,$55,$4d,$d0
.22ab					_end105:
>22ab	07					.byte	_end106-*
>22ac	00					.byte	$00
>22ad	15 12					.word	Xor
>22af	58 4f d2				.byte	$58,$4f,$d2
.22b2					_end106:
>22b2	00					.byte	0

;******  Return to file: kernel.asm

.22b3					EncodeTest:
.22b3	a9 cd		lda #$cd			lda 	#(EncodeTestLine & $FF)
.22b5	a0 22		ldy #$22			ldy 	#(EncodeTestLine >> 8)
.22b7	20 3b 16	jsr $163b			jsr 	EncodeProgram
.22ba	a9 10		lda #$10			lda 	#(textBuffer) & $FF
.22bc	85 0a		sta $0a				sta 	0+(bufPtr)
.22be	a9 08		lda #$08			lda 	#(textBuffer) >> 8
.22c0	85 0b		sta $0b				sta 	1+(bufPtr)
.22c2	a0 09		ldy #$09			ldy 	#encodeBuffer>>8
.22c4	a9 10		lda #$10			lda 	#encodeBuffer & $FF
.22c6	38		sec				sec
.22c7	20 89 1a	jsr $1a89			jsr 	DecodeLineIntoBufPtr
.22ca	4c ff ff	jmp $ffff			jmp 	$FFFF
.22cd					EncodeTestLine:

;******  Processing file: generated/edtext.inc

>22cd	35 39 36 32 33 20 22 55			.byte $35,$39,$36,$32,$33,$20,$22,$55,$48,$4f,$51,$35,$22,$20,$22,$57,$56,$5a,$31,$22,$20,$22,$42,$30,$31,$31,$38,$50,$58,$4e,$22,$20,$59,$37,$5a,$35,$39,$20,$32,$35,$36,$2f,$20,$4f,$52,$20,$4a,$57,$20,$22,$44,$48,$39,$48,$22,$20,$59,$31,$42,$4c,$34,$20,$22,$50,$4d,$33,$45,$39,$54,$22,$20,$33,$32,$37,$36,$38,$20,$59,$37,$5a,$35,$39,$20,$22,$50,$42,$52,$4b,$22,$20,$31,$2d,$20,$43,$38,$34,$45,$33,$45,$52,$43,$20,$22,$43,$59,$48,$59,$59,$22,$20,$22,$50,$4a,$46,$50,$42,$31,$22,$20,$22,$42,$47,$44,$22,$20,$2d,$31,$20,$27,$20,$57,$30,$33,$47,$34,$48,$20,$22,$56,$33,$51,$59,$58,$4c,$39,$22,$20,$22,$4e,$56,$36,$30,$22,$20,$4c,$48,$39,$52,$59,$20,$22,$49,$4f,$42,$46,$47,$4f,$51,$54,$59,$22,$20,$44,$49,$39,$4e,$37,$4a,$36,$4b,$20,$51,$45,$44,$59,$32,$31,$30,$34,$20,$22,$49,$53,$36,$56,$42,$4a,$35,$32,$22,$20,$52,$57,$41,$45,$50,$20,$22,$52,$4b,$55,$22,$20,$51,$56,$56,$20,$51,$45,$44,$59,$32,$31,$30,$34,$00
>22d5	48 4f 51 35 22 20 22 57 56 5a 31 22 20 22 42 30
>22e5	31 31 38 50 58 4e 22 20 59 37 5a 35 39 20 32 35
>22f5	36 2f 20 4f 52 20 4a 57 20 22 44 48 39 48 22 20
>2305	59 31 42 4c 34 20 22 50 4d 33 45 39 54 22 20 33
>2315	32 37 36 38 20 59 37 5a 35 39 20 22 50 42 52 4b
>2325	22 20 31 2d 20 43 38 34 45 33 45 52 43 20 22 43
>2335	59 48 59 59 22 20 22 50 4a 46 50 42 31 22 20 22
>2345	42 47 44 22 20 2d 31 20 27 20 57 30 33 47 34 48
>2355	20 22 56 33 51 59 58 4c 39 22 20 22 4e 56 36 30
>2365	22 20 4c 48 39 52 59 20 22 49 4f 42 46 47 4f 51
>2375	54 59 22 20 44 49 39 4e 37 4a 36 4b 20 51 45 44
>2385	59 32 31 30 34 20 22 49 53 36 56 42 4a 35 32 22
>2395	20 52 57 41 45 50 20 22 52 4b 55 22 20 51 56 56
>23a5	20 51 45 44 59 32 31 30 34 00

;******  Return to file: kernel.asm

>3fff	ff						.byte 	$FF
.4000					ProgramMemory:

;******  End of listing
