
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -q -D encode=0 -c -o kernel_nocode.prg -L kernel.lst -l kernel.lbl kernel.asm
; Tue Jan 14 13:06:24 2020

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=0					encode=0

;******  Processing input file: kernel.asm

=$1000					RplBuild = $1000 							; code starts here.

;******  Processing file: code/data.asm

.0000					NextCode:
>0000							.fill 	5
=3					IP = NextCode+3 							; the IP which points to the current instruction
.0005					rsp:
>0005							.byte 	?
.0006					tos:
>0006							.word 	?
.0008					srcPtr:
>0008							.word 	?
.000a					bufPtr:
>000a							.word 	?
.000c					matchPtr:
>000c							.word 	?
.000e					nextFreeMem:
>000e							.word 	?
.0010					temp1:
>0010							.word 	?
.0012					temp2:
>0012							.word 	?
.0014					temp3:
>0014							.word 	?
.0016					temp4:
>0016							.word 	?
.0018					listPtr:
>0018							.word 	?
.001a					SignCount:
>001a							.byte 	?
.001b					RandomSeed:
>001b							.word 	?
.001d					ListCount:
>001d							.byte 	?
.001e					ListLowest:
>001e							.word 	?
=$102					stack2Low = $102							; access other stack members following tsx
=$101					stack2High = $101							; (which requires saving X, not on the stack !)
=$104					stack3Low = $104
=$103					stack3High = $103
=$600					azVariables = $600 							; 26 x 2 variables occupying 52 bytes * PAGE BOUNDARY *
=16					hashTableSize = 16 							; hash tables for variables.
=$640					hashTable = $640 							; hash tables start here * ALL ON ONE PAGE *
=$810					textBuffer = $810 							; buffer for text.
=$700					returnStack = $700							; return stack (1 page)
=$700					returnStackLow = returnStack
=1856					returnStackHigh = returnStack+$40
=1920					returnStackX = returnStack+$80
=$80					NumberStackBase = $80 						; number stack down from here.
=$910					encodeBuffer = $910 						; buffer for encoded program
=0					COL_BLACK = 0
=1					COL_RED = 1
=2					COL_GREEN = 2
=3					COL_YELLOW = 3
=4					COL_BLUE = 4
=5					COL_MAGENTA = 5
=6					COL_CYAN = 6
=7					COL_WHITE = 7
=8					COL_RVS = 8
=2					CTH_LineNo = COL_Green
=6					CTH_Keyword = COL_Cyan
=11					CTH_Comment = COL_Yellow+COL_Rvs
=7					CTH_Definition = COL_White
=5					CTH_String = COL_Magenta
=3					CTH_Call = COL_Yellow
=7					CTH_Variable = COL_White

;******  Return to file: kernel.asm

.1000	a2 ff		ldx #$ff			ldx 	#$FF 						; reset the stack
.1002	9a		txs				txs
.1003	20 31 11	jsr $1131			jsr 	ExternInitialise
.1006	a9 43		lda #$43			lda 	#BootMsg & $FF
.1008	a0 10		ldy #$10			ldy 	#BootMsg >> 8
.100a	20 21 12	jsr $1221			jsr 	EXPrintString
.100d					WarmStartBlankStack:
.100d	86 10		stx $10				stx 	temp1
.100f	a2 80		ldx #$80			ldx 	#NumberStackBase
.1011	9a		txs				txs
.1012	a6 10		ldx $10				ldx 	temp1
.1014					WarmStart:
.1014	a9 03		lda #$03			lda 	#COL_Yellow
.1016	20 68 11	jsr $1168			jsr 	ExternColour
.1019	20 8b 11	jsr $118b			jsr 	ExternInput
.101c	a9 06		lda #$06			lda 	#COL_Cyan
.101e	20 68 11	jsr $1168			jsr 	ExternColour
.1021	a2 10		ldx #$10			ldx 	#encodeBuffer & $FF 		; run what is in the encode buffer.
.1023	a0 09		ldy #$09			ldy 	#encodeBuffer >> 8
.1025	20 95 10	jsr $1095			jsr 	InitialiseCoreCode 			; initialise the NEXT routine at $00 so error line# works
.1028	a9 10		lda #$10			lda 	#textBuffer & $FF
.102a	a0 08		ldy #$08			ldy 	#textBuffer >> 8
.102c	20 8d 16	jsr $168d			jsr 	EncodeProgram
.102f	ad 11 09	lda $0911			lda 	encodeBuffer+1 				; has a line number been entered ?
.1032	0d 12 09	ora $0912			ora 	encodeBuffer+2
.1035	d0 07		bne $103e			bne 	LineEditor 					; if so, do the line editing code.
.1037	a9 ff		lda #$ff			lda 	#$FF
.1039	85 05		sta $05				sta 	rsp
.103b	4c 00 00	jmp $0000			jmp 	NextCode
.103e					LineEditor:
.103e	20 30 1d	jsr $1d30			jsr 	EditProgram
.1041	80 ca		bra $100d			bra 	WarmStartBlankStack
.1043					BootMsg:
>1043	2a 2a 2a 20 52 50 4c 2f				.text 	"*** RPL/C INTERPRETER ***",13,13
>104b	43 20 49 4e 54 45 52 50 52 45 54 45 52 20 2a 2a
>105b	2a 0d 0d
>105e	57 52 49 54 54 45 4e 20				.text	"WRITTEN BY PAUL ROBSON 2020",13,13
>1066	42 59 20 50 41 55 4c 20 52 4f 42 53 4f 4e 20 32
>1076	30 32 30 0d 0d
>107b	42 55 49 4c 44 3a 20				.text 	"BUILD: "

;******  Processing file: generated/timestamp.inc

>1082	5b 32 30 2d 30 31 2d 31			.text	"[20-01-14 13:06]"
>108a	34 20 31 33 3a 30 36 5d

;******  Return to file: kernel.asm

>1092	0d 0d 00					.byte 	13,13,0

;******  Processing file: code/core.src

.1095					InitialiseCoreCode:
.1095	a9 e8		lda #$e8			lda 	#$E8 					; Copy INX INX 			4 cycles when run
.1097	85 00		sta $00				sta 	NextCode
.1099	85 01		sta $01				sta 	NextCode+1
.109b	a9 7c		lda #$7c			lda 	#$7C 					; Copy JMP ($aaaa,x) 	6 cycles when run
.109d	85 02		sta $02				sta 	NextCode+2
.109f	86 03		stx $03				stx 	NextCode+3 				; set the indirect address (IP)
.10a1	84 04		sty $04				sty 	NextCode+4
.10a3	a2 01		ldx #$01			ldx 	#1 						; set up to run from provided word.
.10a5	60		rts				rts								; (2 INX skip offset and line#)
.10a6					Literal2Byte:
.10a6	a5 06		lda $06				lda 	TOS
.10a8	48		pha				pha
.10a9	a5 07		lda $07				lda 	TOS+1
.10ab	48		pha				pha
.10ac	e8		inx				inx  							; point X to the word
.10ad	e8		inx				inx
.10ae	8a		txa				txa 							; copy into Y
.10af	a8		tay				tay
.10b0	b1 03		lda ($03),y			lda 	(IP),y 					; read it. the LSB
.10b2	85 06		sta $06				sta 	TOS
.10b4	c8		iny				iny 							; read and push the MSB
.10b5	b1 03		lda ($03),y			lda 	(IP),y
.10b7	85 07		sta $07				sta 	TOS+1
.10b9	4c 00 00	jmp $0000			jmp 	NextCode
.10bc					Literal2ByteDecode:
.10bc	a9 06		lda #$06			lda 	#CTH_Keyword
.10be	20 f1 1c	jsr $1cf1			jsr 	DecodeWriteBuffer
.10c1	b1 08		lda ($08),y			lda 	(srcPtr),y
.10c3	aa		tax				tax
.10c4	c8		iny				iny
.10c5	b1 08		lda ($08),y			lda 	(srcPtr),y
.10c7	a8		tay				tay
.10c8	8a		txa				txa
.10c9	38		sec				sec 							; output signed
.10ca	20 13 1d	jsr $1d13			jsr 	DecodeYAToBuffer
.10cd	60		rts				rts
.10ce					LiteralString:
.10ce	a5 06		lda $06				lda 	TOS
.10d0	48		pha				pha
.10d1	a5 07		lda $07				lda 	TOS+1
.10d3	48		pha				pha
.10d4	e8		inx				inx
.10d5	e8		inx				inx 							; skip over current word
.10d6	8a		txa				txa 							; add to IP + 1 to give string address
.10d7	a8		tay				tay 							; put in Y
.10d8	38		sec				sec 							; make that TOS
.10d9	65 03		adc $03				adc 	IP
.10db	85 06		sta $06				sta 	TOS
.10dd	a5 04		lda $04				lda 	IP+1
.10df	69 00		adc #$00			adc 	#0
.10e1	85 07		sta $07				sta 	TOS+1
.10e3	8a		txa				txa 							; add data length to X
.10e4	18		clc				clc
.10e5	71 03		adc ($03),y			adc 	(IP),y
.10e7	aa		tax				tax
.10e8	ca		dex				dex
.10e9	ca		dex				dex
.10ea	4c 00 00	jmp $0000			jmp 	NextCode
.10ed					LiteralStringDecoder:
.10ed	a9 05		lda #$05			lda 	#CTH_String
.10ef	20 f1 1c	jsr $1cf1			jsr 	DecodeWriteBuffer
.10f2	a9 22		lda #$22			lda 	#'"'
.10f4	20 f1 1c	jsr $1cf1			jsr 	DecodeWriteBuffer
.10f7	20 fa 1c	jsr $1cfa			jsr 	DecodeOutputData
.10fa	20 f1 1c	jsr $1cf1			jsr 	DecodeWriteBuffer
.10fd	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: code/error.asm

.10fe					ErrorHandler:
.10fe	68		pla				pla 								; get message address
.10ff	7a		ply				ply
.1100	1a		inc a				inc 	a
.1101	d0 01		bne $1104			bne 	_EHNoCarry
.1103	c8		iny				iny
.1104					_EHNoCarry:
.1104	20 21 12	jsr $1221			jsr 	EXPrintString
.1107	a0 01		ldy #$01			ldy 	#1 							; check if there is a line #
.1109	b1 03		lda ($03),y			lda 	(IP),y
.110b	c8		iny				iny
.110c	11 03		ora ($03),y			ora 	(IP),y
.110e	f0 14		beq $1124			beq 	_EHNoLine
.1110	a9 2c		lda #$2c			lda 	#_EHMsg2 & $FF 				; print " at "
.1112	a0 11		ldy #$11			ldy 	#_EHMsg2 >> 8
.1114	20 21 12	jsr $1221			jsr 	EXPrintString
.1117	a0 02		ldy #$02			ldy 	#2 							; print line number
.1119	b1 03		lda ($03),y			lda 	(IP),y
.111b	48		pha				pha
.111c	88		dey				dey
.111d	b1 03		lda ($03),y			lda 	(IP),y
.111f	7a		ply				ply
.1120	18		clc				clc
.1121	20 55 20	jsr $2055			jsr 	PrintYA
.1124					_EHNoLine:
.1124	a9 0d		lda #$0d			lda 	#13
.1126	20 5e 11	jsr $115e			jsr 	ExternPrint
.1129	4c 0d 10	jmp $100d			jmp 	WarmStartBlankStack			; S is indeterminate
>112c	20 41 54 20 00			_EHMsg2:.text 	" AT ",0

;******  Return to file: kernel.asm


;******  Processing file: code/export.asm


;******  Return to file: kernel.asm


;******  Processing file: code/extern.asm

.1131					ExternInitialise:
.1131	a9 90		lda #$90			lda 	#144 						; set colour
.1133	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.1136	a9 01		lda #$01			lda 	#$01
.1138	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.113b	a9 0e		lda #$0e			lda 	#14							; lower case
.113d	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.1140	a9 93		lda #$93			lda 	#147 						; clear screen
.1142	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.1145	a9 07		lda #$07			lda 	#COL_WHITE 					; white text.
.1147	4c 68 11	jmp $1168			jmp 	ExternColour
.114a					ExternCheckBreak:
.114a	da		phx				phx 								; make sure we keep XY
.114b	5a		phy				phy
.114c	20 e1 ff	jsr $ffe1			jsr 	$FFE1						; STOP check on CBM KERNAL
.114f	f0 03		beq $1154			beq		_ECBExit 					; stopped
.1151	7a		ply				ply 								; restore and exit.
.1152	fa		plx				plx
.1153	60		rts				rts
.1154					_ECBExit:
.1154	20 fe 10	jsr $10fe			jsr 	ErrorHandler
>1157	45 53 43 41 50 45 00				.text 	"ESCAPE",0
.115e					ExternPrint:
.115e	48		pha				pha
.115f	da		phx				phx
.1160	5a		phy				phy
.1161	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.1164	7a		ply				ply
.1165	fa		plx				plx
.1166	68		pla				pla
.1167	60		rts				rts
.1168					ExternColour:
.1168	48		pha				pha
.1169	da		phx				phx
.116a	48		pha				pha
.116b	29 08		and #$08			and 	#8
.116d	0a		asl a				asl 	a
.116e	0a		asl a				asl 	a
.116f	0a		asl a				asl 	a
.1170	0a		asl a				asl 	a
.1171	49 92		eor #$92			eor 	#$92
.1173	20 5e 11	jsr $115e			jsr 	ExternPrint
.1176	68		pla				pla
.1177	29 07		and #$07			and 	#7
.1179	aa		tax				tax
.117a	bd 83 11	lda $1183,x			lda 	_ECTable,x
.117d	20 5e 11	jsr $115e			jsr 	ExternPrint
.1180	fa		plx				plx
.1181	68		pla				pla
.1182	60		rts				rts
.1183					_ECTable:
>1183	90						.byte 	144
>1184	1c						.byte 	28
>1185	1e						.byte 	30
>1186	9e						.byte 	158
>1187	1f						.byte 	31
>1188	9c						.byte 	156
>1189	9f						.byte 	159
>118a	05						.byte 	5
.118b					ExternInput:
.118b	a9 10		lda #$10			lda 	#(textBuffer & $FF)
.118d	85 14		sta $14				sta 	temp3
.118f	a9 08		lda #$08			lda 	#(textBuffer >> 8)
.1191	85 15		sta $15				sta 	temp3+1
.1193	20 cf ff	jsr $ffcf	_EIRead:jsr 	$FFCF
.1196	29 7f		and #$7f			and 	#$7F
.1198	c9 0d		cmp #$0d			cmp 	#13
.119a	f0 0a		beq $11a6			beq 	_EIExit
.119c	92 14		sta ($14)			sta 	(temp3)
.119e	e6 14		inc $14				inc 	temp3
.11a0	d0 f1		bne $1193			bne 	_EIRead
.11a2	e6 15		inc $15				inc 	temp3+1
.11a4	80 ed		bra $1193			bra 	_EIRead
.11a6	a9 00		lda #$00	_EIExit:lda 	#0
.11a8	92 14		sta ($14)			sta 	(temp3)
.11aa	a9 0d		lda #$0d			lda 	#13
.11ac	20 5e 11	jsr $115e			jsr 	ExternPrint
.11af	60		rts				rts
.11b0					ExternSave:
.11b0	da		phx				phx
.11b1	5a		phy				phy
.11b2	85 12		sta $12				sta 	temp2 						; save start
.11b4	84 13		sty $13				sty 	temp2+1
.11b6	20 18 12	jsr $1218			jsr 	EXGetLength 				; get length of file into A
.11b9	a6 14		ldx $14				ldx 	temp3
.11bb	a4 15		ldy $15				ldy 	temp3+1
.11bd	20 bd ff	jsr $ffbd			jsr 	$FFBD 						; set name
.11c0	a9 01		lda #$01			lda 	#1
.11c2	a2 08		ldx #$08			ldx 	#8	 						; device #8
.11c4	a0 00		ldy #$00			ldy 	#0
.11c6	20 ba ff	jsr $ffba			jsr 	$FFBA 						; set LFS
.11c9	a6 10		ldx $10				ldx 	temp1 						; end address
.11cb	a4 11		ldy $11				ldy 	temp1+1
.11cd	a9 12		lda #$12			lda 	#temp2
.11cf	20 d8 ff	jsr $ffd8			jsr 	$FFD8 						; save
.11d2	b0 03		bcs $11d7			bcs 	_ESSave
.11d4	7a		ply				ply
.11d5	fa		plx				plx
.11d6	60		rts				rts
.11d7					_ESSave:
.11d7	20 fe 10	jsr $10fe			jsr 	ErrorHandler
>11da	53 41 56 45 20 46 41 49				.text 	"SAVE FAILED",0
>11e2	4c 45 44 00
.11e6					ExternLoad:
.11e6	da		phx				phx 								; save XY
.11e7	5a		phy				phy
.11e8	48		pha				pha 								; save target
.11e9	5a		phy				phy
.11ea	20 18 12	jsr $1218			jsr 	EXGetLength 				; get length of file into A
.11ed	a6 14		ldx $14				ldx 	temp3
.11ef	a4 15		ldy $15				ldy 	temp3+1
.11f1	20 bd ff	jsr $ffbd			jsr 	$FFBD 						; set name
.11f4	a9 01		lda #$01			lda 	#1
.11f6	a2 08		ldx #$08			ldx 	#8	 						; device #8
.11f8	a0 00		ldy #$00			ldy 	#0
.11fa	20 ba ff	jsr $ffba			jsr 	$FFBA 						; set LFS
.11fd	7a		ply				ply 								; restore target to YX and call load
.11fe	fa		plx				plx
.11ff	a9 00		lda #$00			lda 	#0 							; load command
.1201	20 d5 ff	jsr $ffd5			jsr 	$FFD5
.1204	b0 03		bcs $1209			bcs 	_ESLoad
.1206	7a		ply				ply
.1207	fa		plx				plx
.1208	60		rts				rts
.1209					_ESLoad:
.1209	20 fe 10	jsr $10fe			jsr 	ErrorHandler
>120c	4c 4f 41 44 20 46 41 49				.text 	"LOAD FAILED",0
>1214	4c 45 44 00
.1218					EXGetLength:
.1218	b2 14		lda ($14)			lda 	(temp3) 					; get name length
.121a	e6 14		inc $14				inc 	temp3 						; bump ptr past it
.121c	d0 02		bne $1220			bne 	_EXGLExit
.121e	e6 15		inc $15				inc 	temp3+1
.1220					_EXGLExit:
.1220	60		rts				rts
.1221					EXPrintString:
.1221	48		pha				pha
.1222	5a		phy				phy
.1223	84 11		sty $11				sty 	temp1+1
.1225	85 10		sta $10				sta 	temp1
.1227	a0 00		ldy #$00			ldy 	#0
.1229					_EXPSLoop:
.1229	b1 10		lda ($10),y			lda 	(temp1),y
.122b	f0 08		beq $1235			beq 	_EXPSExit
.122d	29 7f		and #$7f			and 	#$7F
.122f	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.1232	c8		iny				iny
.1233	80 f4		bra $1229			bra 	_EXPSLoop
.1235					_EXPSExit:
.1235	7a		ply				ply
.1236	68		pla				pla
.1237	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/binary.src

.1238					Add:
.1238	7a		ply				ply
.1239	68		pla				pla
.123a	18		clc				clc
.123b	65 06		adc $06				adc 	TOS
.123d	85 06		sta $06				sta 	TOS
.123f	98		tya				tya
.1240	65 07		adc $07				adc 	TOS+1
.1242	85 07		sta $07				sta 	TOS+1
.1244	4c 00 00	jmp $0000			jmp 	NextCode
.1247					Subtract:
.1247	7a		ply				ply
.1248	68		pla				pla
.1249	38		sec				sec
.124a	49 ff		eor #$ff			eor 	#$FF
.124c	65 06		adc $06				adc 	TOS
.124e	85 06		sta $06				sta 	TOS
.1250	98		tya				tya
.1251	49 ff		eor #$ff			eor 	#$FF
.1253	65 07		adc $07				adc 	TOS+1
.1255	85 07		sta $07				sta 	TOS+1
.1257	4c 00 00	jmp $0000			jmp 	NextCode
.125a					And:
.125a	68		pla				pla
.125b	25 07		and $07				and 	TOS+1
.125d	85 07		sta $07				sta 	TOS+1
.125f	68		pla				pla
.1260	25 06		and $06				and 	TOS
.1262	85 06		sta $06				sta 	TOS
.1264	4c 00 00	jmp $0000			jmp 	NextCode
.1267					Xor:
.1267	68		pla				pla
.1268	45 07		eor $07				eor 	TOS+1
.126a	85 07		sta $07				sta 	TOS+1
.126c	68		pla				pla
.126d	45 06		eor $06				eor 	TOS
.126f	85 06		sta $06				sta 	TOS
.1271	4c 00 00	jmp $0000			jmp 	NextCode
.1274					LogOr:
.1274	68		pla				pla
.1275	05 07		ora $07				ora 	TOS+1
.1277	85 07		sta $07				sta 	TOS+1
.1279	68		pla				pla
.127a	05 06		ora $06				ora 	TOS
.127c	85 06		sta $06				sta 	TOS
.127e	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/compare.src

.1281					CheckNotEqual:
.1281	38		sec				sec
.1282	80 01		bra $1285			bra 	CECode
.1284					CheckEqual:
.1284	18		clc				clc
.1285					CECode:
.1285	86 10		stx $10				stx 	temp1
.1287	ba		tsx				tsx
.1288	08		php				php
.1289	a5 06		lda $06				lda 	TOS
.128b	5d 02 01	eor $0102,x			eor 	Stack2Low,x
.128e	d0 17		bne $12a7			bne	 	CompareFalse
.1290	a5 07		lda $07				lda 	TOS+1
.1292	5d 01 01	eor $0101,x			eor 	Stack2High,x
.1295	d0 10		bne $12a7			bne 	CompareFalse
.1297					CompareTrue:
.1297	a6 10		ldx $10				ldx 	temp1
.1299	28		plp				plp
.129a	b0 10		bcs $12ac			bcs		CompareFalse2
.129c					CompareTrue2:
.129c	68		pla				pla
.129d	68		pla				pla
.129e	a9 ff		lda #$ff			lda 	#$FF
.12a0	85 06		sta $06				sta 	TOS
.12a2	85 07		sta $07				sta 	TOS+1
.12a4	4c 00 00	jmp $0000			jmp 	NextCode
.12a7					CompareFalse:
.12a7	a6 10		ldx $10				ldx 	temp1
.12a9	28		plp				plp
.12aa	b0 f0		bcs $129c			bcs		CompareTrue2
.12ac					CompareFalse2:
.12ac	68		pla				pla
.12ad	68		pla				pla
.12ae	64 06		stz $06				stz 	TOS
.12b0	64 07		stz $07				stz 	TOS+1
.12b2	4c 00 00	jmp $0000			jmp 	NextCode
.12b5					CheckGreaterEq:
.12b5	38		sec				sec
.12b6	80 01		bra $12b9			bra		CLCode
.12b8					CheckLess:
.12b8	18		clc				clc
.12b9	86 10		stx $10		CLCode:	stx 	temp1
.12bb	ba		tsx				tsx
.12bc	08		php				php
.12bd	18		clc				clc
.12be	a5 06		lda $06				lda 	TOS
.12c0	fd 02 01	sbc $0102,x			sbc 	Stack2Low,x
.12c3	a5 07		lda $07				lda 	TOS+1
.12c5	fd 01 01	sbc $0101,x			sbc 	Stack2High,x
.12c8	50 02		bvc $12cc			bvc 	_CLNoFlip
.12ca	49 80		eor #$80			eor 	#$80
.12cc					_CLNoFlip:
.12cc	0a		asl a				asl 	a
.12cd	b0 d8		bcs $12a7			bcs 	CompareFalse
.12cf	80 c6		bra $1297			bra 	CompareTrue
.12d1					CheckLessEq:
.12d1	38		sec				sec
.12d2	80 01		bra $12d5			bra		CGCode
.12d4					CheckGreater:
.12d4	18		clc				clc
.12d5					CGCode:
.12d5	86 10		stx $10				stx 	temp1
.12d7	ba		tsx				tsx
.12d8	08		php				php
.12d9	18		clc				clc
.12da	bd 02 01	lda $0102,x			lda 	Stack2Low,x
.12dd	e5 06		sbc $06				sbc 	TOS
.12df	bd 01 01	lda $0101,x			lda 	Stack2High,x
.12e2	e5 07		sbc $07				sbc 	TOS+1
.12e4	50 02		bvc $12e8			bvc 	_CGNoFlip
.12e6	49 80		eor #$80			eor 	#$80
.12e8					_CGNoFlip:
.12e8	0a		asl a				asl 	a
.12e9	b0 bc		bcs $12a7			bcs 	CompareFalse
.12eb	80 aa		bra $1297			bra 	CompareTrue
.12ed					Minimum:
.12ed	a9 00		lda #$00			lda 	#0
.12ef	80 02		bra $12f3			bra 	MinMaxCode
.12f1					Maximum:
.12f1	a9 80		lda #$80			lda 	#$80
.12f3					MinMaxCode:
.12f3	85 11		sta $11				sta 	temp1+1
.12f5	86 10		stx $10				stx 	temp1
.12f7	ba		tsx				tsx
.12f8	38		sec				sec
.12f9	a5 06		lda $06				lda 	TOS
.12fb	fd 02 01	sbc $0102,x			sbc 	Stack2Low,x
.12fe	a5 07		lda $07				lda 	TOS+1
.1300	fd 01 01	sbc $0101,x			sbc 	Stack2High,x
.1303	50 02		bvc $1307			bvc 	_MMNoFlip
.1305	49 80		eor #$80			eor 	#$80
.1307					_MMNoFlip:
.1307	45 11		eor $11				eor 	temp1+1
.1309	30 0a		bmi $1315			bmi 	_MMNoCopy
.130b	bd 02 01	lda $0102,x			lda 	Stack2Low,x
.130e	85 06		sta $06				sta 	TOS
.1310	bd 01 01	lda $0101,x			lda 	Stack2High,x
.1313	85 07		sta $07				sta 	TOS+1
.1315					_MMNoCopy:
.1315	a6 10		ldx $10				ldx 	temp1
.1317	68		pla				pla
.1318	68		pla				pla
.1319	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/divide.src

.131c					Divide16x16:
.131c	86 12		stx $12				stx 	temp2
.131e	ba		tsx				tsx
.131f	20 42 13	jsr $1342			jsr 	IntegerDivide
.1322	68		pla				pla
.1323	85 07		sta $07				sta 	TOS+1
.1325	68		pla				pla
.1326	85 06		sta $06				sta 	TOS
.1328	a6 12		ldx $12				ldx 	temp2
.132a	4c 00 00	jmp $0000			jmp 	NextCode
.132d					Modulus16x16:
.132d	86 12		stx $12				stx 	temp2
.132f	ba		tsx				tsx
.1330	20 42 13	jsr $1342			jsr 	IntegerDivide
.1333	a6 12		ldx $12				ldx 	temp2
.1335	68		pla				pla
.1336	68		pla				pla
.1337	a5 10		lda $10				lda 	temp1
.1339	85 06		sta $06				sta 	TOS
.133b	a5 11		lda $11				lda 	temp1+1
.133d	85 07		sta $07				sta 	TOS+1
.133f	4c 00 00	jmp $0000			jmp 	NextCode
.1342					IntegerDivide:
.1342	a5 06		lda $06				lda 	TOS 				; check for division by zero.
.1344	05 07		ora $07				ora 	TOS+1
.1346	d0 14		bne $135c			bne 	_BFDOkay
.1348	20 fe 10	jsr $10fe			jsr 	ErrorHandler
>134b	44 49 56 49 53 49 4f 4e				.text 	"DIVISION BY ZERO",0
>1353	20 42 59 20 5a 45 52 4f 00
.135c					_BFDOkay:
.135c	64 10		stz $10				stz 	temp1 						; Q/Dividend/Left in +0
.135e	64 11		stz $11				stz 	temp1+1 					; M/Divisor/Right in +2
.1360	64 1a		stz $1a				stz 	SignCount 					; Count of signs.
.1362	20 9d 13	jsr $139d			jsr 	CheckIntegerNegate 			; negate 2nd (and bump sign count)
.1365	20 b7 13	jsr $13b7			jsr 	CheckTOSNegate 				; negate TOS (and bump sign count)
.1368	5a		phy				phy 								; Y is the counter
.1369	a0 10		ldy #$10			ldy 	#16 						; 16 iterations of the loop.
.136b					_BFDLoop:
.136b	1e 02 01	asl $0102,x			asl 	Stack2Low,x 				; shift AQ left.
.136e	3e 01 01	rol $0101,x			rol 	Stack2High,x
.1371	26 10		rol $10				rol 	temp1
.1373	26 11		rol $11				rol 	temp1+1
.1375	38		sec				sec
.1376	a5 10		lda $10				lda 	temp1+0 					; Calculate A-M on stack.
.1378	e5 06		sbc $06				sbc 	TOS
.137a	48		pha				pha
.137b	a5 11		lda $11				lda 	temp1+1
.137d	e5 07		sbc $07				sbc 	TOS+1
.137f	90 0f		bcc $1390			bcc 	_BFDNoAdd
.1381	85 11		sta $11				sta 	temp1+1
.1383	68		pla				pla
.1384	85 10		sta $10				sta 	temp1+0
.1386	bd 02 01	lda $0102,x			lda 	Stack2Low,x 				; set Q bit 1.
.1389	09 01		ora #$01			ora 	#1
.138b	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.138e	80 01		bra $1391			bra 	_BFDNext
.1390					_BFDNoAdd:
.1390	68		pla				pla 								; Throw away the intermediate calculations
.1391					_BFDNext:
.1391	88		dey				dey
.1392	d0 d7		bne $136b			bne 	_BFDLoop
.1394	7a		ply				ply 								; restore Y
.1395	46 1a		lsr $1a				lsr 	SignCount 					; if sign count odd,
.1397	90 03		bcc $139c			bcc 	_BFDUnsigned 				; then the result is signed
.1399	20 a3 13	jsr $13a3			jsr		IntegerNegateAlways 		; negate the result
.139c					_BFDUnsigned:
.139c	60		rts				rts
.139d					CheckIntegerNegate:
.139d	bd 01 01	lda $0101,x			lda 	Stack2High,x 				; is it -ve = MSB set ?
.13a0	30 01		bmi $13a3			bmi 	IntegerNegateAlways 		; if so negate it
.13a2	60		rts				rts
.13a3					IntegerNegateAlways:
.13a3	e6 1a		inc $1a				inc 	SignCount 					; bump the count of signs
.13a5	38		sec				sec 								; negate
.13a6	a9 00		lda #$00			lda 	#0
.13a8	fd 02 01	sbc $0102,x			sbc 	Stack2Low,x
.13ab	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.13ae	a9 00		lda #$00			lda 	#0
.13b0	fd 01 01	sbc $0101,x			sbc 	Stack2High,x
.13b3	9d 01 01	sta $0101,x			sta 	Stack2High,x
.13b6	60		rts				rts
.13b7					CheckTOSNegate:
.13b7	a5 07		lda $07				lda 	TOS+1
.13b9	10 0f		bpl $13ca			bpl		CTNNoChange
.13bb	e6 1a		inc $1a				inc 	SignCount
.13bd					TOSNegateAlways:
.13bd	38		sec				sec
.13be	a9 00		lda #$00			lda 	#0
.13c0	e5 06		sbc $06				sbc 	TOS
.13c2	85 06		sta $06				sta 	TOS
.13c4	a9 00		lda #$00			lda 	#0
.13c6	e5 07		sbc $07				sbc 	TOS+1
.13c8	85 07		sta $07				sta 	TOS+1
.13ca					CTNNoChange:
.13ca	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/multiply.src

.13cb					Multiply16x16:
.13cb	86 10		stx $10				stx 	temp1
.13cd	ba		tsx				tsx
.13ce	bd 02 01	lda $0102,x			lda 	Stack2Low,x 				; 2nd value on stack to temp1
.13d1	85 12		sta $12				sta 	temp2
.13d3	bd 01 01	lda $0101,x			lda		Stack2High,x
.13d6	85 13		sta $13				sta 	temp2+1
.13d8	9e 02 01	stz $0102,x			stz 	Stack2Low,x 				; zero 2nd value on stack
.13db	9e 01 01	stz $0101,x			stz 	Stack2High,x
.13de					_MultLoop:
.13de	46 13		lsr $13				lsr 	temp2+1 					; ror temp2 into C
.13e0	66 12		ror $12				ror 	temp2
.13e2	90 11		bcc $13f5			bcc 	_MultNoAdd
.13e4	18		clc				clc 								; add 1st to 2nd
.13e5	a5 06		lda $06				lda 	TOS
.13e7	7d 02 01	adc $0102,x			adc 	Stack2Low,x
.13ea	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.13ed	a5 07		lda $07				lda 	TOS+1
.13ef	7d 01 01	adc $0101,x			adc 	Stack2High,x
.13f2	9d 01 01	sta $0101,x			sta 	Stack2High,x
.13f5					_MultNoAdd:
.13f5	06 06		asl $06				asl 	TOS 						; shift 1st left
.13f7	26 07		rol $07				rol 	TOS+1
.13f9	a5 12		lda $12				lda 	temp2	 					; until zero
.13fb	05 13		ora $13				ora 	temp2+1
.13fd	d0 df		bne $13de			bne 	_MultLoop
.13ff	a6 10		ldx $10				ldx 	temp1 						; restore X load result
.1401	68		pla				pla
.1402	85 07		sta $07				sta 	TOS+1
.1404	68		pla				pla
.1405	85 06		sta $06				sta 	TOS
.1407	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/unary.src

.140a					Unary1Plus:
.140a	e6 06		inc $06				inc 	TOS
.140c	d0 02		bne $1410			bne 	_U1PSkip
.140e	e6 07		inc $07				inc 	TOS+1
.1410					_U1PSkip:
.1410	4c 00 00	jmp $0000			jmp 	NextCode
.1413					Unary2Plus:
.1413	18		clc				clc
.1414	a5 06		lda $06				lda 	TOS
.1416	69 02		adc #$02			adc 	#2
.1418	85 06		sta $06				sta 	TOS
.141a	90 02		bcc $141e			bcc 	_U1PSkip
.141c	e6 07		inc $07				inc 	TOS+1
.141e					_U1PSkip:
.141e	4c 00 00	jmp $0000			jmp 	NextCode
.1421					Unary1Minus:
.1421	a5 06		lda $06				lda 	TOS
.1423	d0 02		bne $1427			bne 	_U1MSkip
.1425	c6 07		dec $07				dec 	TOS+1
.1427					_U1MSkip:
.1427	c6 06		dec $06				dec 	TOS
.1429	4c 00 00	jmp $0000			jmp 	NextCode
.142c					Unary2Minus:
.142c	38		sec				sec
.142d	a5 06		lda $06				lda 	TOS
.142f	e9 02		sbc #$02			sbc 	#2
.1431	85 06		sta $06				sta 	TOS
.1433	b0 02		bcs $1437			bcs 	_U1PSkip
.1435	c6 07		dec $07				dec 	TOS+1
.1437					_U1PSkip:
.1437	4c 00 00	jmp $0000			jmp 	NextCode
.143a					Absolute:
.143a	a5 07		lda $07				lda 	TOS+1
.143c	30 03		bmi $1441			bmi 	Negate
.143e	4c 00 00	jmp $0000			jmp 	NextCode
.1441					Negate:
.1441	38		sec				sec
.1442	a9 00		lda #$00			lda 	#0
.1444	e5 06		sbc $06				sbc 	TOS
.1446	85 06		sta $06				sta 	TOS
.1448	a9 00		lda #$00			lda 	#0
.144a	e5 07		sbc $07				sbc 	TOS+1
.144c	85 07		sta $07				sta 	TOS+1
.144e	4c 00 00	jmp $0000			jmp 	NextCode
.1451					OneComplement:
.1451	a5 06		lda $06				lda 	TOS
.1453	49 ff		eor #$ff			eor 	#$FF
.1455	85 06		sta $06				sta 	TOS
.1457	a5 07		lda $07				lda 	TOS+1
.1459	49 ff		eor #$ff			eor 	#$FF
.145b	85 07		sta $07				sta 	TOS+1
.145d	4c 00 00	jmp $0000			jmp 	NextCode
.1460					CheckMinus:
.1460	a5 07		lda $07				lda 	TOS+1
.1462	30 07		bmi $146b			bmi 	UnaryTrue
.1464					UnaryFalse:
.1464	64 06		stz $06				stz 	TOS
.1466	64 07		stz $07				stz 	TOS+1
.1468	4c 00 00	jmp $0000			jmp 	NextCode
.146b					UnaryTrue:
.146b	a9 ff		lda #$ff			lda 	#$FF
.146d	85 06		sta $06				sta 	TOS
.146f	85 07		sta $07				sta 	TOS+1
.1471	4c 00 00	jmp $0000			jmp 	NextCode
.1474					CheckZero:
.1474	a5 06		lda $06				lda 	TOS
.1476	05 07		ora $07				ora 	TOS+1
.1478	d0 ea		bne $1464			bne 	UnaryFalse
.147a	80 ef		bra $146b			bra 	UnaryTrue
.147c					SignTOS:
.147c	a5 07		lda $07				lda 	TOS+1
.147e	30 eb		bmi $146b			bmi		UnaryTrue
.1480	05 06		ora $06				ora 	TOS
.1482	f0 e0		beq $1464			beq 	UnaryFalse
.1484	a9 01		lda #$01			lda 	#1
.1486	85 06		sta $06				sta 	TOS
.1488	64 07		stz $07				stz		TOS+1
.148a	4c 00 00	jmp $0000			jmp 	NextCode
.148d					ByteSwap:
.148d	a5 06		lda $06				lda 	TOS
.148f	a4 07		ldy $07				ldy 	TOS+1
.1491	85 07		sta $07				sta 	TOS+1
.1493	84 06		sty $06				sty 	TOS
.1495	4c 00 00	jmp $0000			jmp 	NextCode
.1498					Times16:
.1498	06 06		asl $06				asl 	TOS
.149a	26 07		rol $07				rol 	TOS+1
.149c					Times8:
.149c	06 06		asl $06				asl 	TOS
.149e	26 07		rol $07				rol 	TOS+1
.14a0					Times4:
.14a0	06 06		asl $06				asl 	TOS
.14a2	26 07		rol $07				rol 	TOS+1
.14a4					Times2:
.14a4	06 06		asl $06				asl 	TOS
.14a6	26 07		rol $07				rol 	TOS+1
.14a8	4c 00 00	jmp $0000			jmp 	NextCode
.14ab					Divide16:
.14ab	46 07		lsr $07				lsr 	TOS+1
.14ad	66 06		ror $06				ror 	TOS
.14af					Divide8:
.14af	46 07		lsr $07				lsr 	TOS+1
.14b1	66 06		ror $06				ror 	TOS
.14b3					Divide4:
.14b3	46 07		lsr $07				lsr 	TOS+1
.14b5	66 06		ror $06				ror 	TOS
.14b7					Divide2:
.14b7	46 07		lsr $07				lsr 	TOS+1
.14b9	66 06		ror $06				ror 	TOS
.14bb	4c 00 00	jmp $0000			jmp 	NextCode
.14be					Times256:
.14be	a5 06		lda $06				lda 	TOS
.14c0	85 07		sta $07				sta 	TOS+1
.14c2	64 06		stz $06				stz 	TOS
.14c4	4c 00 00	jmp $0000			jmp 	NextCode
.14c7					Divide256:
.14c7	a5 07		lda $07				lda 	TOS+1
.14c9	85 06		sta $06				sta 	TOS
.14cb	64 07		stz $07				stz 	TOS+1
.14cd	4c 00 00	jmp $0000			jmp 	NextCode
.14d0					RandomNumber:
.14d0	a5 06		lda $06				lda 	TOS
.14d2	48		pha				pha
.14d3	a5 07		lda $07				lda 	TOS+1
.14d5	48		pha				pha
.14d6	a5 1b		lda $1b				lda 	randomSeed
.14d8	05 1c		ora $1c				ora 	randomSeed+1
.14da	d0 08		bne $14e4			bne 	_RH_NoInit
.14dc	a9 7c		lda #$7c			lda 	#$7C
.14de	85 1b		sta $1b				sta 	randomSeed
.14e0	a9 a1		lda #$a1			lda 	#$A1
.14e2	85 1c		sta $1c				sta 	randomSeed+1
.14e4					_RH_NoInit:
.14e4	a5 1b		lda $1b				lda 	randomSeed
.14e6	4a		lsr a		        lsr		a
.14e7	26 1c		rol $1c		        rol 	randomSeed+1
.14e9	90 02		bcc $14ed	        bcc 	_RH_NoEor
.14eb	49 b4		eor #$b4	        eor 	#$B4
.14ed					_RH_NoEor:
.14ed	85 1b		sta $1b		        sta 	randomSeed
.14ef	45 1c		eor $1c		        eor 	randomSeed+1
.14f1	85 07		sta $07		        sta 	TOS+1
.14f3	a5 1b		lda $1b		        lda 	randomSeed
.14f5	85 06		sta $06		        sta 	TOS
.14f7	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/data/literals.src

.14fa					Constant0:
.14fa	a5 06		lda $06				lda 	TOS
.14fc	48		pha				pha
.14fd	a5 07		lda $07				lda 	TOS+1
.14ff	48		pha				pha
.1500	64 06		stz $06				stz 	TOS
.1502	64 07		stz $07				stz 	TOS+1
.1504	4c 00 00	jmp $0000			jmp 	NextCode
.1507					ConstantMinus1:
.1507	a5 06		lda $06				lda 	TOS
.1509	48		pha				pha
.150a	a5 07		lda $07				lda 	TOS+1
.150c	48		pha				pha
.150d	a9 ff		lda #$ff			lda 	#$FF
.150f	85 06		sta $06				sta 	TOS
.1511	85 07		sta $07				sta 	TOS+1
.1513	4c 00 00	jmp $0000			jmp 	NextCode
.1516					C1:
.1516	a0 01		ldy #$01			ldy 	#1
.1518	80 24		bra $153e			bra 	Const1Byte
.151a					C2:
.151a	a0 02		ldy #$02			ldy 	#2
.151c	80 20		bra $153e			bra 	Const1Byte
.151e					C3:
.151e	a0 03		ldy #$03			ldy 	#3
.1520	80 1c		bra $153e			bra 	Const1Byte
.1522					C4:
.1522	a0 04		ldy #$04			ldy 	#4
.1524	80 18		bra $153e			bra 	Const1Byte
.1526					C5:
.1526	a0 05		ldy #$05			ldy 	#5
.1528	80 14		bra $153e			bra 	Const1Byte
.152a					C8:
.152a	a0 08		ldy #$08			ldy 	#8
.152c	80 10		bra $153e			bra 	Const1Byte
.152e					C10:
.152e	a0 0a		ldy #$0a			ldy 	#10
.1530	80 0c		bra $153e			bra 	Const1Byte
.1532					C15:
.1532	a0 0f		ldy #$0f			ldy 	#15
.1534	80 08		bra $153e			bra 	Const1Byte
.1536					C16:
.1536	a0 10		ldy #$10			ldy 	#16
.1538	80 04		bra $153e			bra 	Const1Byte
.153a					C24:
.153a	a0 18		ldy #$18			ldy 	#24
.153c	80 00		bra $153e			bra 	Const1Byte
.153e					Const1Byte:
.153e	a5 06		lda $06				lda 	TOS
.1540	48		pha				pha
.1541	a5 07		lda $07				lda 	TOS+1
.1543	48		pha				pha
.1544	84 06		sty $06				sty 	TOS
.1546	64 07		stz $07				stz 	TOS+1
.1548	4c 00 00	jmp $0000			jmp 	NextCode
.154b					C32:
.154b	a0 20		ldy #$20			ldy 	#32
.154d	80 ef		bra $153e			bra 	Const1Byte
.154f					C63:
.154f	a0 3f		ldy #$3f			ldy 	#63
.1551	80 eb		bra $153e			bra 	Const1Byte
.1553					C64:
.1553	a0 40		ldy #$40			ldy 	#64
.1555	80 e7		bra $153e			bra 	Const1Byte
.1557					C100:
.1557	a0 64		ldy #$64			ldy 	#100
.1559	80 e3		bra $153e			bra 	Const1Byte
.155b					C127:
.155b	a0 7f		ldy #$7f			ldy 	#127
.155d	80 df		bra $153e			bra 	Const1Byte
.155f					C128:
.155f	a0 80		ldy #$80			ldy 	#128
.1561	80 db		bra $153e			bra 	Const1Byte
.1563					C255:
.1563	a0 ff		ldy #$ff			ldy 	#255
.1565	80 d7		bra $153e			bra 	Const1Byte
.1567					Const2Byte:
.1567	85 06		sta $06				sta 	TOS
.1569	84 07		sty $07				sty 	TOS+1
.156b	4c 00 00	jmp $0000			jmp 	NextCode
.156e					C256:
.156e	a5 06		lda $06				lda 	TOS
.1570	48		pha				pha
.1571	a5 07		lda $07				lda 	TOS+1
.1573	48		pha				pha
.1574	a9 00		lda #$00			lda 	#(256) & $FF
.1576	a0 01		ldy #$01			ldy 	#(256) >> 8
.1578	80 ed		bra $1567			bra 	Const2Byte
.157a					C512:
.157a	a5 06		lda $06				lda 	TOS
.157c	48		pha				pha
.157d	a5 07		lda $07				lda 	TOS+1
.157f	48		pha				pha
.1580	a9 00		lda #$00			lda 	#(512) & $FF
.1582	a0 02		ldy #$02			ldy 	#(512) >> 8
.1584	80 e1		bra $1567			bra 	Const2Byte
.1586					C1024:
.1586	a5 06		lda $06				lda 	TOS
.1588	48		pha				pha
.1589	a5 07		lda $07				lda 	TOS+1
.158b	48		pha				pha
.158c	a9 00		lda #$00			lda 	#(1024) & $FF
.158e	a0 04		ldy #$04			ldy 	#(1024) >> 8
.1590	80 d5		bra $1567			bra 	Const2Byte
.1592					C4096:
.1592	a5 06		lda $06				lda 	TOS
.1594	48		pha				pha
.1595	a5 07		lda $07				lda 	TOS+1
.1597	48		pha				pha
.1598	a9 00		lda #$00			lda 	#(4096) & $FF
.159a	a0 10		ldy #$10			ldy 	#(4096) >> 8
.159c	80 c9		bra $1567			bra 	Const2Byte
.159e					C32767:
.159e	a5 06		lda $06				lda 	TOS
.15a0	48		pha				pha
.15a1	a5 07		lda $07				lda 	TOS+1
.15a3	48		pha				pha
.15a4	a9 ff		lda #$ff			lda 	#(32767) & $FF
.15a6	a0 7f		ldy #$7f			ldy 	#(32767) >> 8
.15a8	80 bd		bra $1567			bra 	Const2Byte
.15aa					C32768:
.15aa	a5 06		lda $06				lda 	TOS
.15ac	48		pha				pha
.15ad	a5 07		lda $07				lda 	TOS+1
.15af	48		pha				pha
.15b0	a9 00		lda #$00			lda 	#(32768) & $FF
.15b2	a0 80		ldy #$80			ldy 	#(32768) >> 8
.15b4	80 b1		bra $1567			bra 	Const2Byte

;******  Return to file: kernel.asm


;******  Processing file: words/data/stack.src

.15b6					Drop:
.15b6	68		pla				pla
.15b7	85 07		sta $07				sta 	TOS+1
.15b9	68		pla				pla
.15ba	85 06		sta $06				sta 	TOS
.15bc	4c 00 00	jmp $0000			jmp 	NextCode
.15bf					TestDup:
.15bf	a5 06		lda $06				lda 	TOS
.15c1	05 07		ora $07				ora 	TOS+1
.15c3	d0 03		bne $15c8			bne 	Dup
.15c5	4c 00 00	jmp $0000			jmp 	NextCode
.15c8					Dup:
.15c8	a5 06		lda $06				lda 	TOS
.15ca	48		pha				pha
.15cb	a5 07		lda $07				lda 	TOS+1
.15cd	48		pha				pha
.15ce	4c 00 00	jmp $0000			jmp 	NextCode
.15d1					Swap:
.15d1	86 10		stx $10				stx 	temp1
.15d3	7a		ply				ply
.15d4	fa		plx				plx
.15d5	a5 06		lda $06				lda 	TOS
.15d7	48		pha				pha
.15d8	a5 07		lda $07				lda 	TOS+1
.15da	48		pha				pha
.15db	86 06		stx $06				stx 	TOS
.15dd	84 07		sty $07				sty 	TOS+1
.15df	a6 10		ldx $10				ldx 	temp1
.15e1	4c 00 00	jmp $0000			jmp 	NextCode
.15e4					Over:
.15e4	a5 06		lda $06				lda 	TOS
.15e6	48		pha				pha
.15e7	a5 07		lda $07				lda 	TOS+1
.15e9	48		pha				pha
.15ea	86 10		stx $10				stx 	temp1
.15ec	ba		tsx				tsx
.15ed	bd 04 01	lda $0104,x			lda 	stack3low,x
.15f0	85 06		sta $06				sta 	TOS
.15f2	bd 03 01	lda $0103,x			lda 	stack3High,x
.15f5	85 07		sta $07				sta 	TOS+1
.15f7	a6 10		ldx $10				ldx 	temp1
.15f9	4c 00 00	jmp $0000			jmp 	NextCode
.15fc					Nip:
.15fc	68		pla				pla
.15fd	68		pla				pla
.15fe	4c 00 00	jmp $0000			jmp 	NextCode
.1601					Rot:
.1601	86 10		stx $10				stx 	temp1
.1603	ba		tsx				tsx
.1604	bd 04 01	lda $0104,x			lda 	Stack3Low,x
.1607	a8		tay				tay
.1608	bd 02 01	lda $0102,x			lda 	Stack2Low,x
.160b	9d 04 01	sta $0104,x			sta 	Stack3Low,x
.160e	a5 06		lda $06				lda 	TOS
.1610	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.1613	84 06		sty $06				sty 	TOS
.1615	bd 03 01	lda $0103,x			lda 	Stack3High,x
.1618	a8		tay				tay
.1619	bd 01 01	lda $0101,x			lda 	Stack2High,x
.161c	9d 03 01	sta $0103,x			sta 	Stack3High,x
.161f	a5 07		lda $07				lda 	TOS+1
.1621	9d 01 01	sta $0101,x			sta 	Stack2High,x
.1624	84 07		sty $07				sty 	TOS+1
.1626	a6 10		ldx $10				ldx 	temp1
.1628	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/data/memory.src

.162b					ByteRead:
.162b	b2 06		lda ($06)			lda 	(TOS)
.162d	85 06		sta $06				sta 	TOS
.162f	64 07		stz $07				stz 	TOS+1
.1631	4c 00 00	jmp $0000			jmp 	NextCode
.1634					WordRead:
.1634	a0 01		ldy #$01			ldy 	#1
.1636	b1 06		lda ($06),y			lda 	(TOS),y
.1638	a8		tay				tay
.1639	b2 06		lda ($06)			lda 	(TOS)
.163b	85 06		sta $06				sta 	TOS
.163d	84 07		sty $07				sty 	TOS+1
.163f	4c 00 00	jmp $0000			jmp 	NextCode
.1642					ByteWrite:
.1642	68		pla				pla
.1643	68		pla				pla
.1644	92 06		sta ($06)			sta 	(TOS)
.1646	68		pla				pla
.1647	85 07		sta $07				sta 	TOS+1
.1649	68		pla				pla
.164a	85 06		sta $06				sta 	TOS
.164c	4c 00 00	jmp $0000			jmp 	NextCode
.164f					WordWrite:
.164f	68		pla				pla
.1650	a0 01		ldy #$01			ldy 	#1
.1652	91 06		sta ($06),y			sta 	(TOS),y
.1654	68		pla				pla
.1655	92 06		sta ($06)			sta 	(TOS)
.1657	68		pla				pla
.1658	85 07		sta $07				sta 	TOS+1
.165a	68		pla				pla
.165b	85 06		sta $06				sta 	TOS
.165d	4c 00 00	jmp $0000			jmp 	NextCode
.1660					WordAdd:
.1660	7a		ply				ply
.1661	68		pla				pla
.1662	18		clc				clc
.1663	72 06		adc ($06)			adc 	(TOS)
.1665	92 06		sta ($06)			sta 	(TOS)
.1667	98		tya				tya
.1668	a0 01		ldy #$01			ldy 	#1
.166a	71 06		adc ($06),y			adc 	(TOS),y
.166c	91 06		sta ($06),y			sta 	(TOS),y
.166e	68		pla				pla
.166f	85 07		sta $07				sta 	TOS+1
.1671	68		pla				pla
.1672	85 06		sta $06				sta 	TOS
.1674	4c 00 00	jmp $0000			jmp 	NextCode
.1677					AllocateMemory:
.1677	a5 06		lda $06				lda 	TOS 						; save memory required on stack.
.1679	48		pha				pha
.167a	a5 07		lda $07				lda 	TOS+1
.167c	48		pha				pha
.167d	a5 0e		lda $0e				lda 	nextFreeMem 				; copy free mem address to TOS
.167f	85 06		sta $06				sta 	TOS
.1681	a5 0f		lda $0f				lda 	nextFreeMem+1
.1683	85 07		sta $07				sta 	TOS+1
.1685	7a		ply				ply 								; advance the free ram pointer
.1686	68		pla				pla
.1687	20 ee 1b	jsr $1bee			jsr 	AdvanceFreeMem
.168a	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/encode/encode.src

.168d					EncodeProgram:
.168d	48		pha				pha 								; save registers.
.168e	da		phx				phx
.168f	5a		phy				phy
.1690	84 09		sty $09				sty 	srcPtr+1					; save source pointer.
.1692	85 08		sta $08				sta		srcPtr
.1694	20 b9 18	jsr $18b9			jsr 	EncodeTrimTrailingSpaces 	; remove trailing spaces.
.1697	a9 03		lda #$03			lda 	#3 							; reset the encode Buffer
.1699	8d 10 09	sta $0910			sta 	encodeBuffer 				; this is also the write ptr/offset
.169c	9c 11 09	stz $0911			stz 	encodeBuffer+1 				; the line number
.169f	9c 12 09	stz $0912			stz 	encodeBuffer+2 				; which is initially zero.
.16a2	b2 08		lda ($08)			lda 	(srcPtr) 					; check if first character is digit
.16a4	20 64 18	jsr $1864			jsr 	CheckIsDigit
.16a7	90 09		bcc $16b2			bcc 	_EPNoLineNumber 			; if so there is a line number
.16a9	20 86 18	jsr $1886			jsr 	EncodeGetConstant 			; extract that constant from the source
.16ac	8d 11 09	sta $0911			sta 	encodeBuffer+1 				; that is the line number
.16af	8c 12 09	sty $0912			sty 	encodeBuffer+2
.16b2					_EPNoLineNumber:
.16b2					EncodeLoop:
.16b2	20 ab 18	jsr $18ab			jsr 	EncSkipSpaces 				; skip over spaces
.16b5	b2 08		lda ($08)			lda 	(srcPtr) 					; reached end ?
.16b7	d0 0b		bne $16c4			bne 	_EPNotEnd
.16b9					_EPEndEncode:
.16b9	a9 d7		lda #$d7			lda 	#NextLine & $FF 			; compile $$nextline to mark eol
.16bb	a0 1f		ldy #$1f			ldy 	#NextLine >> 8
.16bd	20 3c 18	jsr $183c			jsr 	EncodeWriteWord
.16c0	7a		ply				ply									; restore and exit.
.16c1	fa		plx				plx
.16c2	68		pla				pla
.16c3	60		rts				rts
.16c4					_EPNotEnd:
.16c4	b2 08		lda ($08)			lda 	(srcPtr)
.16c6	c9 22		cmp #$22			cmp 	#'"'						; is it a quoted string or comment ?
.16c8	f0 04		beq $16ce			beq 	_EPIsComStr
.16ca	c9 27		cmp #$27			cmp 	#"'"
.16cc	d0 05		bne $16d3			bne 	_EPNotComStr
.16ce					_EPIsComStr:
.16ce	20 93 17	jsr $1793			jsr 	EncodeCommentString
.16d1	80 df		bra $16b2			bra 	EncodeLoop
.16d3					_EPNotComStr:
.16d3	38		sec				sec
.16d4	20 98 18	jsr $1898			jsr 	EncSetBit7Word
.16d7	20 d2 18	jsr $18d2			jsr 	EncodeSearchDictionary		; look it up
.16da	90 44		bcc $1720			bcc 	_EPNotInDictionary
.16dc	85 10		sta $10				sta 	temp1 						; save dictionary record address
.16de	84 11		sty $11				sty 	temp1+1
.16e0	a0 01		ldy #$01			ldy 	#1
.16e2	b1 10		lda ($10),y			lda 	(temp1),y 					; check if has an encode bit
.16e4	29 20		and #$20			and 	#$20
.16e6	d0 12		bne $16fa			bne 	_EPEncodeRoutine 			; if so, do special routine.
.16e8	a0 02		ldy #$02			ldy 	#2 							; write out the routine address
.16ea	b1 10		lda ($10),y			lda 	(temp1),y
.16ec	20 46 18	jsr $1846			jsr 	EncodeWriteByte
.16ef	c8		iny				iny
.16f0	b1 10		lda ($10),y			lda 	(temp1),y
.16f2	20 46 18	jsr $1846			jsr 	EncodeWriteByte
.16f5	20 70 18	jsr $1870			jsr 	EncodeMoveNextWord 			; advance to the next and loop
.16f8	80 b8		bra $16b2			bra 	EncodeLoop
.16fa					_EPEncodeRoutine:
.16fa	a0 01		ldy #$01			ldy 	#1							; get type bit
.16fc	b1 10		lda ($10),y			lda 	(temp1),y
.16fe	a0 04		ldy #$04			ldy 	#4							; encoder here if no decoder
.1700	29 10		and #$10			and 	#$10 						; but decoder comes first
.1702	f0 02		beq $1706			beq 	_EPENoDecoder
.1704	c8		iny				iny 								; so if it exists, adjust for it.
.1705	c8		iny				iny
.1706					_EPENoDecoder:
.1706	b1 10		lda ($10),y			lda 	(temp1),y 					; copy exec addr to temp2
.1708	85 12		sta $12				sta 	temp2
.170a	c8		iny				iny
.170b	b1 10		lda ($10),y			lda 	(temp1),y
.170d	85 13		sta $13				sta 	temp2+1
.170f	48		pha				pha 								; call routine preserving state
.1710	da		phx				phx
.1711	5a		phy				phy
.1712	20 1d 17	jsr $171d			jsr 	_EPECallTemp2
.1715	7a		ply				ply
.1716	fa		plx				plx
.1717	68		pla				pla
.1718	20 70 18	jsr $1870			jsr 	EncodeMoveNextWord 			; advance to the next and loop
.171b	80 95		bra $16b2			bra 	EncodeLoop
.171d					_EPECallTemp2:
.171d	6c 12 00	jmp ($0012)			jmp 	(temp2)
.1720					_EPNotInDictionary:
.1720	20 ee 17	jsr $17ee			jsr 	EncodeSearchUserDefined 	; are there any user defined routines
.1723	90 19		bcc $173e			bcc 	_EPNotDefined
.1725	48		pha				pha
.1726	a9 6e		lda #$6e			lda	 	#CallHandler & $FF 			; write code call handler
.1728	20 46 18	jsr $1846			jsr 	EncodeWriteByte
.172b	a9 1a		lda #$1a			lda	 	#CallHandler >> 8
.172d	20 46 18	jsr $1846			jsr 	EncodeWriteByte
.1730	68		pla				pla 								; write line number
.1731	20 46 18	jsr $1846			jsr 	EncodeWriteByte
.1734	98		tya				tya
.1735	20 46 18	jsr $1846			jsr 	EncodeWriteByte
.1738	20 70 18	jsr $1870			jsr 	EncodeMoveNextWord 			; advance to the next and loop
.173b	4c b2 16	jmp $16b2			jmp 	EncodeLoop
.173e					_EPNotDefined:
.173e	b2 08		lda ($08)			lda 	(srcPtr) 					; first character
.1740	c9 3c		cmp #$3c			cmp 	#"<"						; is it <line> which is call syntax
.1742	f0 29		beq $176d			beq 	_EPCallDirect
.1744	c9 21		cmp #$21			cmp 	#"!"						; check for variable operators
.1746	f0 42		beq $178a			beq 	_EPVariable
.1748	c9 40		cmp #$40			cmp 	#"@"
.174a	f0 3e		beq $178a			beq 	_EPVariable
.174c	c9 26		cmp #$26			cmp 	#"&"
.174e	f0 3a		beq $178a			beq 	_EPVariable
.1750	a9 a6		lda #$a6			lda 	#Literal2Byte & $FF 		; write out 2 byte literal
.1752	a0 10		ldy #$10			ldy 	#Literal2Byte >> 8
.1754	20 3c 18	jsr $183c			jsr 	EncodeWriteWord
.1757					_EPOutputConstant:
.1757	20 86 18	jsr $1886			jsr 	EncodeGetConstant 			; extract that constant from the source
.175a	90 06		bcc $1762			bcc 	_EPFail 					; if can't find one, that's us done.
.175c	20 3c 18	jsr $183c			jsr 	EncodeWriteWord 			; write out the encoded value.
.175f	4c b2 16	jmp $16b2			jmp 	EncodeLoop 					; and go round again.
.1762					_EPFail:
.1762	20 fe 10	jsr $10fe			jsr 	ErrorHandler
>1765	53 59 4e 54 41 58 3f 00				.text 	"SYNTAX?",0
.176d					_EPCallDirect:
.176d	a9 6e		lda #$6e			lda	 	#CallHandler & $FF 			; write code call handler
.176f	a0 1a		ldy #$1a			ldy	 	#CallHandler >> 8
.1771	20 3c 18	jsr $183c			jsr 	EncodeWriteWord
.1774	a9 01		lda #$01			lda 	#1
.1776	20 7c 18	jsr $187c			jsr 	EncodeAddSrcPtr 			; skip over the <
.1779	a0 ff		ldy #$ff			ldy 	#255 						; scan forward for last character.
.177b					_EPToLast:
.177b	c8		iny				iny
.177c	b1 08		lda ($08),y			lda 	(srcPtr),y
.177e	10 fb		bpl $177b			bpl	 	_EPToLast
.1780	c9 be		cmp #$be			cmp 	#">"+$80 					; must be >
.1782	d0 de		bne $1762			bne 	_EPFail
.1784	a9 20		lda #$20			lda 	#" " 						; strip back to a number, erases last char
.1786	91 08		sta ($08),y			sta 	(srcPtr),y
.1788	80 cd		bra $1757			bra 	_EPOutputConstant 			; borrow the number routines extract/compile constant
.178a					_EPVariable:
.178a	20 26 19	jsr $1926			jsr 	EncodeVariableReference
.178d	20 70 18	jsr $1870			jsr 	EncodeMoveNextWord 			; advance to the next and loop
.1790	4c b2 16	jmp $16b2			jmp 	EncodeLoop

;******  Return to file: kernel.asm


;******  Processing file: words/encode/comstr.src

.1793					EncodeCommentString:
.1793	b2 08		lda ($08)			lda 	(srcPtr) 					; get first character
.1795	64 10		stz $10				stz 	temp1 						; other terminator = EOL
.1797	aa		tax				tax 								; save in X
.1798	a9 ee		lda #$ee			lda 	#(SkipComment & $FF)		; get the routine to use
.179a	a0 1f		ldy #$1f			ldy 	#(SkipComment >> 8)
.179c	e0 27		cpx #$27			cpx 	#"'"
.179e	f0 06		beq $17a6			beq 	_ECSGotCmd
.17a0	86 10		stx $10				stx		temp1 						; other terminator = "
.17a2	a9 ce		lda #$ce			lda 	#(LiteralString & $FF)
.17a4	a0 10		ldy #$10			ldy 	#(LiteralString >> 8)
.17a6					_ECSGotCmd:
.17a6	20 3c 18	jsr $183c			jsr 	EncodeWriteWord 			; write word out.
.17a9	a9 01		lda #$01			lda 	#1 							; skip over ' or "
.17ab	20 7c 18	jsr $187c			jsr 	EncodeAddSrcPtr
.17ae	e0 27		cpx #$27			cpx 	#"'"						; if ' then skip spaces
.17b0	d0 03		bne $17b5			bne 	_ECNoSkipSpaces
.17b2	20 ab 18	jsr $18ab			jsr 	EncSkipSpaces
.17b5					_ECNoSkipSpaces:
.17b5	ae 10 09	ldx $0910			ldx 	encodeBuffer 				; keep offset to buffer in X.
.17b8	a9 01		lda #$01			lda 	#1
.17ba	20 46 18	jsr $1846			jsr 	EncodeWriteByte 			; write total length, so far 1.
.17bd	a0 00		ldy #$00			ldy 	#0 							; for reading the actual text
.17bf					_ECSCopyText:
.17bf	b1 08		lda ($08),y			lda 	(srcPtr),y 					; get next
.17c1	f0 18		beq $17db			beq 	_ECSEndOfLine 				; end of line ?
.17c3	c5 10		cmp $10				cmp 	temp1						; is it the other terminator
.17c5	f0 09		beq $17d0			beq 	_ECSEndOfString 			; if so must be closing quote.
.17c7	20 46 18	jsr $1846			jsr 	EncodeWriteByte 			; write the byte out
.17ca	fe 10 09	inc $0910,x			inc 	encodeBuffer,x				; increase length
.17cd	c8		iny				iny 								; next character
.17ce	80 ef		bra $17bf			bra 	_ECSCopyText
.17d0					_ECSEndOfString:
.17d0	c8		iny				iny 								; skip closing quote.
.17d1	a9 00		lda #$00			lda 	#0 							; write out ASCIIZ
.17d3	20 46 18	jsr $1846			jsr 	EncodeWriteByte
.17d6	fe 10 09	inc $0910,x			inc 	encodeBuffer,x 				; fix the length up.
.17d9	80 0e		bra $17e9			bra 	_ECSComplete 				; and just patching up srcPtr to do.
.17db					_ECSEndOfLine:
.17db	a5 10		lda $10				lda 	temp1 						; missing closing quote
.17dd	f0 0a		beq $17e9			beq 	_ECSComplete 				; if we were doing a string.
.17df	20 fe 10	jsr $10fe			jsr 	ErrorHandler
>17e2	51 55 4f 54 45 3f 00				.text 	"QUOTE?",0
.17e9					_ECSComplete:
.17e9	98		tya				tya									; skip over.
.17ea	20 7c 18	jsr $187c			jsr 	EncodeAddSrcPtr
.17ed	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/encode/encdef.src

.17ee					EncodeSearchUserDefined:
.17ee	38		sec				sec 								; temp1 = srcPtr-6 because the
.17ef	a5 08		lda $08				lda 	srcPtr				 		; name is 6 in (offset line# $$call len)
.17f1	e9 06		sbc #$06			sbc		#6
.17f3	85 10		sta $10				sta 	temp1
.17f5	a5 09		lda $09				lda 	srcPtr+1
.17f7	e9 00		sbc #$00			sbc 	#0
.17f9	85 11		sta $11				sta 	temp1+1
.17fb	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.17fd	85 12		sta $12				sta 	0+(temp2)
.17ff	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.1801	85 13		sta $13				sta 	1+(temp2)
.1803					_ESULoop:
.1803	b2 12		lda ($12)			lda 	(temp2) 					; reached the end (offset 0)
.1805	f0 33		beq $183a			beq 	_ESUFail
.1807	a0 03		ldy #$03			ldy 	#3 							; check it is $$define
.1809	b1 12		lda ($12),y			lda 	(temp2),y
.180b	c9 19		cmp #$19			cmp 	#DefineCode & $FF
.180d	d0 1e		bne $182d			bne 	_ESUNext
.180f	c8		iny				iny
.1810	b1 12		lda ($12),y			lda 	(temp2),y
.1812	c9 20		cmp #$20			cmp 	#DefineCode >> 8
.1814	d0 17		bne $182d			bne 	_ESUNext
.1816	c8		iny				iny 								; skip length byte.
.1817					_ESUCompare:
.1817	c8		iny				iny
.1818	b1 12		lda ($12),y			lda 	(temp2),y
.181a	d1 10		cmp ($10),y			cmp 	(temp1),y
.181c	d0 0f		bne $182d			bne 	_ESUNext
.181e	0a		asl a				asl 	a 							; bit 7 set => found it.
.181f	90 f6		bcc $1817			bcc 	_ESUCompare
.1821	a0 01		ldy #$01			ldy 	#1
.1823	b1 12		lda ($12),y			lda 	(temp2),y 					; read in the line number to YA
.1825	aa		tax				tax
.1826	c8		iny				iny
.1827	b1 12		lda ($12),y			lda 	(temp2),y
.1829	a8		tay				tay
.182a	8a		txa				txa
.182b	38		sec				sec 								; return with carry set as found
.182c	60		rts				rts
.182d					_ESUNext:
.182d	18		clc				clc
.182e	a5 12		lda $12				lda 	temp2
.1830	72 12		adc ($12)			adc 	(temp2)
.1832	85 12		sta $12				sta 	temp2
.1834	90 02		bcc $1838			bcc 	_NoCarryAdv
.1836	e6 13		inc $13				inc 	temp2+1
.1838					_NoCarryAdv:
.1838	80 c9		bra $1803			bra 	_ESULoop 					; and loop round
.183a					_ESUFail:
.183a	18		clc				clc
.183b	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/encode/encutils.src

.183c					EncodeWriteWord:
.183c	48		pha				pha
.183d	20 46 18	jsr $1846			jsr 	EncodeWriteByte
.1840	98		tya				tya
.1841	20 46 18	jsr $1846			jsr 	EncodeWriteByte
.1844	68		pla				pla
.1845	60		rts				rts
.1846					EncodeWriteByte:
.1846	da		phx				phx
.1847	ae 10 09	ldx $0910			ldx 	encodeBuffer
.184a	9d 10 09	sta $0910,x			sta 	encodeBuffer,x
.184d	9e 11 09	stz $0911,x			stz 	encodeBuffer+1,x
.1850	9e 12 09	stz $0912,x			stz 	encodeBuffer+2,x
.1853	ee 10 09	inc $0910			inc 	encodeBuffer
.1856	fa		plx				plx
.1857	60		rts				rts
.1858					CheckIsLetter:
.1858	c9 41		cmp #$41			cmp 	#"A"						; return CS if A..Z
.185a	90 06		bcc $1862			bcc 	_CILFail
.185c	c9 5b		cmp #$5b			cmp 	#"Z"+1
.185e	b0 02		bcs $1862			bcs 	_CILFail
.1860	38		sec				sec
.1861	60		rts				rts
.1862					_CILFail:
.1862	18		clc				clc
.1863	60		rts				rts
.1864					CheckIsDigit:
.1864	c9 30		cmp #$30			cmp 	#"0"						; return CS if 0..9
.1866	90 06		bcc $186e			bcc 	_CIDFail
.1868	c9 3a		cmp #$3a			cmp 	#"9"+1
.186a	b0 02		bcs $186e			bcs 	_CIDFail
.186c	38		sec				sec
.186d	60		rts				rts
.186e					_CIDFail:
.186e	18		clc				clc
.186f	60		rts				rts
.1870					EncodeMoveNextWord:
.1870	a0 ff		ldy #$ff			ldy 	#255 						; search forward
.1872					_EPNWLoop:
.1872	c8		iny				iny
.1873	b1 08		lda ($08),y			lda 	(srcPtr),y
.1875	c9 21		cmp #$21			cmp 	#" "+1						; looking for <= space
.1877	b0 f9		bcs $1872			bcs 	_EPNWLoop
.1879	98		tya				tya
.187a	80 00		bra $187c			bra 	EncodeAddSrcPtr
.187c					EncodeAddSrcPtr:
.187c	18		clc				clc 								; add offset
.187d	65 08		adc $08				adc 	srcPtr
.187f	85 08		sta $08				sta 	srcPtr
.1881	90 02		bcc $1885			bcc 	_EASPNoCarry
.1883	e6 09		inc $09				inc 	srcPtr+1					; carry through
.1885					_EASPNoCarry:
.1885	60		rts				rts
.1886					EncodeGetConstant:
.1886	a5 08		lda $08				lda 	srcPtr 						; get source
.1888	a4 09		ldy $09				ldy 	srcPtr+1
.188a	20 49 1f	jsr $1f49			jsr 	ConvertToInteger 			; call converter
.188d	90 08		bcc $1897			bcc 	_EGCExit
.188f	20 7c 18	jsr $187c			jsr 	EncodeAddSrcPtr 			; if passed add chars to src ptr
.1892	a5 14		lda $14				lda 	temp3 						; get result into YA
.1894	a4 15		ldy $15				ldy 	temp3+1
.1896	38		sec				sec 								; return CS
.1897					_EGCExit:
.1897	60		rts				rts
.1898					EncSetBit7Word:
.1898	08		php				php 								; save carry
.1899	a0 ff		ldy #$ff			ldy 	#255 						; scan forward for space/NULL
.189b					_ESB7Loop:
.189b	c8		iny				iny
.189c	b1 08		lda ($08),y			lda 	(srcPtr),y
.189e	c9 21		cmp #$21			cmp 	#" "+1 						; while > ' '
.18a0	b0 f9		bcs $189b			bcs 	_ESB7Loop
.18a2	88		dey				dey									; previous character
.18a3	b1 08		lda ($08),y			lda 	(srcPtr),y 					; read it
.18a5	0a		asl a				asl 	a 							; shift bit 7 out
.18a6	28		plp				plp 								; restore carry
.18a7	6a		ror a				ror 	a 							; shift it in
.18a8	91 08		sta ($08),y			sta 	(srcPtr),y 					; write back and exit
.18aa	60		rts				rts
.18ab					EncSkipSpaces:
.18ab	b2 08		lda ($08)			lda 	(srcPtr) 					; skip over spaces/ reached end
.18ad	c9 20		cmp #$20			cmp 	#32
.18af	d0 07		bne $18b8			bne 	_ESNotSpace
.18b1	a9 01		lda #$01			lda 	#1
.18b3	20 7c 18	jsr $187c			jsr 	EncodeAddSrcPtr
.18b6	80 f3		bra $18ab			bra	 	EncSkipSpaces
.18b8					_ESNotSpace:
.18b8	60		rts				rts
.18b9					EncodeTrimTrailingSpaces:
.18b9	a0 ff		ldy #$ff			ldy 	#255 						; find EOS
.18bb					_ETTFindEnd:
.18bb	c8		iny				iny
.18bc	b1 08		lda ($08),y			lda 	(srcPtr),y
.18be	d0 fb		bne $18bb			bne 	_ETTFindEnd
.18c0					_ETTRemoveSpace:
.18c0	c0 00		cpy #$00			cpy 	#0 							; start of string
.18c2	f0 0d		beq $18d1			beq 	_ETTExit
.18c4	88		dey				dey 								; previous character 1..32
.18c5	b1 08		lda ($08),y			lda 	(srcPtr),y
.18c7	c9 21		cmp #$21			cmp 	#32+1
.18c9	b0 06		bcs $18d1			bcs 	_ETTExit
.18cb	a9 00		lda #$00			lda 	#0 							; erase it and go round again
.18cd	91 08		sta ($08),y			sta 	(srcPtr),y
.18cf	80 ef		bra $18c0			bra 	_ETTRemoveSpace
.18d1					_ETTExit:
.18d1	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/encode/encsearch.src

.18d2					EncodeSearchDictionary:
.18d2	a9 39		lda #$39			lda 	#(Dictionary) & $FF
.18d4	85 10		sta $10				sta 	0+(temp1)
.18d6	a9 22		lda #$22			lda 	#(Dictionary) >> 8
.18d8	85 11		sta $11				sta 	1+(temp1)
.18da					_ESDLoop:
.18da	b2 10		lda ($10)			lda 	(temp1) 					; end of dictionary return with CC.
.18dc	18		clc				clc
.18dd	f0 46		beq $1925			beq 	_ESDExit
.18df	a0 01		ldy #$01			ldy 	#1 							; get control bits, get offset to name.
.18e1	b1 10		lda ($10),y			lda 	(temp1),y
.18e3	4a		lsr a				lsr 	a 							; encode/decode bits move to 0,1
.18e4	4a		lsr a				lsr 	a
.18e5	4a		lsr a				lsr 	a
.18e6	4a		lsr a				lsr 	a
.18e7	c8		iny				iny 								; Y = 2
.18e8	4a		lsr a				lsr 	a
.18e9	90 01		bcc $18ec			bcc 	_ESDNotDec
.18eb	c8		iny				iny
.18ec					_ESDNotDec:
.18ec	4a		lsr a				lsr 	a
.18ed	90 01		bcc $18f0			bcc 	_ESDNotInc
.18ef	c8		iny				iny
.18f0					_ESDNotInc:
.18f0	98		tya				tya
.18f1	0a		asl a				asl 	a 							; A is now 4,6,8 offset to name.
.18f2	a8		tay				tay
.18f3	b1 10		lda ($10),y			lda 	(temp1),y 					; quick check of first character
.18f5	d2 08		cmp ($08)			cmp 	(srcPtr)
.18f7	d0 1f		bne $1918			bne 	_ESDNext 					; do not match, go to next
.18f9	98		tya				tya 								; make temp2 point to the name in
.18fa	18		clc				clc 								; the dictionary.
.18fb	65 10		adc $10				adc 	temp1
.18fd	85 12		sta $12				sta 	temp2
.18ff	a5 11		lda $11				lda 	temp1+1
.1901	69 00		adc #$00			adc 	#0
.1903	85 13		sta $13				sta 	temp2+1
.1905	a0 ff		ldy #$ff			ldy 	#255 						; now start matching up.
.1907					_ESDCompare:
.1907	c8		iny				iny
.1908	b1 08		lda ($08),y			lda 	(srcPtr),y
.190a	d1 12		cmp ($12),y			cmp 	(temp2),y
.190c	d0 0a		bne $1918			bne 	_ESDNext
.190e	0a		asl a				asl 	a
.190f	90 f6		bcc $1907			bcc 	_ESDCompare
.1911	a5 10		lda $10				lda 	temp1 						; return address in YA and carry set.
.1913	a4 11		ldy $11				ldy 	temp1+1
.1915	38		sec				sec
.1916	80 0d		bra $1925			bra 	_ESDExit
.1918					_ESDNext:
.1918	18		clc				clc
.1919	a5 10		lda $10				lda 	temp1
.191b	72 10		adc ($10)			adc 	(temp1)
.191d	85 10		sta $10				sta 	temp1
.191f	90 b9		bcc $18da			bcc 	_ESDLoop
.1921	e6 11		inc $11				inc 	temp1+1
.1923	80 b5		bra $18da			bra 	_ESDLoop
.1925					_ESDExit:
.1925	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/encode/encvar.src

.1926					EncodeVariableReference:
.1926	b2 08		lda ($08)			lda 	(srcPtr)					; get the type, use it to identify the routine
.1928	a2 e6		ldx #$e6			ldx 	#VarAddressHandler & $FF
.192a	a0 20		ldy #$20			ldy 	#VarAddressHandler >> 8
.192c	c9 26		cmp #$26			cmp 	#"&"
.192e	f0 0c		beq $193c			beq 	_EVFHaveAddress
.1930	a2 00		ldx #$00			ldx 	#VarReadHandler & $FF
.1932	a0 21		ldy #$21			ldy 	#VarReadHandler >> 8
.1934	c9 40		cmp #$40			cmp 	#"@"
.1936	f0 04		beq $193c			beq 	_EVFHaveAddress
.1938	a2 1c		ldx #$1c			ldx 	#VarWriteHandler & $FF
.193a	a0 21		ldy #$21			ldy 	#VarWriteHandler >> 8
.193c					_EVFHaveAddress:
.193c	8a		txa				txa
.193d	20 3c 18	jsr $183c			jsr 	EncodeWriteWord 			; write it out.
.1940	a0 01		ldy #$01			ldy 	#1 							; get the first charactere
.1942	b1 08		lda ($08),y			lda 	(srcPtr),y
.1944	29 7f		and #$7f			and 	#$7F 						; might be the last.
.1946	20 58 18	jsr $1858			jsr 	CheckIsLetter 				; is it A-Z
.1949	90 1a		bcc $1965			bcc 	EVFFail
.194b	29 1f		and #$1f			and 	#31 						; make 1-26
.194d	85 10		sta $10				sta 	temp1 						; start building the name in temp1
.194f	64 11		stz $11				stz 	temp1+1
.1951	38		sec				sec 								; possible char 2
.1952	20 72 19	jsr $1972			jsr 	EncVarAlNum
.1955	18		clc				clc 								; possible char 3
.1956	20 72 19	jsr $1972			jsr 	EncVarAlNum
.1959	b1 08		lda ($08),y			lda 	(srcPtr),y 					; more text after ?
.195b	10 08		bpl $1965			bpl 	EVFFail
.195d	a5 10		lda $10				lda 	temp1 						; write out variable identifier.
.195f	a4 11		ldy $11				ldy 	temp1+1
.1961	20 3c 18	jsr $183c			jsr 	EncodeWriteWord
.1964	60		rts				rts
.1965					EVFFail:
.1965	20 fe 10	jsr $10fe			jsr 	ErrorHandler
>1968	56 41 52 49 41 42 4c 45				.text 	"VARIABLE?",0
>1970	3f 00
.1972					EncVarAlNum:
.1972	b1 08		lda ($08),y			lda 	(srcPtr),y 					; points to the  last char processed.
.1974	10 01		bpl $1977			bpl 	_EVAContinue
.1976	60		rts				rts
.1977					_EVAContinue:
.1977	08		php				php 								; CS x 32 ; CC x 32 x 40
.1978	c8		iny				iny 								; get the next character, strip bit 7
.1979	b1 08		lda ($08),y			lda 	(srcPtr),y
.197b	29 7f		and #$7f			and 	#$7F
.197d	20 58 18	jsr $1858			jsr 	CheckIsLetter 				; letter ?
.1980	b0 08		bcs $198a			bcs 	_EVACharOkay
.1982	20 64 18	jsr $1864			jsr 	CheckIsDigit				; fail if not digit.
.1985	90 de		bcc $1965			bcc 	EVFFail
.1987	18		clc				clc
.1988	69 2b		adc #$2b			adc 	#"Z"+1-"0"					; shift 0 so after Z
.198a					_EVACharOkay:
.198a	38		sec				sec 								; range 1-36
.198b	e9 40		sbc #$40			sbc 	#64
.198d	28		plp				plp 								; which multiplier ?
.198e	90 0f		bcc $199f			bcc 	_EVATimes32x40
.1990	85 12		sta $12				sta 	temp2 						; save in temp2 - A x 32
.1992	64 13		stz $13				stz 	temp2+1
.1994	a2 05		ldx #$05			ldx 	#5
.1996	06 12		asl $12		_EVA32:	asl 	temp2
.1998	26 13		rol $13				rol 	temp2+1
.199a	ca		dex				dex
.199b	d0 f9		bne $1996			bne 	_EVA32
.199d	80 0b		bra $19aa			bra 	_EVAAddVar
.199f					_EVATimes32x40:
.199f	85 13		sta $13				sta 	temp2+1						; 32 x 40 = 1280 or $500, so temp2 = A x 256 x 5
.19a1	64 12		stz $12				stz 	temp2
.19a3	0a		asl a				asl 	a
.19a4	0a		asl a				asl 	a
.19a5	18		clc				clc
.19a6	65 13		adc $13				adc 	temp2+1
.19a8	85 13		sta $13				sta 	temp2+1
.19aa					_EVAAddVar:
.19aa	18		clc				clc
.19ab	a5 10		lda $10				lda 	temp1
.19ad	65 12		adc $12				adc 	temp2
.19af	85 10		sta $10				sta 	temp1
.19b1	a5 11		lda $11				lda 	temp1+1
.19b3	65 13		adc $13				adc 	temp2+1
.19b5	85 11		sta $11				sta 	temp1+1
.19b7	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/structures/fornext.src

.19b8					ForHandler:
.19b8	e6 05		inc $05				inc 	rsp 						; bump the RSP
.19ba	a4 05		ldy $05				ldy 	rsp 						; get return stack and push TOS/$FF on it.
.19bc	c0 40		cpy #$40			cpy 	#$40 						; overflow
.19be	f0 18		beq $19d8			beq 	_FHOverflow
.19c0	a5 07		lda $07				lda 	TOS+1
.19c2	99 40 07	sta $0740,y			sta 	returnStackHigh,y
.19c5	a5 06		lda $06				lda 	TOS
.19c7	99 00 07	sta $0700,y			sta 	returnStackLow,y
.19ca	a9 ff		lda #$ff			lda 	#$FF
.19cc	99 80 07	sta $0780,y			sta 	returnStackX,y
.19cf	68		pla				pla
.19d0	85 07		sta $07				sta 	TOS+1
.19d2	68		pla				pla
.19d3	85 06		sta $06				sta 	TOS
.19d5	4c 00 00	jmp $0000			jmp 	NextCode
.19d8					_FHOverflow:
.19d8	20 fe 10	jsr $10fe			jsr 	ErrorHandler
>19db	46 4f 52 20 53 54 41 43				.text 	"FOR STACK?",0
>19e3	4b 3f 00
.19e6					NextHandler:
.19e6	da		phx				phx
.19e7	a6 05		ldx $05				ldx 	rsp 						; get current stack ptr
.19e9	bd 80 07	lda $0780,x			lda 	returnStackX,x 				; check it's a FOR Loop
.19ec	c9 ff		cmp #$ff			cmp 	#$FF
.19ee	d0 21		bne $1a11			bne 	NHNoFor
.19f0	bd 00 07	lda $0700,x			lda 	returnStackLow,x 			; decrement the count
.19f3	d0 03		bne $19f8			bne 	_NHNoBorrow
.19f5	de 40 07	dec $0740,x			dec 	returnStackHigh,x
.19f8					_NHNoBorrow:
.19f8	de 00 07	dec $0700,x			dec 	returnStackLow,x
.19fb	bd 00 07	lda $0700,x			lda 	returnStackLow,x 			; have we reached the end ?
.19fe	1d 40 07	ora $0740,x			ora 	returnStackHigh,x
.1a01	fa		plx				plx 								; restore X and re-test
.1a02	09 00		ora #$00			ora 	#0
.1a04	f0 05		beq $1a0b			beq 	_NHComplete 				; if so then complete, else loop.
.1a06	e8		inx				inx 								; advance to branch
.1a07	e8		inx				inx
.1a08	4c 64 1a	jmp $1a64			jmp 	BranchAlways
.1a0b					_NHComplete:
.1a0b	e8		inx				inx 								; skip over the branch quantity
.1a0c	c6 05		dec $05				dec 	rsp 						; drop the indx
.1a0e	4c 00 00	jmp $0000			jmp 	NextCode
.1a11					NHNoFor:
.1a11	20 fe 10	jsr $10fe			jsr 	ErrorHandler
>1a14	4e 4f 20 46 4f 52 3f 00				.text 	"NO FOR?",0
.1a1c					GetIndex:
.1a1c	a4 05		ldy $05				ldy 	rsp 						; get current stack ptr
.1a1e	b9 80 07	lda $0780,y			lda 	returnStackX,y 				; check it's a FOR Loop
.1a21	c9 ff		cmp #$ff			cmp 	#$FF
.1a23	d0 ec		bne $1a11			bne 	NHNoFor
.1a25	a5 06		lda $06				lda 	TOS
.1a27	48		pha				pha
.1a28	a5 07		lda $07				lda 	TOS+1
.1a2a	48		pha				pha
.1a2b	b9 00 07	lda $0700,y			lda 	returnStackLow,y 			; put counter-1 out
.1a2e	38		sec				sec
.1a2f	e9 01		sbc #$01			sbc 	#1
.1a31	85 06		sta $06				sta 	TOS
.1a33	b9 40 07	lda $0740,y			lda 	returnStackHigh,y
.1a36	e9 00		sbc #$00			sbc 	#0
.1a38	85 07		sta $07				sta 	TOS+1
.1a3a	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/structures/ifelseendif.src

.1a3d					IfHandler:
.1a3d	4c 4c 1a	jmp $1a4c			jmp 	BranchIfZero
.1a40					ElseHandler:
.1a40	4c 62 1a	jmp $1a62			jmp 	BranchTestSucceedsNoPop
.1a43					EndIfHandler:
.1a43	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/structures/repeatuntil.src

.1a46					RepeatHandler:
.1a46	4c 00 00	jmp $0000			jmp 	NextCode
.1a49					UntilHandler:
.1a49	4c 4c 1a	jmp $1a4c			jmp 	BranchIfZero

;******  Return to file: kernel.asm


;******  Processing file: words/system/branch.src

.1a4c					BranchIfZero:
.1a4c	a5 06		lda $06				lda 	TOS 						; check TOS = 0
.1a4e	05 07		ora $07				ora 	TOS+1
.1a50	f0 0a		beq $1a5c			beq 	BranchTestSucceeds
.1a52					BranchTestFails:
.1a52	68		pla				pla
.1a53	85 07		sta $07				sta 	TOS+1
.1a55	68		pla				pla
.1a56	85 06		sta $06				sta 	TOS
.1a58	e8		inx				inx 								; skip over the relative branch.
.1a59	4c 00 00	jmp $0000			jmp 	NextCode
.1a5c					BranchTestSucceeds:
.1a5c	68		pla				pla
.1a5d	85 07		sta $07				sta 	TOS+1
.1a5f	68		pla				pla
.1a60	85 06		sta $06				sta 	TOS
.1a62					BranchTestSucceedsNoPop:
.1a62	e8		inx				inx 								; advance by two, to the offset
.1a63	e8		inx				inx
.1a64					BranchAlways:
.1a64	8a		txa				txa 								; A = Y = position
.1a65	a8		tay				tay 								; (IP),Y now points to the branch target
.1a66	b1 03		lda ($03),y			lda 	(IP),y 						; adjust the position
.1a68	aa		tax				tax 								; position back in this line.
.1a69	ca		dex				dex
.1a6a	ca		dex				dex
.1a6b	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/system/callhandler.src

.1a6e					CallHandler:
.1a6e	e8		inx				inx									; bump X to the call address.
.1a6f	e8		inx				inx
.1a70	e6 05		inc $05				inc 	rsp 						; bump the RSP (first time to zero)
.1a72	a4 05		ldy $05				ldy 	rsp 						; get return stack and push IP/X on it.
.1a74	c0 40		cpy #$40			cpy 	#$40 						; overflow
.1a76	f0 4b		beq $1ac3			beq 	_CHOverflow
.1a78	a5 04		lda $04				lda 	IP+1
.1a7a	99 40 07	sta $0740,y			sta 	returnStackHigh,y
.1a7d	a5 03		lda $03				lda 	IP
.1a7f	99 00 07	sta $0700,y			sta 	returnStackLow,y
.1a82	8a		txa				txa
.1a83	99 80 07	sta $0780,y			sta 	returnStackX,y
.1a86	8a		txa				txa 								; get the line number into temp1.
.1a87	a8		tay				tay
.1a88	b1 03		lda ($03),y			lda 	(IP),y
.1a8a	85 10		sta $10				sta 	temp1
.1a8c	c8		iny				iny
.1a8d	b1 03		lda ($03),y			lda 	(IP),y
.1a8f	85 11		sta $11				sta 	temp1+1
.1a91	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.1a93	85 03		sta $03				sta 	0+(IP)
.1a95	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.1a97	85 04		sta $04				sta 	1+(IP)
.1a99	b2 03		lda ($03)			lda 	(IP)						; no program code ?
.1a9b	f0 17		beq $1ab4			beq 	_CHFail
.1a9d	a0 01		ldy #$01			ldy 	#1 							; Y = 1 throughout.
.1a9f					_CHSearch:
.1a9f	b1 03		lda ($03),y			lda 	(IP),y 						; check LSB of line number
.1aa1	c5 10		cmp $10				cmp 	temp1
.1aa3	f0 2d		beq $1ad2			beq 	_CHFoundLSB
.1aa5					_CHSearchNext:
.1aa5	18		clc				clc
.1aa6	a5 03		lda $03				lda 	IP
.1aa8	72 03		adc ($03)			adc 	(IP)
.1aaa	85 03		sta $03				sta 	IP
.1aac	90 02		bcc $1ab0			bcc 	_NoCarryAdv
.1aae	e6 04		inc $04				inc 	IP+1
.1ab0					_NoCarryAdv:
.1ab0	b2 03		lda ($03)			lda 	(IP)						; check reached the end.
.1ab2	d0 eb		bne $1a9f			bne 	_CHSearch
.1ab4					_CHFail:
.1ab4	20 fe 10	jsr $10fe			jsr 	ErrorHandler
>1ab7	44 45 46 49 4e 49 54 49				.text 	"DEFINITION?",0
>1abf	4f 4e 3f 00
.1ac3					_CHOverflow:
.1ac3	20 fe 10	jsr $10fe			jsr 	ErrorHandler
>1ac6	53 54 41 43 4b 44 45 50				.text 	"STACKDEPTH?",0
>1ace	54 48 3f 00
.1ad2					_CHFoundLSB:
.1ad2	c8		iny				iny 								; get MSB
.1ad3	b1 03		lda ($03),y			lda 	(IP),y
.1ad5	88		dey				dey
.1ad6	c5 11		cmp $11				cmp 	temp1+1 					; matches, if not contineu
.1ad8	d0 cb		bne $1aa5			bne 	_CHSearchNext
.1ada	a0 03		ldy #$03			ldy 	#3	 						; check it begins with $$define
.1adc	b1 03		lda ($03),y			lda 	(IP),y
.1ade	c9 19		cmp #$19			cmp 	#DefineCode & $FF
.1ae0	d0 d2		bne $1ab4			bne 	_CHFail
.1ae2	c8		iny				iny
.1ae3	b1 03		lda ($03),y			lda 	(IP),y
.1ae5	c9 20		cmp #$20			cmp 	#DefineCode >> 8
.1ae7	d0 cb		bne $1ab4			bne 	_CHFail
.1ae9	c8		iny				iny
.1aea	b1 03		lda ($03),y			lda 	(IP),y 						; this is the length of the define name
.1aec	18		clc				clc
.1aed	69 03		adc #$03			adc 	#5-2 						; $$define token, line number, offset - 2 for Next
.1aef	aa		tax				tax
.1af0	4c 00 00	jmp $0000			jmp 	NextCode
.1af3					ReturnHandler:
.1af3	a4 05		ldy $05				ldy 	rsp 						; get rsp
.1af5	30 15		bmi $1b0c			bmi 	_RHUnderflow 				; if -ve underflowed
.1af7	c6 05		dec $05				dec 	rsp 						; decrement rsp
.1af9	b9 40 07	lda $0740,y			lda 	returnStackHigh,y 			; restore IP/X
.1afc	85 04		sta $04				sta 	IP+1
.1afe	b9 00 07	lda $0700,y			lda 	returnStackLow,y
.1b01	85 03		sta $03				sta 	IP
.1b03	b9 80 07	lda $0780,y			lda 	returnStackX,y
.1b06	aa		tax				tax
.1b07	f0 0e		beq $1b17			beq 	_RHInLoop 					; this means you have done :something for ; next
.1b09	4c 00 00	jmp $0000			jmp 	NextCode
.1b0c					_RHUnderflow:
.1b0c	20 fe 10	jsr $10fe			jsr 	ErrorHandler
>1b0f	52 45 54 55 52 4e 3f 00				.text 	"RETURN?",0
.1b17					_RHInLoop:
.1b17	20 fe 10	jsr $10fe			jsr 	ErrorHandler
>1b1a	52 45 54 55 52 4e 20 49				.text 	"RETURN IN LOOP?",0
>1b22	4e 20 4c 4f 4f 50 3f 00
.1b2a					CallHandlerDecode:
.1b2a	a9 03		lda #$03			lda 	#CTH_Call					; space
.1b2c	20 f1 1c	jsr $1cf1			jsr 	DecodeWriteBuffer
.1b2f	b1 08		lda ($08),y			lda 	(srcPtr),y 					; get line number into YA
.1b31	aa		tax				tax
.1b32	c8		iny				iny
.1b33	b1 08		lda ($08),y			lda 	(srcPtr),y
.1b35	a8		tay				tay
.1b36	8a		txa				txa
.1b37	20 74 1b	jsr $1b74			jsr 	FindLine 					; try to locate that line.
.1b3a	b0 11		bcs $1b4d			bcs 	_CHDFound 					; if found .....
.1b3c					_CHDLineOnly:
.1b3c	48		pha				pha
.1b3d	a9 3c		lda #$3c			lda 	#"<"
.1b3f	20 f1 1c	jsr $1cf1			jsr 	DecodeWriteBuffer
.1b42	68		pla				pla
.1b43	18		clc				clc 								; output unsigned
.1b44	20 13 1d	jsr $1d13			jsr 	DecodeYAToBuffer
.1b47	a9 3e		lda #$3e			lda 	#">"
.1b49	20 f1 1c	jsr $1cf1			jsr 	DecodeWriteBuffer
.1b4c	60		rts				rts
.1b4d					_CHDFound:
.1b4d	48		pha				pha 								; save YA
.1b4e	5a		phy				phy
.1b4f	a0 03		ldy #$03			ldy 	#3 							; check first is $$define
.1b51	b1 10		lda ($10),y			lda 	(temp1),y
.1b53	c9 19		cmp #$19			cmp 	#DefineCode & 255
.1b55	d0 07		bne $1b5e			bne 	_CHDNoDefine
.1b57	c8		iny				iny
.1b58	b1 10		lda ($10),y			lda 	(temp1),y
.1b5a	c9 20		cmp #$20			cmp 	#DefineCode >> 8
.1b5c	f0 04		beq $1b62			beq 	_CHDFoundDefine
.1b5e					_CHDNoDefine:
.1b5e	7a		ply				ply									; restore the line number and print it in <>
.1b5f	68		pla				pla
.1b60	80 da		bra $1b3c			bra 	_CHDLineOnly
.1b62					_CHDFoundDefine:
.1b62	68		pla				pla 								; throw saved line number.
.1b63	68		pla				pla
.1b64	a0 05		ldy #$05			ldy 	#5 							; 3,4 $$define 5 length, name has bit 7 set at end
.1b66					_CHDOutName:
.1b66	c8		iny				iny 								; next
.1b67	b1 10		lda ($10),y			lda 	(temp1),y 					; print char no bit 7
.1b69	48		pha				pha
.1b6a	29 7f		and #$7f			and 	#$7F
.1b6c	20 f1 1c	jsr $1cf1			jsr 	DecodeWriteBuffer
.1b6f	68		pla				pla
.1b70	0a		asl a				asl 	a 							; bit 7 to carry
.1b71	90 f3		bcc $1b66			bcc 	_CHDOutName
.1b73	60		rts				rts
.1b74					FindLine:
.1b74	48		pha				pha 								; save registers
.1b75	da		phx				phx
.1b76	5a		phy				phy
.1b77	85 12		sta $12				sta 	temp2 						; temp2 = target line#
.1b79	84 13		sty $13				sty 	temp2+1
.1b7b	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.1b7d	85 10		sta $10				sta 	0+(temp1)
.1b7f	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.1b81	85 11		sta $11				sta 	1+(temp1)
.1b83					_FLLoop:
.1b83	b2 10		lda ($10)			lda 	(temp1) 					; found end ?
.1b85	18		clc				clc									; if so exit with CC.
.1b86	f0 1d		beq $1ba5			beq 	_FLExit
.1b88	a0 01		ldy #$01			ldy 	#1 							; check line # match
.1b8a	b1 10		lda ($10),y			lda 	(temp1),y
.1b8c	c5 12		cmp $12				cmp 	temp2
.1b8e	d0 08		bne $1b98			bne 	_FLNext
.1b90	c8		iny				iny
.1b91	b1 10		lda ($10),y			lda 	(temp1),y
.1b93	c5 13		cmp $13				cmp 	temp2+1
.1b95	38		sec				sec 								; if so exit with CS
.1b96	f0 0d		beq $1ba5			beq 	_FLExit
.1b98					_FLNext:
.1b98	18		clc				clc
.1b99	a5 10		lda $10				lda 	temp1
.1b9b	72 10		adc ($10)			adc 	(temp1)
.1b9d	85 10		sta $10				sta 	temp1
.1b9f	90 02		bcc $1ba3			bcc 	_NoCarryAdv
.1ba1	e6 11		inc $11				inc 	temp1+1
.1ba3					_NoCarryAdv:
.1ba3	80 de		bra $1b83			bra 	_FLLoop 					; keep looking.
.1ba5					_FLExit:
.1ba5	7a		ply				ply
.1ba6	fa		plx				plx
.1ba7	68		pla				pla
.1ba8	60		rts				rts
.1ba9	18		clc				clc
.1baa	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/clrnew.src

.1bab					NewHandler:
.1bab	9c 00 40	stz $4000			stz 	ProgramMemory 				; Make the first offset zero.
.1bae	20 c1 1b	jsr $1bc1			jsr 	ClearVariableSpace 			; clear variables, reset pointers
.1bb1	4c 00 00	jmp $0000			jmp 	NextCode
.1bb4					ClrHandler:
.1bb4	86 10		stx $10				stx 	temp1
.1bb6	a2 80		ldx #$80			ldx 	#NumberStackBase
.1bb8	9a		txs				txs
.1bb9	a6 10		ldx $10				ldx 	temp1
.1bbb	20 c1 1b	jsr $1bc1			jsr 	ClearVariableSpace 			; clear variables, reset pointers
.1bbe	4c 00 00	jmp $0000			jmp 	NextCode
.1bc1					ClearVariableSpace:
.1bc1	a9 ff		lda #$ff			lda 	#$FF
.1bc3	85 05		sta $05				sta 	rsp
.1bc5	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.1bc7	85 0e		sta $0e				sta 	0+(nextFreeMem)
.1bc9	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.1bcb	85 0f		sta $0f				sta 	1+(nextFreeMem)
.1bcd	a0 1f		ldy #$1f			ldy 	#hashTableSize*2-1 			; erase the hash table (used for variables)
.1bcf					_CVSHashClear:
.1bcf	a9 00		lda #$00			lda 	#0 							; all the first record pointers are $00
.1bd1	99 40 06	sta $0640,y			sta 	hashTable,y
.1bd4	88		dey				dey
.1bd5	10 f8		bpl $1bcf			bpl 	_CVSHashClear
.1bd7					_CVSFindEnd:
.1bd7	18		clc				clc
.1bd8	a5 0e		lda $0e				lda 	nextFreeMem
.1bda	72 0e		adc ($0e)			adc 	(nextFreeMem)
.1bdc	85 0e		sta $0e				sta 	nextFreeMem
.1bde	90 02		bcc $1be2			bcc 	_NoCarryAdv
.1be0	e6 0f		inc $0f				inc 	nextFreeMem+1
.1be2					_NoCarryAdv:
.1be2	b2 0e		lda ($0e)			lda 	(nextFreeMem)
.1be4	d0 f1		bne $1bd7			bne 	_CVSFindEnd
.1be6	a9 08		lda #$08			lda 	#8 							; this puts a gap in, more for clarity than anything.
.1be8	a0 00		ldy #$00			ldy 	#0
.1bea	20 ee 1b	jsr $1bee			jsr 	AdvanceFreeMem				; we need +1 because the previous code leaves the
.1bed	60		rts				rts 								; free mem pointer pointing to the last zero offset
.1bee					AdvanceFreeMem:
.1bee	18		clc				clc
.1bef	65 0e		adc $0e				adc 	nextFreeMem
.1bf1	85 0e		sta $0e				sta 	nextFreeMem
.1bf3	98		tya				tya
.1bf4	65 0f		adc $0f				adc 	nextFreeMem+1
.1bf6	85 0f		sta $0f				sta 	nextFreeMem+1
.1bf8	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/debug.src

.1bf9					ExitDump:
.1bf9	ba		tsx				tsx 								; save Data Stack in temp1
.1bfa	86 10		stx $10				stx 	temp1
.1bfc	4c ff ff	jmp $ffff			jmp 	$FFFF 						; makes the X16-Emulator dump-exit.
.1bff					BreakCmd:
>1bff	ff						.byte 	$FF
.1c00	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/system/decode.src

.1c03					DecodeLineIntoBufPtr:
.1c03	48		pha				pha
.1c04	da		phx				phx
.1c05	5a		phy				phy
.1c06	85 08		sta $08				sta 	srcPtr 						; save the source line.
.1c08	84 09		sty $09				sty 	srcPtr+1
.1c0a	90 1b		bcc $1c27			bcc 	_DecodeNoLineNumber
.1c0c	a0 01		ldy #$01			ldy 	#1 							; get line # to YA
.1c0e	b1 08		lda ($08),y			lda 	(srcPtr),y
.1c10	aa		tax				tax
.1c11	c8		iny				iny
.1c12	b1 08		lda ($08),y			lda 	(srcPtr),y
.1c14	a8		tay				tay
.1c15	8a		txa				txa
.1c16	18		clc				clc
.1c17	20 13 1d	jsr $1d13			jsr 	DecodeYAToBuffer 			; convert to string in buffer
.1c1a	aa		tax				tax 								; count in X
.1c1b					_DecodeLineSpace:
.1c1b	e0 05		cpx #$05			cpx 	#5
.1c1d	f0 08		beq $1c27			beq 	_DecodeNoLineNumber
.1c1f	a9 20		lda #$20			lda 	#" " 						; pad to 5 spaces
.1c21	20 f1 1c	jsr $1cf1			jsr 	DecodeWriteBuffer
.1c24	e8		inx				inx
.1c25	80 f4		bra $1c1b			bra 	_DecodeLineSpace
.1c27					_DecodeNoLineNumber:
.1c27	a0 03		ldy #$03			ldy 	#3 							; initial position.
.1c29					_DecodeLoop:
.1c29	b1 08		lda ($08),y			lda 	(srcPtr),y 					; copy the current character to temp1
.1c2b	85 10		sta $10				sta 	temp1 						; must be an execution address.
.1c2d	c8		iny				iny
.1c2e	b1 08		lda ($08),y			lda 	(srcPtr),y
.1c30	85 11		sta $11				sta 	temp1+1
.1c32	c8		iny				iny 								; y points to the byte after it.
.1c33	a5 10		lda $10				lda 	temp1
.1c35	c9 d7		cmp #$d7			cmp 	#NextLine & $FF
.1c37	d0 06		bne $1c3f			bne 	_DecodeNotEOL
.1c39	a5 11		lda $11				lda 	temp1+1
.1c3b	c9 1f		cmp #$1f			cmp 	#NextLine >> 8
.1c3d	f0 0b		beq $1c4a			beq 	_DecodeEOL
.1c3f					_DecodeNotEOL:
.1c3f	20 52 1c	jsr $1c52			jsr 	IdentifyCodeWord
.1c42	20 9c 1c	jsr $1c9c			jsr 	DecodeFoundWord
.1c45	20 86 1c	jsr $1c86			jsr 	AdvanceToNext 				; advance to next entry in the line.
.1c48	80 df		bra $1c29			bra 	_DecodeLoop 				; and go round again
.1c4a					_DecodeEOL:
.1c4a	a9 00		lda #$00			lda 	#0
.1c4c	92 0a		sta ($0a)			sta 	(bufPtr)
.1c4e	7a		ply				ply 								; restore registers and exit
.1c4f	fa		plx				plx
.1c50	68		pla				pla
.1c51	60		rts				rts
.1c52					IdentifyCodeWord:
.1c52	5a		phy				phy 								; save current position on the stack.
.1c53	a9 39		lda #$39			lda 	#(Dictionary) & $FF
.1c55	85 0c		sta $0c				sta 	0+(matchPtr)
.1c57	a9 22		lda #$22			lda 	#(Dictionary) >> 8
.1c59	85 0d		sta $0d				sta 	1+(matchPtr)
.1c5b					_DecodeIdentify:
.1c5b	a0 02		ldy #$02			ldy 	#2 							; have we found a match ?
.1c5d	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.1c5f	c5 10		cmp $10				cmp 	temp1
.1c61	d0 07		bne $1c6a			bne 	_DecodeIdNext
.1c63	c8		iny				iny
.1c64	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.1c66	c5 11		cmp $11				cmp 	temp1+1
.1c68	f0 1a		beq $1c84			beq 	_DecodeIdFound
.1c6a					_DecodeIdNext:
.1c6a	18		clc				clc
.1c6b	b2 0c		lda ($0c)			lda 	(matchPtr)
.1c6d	f0 0a		beq $1c79			beq 	_DecodeIdIssue
.1c6f	65 0c		adc $0c				adc 	matchPtr
.1c71	85 0c		sta $0c				sta 	matchPtr
.1c73	90 e6		bcc $1c5b			bcc 	_DecodeIdentify
.1c75	e6 0d		inc $0d				inc 	matchPtr+1
.1c77	80 e2		bra $1c5b			bra 	_DecodeIdentify
.1c79					_DecodeIdIssue:
.1c79	20 fe 10	jsr $10fe			jsr 	ErrorHandler
>1c7c	44 45 43 4f 44 45 3f 00				.text 	"DECODE?",0
.1c84					_DecodeIdFound:
.1c84	7a		ply				ply 								; restore position.
.1c85	60		rts				rts
.1c86					AdvanceToNext:
.1c86	5a		phy				phy 								; get the parameter count from bits 0-1 of the type byte
.1c87	a0 01		ldy #$01			ldy 	#1
.1c89	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.1c8b	29 03		and #$03			and 	#3 							; bits 0-1.
.1c8d	7a		ply				ply
.1c8e	c9 03		cmp #$03			cmp 	#3 							; is it n-bytes e.g. specified by the next byte
.1c90	d0 02		bne $1c94			bne 	_ATN012
.1c92	b1 08		lda ($08),y			lda 	(srcPtr),y 					; if so, use that byte as the overall length.
.1c94					_ATN012:
.1c94	85 12		sta $12				sta 	temp2 						; now add that to Y
.1c96	98		tya				tya
.1c97	18		clc				clc
.1c98	65 12		adc $12				adc 	temp2
.1c9a	a8		tay				tay
.1c9b	60		rts				rts
.1c9c					DecodeFoundWord:
.1c9c	5a		phy				phy 								; save current position
.1c9d	84 12		sty $12				sty		temp2 						; put it in temp2 as well.
.1c9f	a0 01		ldy #$01			ldy 	#1 							; get the type byte
.1ca1	b1 0c		lda ($0c),y			lda 	(matchPtr),y 				; is there a special decoder check (bit 4 set) ?
.1ca3	29 10		and #$10			and 	#$10
.1ca5	d0 0e		bne $1cb5			bne 	_DFWSpecialDecoder
.1ca7	b1 0c		lda ($0c),y			lda 	(matchPtr),y 				; reget it.
.1ca9	30 08		bmi $1cb3			bmi 	_DFWExit 					; if hidden word (bit 7 set)
.1cab	a9 06		lda #$06			lda 	#CTH_Keyword				; output a space to the buffer
.1cad	20 f1 1c	jsr $1cf1			jsr 	DecodeWriteBuffer
.1cb0	20 ce 1c	jsr $1cce			jsr 	DecodeCurrentWord 			; expand that.
.1cb3					_DFWExit:
.1cb3	7a		ply				ply 								; restore current position
.1cb4	60		rts				rts
.1cb5					_DFWSpecialDecoder:
.1cb5	a0 04		ldy #$04			ldy 	#4 							; the decode word address is at offset 4,5
.1cb7	b1 0c		lda ($0c),y			lda 	(matchPtr),y 				; copy this into temp2
.1cb9	85 12		sta $12				sta 	temp2
.1cbb	c8		iny				iny
.1cbc	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.1cbe	85 13		sta $13				sta 	temp2+1
.1cc0	7a		ply				ply 	 							; restore current position into Y
.1cc1	48		pha				pha 								; save registers
.1cc2	da		phx				phx
.1cc3	5a		phy				phy
.1cc4	20 cb 1c	jsr $1ccb			jsr 	_DFWCallDecoder				; call the decoder routine
.1cc7	7a		ply				ply 								; restore registers and exit
.1cc8	fa		plx				plx
.1cc9	68		pla				pla
.1cca	60		rts				rts
.1ccb					_DFWCallDecoder:
.1ccb	6c 12 00	jmp ($0012)			jmp 	(temp2)
.1cce					DecodeCurrentWord:
.1cce	5a		phy				phy
.1ccf	a0 01		ldy #$01			ldy 	#1 							; read type byte
.1cd1	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.1cd3	a0 04		ldy #$04			ldy 	#4 							; original offset
.1cd5	4a		lsr a				lsr 	a 							; encoder/decoder bits in 0-1
.1cd6	4a		lsr a				lsr 	a 							; add 2 to Y for each encoder/decoder
.1cd7	4a		lsr a				lsr 	a 							; bit set.
.1cd8	4a		lsr a				lsr 	a
.1cd9	4a		lsr a				lsr 	a 							; decoder bit
.1cda	90 02		bcc $1cde			bcc 	_DWBNoDec
.1cdc	c8		iny				iny
.1cdd	c8		iny				iny
.1cde					_DWBNoDec:
.1cde	4a		lsr a				lsr 	a
.1cdf	90 02		bcc $1ce3			bcc 	_DWBNoEnc
.1ce1	c8		iny				iny
.1ce2	c8		iny				iny
.1ce3					_DWBNoEnc:
.1ce3					_DWBWordOut:
.1ce3	b1 0c		lda ($0c),y			lda 	(matchPtr),y 				; output until bit 7 set.
.1ce5	48		pha				pha
.1ce6	29 7f		and #$7f			and 	#$7F
.1ce8	20 f1 1c	jsr $1cf1			jsr		DecodeWriteBuffer
.1ceb	c8		iny				iny
.1cec	68		pla				pla
.1ced	10 f4		bpl $1ce3			bpl 	_DWBWordOut
.1cef	7a		ply				ply 								; restore Y and exit
.1cf0	60		rts				rts
.1cf1					DecodeWriteBuffer:
.1cf1	92 0a		sta ($0a)			sta 	(bufPtr)
.1cf3	e6 0a		inc $0a				inc 	bufPtr
.1cf5	d0 02		bne $1cf9			bne 	_DWBNoCarry
.1cf7	e6 0b		inc $0b				inc 	bufPtr+1
.1cf9					_DWBNoCarry:
.1cf9	60		rts				rts
.1cfa					DecodeOutputData:
.1cfa	48		pha				pha
.1cfb	da		phx				phx
.1cfc	5a		phy				phy
.1cfd	b1 08		lda ($08),y			lda 	(srcPtr),y 					; length + 1
.1cff	aa		tax				tax
.1d00					_DODLoop:
.1d00	ca		dex				dex 								; done it all ?
.1d01	f0 0c		beq $1d0f			beq		_DODExit
.1d03	c8		iny				iny 								; output next character
.1d04	b1 08		lda ($08),y			lda 	(srcPtr),y
.1d06	29 7f		and #$7f			and 	#$7F
.1d08	f0 f6		beq $1d00			beq 	_DODLoop 					; don't print NULL
.1d0a	20 f1 1c	jsr $1cf1			jsr 	DecodeWriteBuffer
.1d0d	80 f1		bra $1d00			bra 	_DODLoop
.1d0f					_DODExit:
.1d0f	7a		ply				ply
.1d10	fa		plx				plx
.1d11	68		pla				pla
.1d12	60		rts				rts
.1d13					DecodeYAToBuffer:
.1d13	da		phx				phx
.1d14	5a		phy				phy
.1d15	48		pha				pha
.1d16	a5 0a		lda $0a				lda 	bufPtr 						; copy bufPtr to temp2
.1d18	85 12		sta $12				sta 	temp2
.1d1a	a5 0b		lda $0b				lda 	bufPtr+1
.1d1c	85 13		sta $13				sta 	temp2+1
.1d1e	68		pla				pla
.1d1f	20 7b 20	jsr $207b			jsr 	ConvertToStringMain 		; convert YA to string there
.1d22	aa		tax				tax 								; chars output to X
.1d23	18		clc				clc
.1d24	65 0a		adc $0a				adc 	bufPtr 						; add to buffer pointer
.1d26	85 0a		sta $0a				sta 	bufPtr
.1d28	90 02		bcc $1d2c			bcc 	_DYABNoCarry
.1d2a	e6 0b		inc $0b				inc 	bufPtr+1
.1d2c					_DYABNoCarry:
.1d2c	8a		txa				txa 								; count in A
.1d2d	7a		ply				ply									; restore and exit.
.1d2e	fa		plx				plx
.1d2f	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/edit.src

.1d30					EditProgram:
.1d30	20 ad 1d	jsr $1dad			jsr 	EDFindLine					; find line address -> temp1
.1d33	90 0f		bcc $1d44			bcc 	_EPNotFound 				; if missing don't delete it.
.1d35	a5 10		lda $10				lda 	temp1 						; save line address
.1d37	48		pha				pha
.1d38	a5 11		lda $11				lda 	temp1+1
.1d3a	48		pha				pha
.1d3b	20 52 1d	jsr $1d52			jsr 	EDDeleteLine 				; delete the line
.1d3e	68		pla				pla 								; restore line address
.1d3f	85 11		sta $11				sta 	temp1+1
.1d41	68		pla				pla
.1d42	85 10		sta $10				sta 	temp1
.1d44					_EPNotFound:
.1d44	ad 10 09	lda $0910			lda 	encodeBuffer 				; is there anything in the line.
.1d47	c9 05		cmp #$05			cmp 	#5 							; <offset> <line#> <next line>
.1d49	f0 03		beq $1d4e			beq 	_EPNoInsert
.1d4b	20 75 1d	jsr $1d75			jsr 	EDInsertLine 				; insert line back in.
.1d4e					_EPNoInsert:
.1d4e	20 c1 1b	jsr $1bc1			jsr 	ClearVariableSpace
.1d51	60		rts				rts
.1d52					EDDeleteLine:
.1d52	20 c1 1b	jsr $1bc1			jsr 	ClearVariableSpace
.1d55	a0 00		ldy #$00			ldy 	#0 							; this is the offset to copy down.
.1d57	a2 00		ldx #$00			ldx 	#0
.1d59	b1 10		lda ($10),y			lda 	(temp1),y
.1d5b	a8		tay				tay 								; put in Y
.1d5c					_EDDelLoop:
.1d5c	b1 10		lda ($10),y			lda 	(temp1),y 					; get it
.1d5e	81 10		sta ($10,x)			sta 	(temp1,x) 					; write it.
.1d60	a5 10		lda $10				lda 	temp1 						; check if pointer has reached the end of
.1d62	c5 0e		cmp $0e				cmp		nextFreeMem 				; low memory. We will have copied down an
.1d64	d0 06		bne $1d6c			bne 	_EDDelNext 					; extra pile of stuff - technically should
.1d66	a5 11		lda $11				lda 	temp1+1 					; check the upper value (e.g. temp1+y)
.1d68	c5 0f		cmp $0f				cmp 	nextFreeMem+1				; doesn't really matter.
.1d6a	f0 08		beq $1d74			beq		_EDDelExit
.1d6c					_EDDelNext:
.1d6c	e6 10		inc $10				inc 	temp1 						; go to next byte.
.1d6e	d0 ec		bne $1d5c			bne 	_EDDelLoop
.1d70	e6 11		inc $11				inc 	temp1+1
.1d72	80 e8		bra $1d5c			bra 	_EDDelLoop
.1d74					_EDDelExit:
.1d74	60		rts				rts
.1d75					EDInsertLine:
.1d75	20 c1 1b	jsr $1bc1			jsr 	ClearVariableSpace
.1d78	a5 0e		lda $0e				lda 	nextFreeMem 				; copy high memory to temp3
.1d7a	85 14		sta $14				sta 	temp3
.1d7c	a5 0f		lda $0f				lda 	nextFreeMem+1
.1d7e	85 15		sta $15				sta 	temp3+1
.1d80	ac 10 09	ldy $0910			ldy 	encodeBuffer 				; space to move it to in Y
.1d83	a2 00		ldx #$00			ldx 	#0
.1d85					_EDInsLoop:
.1d85	a1 14		lda ($14,x)			lda 	(temp3,x)					; copy it up
.1d87	91 14		sta ($14),y			sta 	(temp3),y
.1d89	a5 14		lda $14				lda 	temp3 						; reached the insert point (temp1)
.1d8b	c5 10		cmp $10				cmp 	temp1
.1d8d	d0 06		bne $1d95			bne 	_EDINextShift
.1d8f	a5 15		lda $15				lda 	temp3+1
.1d91	c5 11		cmp $11				cmp 	temp1+1
.1d93	f0 0a		beq $1d9f			beq 	_EDIShiftOver
.1d95					_EDINextShift:
.1d95	a5 14		lda $14				lda 	temp3 						; decrement the copy pointer.
.1d97	d0 02		bne $1d9b			bne 	_EDINoBorrow
.1d99	c6 15		dec $15				dec 	temp3+1
.1d9b					_EDINoBorrow:
.1d9b	c6 14		dec $14				dec 	temp3
.1d9d	80 e6		bra $1d85			bra 	_EDInsLoop
.1d9f					_EDIShiftOver:
.1d9f	a0 00		ldy #$00			ldy 	#0
.1da1					_EDICopyCode:
.1da1	b9 10 09	lda $0910,y			lda 	encodeBuffer,y				; read from the current line
.1da4	91 10		sta ($10),y			sta 	(temp1),y 					; write out
.1da6	c8		iny				iny 								; bump pointers
.1da7	cc 10 09	cpy $0910			cpy 	encodeBuffer 				; done the whole lot ?
.1daa	d0 f5		bne $1da1			bne 	_EDICopyCode
.1dac	60		rts				rts
.1dad					EDFindLine:
.1dad	a9 00		lda #$00			lda 	#(programMemory) & $FF
.1daf	85 10		sta $10				sta 	0+(temp1)
.1db1	a9 40		lda #$40			lda 	#(programMemory) >> 8
.1db3	85 11		sta $11				sta 	1+(temp1)
.1db5					_EDFLLoop:
.1db5	b2 10		lda ($10)			lda 	(temp1) 					; check offset
.1db7	f0 24		beq $1ddd			beq 	_EDFLFail 					; then obviously that's the end ;-) (great comment !)
.1db9	a0 01		ldy #$01			ldy 	#1							; look at line #
.1dbb	38		sec				sec
.1dbc	ad 11 09	lda $0911			lda 	encodeBuffer+1				; subtract the current from the target
.1dbf	f1 10		sbc ($10),y			sbc 	(temp1),y 					; so if searching for 100 and this one is 90,
.1dc1	aa		tax				tax	 								; this will return 10.
.1dc2	ad 12 09	lda $0912			lda 	encodeBuffer+2
.1dc5	c8		iny				iny
.1dc6	f1 10		sbc ($10),y			sbc 	(temp1),y
.1dc8	90 13		bcc $1ddd			bcc 	_EDFLFail					; if target < current then failed.
.1dca	d0 04		bne $1dd0			bne 	_EDFLNext 					; if non-zero then goto next
.1dcc	e0 00		cpx #$00			cpx 	#0 							; same for the LSB - zero if match found.
.1dce	f0 0f		beq $1ddf			beq 	_EDFLFound
.1dd0					_EDFLNext:
.1dd0	18		clc				clc
.1dd1	a5 10		lda $10				lda 	temp1
.1dd3	72 10		adc ($10)			adc 	(temp1)
.1dd5	85 10		sta $10				sta 	temp1
.1dd7	90 02		bcc $1ddb			bcc 	_NoCarryAdv
.1dd9	e6 11		inc $11				inc 	temp1+1
.1ddb					_NoCarryAdv:
.1ddb	80 d8		bra $1db5			bra 	_EDFLLoop
.1ddd					_EDFLFail:
.1ddd	18		clc				clc
.1dde	60		rts				rts
.1ddf					_EDFLFound:
.1ddf	38		sec				sec
.1de0	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/list.src

.1de1					ListCode:
.1de1	64 1e		stz $1e				stz 	ListLowest 					; zero lowest line#
.1de3	64 1f		stz $1f				stz 	ListLowest+1
.1de5	a9 18		lda #$18			lda 	#24 						; show max 24 after lowest line
.1de7	85 1d		sta $1d				sta 	ListCount
.1de9	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.1deb	85 18		sta $18				sta 	0+(listPtr)
.1ded	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.1def	85 19		sta $19				sta 	1+(listPtr)
.1df1	86 10		stx $10				stx 	temp1						; S->A
.1df3	ba		tsx				tsx
.1df4	8a		txa				txa
.1df5	a6 10		ldx $10				ldx 	temp1
.1df7	c9 80		cmp #$80			cmp 	#NumberStackBase
.1df9	f0 0e		beq $1e09			beq 	_LCLoop
.1dfb	a5 06		lda $06				lda 	TOS 						; copy TOS to lowest
.1dfd	85 1e		sta $1e				sta 	ListLowest
.1dff	a5 07		lda $07				lda 	TOS+1
.1e01	85 1f		sta $1f				sta 	ListLowest+1
.1e03	68		pla				pla
.1e04	85 07		sta $07				sta 	TOS+1
.1e06	68		pla				pla
.1e07	85 06		sta $06				sta 	TOS
.1e09					_LCLoop:
.1e09	b2 18		lda ($18)			lda 	(listPtr)					; reached end ?
.1e0b	f0 4e		beq $1e5b			beq 	_LCExit
.1e0d	a0 01		ldy #$01			ldy 	#1							; >= list lowest
.1e0f	b1 18		lda ($18),y			lda 	(listPtr),y
.1e11	c5 1e		cmp $1e				cmp 	ListLowest
.1e13	c8		iny				iny
.1e14	b1 18		lda ($18),y			lda 	(listPtr),y
.1e16	e5 1f		sbc $1f				sbc 	ListLowest+1
.1e18	90 34		bcc $1e4e			bcc 	_LCNext
.1e1a	a9 10		lda #$10			lda 	#(textBuffer) & $FF
.1e1c	85 0a		sta $0a				sta 	0+(bufPtr)
.1e1e	a9 08		lda #$08			lda 	#(textBuffer) >> 8
.1e20	85 0b		sta $0b				sta 	1+(bufPtr)
.1e22	a5 18		lda $18				lda 	listPtr 					; output the line.
.1e24	a4 19		ldy $19				ldy 	listPtr+1
.1e26	38		sec				sec
.1e27	20 03 1c	jsr $1c03			jsr 	DecodeLineIntoBufPtr
.1e2a	a9 02		lda #$02			lda 	#CTH_LineNo
.1e2c	20 68 11	jsr $1168			jsr 	ExternColour
.1e2f	a0 ff		ldy #$ff			ldy 	#255
.1e31					_LCLoop2:
.1e31	c8		iny				iny
.1e32	b9 10 08	lda $0810,y			lda 	textBuffer,y
.1e35	f0 0e		beq $1e45			beq 	_LCEnd
.1e37	c9 20		cmp #$20			cmp 	#32
.1e39	b0 05		bcs $1e40			bcs 	_LCPrint
.1e3b	20 68 11	jsr $1168			jsr 	ExternColour
.1e3e	a9 20		lda #$20			lda 	#32
.1e40					_LCPrint:
.1e40	20 5e 11	jsr $115e			jsr 	ExternPrint
.1e43	80 ec		bra $1e31			bra 	_LCLoop2
.1e45	a9 0d		lda #$0d	_LCEnd:	lda 	#13 						; new line
.1e47	20 5e 11	jsr $115e			jsr 	ExternPrint
.1e4a	c6 1d		dec $1d				dec 	ListCount					; done all the lines allowed
.1e4c	f0 0d		beq $1e5b			beq 	_LCExit
.1e4e					_LCNext:
.1e4e	18		clc				clc
.1e4f	a5 18		lda $18				lda 	listPtr
.1e51	72 18		adc ($18)			adc 	(listPtr)
.1e53	85 18		sta $18				sta 	listPtr
.1e55	90 02		bcc $1e59			bcc 	_NoCarryAdv
.1e57	e6 19		inc $19				inc 	listPtr+1
.1e59					_NoCarryAdv:
.1e59	80 ae		bra $1e09			bra 	_LCLoop 					; go round again.
.1e5b					_LCExit:
.1e5b	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/system/miscellany.src

.1e5e					RunProgram:
.1e5e	86 10		stx $10				stx 	temp1
.1e60	a2 80		ldx #$80			ldx 	#NumberStackBase
.1e62	9a		txs				txs
.1e63	a6 10		ldx $10				ldx 	temp1
.1e65	20 c1 1b	jsr $1bc1			jsr 	ClearVariableSpace 			; clear variables etc.
.1e68	a2 00		ldx #$00			ldx		#ProgramMemory & $FF		; boot address
.1e6a	a0 40		ldy #$40			ldy 	#ProgramMemory >>8
.1e6c	20 95 10	jsr $1095			jsr 	InitialiseCoreCode 			; initialise the NEXT routine at $00
.1e6f	4c 00 00	jmp $0000			jmp 	NextCode
.1e72					Call6502:
.1e72	a5 06		lda $06				lda 	TOS 						; copy call address
.1e74	85 10		sta $10				sta 	temp1
.1e76	a5 07		lda $07				lda 	TOS+1
.1e78	85 11		sta $11				sta 	temp1+1
.1e7a	68		pla				pla
.1e7b	85 07		sta $07				sta 	TOS+1
.1e7d	68		pla				pla
.1e7e	85 06		sta $06				sta 	TOS
.1e80	20 86 1e	jsr $1e86			jsr 	_CallTemp1 					; call it
.1e83	4c 00 00	jmp $0000			jmp 	NextCode
.1e86					_CallTemp1:
.1e86	6c 10 00	jmp ($0010)			jmp 	(temp1)
.1e89					AssertCode:
.1e89	a5 06		lda $06				lda 	TOS 						; TOS = 0
.1e8b	05 07		ora $07				ora 	TOS+1
.1e8d	f0 09		beq $1e98			beq 	_ASFail 					; if zero fail
.1e8f	68		pla				pla
.1e90	85 07		sta $07				sta 	TOS+1
.1e92	68		pla				pla
.1e93	85 06		sta $06				sta 	TOS
.1e95	4c 00 00	jmp $0000			jmp 	NextCode
.1e98					_ASFail:
.1e98	20 fe 10	jsr $10fe			jsr 	ErrorHandler
>1e9b	41 53 53 45 52 54 00				.text 	"ASSERT",0
.1ea2					StopCode:
.1ea2	20 fe 10	jsr $10fe			jsr 	ErrorHandler
>1ea5	53 54 4f 50 00					.text 	"STOP",0
.1eaa					EndProgram:
.1eaa	4c 14 10	jmp $1014			jmp 	WarmStart
.1ead					VlistCode:
.1ead	a9 39		lda #$39			lda 	#(Dictionary) & $FF
.1eaf	85 10		sta $10				sta 	0+(temp1)
.1eb1	a9 22		lda #$22			lda 	#(Dictionary) >> 8
.1eb3	85 11		sta $11				sta 	1+(temp1)
.1eb5	a0 01		ldy #$01	_VLLoop:ldy 	#1							; type byte
.1eb7	b1 10		lda ($10),y			lda 	(temp1),y
.1eb9	a0 04		ldy #$04			ldy 	#4 							; Y = 4
.1ebb	4a		lsr a				lsr 	a 							; shift bits 4 and 5 to 0,1
.1ebc	4a		lsr a				lsr 	a
.1ebd	4a		lsr a				lsr		a
.1ebe	4a		lsr a				lsr 	a
.1ebf	4a		lsr a				lsr 	a 							; add those bits in
.1ec0	90 02		bcc $1ec4			bcc 	_VLNoDec
.1ec2	c8		iny				iny
.1ec3	c8		iny				iny
.1ec4					_VLNoDec:
.1ec4	4a		lsr a				lsr 	a
.1ec5	90 02		bcc $1ec9			bcc 	_VLNoEnc
.1ec7	c8		iny				iny
.1ec8	c8		iny				iny
.1ec9					_VLNoEnc:
.1ec9	b1 10		lda ($10),y			lda 	(temp1),y 					; remove $$ words
.1ecb	c9 24		cmp #$24			cmp 	#"$"
.1ecd	d0 06		bne $1ed5			bne 	_VLPrint
.1ecf	c8		iny				iny
.1ed0	51 10		eor ($10),y			eor 	(temp1),y
.1ed2	f0 13		beq $1ee7			beq 	_VLNext
.1ed4	88		dey				dey
.1ed5					_VLPrint:
.1ed5	b1 10		lda ($10),y			lda 	(temp1),y
.1ed7	48		pha				pha
.1ed8	c8		iny				iny
.1ed9	29 7f		and #$7f			and 	#$7F
.1edb	20 5e 11	jsr $115e			jsr 	ExternPrint
.1ede	68		pla				pla
.1edf	0a		asl a				asl 	a
.1ee0	90 f3		bcc $1ed5			bcc 	_VLPrint
.1ee2	a9 20		lda #$20			lda 	#32
.1ee4	20 5e 11	jsr $115e			jsr 	ExternPrint
.1ee7					_VLNext:
.1ee7	18		clc				clc 								; go to next
.1ee8	b2 10		lda ($10)			lda 	(temp1)
.1eea	65 10		adc $10				adc 	temp1
.1eec	85 10		sta $10				sta 	temp1
.1eee	90 02		bcc $1ef2			bcc 	_VLNoCarry
.1ef0	e6 11		inc $11				inc 	temp1+1
.1ef2					_VLNoCarry:
.1ef2	b2 10		lda ($10)			lda 	(temp1)
.1ef4	d0 bf		bne $1eb5			bne 	_VLLoop
.1ef6	a9 0d		lda #$0d			lda 	#13
.1ef8	20 5e 11	jsr $115e			jsr 	ExternPrint
.1efb	4c 00 00	jmp $0000			jmp 	NextCode
.1efe					DumpStack:
.1efe	a9 5b		lda #$5b			lda		#"["
.1f00	20 5e 11	jsr $115e			jsr 	ExternPrint
.1f03	86 10		stx $10				stx 	temp1 						; X -> A
.1f05	ba		tsx				tsx
.1f06	8a		txa				txa
.1f07	a6 10		ldx $10				ldx 	temp1
.1f09	c9 80		cmp #$80			cmp 	#NumberStackBase 			; out of range, exit
.1f0b	f0 2f		beq $1f3c			beq 	_DSExit
.1f0d	48		pha				pha 								; save it
.1f0e	a9 07		lda #$07			lda 	#COL_WHITE
.1f10	20 68 11	jsr $1168			jsr 	ExternColour
.1f13	a5 06		lda $06				lda 	TOS 						; print TOS then stack values backwards
.1f15	a4 07		ldy $07				ldy 	TOS+1
.1f17	38		sec				sec 								; print unsigned.
.1f18	20 55 20	jsr $2055			jsr 	PrintYA
.1f1b	a9 06		lda #$06			lda 	#COL_CYAN
.1f1d	20 68 11	jsr $1168			jsr 	ExternColour
.1f20	7a		ply				ply 								; restore offset
.1f21					_DSLoop:
.1f21	c0 7e		cpy #$7e			cpy 	#NumberStackBase-2 			; till done whole stack.
.1f23	f0 17		beq $1f3c			beq 	_DSExit
.1f25	a9 20		lda #$20			lda 	#" " 						; space
.1f27	20 5e 11	jsr $115e			jsr 	ExternPrint
.1f2a	5a		phy				phy 								; save pos
.1f2b	b9 01 01	lda $0101,y			lda 	$0101,y 					; read stack item
.1f2e	48		pha				pha
.1f2f	b9 02 01	lda $0102,y			lda 	$0102,y
.1f32	7a		ply				ply
.1f33	38		sec				sec
.1f34	20 55 20	jsr $2055			jsr 	PrintYA 					; print it
.1f37	7a		ply				ply 								; restore and advance pos
.1f38	c8		iny				iny
.1f39	c8		iny				iny
.1f3a	80 e5		bra $1f21			bra 	_DSLoop
.1f3c					_DSExit:
.1f3c	a9 5d		lda #$5d			lda		#"]"
.1f3e	20 5e 11	jsr $115e			jsr 	ExternPrint
.1f41	a9 0d		lda #$0d			lda 	#13
.1f43	20 5e 11	jsr $115e			jsr 	ExternPrint
.1f46	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/system/toint.src

.1f49					ConvertToInteger:
.1f49	84 17		sty $17				sty 	temp4+1
.1f4b	85 16		sta $16				sta 	temp4
.1f4d	64 14		stz $14				stz 	temp3 						; reset value
.1f4f	64 15		stz $15				stz 	temp3+1
.1f51	64 10		stz $10				stz 	temp1 						; temp1 = 0 (decimal) 255 (hex)
.1f53	a0 00		ldy #$00			ldy 	#0 							; look at first character
.1f55	b1 16		lda ($16),y			lda 	(temp4),y
.1f57	49 2d		eor #$2d			eor 	#"-"						; zero if '-'
.1f59	85 11		sta $11				sta 	temp1+1 					; save this in temp1+1
.1f5b	d0 01		bne $1f5e			bne 	_CTINotMinus
.1f5d	c8		iny				iny									; skip -
.1f5e					_CTINotMinus:
.1f5e	b1 16		lda ($16),y			lda 	(temp4),y
.1f60	c9 24		cmp #$24			cmp		#'$'						; if $ then skip it and set hex flag
.1f62	d0 03		bne $1f67			bne 	_CTILoop
.1f64	c6 10		dec $10				dec 	temp1
.1f66	c8		iny				iny
.1f67					_CTILoop:
.1f67	b1 16		lda ($16),y			lda 	(temp4),y 					; next digit
.1f69	29 7f		and #$7f			and 	#$7F 						; drop end of word flag
.1f6b	38		sec				sec
.1f6c	e9 30		sbc #$30			sbc 	#'0' 						; put in range '0'+
.1f6e	90 65		bcc $1fd5			bcc 	_CTIFail 					; out of range.
.1f70	c9 0a		cmp #$0a			cmp 	#10 						; in 0-9 ?
.1f72	90 0b		bcc $1f7f			bcc 	_CTILegal
.1f74	c9 11		cmp #$11			cmp 	#'A'-'0'					; between 9 and A ?
.1f76	90 5d		bcc $1fd5			bcc 	_CTIFail
.1f78	38		sec				sec
.1f79	e9 07		sbc #$07			sbc 	#7 							; hex adjust
.1f7b	c9 10		cmp #$10			cmp 	#16 						; out of range ?
.1f7d	b0 56		bcs $1fd5			bcs 	_CTIFail
.1f7f					_CTILegal:
.1f7f	48		pha				pha 								; save digit value.
.1f80	06 14		asl $14				asl 	temp3
.1f82	26 15		rol $15				rol 	temp3+1
.1f84	a5 14		lda $14				lda 	temp3 						; copy x2 into temp2
.1f86	85 12		sta $12				sta 	temp2
.1f88	a5 15		lda $15				lda 	temp3+1
.1f8a	85 13		sta $13				sta 	temp2+1
.1f8c	06 14		asl $14				asl 	temp3
.1f8e	26 15		rol $15				rol 	temp3+1
.1f90	06 14		asl $14				asl 	temp3
.1f92	26 15		rol $15				rol 	temp3+1
.1f94	24 10		bit $10				bit 	temp1 						; hexadecimal
.1f96	10 07		bpl $1f9f			bpl 	_CTIDecimal
.1f98	06 14		asl $14				asl 	temp3
.1f9a	26 15		rol $15				rol 	temp3+1
.1f9c	68		pla				pla 								; get digit back
.1f9d	80 12		bra $1fb1			bra 	_CTIAddLoop
.1f9f					_CTIDecimal:
.1f9f	18		clc				clc 								; x 8 + x 2 = x 10
.1fa0	a5 14		lda $14				lda 	temp3
.1fa2	65 12		adc $12				adc 	temp2
.1fa4	85 14		sta $14				sta 	temp3
.1fa6	a5 15		lda $15				lda 	temp3+1
.1fa8	65 13		adc $13				adc 	temp2+1
.1faa	85 15		sta $15				sta 	temp3+1
.1fac	68		pla				pla 								; check digit 0-9
.1fad	c9 0a		cmp #$0a			cmp 	#10
.1faf	b0 24		bcs $1fd5			bcs 	_CTIFail
.1fb1					_CTIAddLoop:
.1fb1	18		clc				clc
.1fb2	65 14		adc $14				adc 	temp3
.1fb4	85 14		sta $14				sta 	temp3
.1fb6	90 02		bcc $1fba			bcc 	_CTINoCarry
.1fb8	e6 15		inc $15				inc 	temp3+1
.1fba					_CTINoCarry:
.1fba	c8		iny				iny
.1fbb	b1 16		lda ($16),y			lda 	(temp4),y 					; was this the last character
.1fbd	c9 21		cmp #$21			cmp 	#32+1
.1fbf	b0 a6		bcs $1f67			bcs 	_CTILoop 					; no, go back.
.1fc1	a5 11		lda $11				lda 	temp1+1 					; was it - ?
.1fc3	d0 0d		bne $1fd2			bne 	_CTIOkay
.1fc5	38		sec				sec
.1fc6	a9 00		lda #$00			lda 	#0 							; negate temp3.
.1fc8	e5 14		sbc $14				sbc 	temp3
.1fca	85 14		sta $14				sta 	temp3
.1fcc	a9 00		lda #$00			lda 	#0
.1fce	e5 15		sbc $15				sbc 	temp3+1
.1fd0	85 15		sta $15				sta 	temp3+1
.1fd2					_CTIOkay:
.1fd2	98		tya				tya
.1fd3	38		sec				sec
.1fd4	60		rts				rts
.1fd5					_CTIFail:
.1fd5	18		clc				clc
.1fd6	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/skipper.src

.1fd7					NextLine:
.1fd7	18		clc				clc
.1fd8	a5 03		lda $03				lda 	IP
.1fda	72 03		adc ($03)			adc 	(IP)
.1fdc	85 03		sta $03				sta 	IP
.1fde	90 02		bcc $1fe2			bcc 	_NoCarryAdv
.1fe0	e6 04		inc $04				inc 	IP+1
.1fe2					_NoCarryAdv:
.1fe2	b2 03		lda ($03)			lda 	(IP)						; is there any following program ?
.1fe4	f0 05		beq $1feb			beq 	_NLGoEnd
.1fe6	a2 01		ldx #$01			ldx 	#1 							; start 3 in (-2 for Next)
.1fe8	4c 00 00	jmp $0000			jmp 	NextCode
.1feb					_NLGoEnd:
.1feb	4c 14 10	jmp $1014			jmp 	WarmStart
.1fee					SkipComment:
.1fee	e8		inx				inx									; (IP),X points to the length.
.1fef	e8		inx				inx
.1ff0	8a		txa				txa
.1ff1	a8		tay				tay 								; put into Y
.1ff2	18		clc				clc
.1ff3	71 03		adc ($03),y			adc 	(IP),y 						; add the length to X
.1ff5	aa		tax				tax 								; put back in X
.1ff6	ca		dex				dex
.1ff7	ca		dex				dex
.1ff8	4c 00 00	jmp $0000			jmp 	NextCode
.1ffb					CommentDecoder:
.1ffb	a9 06		lda #$06			lda 	#CTH_Keyword
.1ffd	20 f1 1c	jsr $1cf1			jsr 	DecodeWriteBuffer
.2000	a9 27		lda #$27			lda 	#"'"
.2002	20 f1 1c	jsr $1cf1			jsr 	DecodeWriteBuffer
.2005	b1 08		lda ($08),y			lda 	(srcPtr),y 					; check if there is no data
.2007	c9 01		cmp #$01			cmp 	#1
.2009	f0 0d		beq $2018			beq 	_CDEmpty 					; if so print nothing.
.200b	a9 0b		lda #$0b			lda 	#CTH_Comment
.200d	20 f1 1c	jsr $1cf1			jsr 	DecodeWriteBuffer
.2010	20 fa 1c	jsr $1cfa			jsr 	DecodeOutputData
.2013	a9 20		lda #$20			lda 	#32
.2015	20 f1 1c	jsr $1cf1			jsr 	DecodeWriteBuffer
.2018					_CDEmpty
.2018	60		rts				rts
.2019					DefineCode:
.2019	20 fe 10	jsr $10fe			jsr 	ErrorHandler
>201c	44 45 46 49 4e 49 54 49				.text 	"DEFINITION?",0
>2024	4f 4e 3f 00
.2028					DefineDecoder:
.2028	a9 07		lda #$07			lda 	#CTH_Definition
.202a	20 f1 1c	jsr $1cf1			jsr 	DecodeWriteBuffer
.202d	a9 3a		lda #$3a			lda 	#":"
.202f	20 f1 1c	jsr $1cf1			jsr 	DecodeWriteBuffer
.2032	20 fa 1c	jsr $1cfa			jsr 	DecodeOutputData
.2035	a9 20		lda #$20			lda 	#32
.2037	20 f1 1c	jsr $1cf1			jsr 	DecodeWriteBuffer
.203a	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/tostr.src

.203b					IntToString:
.203b	a9 10		lda #$10			lda 	#(textBuffer) & $FF
.203d	85 12		sta $12				sta 	0+(temp2)
.203f	a9 08		lda #$08			lda 	#(textBuffer) >> 8
.2041	85 13		sta $13				sta 	1+(temp2)
.2043	a5 06		lda $06				lda 	TOS 						; value in YA
.2045	a4 07		ldy $07				ldy 	TOS+1
.2047	20 77 20	jsr $2077			jsr 	ConvertToString
.204a	a9 10		lda #$10			lda 	#(textBuffer) & $FF
.204c	85 06		sta $06				sta 	0+(TOS)
.204e	a9 08		lda #$08			lda 	#(textBuffer) >> 8
.2050	85 07		sta $07				sta 	1+(TOS)
.2052	4c 00 00	jmp $0000			jmp 	NextCode
.2055					PrintYA:
.2055	48		pha				pha
.2056	da		phx				phx
.2057	5a		phy				phy
.2058	48		pha				pha
.2059	a9 10		lda #$10			lda 	#(textBuffer) & $FF
.205b	85 12		sta $12				sta 	0+(temp2)
.205d	a9 08		lda #$08			lda 	#(textBuffer) >> 8
.205f	85 13		sta $13				sta 	1+(temp2)
.2061	68		pla				pla
.2062	20 7b 20	jsr $207b			jsr 	ConvertToStringMain
.2065	a2 00		ldx #$00			ldx 	#0
.2067					_PrintYALoop:
.2067	bd 10 08	lda $0810,x			lda 	textBuffer,x
.206a	20 5e 11	jsr $115e			jsr 	ExternPrint
.206d	e8		inx				inx
.206e	bd 10 08	lda $0810,x			lda 	textBuffer,x
.2071	d0 f4		bne $2067			bne 	_PrintYALoop
.2073	7a		ply				ply
.2074	fa		plx				plx
.2075	68		pla				pla
.2076	60		rts				rts
.2077					ConvertToString:
.2077	38		sec				sec
.2078	80 01		bra $207b			bra 	ConvertToStringMain
.207a					ConvertToStringUnsigned:
.207a	18		clc				clc
.207b					ConvertToStringMain:
.207b	da		phx				phx									; save XY
.207c	5a		phy				phy
.207d	64 1a		stz $1a				stz 	SignCount 					; this is zero suppression
.207f	85 10		sta $10				sta 	temp1 						; save YA in temp1
.2081	84 11		sty $11				sty 	temp1+1
.2083	a0 00		ldy #$00			ldy 	#0 							; index to result.
.2085	90 16		bcc $209d			bcc 	_CTSUnsigned 				; if carry clear do not adjust for -
.2087	a5 11		lda $11				lda 	temp1+1 					; is it negative
.2089	10 12		bpl $209d			bpl 	_CTSUnsigned
.208b	a9 2d		lda #$2d			lda 	#"-"						; output - sign
.208d	91 12		sta ($12),y			sta 	(temp2),y
.208f	c8		iny				iny
.2090	38		sec				sec 								; negate temp1
.2091	a9 00		lda #$00			lda 	#0
.2093	e5 10		sbc $10				sbc 	temp1
.2095	85 10		sta $10				sta 	temp1
.2097	a9 00		lda #$00			lda 	#0
.2099	e5 11		sbc $11				sbc 	temp1+1
.209b	85 11		sta $11				sta 	temp1+1
.209d					_CTSUnsigned:
.209d	a2 00		ldx #$00			ldx 	#0 							; index into subtraction table
.209f					_CTSLoop:
.209f	a9 2f		lda #$2f			lda 	#"0"-1						; set the digit to '0' code.
.20a1	91 12		sta ($12),y			sta 	(temp2),y
.20a3					_CTSSubLoop:
.20a3	b1 12		lda ($12),y			lda 	(temp2),y 					; bump the count
.20a5	1a		inc a				inc 	a
.20a6	91 12		sta ($12),y			sta 	(temp2),y
.20a8	38		sec				sec 								; do subtraction saving interim result
.20a9	a5 10		lda $10				lda 	temp1
.20ab	fd de 20	sbc $20de,x			sbc 	_CTSTable,x
.20ae	48		pha				pha
.20af	a5 11		lda $11				lda 	temp1+1
.20b1	fd df 20	sbc $20df,x			sbc 	_CTSTable+1,x
.20b4	90 07		bcc $20bd			bcc 	_CTSCantSubtract 			; end of subtraction.
.20b6	85 11		sta $11				sta 	temp1+1 					; save result back
.20b8	68		pla				pla
.20b9	85 10		sta $10				sta 	temp1
.20bb	80 e6		bra $20a3			bra 	_CTSSubLoop
.20bd					_CTSCantSubtract:
.20bd	68		pla				pla 								; throw away interim
.20be	e8		inx				inx 								; next subtractor
.20bf	e8		inx				inx
.20c0	b1 12		lda ($12),y			lda 	(temp2),y 					; update leading zero
.20c2	49 30		eor #$30			eor 	#"0"
.20c4	05 1a		ora $1a				ora 	SignCount
.20c6	85 1a		sta $1a				sta 	SignCount
.20c8	f0 01		beq $20cb			beq		_CTSLZ 						; if all zeros so far suppress.
.20ca	c8		iny				iny 								; next character
.20cb					_CTSLZ:
.20cb	e0 08		cpx #$08			cpx 	#_CTSTableEnd-_CTSTable 	; done them all ?
.20cd	d0 d0		bne $209f			bne 	_CTSLoop
.20cf					_CTSComplete:
.20cf	a5 10		lda $10				lda		temp1 						; get remainder 0-9
.20d1	09 30		ora #$30			ora 	#48 						; ASCII
.20d3	91 12		sta ($12),y			sta 	(temp2),y					; write out
.20d5	c8		iny				iny
.20d6	a9 00		lda #$00			lda 	#0							; make ASCIIZ
.20d8	91 12		sta ($12),y			sta 	(temp2),y
.20da	98		tya				tya 								; size in A
.20db	7a		ply				ply									; pull and exit.
.20dc	fa		plx				plx
.20dd	60		rts				rts
.20de					_CTSTable:
>20de	10 27 e8 03 64 00 0a 00				.word 	10000,1000,100,10 			; subtractors, this is a simple version.
.20e6					_CTSTableEnd:

;******  Return to file: kernel.asm


;******  Processing file: words/system/varhandlers.src

.20e6					VarAddressHandler:
.20e6	18		clc				clc 								; find variable, error if it doesn't exist.
.20e7	20 38 21	jsr $2138			jsr 	VariableFind
.20ea	a5 06		lda $06				lda 	TOS
.20ec	48		pha				pha
.20ed	a5 07		lda $07				lda 	TOS+1
.20ef	48		pha				pha
.20f0	a5 10		lda $10				lda 	temp1 						; the address is the new value
.20f2	85 06		sta $06				sta 	TOS
.20f4	a5 11		lda $11				lda		temp1+1
.20f6	85 07		sta $07				sta 	TOS+1
.20f8	4c 00 00	jmp $0000			jmp 	NextCode
.20fb					VarAddrHandlerDecode:
.20fb	a9 26		lda #$26			lda 	#"&"
.20fd	4c e6 21	jmp $21e6			jmp 	VarHandlerDecode
.2100					VarReadHandler:
.2100	18		clc				clc 								; find variable, error if it doesn't exist.
.2101	20 38 21	jsr $2138			jsr 	VariableFind
.2104	a5 06		lda $06				lda 	TOS
.2106	48		pha				pha
.2107	a5 07		lda $07				lda 	TOS+1
.2109	48		pha				pha
.210a	b2 10		lda ($10)			lda 	(temp1)						; read variable address to TOS
.210c	85 06		sta $06				sta 	TOS
.210e	a0 01		ldy #$01			ldy 	#1
.2110	b1 10		lda ($10),y			lda 	(temp1),y
.2112	85 07		sta $07				sta 	TOS+1
.2114	4c 00 00	jmp $0000			jmp 	NextCode
.2117					VarReadHandlerDecode:
.2117	a9 40		lda #$40			lda 	#"@"
.2119	4c e6 21	jmp $21e6			jmp 	VarHandlerDecode
.211c					VarWriteHandler:
.211c	38		sec				sec 								; find variable, create it if it doesn't exist.
.211d	20 38 21	jsr $2138			jsr 	VariableFind
.2120	a5 06		lda $06				lda 	TOS 						; write TOS to that address.
.2122	92 10		sta ($10)			sta 	(temp1)
.2124	a5 07		lda $07				lda 	TOS+1
.2126	a0 01		ldy #$01			ldy 	#1
.2128	91 10		sta ($10),y			sta 	(temp1),y
.212a	68		pla				pla
.212b	85 07		sta $07				sta 	TOS+1
.212d	68		pla				pla
.212e	85 06		sta $06				sta 	TOS
.2130	4c 00 00	jmp $0000			jmp 	NextCode
.2133					VarWriteHandlerDecode:
.2133	a9 21		lda #$21			lda 	#"!"
.2135	4c e6 21	jmp $21e6			jmp 	VarHandlerDecode
.2138					VariableFind:
.2138	08		php				php 								; save autocreate flag.
.2139	e8		inx				inx 								; advance to/over the variable name.
.213a	e8		inx				inx
.213b	8a		txa				txa 								; put in Y
.213c	a8		tay				tay
.213d	b1 03		lda ($03),y			lda 	(IP),y 						; copy name word into temp2
.213f	85 12		sta $12				sta 	temp2
.2141	c8		iny				iny
.2142	b1 03		lda ($03),y			lda 	(IP),y
.2144	85 13		sta $13				sta 	temp2+1
.2146	c9 1b		cmp #$1b			cmp 	#27 						; check for A-Z
.2148	b0 0f		bcs $2159			bcs 	_VFLong
.214a	a5 13		lda $13				lda 	temp2+1
.214c	d0 0b		bne $2159			bne 	_VFLong
.214e	a5 12		lda $12				lda 	temp2						; this is the index
.2150	0a		asl a				asl 	a 							; double it
.2151	85 10		sta $10				sta 	temp1
.2153	a9 06		lda #$06			lda 	#azVariables >> 8			; set the MSB
.2155	85 11		sta $11				sta 	temp1+1
.2157	28		plp				plp 								; throw creation flag, it always exists.
.2158	60		rts				rts
.2159					_VFLong:
.2159	a5 12		lda $12				lda 	temp2 						; built a hash table index into temp3/temp4
.215b	6a		ror a				ror 	a
.215c	6a		ror a				ror 	a
.215d	6a		ror a				ror 	a
.215e	6a		ror a				ror 	a
.215f	45 12		eor $12				eor 	temp2
.2161	45 13		eor $13				eor 	temp2+1
.2163	29 0f		and #$0f			and 	#(hashTableSize-1)			; force into range
.2165	0a		asl a				asl 	a
.2166	69 40		adc #$40			adc 	#hashTable & $FF 			; make an address of the head => temp1/3
.2168	85 10		sta $10				sta 	temp1
.216a	85 14		sta $14				sta 	temp3
.216c	a9 06		lda #$06			lda 	#hashTable >> 8
.216e	85 11		sta $11				sta 	temp1+1
.2170	85 15		sta $15				sta 	temp3+1
.2172					_VFSearch:
.2172	a0 01		ldy #$01			ldy 	#1							; read MSB of first record
.2174	b1 10		lda ($10),y			lda 	(temp1),y
.2176	f0 23		beq $219b			beq 	_VFNotFound 				; is MSB is zero, can't be a variable record
.2178	a8		tay				tay 								; follow the link through.
.2179	b2 10		lda ($10)			lda 	(temp1)
.217b	85 10		sta $10				sta 	temp1
.217d	84 11		sty $11				sty 	temp1+1
.217f	a0 04		ldy #$04			ldy 	#4							; check if the name matches
.2181	b1 10		lda ($10),y			lda 	(temp1),y
.2183	c5 12		cmp $12				cmp 	temp2
.2185	d0 eb		bne $2172			bne 	_VFSearch 					; if it doesn't, follow the next link.
.2187	c8		iny				iny 								; same for 2nd byte of name
.2188	b1 10		lda ($10),y			lda 	(temp1),y
.218a	c5 13		cmp $13				cmp 	temp2+1
.218c	d0 e4		bne $2172			bne 	_VFSearch
.218e	18		clc				clc
.218f	a5 10		lda $10				lda 	temp1 						; make temp1 point to the data at offset 2
.2191	69 02		adc #$02			adc 	#2
.2193	85 10		sta $10				sta 	temp1
.2195	90 02		bcc $2199			bcc 	_VFNoPage1
.2197	e6 11		inc $11				inc 	temp1+1
.2199					_VFNoPage1:
.2199	28		plp				plp 								; don't need to worry about creation flag
.219a	60		rts				rts
.219b					_VFNotFound:
.219b	28		plp				plp 								; was carry set, e.g. create a new record if not found ?
.219c	b0 0d		bcs $21ab			bcs 	_VFCreate
.219e	20 fe 10	jsr $10fe			jsr 	ErrorHandler
>21a1	56 41 52 49 41 42 4c 45				.text 	"VARIABLE?",0
>21a9	3f 00
.21ab					_VFCreate:
.21ab	a0 01		ldy #$01			ldy 	#1
.21ad	b2 14		lda ($14)			lda 	(temp3) 					; copy the head link to the first 2 bytes
.21af	92 0e		sta ($0e)			sta 	(nextFreeMem)
.21b1	b1 14		lda ($14),y			lda 	(temp3),y
.21b3	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.21b5	c8		iny				iny
.21b6	a9 00		lda #$00			lda 	#0	 						; write zero initialised data out.
.21b8	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.21ba	c8		iny				iny
.21bb	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.21bd	c8		iny				iny
.21be	a5 12		lda $12				lda 	temp2 						; copy the name out
.21c0	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.21c2	c8		iny				iny
.21c3	a5 13		lda $13				lda 	temp2+1
.21c5	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.21c7	a0 01		ldy #$01			ldy 	#1
.21c9	a5 0e		lda $0e				lda 	nextFreeMem 				; update the head link
.21cb	92 14		sta ($14)			sta 	(temp3)
.21cd	a5 0f		lda $0f				lda 	nextFreeMem+1
.21cf	91 14		sta ($14),y			sta 	(temp3),y
.21d1	18		clc				clc
.21d2	a5 0e		lda $0e				lda 	nextFreeMem 				; put nextFreeMem+2 in temp1 (data pointer)
.21d4	69 02		adc #$02			adc 	#2
.21d6	85 10		sta $10				sta 	temp1
.21d8	a5 0f		lda $0f				lda 	nextFreeMem+1
.21da	69 00		adc #$00			adc 	#0
.21dc	85 11		sta $11				sta 	temp1+1
.21de	a9 06		lda #$06			lda 	#6							; shift freemem pointer up 6
.21e0	a0 00		ldy #$00			ldy 	#0
.21e2	20 ee 1b	jsr $1bee			jsr 	AdvanceFreeMem
.21e5	60		rts				rts
.21e6					VarHandlerDecode:
.21e6	48		pha				pha 								; save, leading space
.21e7	a9 07		lda #$07			lda 	#CTH_Variable
.21e9	20 f1 1c	jsr $1cf1			jsr 	DecodeWriteBuffer
.21ec	68		pla				pla 								; restore and write type
.21ed	20 f1 1c	jsr $1cf1			jsr 	DecodeWriteBuffer
.21f0	b1 08		lda ($08),y			lda 	(srcPtr),y 					; copy to temp1
.21f2	85 10		sta $10				sta 	temp1
.21f4	c8		iny				iny
.21f5	b1 08		lda ($08),y			lda 	(srcPtr),y
.21f7	85 11		sta $11				sta 	temp1+1
.21f9	a5 10		lda $10				lda 	temp1 						; output the first character
.21fb	29 1f		and #$1f			and 	#31
.21fd	20 28 22	jsr $2228			jsr 	VHOutVarChar
.2200	a2 05		ldx #$05			ldx 	#5 							; divide temp1 by 32
.2202					_VHDShift:
.2202	46 11		lsr $11				lsr 	temp1+1
.2204	66 10		ror $10				ror 	temp1
.2206	ca		dex				dex
.2207	d0 f9		bne $2202			bne 	_VHDShift
.2209	a2 ff		ldx #$ff			ldx 	#255 						; now divide that by 40 by repeated subtraction.
.220b					_VHDDiv40:
.220b	e8		inx				inx
.220c	38		sec				sec
.220d	a5 10		lda $10				lda 	temp1
.220f	e9 28		sbc #$28			sbc 	#40
.2211	a8		tay				tay
.2212	a5 11		lda $11				lda 	temp1+1
.2214	e9 00		sbc #$00			sbc 	#0
.2216	90 06		bcc $221e			bcc 	_VHDivDone
.2218	85 11		sta $11				sta 	temp1+1
.221a	84 10		sty $10				sty 	temp1
.221c	80 ed		bra $220b			bra 	_VHDDiv40
.221e					_VHDivDone:
.221e	a5 10		lda $10				lda 	temp1 						; remainder
.2220	20 28 22	jsr $2228			jsr 	VHOutVarChar
.2223	8a		txa				txa
.2224	20 28 22	jsr $2228			jsr 	VHOutVarChar 				; and result.
.2227	60		rts				rts
.2228					VHOutVarChar:
.2228	c9 00		cmp #$00			cmp 	#0
.222a	f0 0c		beq $2238			beq 	_VHOExit
.222c	18		clc				clc
.222d	69 40		adc #$40			adc 	#64 						; 65-90 A-Z 91-100 0-9
.222f	c9 5b		cmp #$5b			cmp 	#91 						; convert back ?
.2231	90 02		bcc $2235			bcc 	_VHOOut
.2233	e9 2b		sbc #$2b			sbc 	#91-48 						; adjust to digit
.2235					_VHOOut:
.2235	20 f1 1c	jsr $1cf1			jsr 	DecodeWriteBuffer
.2238					_VHOExit:
.2238	60		rts				rts

;******  Return to file: kernel.asm

.2239					Dictionary:

;******  Processing file: generated/dictionary.inc

>2239	05					.byte	_end1-*
>223a	00					.byte	$00
>223b	4f 16					.word	WordWrite
>223d	a1					.byte	$a1
.223e					_end1:
>223e	10					.byte	_end2-*
>223f	52					.byte	$52
>2240	1c 21					.word	VarWriteHandler
>2242	33 21					.word	VarWriteHandlerDecode
>2244	24 24 21 48 41 4e 44 4c			.byte	$24,$24,$21,$48,$41,$4e,$44,$4c,$45,$d2
>224c	45 d2
.224e					_end2:
>224e	10					.byte	_end3-*
>224f	52					.byte	$52
>2250	e6 20					.word	VarAddressHandler
>2252	fb 20					.word	VarAddrHandlerDecode
>2254	24 24 26 48 41 4e 44 4c			.byte	$24,$24,$26,$48,$41,$4e,$44,$4c,$45,$d2
>225c	45 d2
.225e					_end3:
>225e	10					.byte	_end4-*
>225f	52					.byte	$52
>2260	00 21					.word	VarReadHandler
>2262	17 21					.word	VarReadHandlerDecode
>2264	24 24 40 48 41 4e 44 4c			.byte	$24,$24,$40,$48,$41,$4e,$44,$4c,$45,$d2
>226c	45 d2
.226e					_end4:
>226e	0c					.byte	_end5-*
>226f	52					.byte	$52
>2270	6e 1a					.word	CallHandler
>2272	2a 1b					.word	CallHandlerDecode
>2274	24 24 43 41 4c cc			.byte	$24,$24,$43,$41,$4c,$cc
.227a					_end5:
>227a	0f					.byte	_end6-*
>227b	53					.byte	$53
>227c	ee 1f					.word	SkipComment
>227e	fb 1f					.word	CommentDecoder
>2280	24 24 43 4f 4d 4d 45 4e			.byte	$24,$24,$43,$4f,$4d,$4d,$45,$4e,$d4
>2288	d4
.2289					_end6:
>2289	0e					.byte	_end7-*
>228a	53					.byte	$53
>228b	19 20					.word	DefineCode
>228d	28 20					.word	DefineDecoder
>228f	24 24 44 45 46 49 4e c5			.byte	$24,$24,$44,$45,$46,$49,$4e,$c5
.2297					_end7:
>2297	0f					.byte	_end8-*
>2298	52					.byte	$52
>2299	a6 10					.word	Literal2Byte
>229b	bc 10					.word	Literal2ByteDecode
>229d	24 24 4c 49 54 45 52 41			.byte	$24,$24,$4c,$49,$54,$45,$52,$41,$cc
>22a5	cc
.22a6					_end8:
>22a6	0e					.byte	_end9-*
>22a7	80					.byte	$80
>22a8	d7 1f					.word	NextLine
>22aa	24 24 4e 45 58 54 4c 49			.byte	$24,$24,$4e,$45,$58,$54,$4c,$49,$4e,$c5
>22b2	4e c5
.22b4					_end9:
>22b4	0e					.byte	_end10-*
>22b5	53					.byte	$53
>22b6	ce 10					.word	LiteralString
>22b8	ed 10					.word	LiteralStringDecoder
>22ba	24 24 53 54 52 49 4e c7			.byte	$24,$24,$53,$54,$52,$49,$4e,$c7
.22c2					_end10:
>22c2	05					.byte	_end11-*
>22c3	00					.byte	$00
>22c4	cb 13					.word	Multiply16x16
>22c6	aa					.byte	$aa
.22c7					_end11:
>22c7	05					.byte	_end12-*
>22c8	00					.byte	$00
>22c9	38 12					.word	Add
>22cb	ab					.byte	$ab
.22cc					_end12:
>22cc	06					.byte	_end13-*
>22cd	00					.byte	$00
>22ce	60 16					.word	WordAdd
>22d0	2b a1					.byte	$2b,$a1
.22d2					_end13:
>22d2	05					.byte	_end14-*
>22d3	00					.byte	$00
>22d4	47 12					.word	Subtract
>22d6	ad					.byte	$ad
.22d7					_end14:
>22d7	06					.byte	_end15-*
>22d8	00					.byte	$00
>22d9	07 15					.word	ConstantMinus1
>22db	2d b1					.byte	$2d,$b1
.22dd					_end15:
>22dd	06					.byte	_end16-*
>22de	00					.byte	$00
>22df	fe 1e					.word	DumpStack
>22e1	2e ae					.byte	$2e,$ae
.22e3					_end16:
>22e3	05					.byte	_end17-*
>22e4	00					.byte	$00
>22e5	1c 13					.word	Divide16x16
>22e7	af					.byte	$af
.22e8					_end17:
>22e8	05					.byte	_end18-*
>22e9	00					.byte	$00
>22ea	fa 14					.word	Constant0
>22ec	b0					.byte	$b0
.22ed					_end18:
>22ed	06					.byte	_end19-*
>22ee	00					.byte	$00
>22ef	60 14					.word	CheckMinus
>22f1	30 bc					.byte	$30,$bc
.22f3					_end19:
>22f3	06					.byte	_end20-*
>22f4	00					.byte	$00
>22f5	74 14					.word	CheckZero
>22f7	30 bd					.byte	$30,$bd
.22f9					_end20:
>22f9	05					.byte	_end21-*
>22fa	00					.byte	$00
>22fb	16 15					.word	C1
>22fd	b1					.byte	$b1
.22fe					_end21:
>22fe	06					.byte	_end22-*
>22ff	00					.byte	$00
>2300	0a 14					.word	Unary1Plus
>2302	31 ab					.byte	$31,$ab
.2304					_end22:
>2304	06					.byte	_end23-*
>2305	00					.byte	$00
>2306	21 14					.word	Unary1Minus
>2308	31 ad					.byte	$31,$ad
.230a					_end23:
>230a	06					.byte	_end24-*
>230b	00					.byte	$00
>230c	2e 15					.word	C10
>230e	31 b0					.byte	$31,$b0
.2310					_end24:
>2310	07					.byte	_end25-*
>2311	00					.byte	$00
>2312	57 15					.word	C100
>2314	31 30 b0				.byte	$31,$30,$b0
.2317					_end25:
>2317	08					.byte	_end26-*
>2318	00					.byte	$00
>2319	86 15					.word	C1024
>231b	31 30 32 b4				.byte	$31,$30,$32,$b4
.231f					_end26:
>231f	07					.byte	_end27-*
>2320	00					.byte	$00
>2321	5b 15					.word	C127
>2323	31 32 b7				.byte	$31,$32,$b7
.2326					_end27:
>2326	07					.byte	_end28-*
>2327	00					.byte	$00
>2328	5f 15					.word	C128
>232a	31 32 b8				.byte	$31,$32,$b8
.232d					_end28:
>232d	06					.byte	_end29-*
>232e	00					.byte	$00
>232f	32 15					.word	C15
>2331	31 b5					.byte	$31,$b5
.2333					_end29:
>2333	06					.byte	_end30-*
>2334	00					.byte	$00
>2335	36 15					.word	C16
>2337	31 b6					.byte	$31,$b6
.2339					_end30:
>2339	07					.byte	_end31-*
>233a	00					.byte	$00
>233b	98 14					.word	Times16
>233d	31 36 aa				.byte	$31,$36,$aa
.2340					_end31:
>2340	07					.byte	_end32-*
>2341	00					.byte	$00
>2342	ab 14					.word	Divide16
>2344	31 36 af				.byte	$31,$36,$af
.2347					_end32:
>2347	05					.byte	_end33-*
>2348	00					.byte	$00
>2349	1a 15					.word	C2
>234b	b2					.byte	$b2
.234c					_end33:
>234c	06					.byte	_end34-*
>234d	00					.byte	$00
>234e	a4 14					.word	Times2
>2350	32 aa					.byte	$32,$aa
.2352					_end34:
>2352	06					.byte	_end35-*
>2353	00					.byte	$00
>2354	13 14					.word	Unary2Plus
>2356	32 ab					.byte	$32,$ab
.2358					_end35:
>2358	06					.byte	_end36-*
>2359	00					.byte	$00
>235a	2c 14					.word	Unary2Minus
>235c	32 ad					.byte	$32,$ad
.235e					_end36:
>235e	06					.byte	_end37-*
>235f	00					.byte	$00
>2360	b7 14					.word	Divide2
>2362	32 af					.byte	$32,$af
.2364					_end37:
>2364	06					.byte	_end38-*
>2365	00					.byte	$00
>2366	3a 15					.word	C24
>2368	32 b4					.byte	$32,$b4
.236a					_end38:
>236a	07					.byte	_end39-*
>236b	00					.byte	$00
>236c	63 15					.word	C255
>236e	32 35 b5				.byte	$32,$35,$b5
.2371					_end39:
>2371	07					.byte	_end40-*
>2372	00					.byte	$00
>2373	6e 15					.word	C256
>2375	32 35 b6				.byte	$32,$35,$b6
.2378					_end40:
>2378	08					.byte	_end41-*
>2379	00					.byte	$00
>237a	be 14					.word	Times256
>237c	32 35 36 aa				.byte	$32,$35,$36,$aa
.2380					_end41:
>2380	08					.byte	_end42-*
>2381	00					.byte	$00
>2382	c7 14					.word	Divide256
>2384	32 35 36 af				.byte	$32,$35,$36,$af
.2388					_end42:
>2388	05					.byte	_end43-*
>2389	00					.byte	$00
>238a	1e 15					.word	C3
>238c	b3					.byte	$b3
.238d					_end43:
>238d	06					.byte	_end44-*
>238e	00					.byte	$00
>238f	4b 15					.word	C32
>2391	33 b2					.byte	$33,$b2
.2393					_end44:
>2393	09					.byte	_end45-*
>2394	00					.byte	$00
>2395	9e 15					.word	C32767
>2397	33 32 37 36 b7				.byte	$33,$32,$37,$36,$b7
.239c					_end45:
>239c	09					.byte	_end46-*
>239d	00					.byte	$00
>239e	aa 15					.word	C32768
>23a0	33 32 37 36 b8				.byte	$33,$32,$37,$36,$b8
.23a5					_end46:
>23a5	05					.byte	_end47-*
>23a6	00					.byte	$00
>23a7	22 15					.word	C4
>23a9	b4					.byte	$b4
.23aa					_end47:
>23aa	06					.byte	_end48-*
>23ab	00					.byte	$00
>23ac	a0 14					.word	Times4
>23ae	34 aa					.byte	$34,$aa
.23b0					_end48:
>23b0	06					.byte	_end49-*
>23b1	00					.byte	$00
>23b2	b3 14					.word	Divide4
>23b4	34 af					.byte	$34,$af
.23b6					_end49:
>23b6	08					.byte	_end50-*
>23b7	00					.byte	$00
>23b8	92 15					.word	C4096
>23ba	34 30 39 b6				.byte	$34,$30,$39,$b6
.23be					_end50:
>23be	05					.byte	_end51-*
>23bf	00					.byte	$00
>23c0	26 15					.word	C5
>23c2	b5					.byte	$b5
.23c3					_end51:
>23c3	07					.byte	_end52-*
>23c4	00					.byte	$00
>23c5	7a 15					.word	C512
>23c7	35 31 b2				.byte	$35,$31,$b2
.23ca					_end52:
>23ca	06					.byte	_end53-*
>23cb	00					.byte	$00
>23cc	4f 15					.word	C63
>23ce	36 b3					.byte	$36,$b3
.23d0					_end53:
>23d0	06					.byte	_end54-*
>23d1	00					.byte	$00
>23d2	53 15					.word	C64
>23d4	36 b4					.byte	$36,$b4
.23d6					_end54:
>23d6	05					.byte	_end55-*
>23d7	00					.byte	$00
>23d8	2a 15					.word	C8
>23da	b8					.byte	$b8
.23db					_end55:
>23db	06					.byte	_end56-*
>23dc	00					.byte	$00
>23dd	9c 14					.word	Times8
>23df	38 aa					.byte	$38,$aa
.23e1					_end56:
>23e1	06					.byte	_end57-*
>23e2	00					.byte	$00
>23e3	af 14					.word	Divide8
>23e5	38 af					.byte	$38,$af
.23e7					_end57:
>23e7	05					.byte	_end58-*
>23e8	40					.byte	$40
>23e9	f3 1a					.word	ReturnHandler
>23eb	bb					.byte	$bb
.23ec					_end58:
>23ec	05					.byte	_end59-*
>23ed	00					.byte	$00
>23ee	b8 12					.word	CheckLess
>23f0	bc					.byte	$bc
.23f1					_end59:
>23f1	06					.byte	_end60-*
>23f2	00					.byte	$00
>23f3	d1 12					.word	CheckLessEq
>23f5	3c bd					.byte	$3c,$bd
.23f7					_end60:
>23f7	06					.byte	_end61-*
>23f8	00					.byte	$00
>23f9	81 12					.word	CheckNotEqual
>23fb	3c be					.byte	$3c,$be
.23fd					_end61:
>23fd	05					.byte	_end62-*
>23fe	00					.byte	$00
>23ff	84 12					.word	CheckEqual
>2401	bd					.byte	$bd
.2402					_end62:
>2402	05					.byte	_end63-*
>2403	00					.byte	$00
>2404	d4 12					.word	CheckGreater
>2406	be					.byte	$be
.2407					_end63:
>2407	06					.byte	_end64-*
>2408	00					.byte	$00
>2409	b5 12					.word	CheckGreaterEq
>240b	3e bd					.byte	$3e,$bd
.240d					_end64:
>240d	08					.byte	_end65-*
>240e	00					.byte	$00
>240f	bf 15					.word	TestDup
>2411	3f 44 55 d0				.byte	$3f,$44,$55,$d0
.2415					_end65:
>2415	05					.byte	_end66-*
>2416	00					.byte	$00
>2417	34 16					.word	WordRead
>2419	c0					.byte	$c0
.241a					_end66:
>241a	07					.byte	_end67-*
>241b	00					.byte	$00
>241c	3a 14					.word	Absolute
>241e	41 42 d3				.byte	$41,$42,$d3
.2421					_end67:
>2421	09					.byte	_end68-*
>2422	00					.byte	$00
>2423	77 16					.word	AllocateMemory
>2425	41 4c 4c 4f c3				.byte	$41,$4c,$4c,$4f,$c3
.242a					_end68:
>242a	07					.byte	_end69-*
>242b	00					.byte	$00
>242c	5a 12					.word	And
>242e	41 4e c4				.byte	$41,$4e,$c4
.2431					_end69:
>2431	0a					.byte	_end70-*
>2432	00					.byte	$00
>2433	89 1e					.word	AssertCode
>2435	41 53 53 45 52 d4			.byte	$41,$53,$53,$45,$52,$d4
.243b					_end70:
>243b	09					.byte	_end71-*
>243c	00					.byte	$00
>243d	8d 14					.word	ByteSwap
>243f	42 53 57 41 d0				.byte	$42,$53,$57,$41,$d0
.2444					_end71:
>2444	06					.byte	_end72-*
>2445	00					.byte	$00
>2446	42 16					.word	ByteWrite
>2448	43 a1					.byte	$43,$a1
.244a					_end72:
>244a	06					.byte	_end73-*
>244b	00					.byte	$00
>244c	2b 16					.word	ByteRead
>244e	43 c0					.byte	$43,$c0
.2450					_end73:
>2450	07					.byte	_end74-*
>2451	00					.byte	$00
>2452	b4 1b					.word	ClrHandler
>2454	43 4c d2				.byte	$43,$4c,$d2
.2457					_end74:
>2457	08					.byte	_end75-*
>2458	00					.byte	$00
>2459	b6 15					.word	Drop
>245b	44 52 4f d0				.byte	$44,$52,$4f,$d0
.245f					_end75:
>245f	07					.byte	_end76-*
>2460	00					.byte	$00
>2461	c8 15					.word	Dup
>2463	44 55 d0				.byte	$44,$55,$d0
.2466					_end76:
>2466	08					.byte	_end77-*
>2467	01					.byte	$01
>2468	40 1a					.word	ElseHandler
>246a	45 4c 53 c5				.byte	$45,$4c,$53,$c5
.246e					_end77:
>246e	07					.byte	_end78-*
>246f	00					.byte	$00
>2470	aa 1e					.word	EndProgram
>2472	45 4e c4				.byte	$45,$4e,$c4
.2475					_end78:
>2475	09					.byte	_end79-*
>2476	00					.byte	$00
>2477	43 1a					.word	EndIfHandler
>2479	45 4e 44 49 c6				.byte	$45,$4e,$44,$49,$c6
.247e					_end79:
>247e	07					.byte	_end80-*
>247f	00					.byte	$00
>2480	b8 19					.word	ForHandler
>2482	46 4f d2				.byte	$46,$4f,$d2
.2485					_end80:
>2485	06					.byte	_end81-*
>2486	01					.byte	$01
>2487	3d 1a					.word	IfHandler
>2489	49 c6					.byte	$49,$c6
.248b					_end81:
>248b	09					.byte	_end82-*
>248c	00					.byte	$00
>248d	1c 1a					.word	GetIndex
>248f	49 4e 44 45 d8				.byte	$49,$4e,$44,$45,$d8
.2494					_end82:
>2494	08					.byte	_end83-*
>2495	00					.byte	$00
>2496	e1 1d					.word	ListCode
>2498	4c 49 53 d4				.byte	$4c,$49,$53,$d4
.249c					_end83:
>249c	07					.byte	_end84-*
>249d	00					.byte	$00
>249e	f1 12					.word	Maximum
>24a0	4d 41 d8				.byte	$4d,$41,$d8
.24a3					_end84:
>24a3	07					.byte	_end85-*
>24a4	00					.byte	$00
>24a5	ed 12					.word	Minimum
>24a7	4d 49 ce				.byte	$4d,$49,$ce
.24aa					_end85:
>24aa	07					.byte	_end86-*
>24ab	00					.byte	$00
>24ac	2d 13					.word	Modulus16x16
>24ae	4d 4f c4				.byte	$4d,$4f,$c4
.24b1					_end86:
>24b1	0a					.byte	_end87-*
>24b2	00					.byte	$00
>24b3	41 14					.word	Negate
>24b5	4e 45 47 41 54 c5			.byte	$4e,$45,$47,$41,$54,$c5
.24bb					_end87:
>24bb	07					.byte	_end88-*
>24bc	00					.byte	$00
>24bd	ab 1b					.word	NewHandler
>24bf	4e 45 d7				.byte	$4e,$45,$d7
.24c2					_end88:
>24c2	08					.byte	_end89-*
>24c3	01					.byte	$01
>24c4	e6 19					.word	NextHandler
>24c6	4e 45 58 d4				.byte	$4e,$45,$58,$d4
.24ca					_end89:
>24ca	07					.byte	_end90-*
>24cb	00					.byte	$00
>24cc	fc 15					.word	Nip
>24ce	4e 49 d0				.byte	$4e,$49,$d0
.24d1					_end90:
>24d1	07					.byte	_end91-*
>24d2	00					.byte	$00
>24d3	51 14					.word	OneComplement
>24d5	4e 4f d4				.byte	$4e,$4f,$d4
.24d8					_end91:
>24d8	06					.byte	_end92-*
>24d9	00					.byte	$00
>24da	74 12					.word	LogOr
>24dc	4f d2					.byte	$4f,$d2
.24de					_end92:
>24de	08					.byte	_end93-*
>24df	00					.byte	$00
>24e0	e4 15					.word	Over
>24e2	4f 56 45 d2				.byte	$4f,$56,$45,$d2
.24e6					_end93:
>24e6	0a					.byte	_end94-*
>24e7	00					.byte	$00
>24e8	46 1a					.word	RepeatHandler
>24ea	52 45 50 45 41 d4			.byte	$52,$45,$50,$45,$41,$d4
.24f0					_end94:
>24f0	07					.byte	_end95-*
>24f1	00					.byte	$00
>24f2	d0 14					.word	RandomNumber
>24f4	52 4e c4				.byte	$52,$4e,$c4
.24f7					_end95:
>24f7	07					.byte	_end96-*
>24f8	00					.byte	$00
>24f9	01 16					.word	Rot
>24fb	52 4f d4				.byte	$52,$4f,$d4
.24fe					_end96:
>24fe	07					.byte	_end97-*
>24ff	00					.byte	$00
>2500	5e 1e					.word	RunProgram
>2502	52 55 ce				.byte	$52,$55,$ce
.2505					_end97:
>2505	07					.byte	_end98-*
>2506	00					.byte	$00
>2507	7c 14					.word	SignTOS
>2509	53 47 ce				.byte	$53,$47,$ce
.250c					_end98:
>250c	08					.byte	_end99-*
>250d	00					.byte	$00
>250e	a2 1e					.word	StopCode
>2510	53 54 4f d0				.byte	$53,$54,$4f,$d0
.2514					_end99:
>2514	08					.byte	_end100-*
>2515	00					.byte	$00
>2516	d1 15					.word	Swap
>2518	53 57 41 d0				.byte	$53,$57,$41,$d0
.251c					_end100:
>251c	07					.byte	_end101-*
>251d	00					.byte	$00
>251e	72 1e					.word	Call6502
>2520	53 59 d3				.byte	$53,$59,$d3
.2523					_end101:
>2523	0d					.byte	_end102-*
>2524	00					.byte	$00
>2525	3b 20					.word	IntToString
>2527	54 4f 2e 53 54 52 49 4e			.byte	$54,$4f,$2e,$53,$54,$52,$49,$4e,$c7
>252f	c7
.2530					_end102:
>2530	09					.byte	_end103-*
>2531	01					.byte	$01
>2532	49 1a					.word	UntilHandler
>2534	55 4e 54 49 cc				.byte	$55,$4e,$54,$49,$cc
.2539					_end103:
>2539	09					.byte	_end104-*
>253a	00					.byte	$00
>253b	ad 1e					.word	VlistCode
>253d	56 4c 49 53 d4				.byte	$56,$4c,$49,$53,$d4
.2542					_end104:
>2542	0a					.byte	_end105-*
>2543	40					.byte	$40
>2544	ff 1b					.word	BreakCmd
>2546	58 42 52 45 41 cb			.byte	$58,$42,$52,$45,$41,$cb
.254c					_end105:
>254c	09					.byte	_end106-*
>254d	00					.byte	$00
>254e	f9 1b					.word	ExitDump
>2550	58 44 55 4d d0				.byte	$58,$44,$55,$4d,$d0
.2555					_end106:
>2555	07					.byte	_end107-*
>2556	00					.byte	$00
>2557	67 12					.word	Xor
>2559	58 4f d2				.byte	$58,$4f,$d2
.255c					_end107:
>255c	00					.byte	0

;******  Return to file: kernel.asm

>3fff	ff						.byte 	$FF
.4000					ProgramMemory:

;******  End of listing
