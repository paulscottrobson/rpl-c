
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -q -D encode=0 -c -o kernel_nocode.prg -L kernel.lst -l kernel.lbl kernel.asm
; Thu Jan 16 12:17:42 2020

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=0					encode=0

;******  Processing input file: kernel.asm

=$1000					RplBuild = $1000 							; code starts here.

;******  Processing file: code/data.asm

.0000					NextCode:
>0000							.fill 	5
=3					IP = NextCode+3 							; the IP which points to the current instruction
.0005					rsp:
>0005							.byte 	?
.0006					tos:
>0006							.word 	?
.0008					srcPtr:
>0008							.word 	?
.000a					bufPtr:
>000a							.word 	?
.000c					matchPtr:
>000c							.word 	?
.000e					nextFreeMem:
>000e							.word 	?
.0010					temp1:
>0010							.word 	?
.0012					temp2:
>0012							.word 	?
.0014					temp3:
>0014							.word 	?
.0016					temp4:
>0016							.word 	?
.0018					listPtr:
>0018							.word 	?
.001a					SignCount:
>001a							.byte 	?
.001b					RandomSeed:
>001b							.word 	?
.001d					ListCount:
>001d							.byte 	?
.001e					ListLowest:
>001e							.word 	?
=$102					stack2Low = $102							; access other stack members following tsx
=$101					stack2High = $101							; (which requires saving X, not on the stack !)
=$104					stack3Low = $104
=$103					stack3High = $103
=$600					azVariables = $600 							; 26 x 2 variables occupying 52 bytes * PAGE BOUNDARY *
=16					hashTableSize = 16 							; hash tables for variables.
=$640					hashTable = $640 							; hash tables start here * ALL ON ONE PAGE *
=$810					textBuffer = $810 							; buffer for text.
=$700					returnStack = $700							; return stack (1 page)
=$700					returnStackLow = returnStack
=1856					returnStackHigh = returnStack+$40
=1920					returnStackX = returnStack+$80
=$80					NumberStackBase = $80 						; number stack down from here.
=$910					encodeBuffer = $910 						; buffer for encoded program
=0					COL_BLACK = 0
=1					COL_RED = 1
=2					COL_GREEN = 2
=3					COL_YELLOW = 3
=4					COL_BLUE = 4
=5					COL_MAGENTA = 5
=6					COL_CYAN = 6
=7					COL_WHITE = 7
=8					COL_RVS = 8
=2					CTH_LineNo = COL_Green
=6					CTH_Keyword = COL_Cyan
=11					CTH_Comment = COL_Yellow+COL_Rvs
=7					CTH_Definition = COL_White
=5					CTH_String = COL_Magenta
=3					CTH_Call = COL_Yellow
=7					CTH_Variable = COL_White

;******  Return to file: kernel.asm

.1000	a2 ff		ldx #$ff			ldx 	#$FF 						; reset the stack
.1002	9a		txs				txs
.1003	20 1c 24	jsr $241c			jsr 	ExternInitialise
.1006	a9 97		lda #$97			lda 	#BootMsg & $FF
.1008	a0 23		ldy #$23			ldy 	#BootMsg >> 8
.100a	20 10 25	jsr $2510			jsr 	EXPrintString
.100d					WarmStartBlankStack:
.100d	86 10		stx $10				stx 	temp1
.100f	a2 80		ldx #$80			ldx 	#NumberStackBase
.1011	9a		txs				txs
.1012	a6 10		ldx $10				ldx 	temp1
.1014					WarmStart:
.1014	a9 03		lda #$03			lda 	#COL_Yellow
.1016	20 55 24	jsr $2455			jsr 	ExternColour
.1019	20 78 24	jsr $2478			jsr 	ExternInput
.101c	a9 06		lda #$06			lda 	#COL_Cyan
.101e	20 55 24	jsr $2455			jsr 	ExternColour
.1021	a2 10		ldx #$10			ldx 	#encodeBuffer & $FF 		; run what is in the encode buffer.
.1023	a0 09		ldy #$09			ldy 	#encodeBuffer >> 8
.1025	20 41 10	jsr $1041			jsr 	InitialiseCoreCode 			; initialise the NEXT routine at $00 so error line# works
.1028	a9 10		lda #$10			lda 	#textBuffer & $FF
.102a	a0 08		ldy #$08			ldy 	#textBuffer >> 8
.102c	20 fb 14	jsr $14fb			jsr 	EncodeProgram
.102f	ad 11 09	lda $0911			lda 	encodeBuffer+1 				; has a line number been entered ?
.1032	0d 12 09	ora $0912			ora 	encodeBuffer+2
.1035	d0 05		bne $103c			bne 	LineEditor 					; if so, do the line editing code.
.1037	64 05		stz $05				stz 	rsp
.1039	4c 00 00	jmp $0000			jmp 	NextCode
.103c					LineEditor:
.103c	20 43 1d	jsr $1d43			jsr 	EditProgram
.103f	80 cc		bra $100d			bra 	WarmStartBlankStack

;******  Processing file: code/core.src

.1041					InitialiseCoreCode:
.1041	a9 e8		lda #$e8			lda 	#$E8 					; Copy INX INX 			4 cycles when run
.1043	85 00		sta $00				sta 	NextCode
.1045	85 01		sta $01				sta 	NextCode+1
.1047	a9 7c		lda #$7c			lda 	#$7C 					; Copy JMP ($aaaa,x) 	6 cycles when run
.1049	85 02		sta $02				sta 	NextCode+2
.104b	86 03		stx $03				stx 	NextCode+3 				; set the indirect address (IP)
.104d	84 04		sty $04				sty 	NextCode+4
.104f	a2 01		ldx #$01			ldx 	#1 						; set up to run from provided word.
.1051	60		rts				rts								; (2 INX skip offset and line#)
.1052					Literal2Byte:
.1052	a5 06		lda $06				lda 	TOS
.1054	48		pha				pha
.1055	a5 07		lda $07				lda 	TOS+1
.1057	48		pha				pha
.1058	e8		inx				inx  							; point X to the word
.1059	e8		inx				inx
.105a	8a		txa				txa 							; copy into Y
.105b	a8		tay				tay
.105c	b1 03		lda ($03),y			lda 	(IP),y 					; read it. the LSB
.105e	85 06		sta $06				sta 	TOS
.1060	c8		iny				iny 							; read and push the MSB
.1061	b1 03		lda ($03),y			lda 	(IP),y
.1063	85 07		sta $07				sta 	TOS+1
.1065	4c 00 00	jmp $0000			jmp 	NextCode
.1068					Literal2ByteDecode:
.1068	a9 06		lda #$06			lda 	#CTH_Keyword
.106a	20 04 1d	jsr $1d04			jsr 	DecodeWriteBuffer
.106d	b1 08		lda ($08),y			lda 	(srcPtr),y
.106f	aa		tax				tax
.1070	c8		iny				iny
.1071	b1 08		lda ($08),y			lda 	(srcPtr),y
.1073	a8		tay				tay
.1074	8a		txa				txa
.1075	38		sec				sec 							; output signed
.1076	20 26 1d	jsr $1d26			jsr 	DecodeYAToBuffer
.1079	60		rts				rts
.107a					LiteralString:
.107a	a5 06		lda $06				lda 	TOS
.107c	48		pha				pha
.107d	a5 07		lda $07				lda 	TOS+1
.107f	48		pha				pha
.1080	e8		inx				inx
.1081	e8		inx				inx 							; skip over current word
.1082	8a		txa				txa 							; add to IP + 1 to give string address
.1083	a8		tay				tay 							; put in Y
.1084	38		sec				sec 							; make that TOS
.1085	65 03		adc $03				adc 	IP
.1087	85 06		sta $06				sta 	TOS
.1089	a5 04		lda $04				lda 	IP+1
.108b	69 00		adc #$00			adc 	#0
.108d	85 07		sta $07				sta 	TOS+1
.108f	8a		txa				txa 							; add data length to X
.1090	18		clc				clc
.1091	71 03		adc ($03),y			adc 	(IP),y
.1093	aa		tax				tax
.1094	ca		dex				dex
.1095	ca		dex				dex
.1096	4c 00 00	jmp $0000			jmp 	NextCode
.1099					LiteralStringDecoder:
.1099	a9 05		lda #$05			lda 	#CTH_String
.109b	20 04 1d	jsr $1d04			jsr 	DecodeWriteBuffer
.109e	a9 22		lda #$22			lda 	#'"'
.10a0	20 04 1d	jsr $1d04			jsr 	DecodeWriteBuffer
.10a3	20 0d 1d	jsr $1d0d			jsr 	DecodeOutputData
.10a6	20 04 1d	jsr $1d04			jsr 	DecodeWriteBuffer
.10a9	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/binary.src

.10aa					Add:
.10aa	7a		ply				ply
.10ab	68		pla				pla
.10ac	18		clc				clc
.10ad	65 06		adc $06				adc 	TOS
.10af	85 06		sta $06				sta 	TOS
.10b1	98		tya				tya
.10b2	65 07		adc $07				adc 	TOS+1
.10b4	85 07		sta $07				sta 	TOS+1
.10b6	4c 00 00	jmp $0000			jmp 	NextCode
.10b9					Subtract:
.10b9	7a		ply				ply
.10ba	68		pla				pla
.10bb	38		sec				sec
.10bc	e5 06		sbc $06				sbc 	TOS
.10be	85 06		sta $06				sta 	TOS
.10c0	98		tya				tya
.10c1	e5 07		sbc $07				sbc 	TOS+1
.10c3	85 07		sta $07				sta 	TOS+1
.10c5	4c 00 00	jmp $0000			jmp 	NextCode
.10c8					And:
.10c8	68		pla				pla
.10c9	25 07		and $07				and 	TOS+1
.10cb	85 07		sta $07				sta 	TOS+1
.10cd	68		pla				pla
.10ce	25 06		and $06				and 	TOS
.10d0	85 06		sta $06				sta 	TOS
.10d2	4c 00 00	jmp $0000			jmp 	NextCode
.10d5					Xor:
.10d5	68		pla				pla
.10d6	45 07		eor $07				eor 	TOS+1
.10d8	85 07		sta $07				sta 	TOS+1
.10da	68		pla				pla
.10db	45 06		eor $06				eor 	TOS
.10dd	85 06		sta $06				sta 	TOS
.10df	4c 00 00	jmp $0000			jmp 	NextCode
.10e2					LogOr:
.10e2	68		pla				pla
.10e3	05 07		ora $07				ora 	TOS+1
.10e5	85 07		sta $07				sta 	TOS+1
.10e7	68		pla				pla
.10e8	05 06		ora $06				ora 	TOS
.10ea	85 06		sta $06				sta 	TOS
.10ec	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/compare.src

.10ef					CheckNotEqual:
.10ef	38		sec				sec
.10f0	80 01		bra $10f3			bra 	CECode
.10f2					CheckEqual:
.10f2	18		clc				clc
.10f3					CECode:
.10f3	86 10		stx $10				stx 	temp1
.10f5	ba		tsx				tsx
.10f6	08		php				php
.10f7	a5 06		lda $06				lda 	TOS
.10f9	5d 02 01	eor $0102,x			eor 	Stack2Low,x
.10fc	d0 17		bne $1115			bne	 	CompareFalse
.10fe	a5 07		lda $07				lda 	TOS+1
.1100	5d 01 01	eor $0101,x			eor 	Stack2High,x
.1103	d0 10		bne $1115			bne 	CompareFalse
.1105					CompareTrue:
.1105	a6 10		ldx $10				ldx 	temp1
.1107	28		plp				plp
.1108	b0 10		bcs $111a			bcs		CompareFalse2
.110a					CompareTrue2:
.110a	68		pla				pla
.110b	68		pla				pla
.110c	a9 ff		lda #$ff			lda 	#$FF
.110e	85 06		sta $06				sta 	TOS
.1110	85 07		sta $07				sta 	TOS+1
.1112	4c 00 00	jmp $0000			jmp 	NextCode
.1115					CompareFalse:
.1115	a6 10		ldx $10				ldx 	temp1
.1117	28		plp				plp
.1118	b0 f0		bcs $110a			bcs		CompareTrue2
.111a					CompareFalse2:
.111a	68		pla				pla
.111b	68		pla				pla
.111c	64 06		stz $06				stz 	TOS
.111e	64 07		stz $07				stz 	TOS+1
.1120	4c 00 00	jmp $0000			jmp 	NextCode
.1123					CheckGreaterEq:
.1123	38		sec				sec
.1124	80 01		bra $1127			bra		CLCode
.1126					CheckLess:
.1126	18		clc				clc
.1127	86 10		stx $10		CLCode:	stx 	temp1
.1129	ba		tsx				tsx
.112a	08		php				php
.112b	18		clc				clc
.112c	a5 06		lda $06				lda 	TOS
.112e	fd 02 01	sbc $0102,x			sbc 	Stack2Low,x
.1131	a5 07		lda $07				lda 	TOS+1
.1133	fd 01 01	sbc $0101,x			sbc 	Stack2High,x
.1136	50 02		bvc $113a			bvc 	_CLNoFlip
.1138	49 80		eor #$80			eor 	#$80
.113a					_CLNoFlip:
.113a	0a		asl a				asl 	a
.113b	b0 d8		bcs $1115			bcs 	CompareFalse
.113d	80 c6		bra $1105			bra 	CompareTrue
.113f					CheckLessEq:
.113f	38		sec				sec
.1140	80 01		bra $1143			bra		CGCode
.1142					CheckGreater:
.1142	18		clc				clc
.1143					CGCode:
.1143	86 10		stx $10				stx 	temp1
.1145	ba		tsx				tsx
.1146	08		php				php
.1147	18		clc				clc
.1148	bd 02 01	lda $0102,x			lda 	Stack2Low,x
.114b	e5 06		sbc $06				sbc 	TOS
.114d	bd 01 01	lda $0101,x			lda 	Stack2High,x
.1150	e5 07		sbc $07				sbc 	TOS+1
.1152	50 02		bvc $1156			bvc 	_CGNoFlip
.1154	49 80		eor #$80			eor 	#$80
.1156					_CGNoFlip:
.1156	0a		asl a				asl 	a
.1157	b0 bc		bcs $1115			bcs 	CompareFalse
.1159	80 aa		bra $1105			bra 	CompareTrue
.115b					Minimum:
.115b	a9 00		lda #$00			lda 	#0
.115d	80 02		bra $1161			bra 	MinMaxCode
.115f					Maximum:
.115f	a9 80		lda #$80			lda 	#$80
.1161					MinMaxCode:
.1161	85 11		sta $11				sta 	temp1+1
.1163	86 10		stx $10				stx 	temp1
.1165	ba		tsx				tsx
.1166	38		sec				sec
.1167	a5 06		lda $06				lda 	TOS
.1169	fd 02 01	sbc $0102,x			sbc 	Stack2Low,x
.116c	a5 07		lda $07				lda 	TOS+1
.116e	fd 01 01	sbc $0101,x			sbc 	Stack2High,x
.1171	50 02		bvc $1175			bvc 	_MMNoFlip
.1173	49 80		eor #$80			eor 	#$80
.1175					_MMNoFlip:
.1175	45 11		eor $11				eor 	temp1+1
.1177	30 0a		bmi $1183			bmi 	_MMNoCopy
.1179	bd 02 01	lda $0102,x			lda 	Stack2Low,x
.117c	85 06		sta $06				sta 	TOS
.117e	bd 01 01	lda $0101,x			lda 	Stack2High,x
.1181	85 07		sta $07				sta 	TOS+1
.1183					_MMNoCopy:
.1183	a6 10		ldx $10				ldx 	temp1
.1185	68		pla				pla
.1186	68		pla				pla
.1187	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/divide.src

.118a					Divide16x16:
.118a	86 12		stx $12				stx 	temp2
.118c	ba		tsx				tsx
.118d	20 b0 11	jsr $11b0			jsr 	IntegerDivide
.1190	68		pla				pla
.1191	85 07		sta $07				sta 	TOS+1
.1193	68		pla				pla
.1194	85 06		sta $06				sta 	TOS
.1196	a6 12		ldx $12				ldx 	temp2
.1198	4c 00 00	jmp $0000			jmp 	NextCode
.119b					Modulus16x16:
.119b	86 12		stx $12				stx 	temp2
.119d	ba		tsx				tsx
.119e	20 b0 11	jsr $11b0			jsr 	IntegerDivide
.11a1	a6 12		ldx $12				ldx 	temp2
.11a3	68		pla				pla
.11a4	68		pla				pla
.11a5	a5 10		lda $10				lda 	temp1
.11a7	85 06		sta $06				sta 	TOS
.11a9	a5 11		lda $11				lda 	temp1+1
.11ab	85 07		sta $07				sta 	TOS+1
.11ad	4c 00 00	jmp $0000			jmp 	NextCode
.11b0					IntegerDivide:
.11b0	a5 06		lda $06				lda 	TOS 				; check for division by zero.
.11b2	05 07		ora $07				ora 	TOS+1
.11b4	d0 14		bne $11ca			bne 	_BFDOkay
.11b6	20 e9 23	jsr $23e9			jsr 	ErrorHandler
>11b9	44 49 56 49 53 49 4f 4e				.text 	"DIVISION BY ZERO",0
>11c1	20 42 59 20 5a 45 52 4f 00
.11ca					_BFDOkay:
.11ca	64 10		stz $10				stz 	temp1 						; Q/Dividend/Left in +0
.11cc	64 11		stz $11				stz 	temp1+1 					; M/Divisor/Right in +2
.11ce	64 1a		stz $1a				stz 	SignCount 					; Count of signs.
.11d0	20 0b 12	jsr $120b			jsr 	CheckIntegerNegate 			; negate 2nd (and bump sign count)
.11d3	20 25 12	jsr $1225			jsr 	CheckTOSNegate 				; negate TOS (and bump sign count)
.11d6	5a		phy				phy 								; Y is the counter
.11d7	a0 10		ldy #$10			ldy 	#16 						; 16 iterations of the loop.
.11d9					_BFDLoop:
.11d9	1e 02 01	asl $0102,x			asl 	Stack2Low,x 				; shift AQ left.
.11dc	3e 01 01	rol $0101,x			rol 	Stack2High,x
.11df	26 10		rol $10				rol 	temp1
.11e1	26 11		rol $11				rol 	temp1+1
.11e3	38		sec				sec
.11e4	a5 10		lda $10				lda 	temp1+0 					; Calculate A-M on stack.
.11e6	e5 06		sbc $06				sbc 	TOS
.11e8	48		pha				pha
.11e9	a5 11		lda $11				lda 	temp1+1
.11eb	e5 07		sbc $07				sbc 	TOS+1
.11ed	90 0f		bcc $11fe			bcc 	_BFDNoAdd
.11ef	85 11		sta $11				sta 	temp1+1
.11f1	68		pla				pla
.11f2	85 10		sta $10				sta 	temp1+0
.11f4	bd 02 01	lda $0102,x			lda 	Stack2Low,x 				; set Q bit 1.
.11f7	09 01		ora #$01			ora 	#1
.11f9	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.11fc	80 01		bra $11ff			bra 	_BFDNext
.11fe					_BFDNoAdd:
.11fe	68		pla				pla 								; Throw away the intermediate calculations
.11ff					_BFDNext:
.11ff	88		dey				dey
.1200	d0 d7		bne $11d9			bne 	_BFDLoop
.1202	7a		ply				ply 								; restore Y
.1203	46 1a		lsr $1a				lsr 	SignCount 					; if sign count odd,
.1205	90 03		bcc $120a			bcc 	_BFDUnsigned 				; then the result is signed
.1207	20 11 12	jsr $1211			jsr		IntegerNegateAlways 		; negate the result
.120a					_BFDUnsigned:
.120a	60		rts				rts
.120b					CheckIntegerNegate:
.120b	bd 01 01	lda $0101,x			lda 	Stack2High,x 				; is it -ve = MSB set ?
.120e	30 01		bmi $1211			bmi 	IntegerNegateAlways 		; if so negate it
.1210	60		rts				rts
.1211					IntegerNegateAlways:
.1211	e6 1a		inc $1a				inc 	SignCount 					; bump the count of signs
.1213	38		sec				sec 								; negate
.1214	a9 00		lda #$00			lda 	#0
.1216	fd 02 01	sbc $0102,x			sbc 	Stack2Low,x
.1219	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.121c	a9 00		lda #$00			lda 	#0
.121e	fd 01 01	sbc $0101,x			sbc 	Stack2High,x
.1221	9d 01 01	sta $0101,x			sta 	Stack2High,x
.1224	60		rts				rts
.1225					CheckTOSNegate:
.1225	a5 07		lda $07				lda 	TOS+1
.1227	10 0f		bpl $1238			bpl		CTNNoChange
.1229	e6 1a		inc $1a				inc 	SignCount
.122b					TOSNegateAlways:
.122b	38		sec				sec
.122c	a9 00		lda #$00			lda 	#0
.122e	e5 06		sbc $06				sbc 	TOS
.1230	85 06		sta $06				sta 	TOS
.1232	a9 00		lda #$00			lda 	#0
.1234	e5 07		sbc $07				sbc 	TOS+1
.1236	85 07		sta $07				sta 	TOS+1
.1238					CTNNoChange:
.1238	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/multiply.src

.1239					Multiply16x16:
.1239	86 10		stx $10				stx 	temp1
.123b	ba		tsx				tsx
.123c	bd 02 01	lda $0102,x			lda 	Stack2Low,x 				; 2nd value on stack to temp1
.123f	85 12		sta $12				sta 	temp2
.1241	bd 01 01	lda $0101,x			lda		Stack2High,x
.1244	85 13		sta $13				sta 	temp2+1
.1246	9e 02 01	stz $0102,x			stz 	Stack2Low,x 				; zero 2nd value on stack
.1249	9e 01 01	stz $0101,x			stz 	Stack2High,x
.124c					_MultLoop:
.124c	46 13		lsr $13				lsr 	temp2+1 					; ror temp2 into C
.124e	66 12		ror $12				ror 	temp2
.1250	90 11		bcc $1263			bcc 	_MultNoAdd
.1252	18		clc				clc 								; add 1st to 2nd
.1253	a5 06		lda $06				lda 	TOS
.1255	7d 02 01	adc $0102,x			adc 	Stack2Low,x
.1258	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.125b	a5 07		lda $07				lda 	TOS+1
.125d	7d 01 01	adc $0101,x			adc 	Stack2High,x
.1260	9d 01 01	sta $0101,x			sta 	Stack2High,x
.1263					_MultNoAdd:
.1263	06 06		asl $06				asl 	TOS 						; shift 1st left
.1265	26 07		rol $07				rol 	TOS+1
.1267	a5 12		lda $12				lda 	temp2	 					; until zero
.1269	05 13		ora $13				ora 	temp2+1
.126b	d0 df		bne $124c			bne 	_MultLoop
.126d	a6 10		ldx $10				ldx 	temp1 						; restore X load result
.126f	68		pla				pla
.1270	85 07		sta $07				sta 	TOS+1
.1272	68		pla				pla
.1273	85 06		sta $06				sta 	TOS
.1275	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/unary.src

.1278					Unary1Plus:
.1278	e6 06		inc $06				inc 	TOS
.127a	d0 02		bne $127e			bne 	_U1PSkip
.127c	e6 07		inc $07				inc 	TOS+1
.127e					_U1PSkip:
.127e	4c 00 00	jmp $0000			jmp 	NextCode
.1281					Unary2Plus:
.1281	18		clc				clc
.1282	a5 06		lda $06				lda 	TOS
.1284	69 02		adc #$02			adc 	#2
.1286	85 06		sta $06				sta 	TOS
.1288	90 02		bcc $128c			bcc 	_U1PSkip
.128a	e6 07		inc $07				inc 	TOS+1
.128c					_U1PSkip:
.128c	4c 00 00	jmp $0000			jmp 	NextCode
.128f					Unary1Minus:
.128f	a5 06		lda $06				lda 	TOS
.1291	d0 02		bne $1295			bne 	_U1MSkip
.1293	c6 07		dec $07				dec 	TOS+1
.1295					_U1MSkip:
.1295	c6 06		dec $06				dec 	TOS
.1297	4c 00 00	jmp $0000			jmp 	NextCode
.129a					Unary2Minus:
.129a	38		sec				sec
.129b	a5 06		lda $06				lda 	TOS
.129d	e9 02		sbc #$02			sbc 	#2
.129f	85 06		sta $06				sta 	TOS
.12a1	b0 02		bcs $12a5			bcs 	_U1PSkip
.12a3	c6 07		dec $07				dec 	TOS+1
.12a5					_U1PSkip:
.12a5	4c 00 00	jmp $0000			jmp 	NextCode
.12a8					Absolute:
.12a8	a5 07		lda $07				lda 	TOS+1
.12aa	30 03		bmi $12af			bmi 	Negate
.12ac	4c 00 00	jmp $0000			jmp 	NextCode
.12af					Negate:
.12af	38		sec				sec
.12b0	a9 00		lda #$00			lda 	#0
.12b2	e5 06		sbc $06				sbc 	TOS
.12b4	85 06		sta $06				sta 	TOS
.12b6	a9 00		lda #$00			lda 	#0
.12b8	e5 07		sbc $07				sbc 	TOS+1
.12ba	85 07		sta $07				sta 	TOS+1
.12bc	4c 00 00	jmp $0000			jmp 	NextCode
.12bf					OneComplement:
.12bf	a5 06		lda $06				lda 	TOS
.12c1	49 ff		eor #$ff			eor 	#$FF
.12c3	85 06		sta $06				sta 	TOS
.12c5	a5 07		lda $07				lda 	TOS+1
.12c7	49 ff		eor #$ff			eor 	#$FF
.12c9	85 07		sta $07				sta 	TOS+1
.12cb	4c 00 00	jmp $0000			jmp 	NextCode
.12ce					CheckMinus:
.12ce	a5 07		lda $07				lda 	TOS+1
.12d0	30 07		bmi $12d9			bmi 	UnaryTrue
.12d2					UnaryFalse:
.12d2	64 06		stz $06				stz 	TOS
.12d4	64 07		stz $07				stz 	TOS+1
.12d6	4c 00 00	jmp $0000			jmp 	NextCode
.12d9					UnaryTrue:
.12d9	a9 ff		lda #$ff			lda 	#$FF
.12db	85 06		sta $06				sta 	TOS
.12dd	85 07		sta $07				sta 	TOS+1
.12df	4c 00 00	jmp $0000			jmp 	NextCode
.12e2					CheckZero:
.12e2	a5 06		lda $06				lda 	TOS
.12e4	05 07		ora $07				ora 	TOS+1
.12e6	d0 ea		bne $12d2			bne 	UnaryFalse
.12e8	80 ef		bra $12d9			bra 	UnaryTrue
.12ea					SignTOS:
.12ea	a5 07		lda $07				lda 	TOS+1
.12ec	30 eb		bmi $12d9			bmi		UnaryTrue
.12ee	05 06		ora $06				ora 	TOS
.12f0	f0 e0		beq $12d2			beq 	UnaryFalse
.12f2	a9 01		lda #$01			lda 	#1
.12f4	85 06		sta $06				sta 	TOS
.12f6	64 07		stz $07				stz		TOS+1
.12f8	4c 00 00	jmp $0000			jmp 	NextCode
.12fb					ByteSwap:
.12fb	a5 06		lda $06				lda 	TOS
.12fd	a4 07		ldy $07				ldy 	TOS+1
.12ff	85 07		sta $07				sta 	TOS+1
.1301	84 06		sty $06				sty 	TOS
.1303	4c 00 00	jmp $0000			jmp 	NextCode
.1306					Times16:
.1306	06 06		asl $06				asl 	TOS
.1308	26 07		rol $07				rol 	TOS+1
.130a					Times8:
.130a	06 06		asl $06				asl 	TOS
.130c	26 07		rol $07				rol 	TOS+1
.130e					Times4:
.130e	06 06		asl $06				asl 	TOS
.1310	26 07		rol $07				rol 	TOS+1
.1312					Times2:
.1312	06 06		asl $06				asl 	TOS
.1314	26 07		rol $07				rol 	TOS+1
.1316	4c 00 00	jmp $0000			jmp 	NextCode
.1319					Divide16:
.1319	46 07		lsr $07				lsr 	TOS+1
.131b	66 06		ror $06				ror 	TOS
.131d					Divide8:
.131d	46 07		lsr $07				lsr 	TOS+1
.131f	66 06		ror $06				ror 	TOS
.1321					Divide4:
.1321	46 07		lsr $07				lsr 	TOS+1
.1323	66 06		ror $06				ror 	TOS
.1325					Divide2:
.1325	46 07		lsr $07				lsr 	TOS+1
.1327	66 06		ror $06				ror 	TOS
.1329	4c 00 00	jmp $0000			jmp 	NextCode
.132c					Times256:
.132c	a5 06		lda $06				lda 	TOS
.132e	85 07		sta $07				sta 	TOS+1
.1330	64 06		stz $06				stz 	TOS
.1332	4c 00 00	jmp $0000			jmp 	NextCode
.1335					Divide256:
.1335	a5 07		lda $07				lda 	TOS+1
.1337	85 06		sta $06				sta 	TOS
.1339	64 07		stz $07				stz 	TOS+1
.133b	4c 00 00	jmp $0000			jmp 	NextCode
.133e					RandomNumber:
.133e	a5 06		lda $06				lda 	TOS
.1340	48		pha				pha
.1341	a5 07		lda $07				lda 	TOS+1
.1343	48		pha				pha
.1344	a5 1b		lda $1b				lda 	randomSeed
.1346	05 1c		ora $1c				ora 	randomSeed+1
.1348	d0 08		bne $1352			bne 	_RH_NoInit
.134a	a9 7c		lda #$7c			lda 	#$7C
.134c	85 1b		sta $1b				sta 	randomSeed
.134e	a9 a1		lda #$a1			lda 	#$A1
.1350	85 1c		sta $1c				sta 	randomSeed+1
.1352					_RH_NoInit:
.1352	a5 1b		lda $1b				lda 	randomSeed
.1354	4a		lsr a		        lsr		a
.1355	26 1c		rol $1c		        rol 	randomSeed+1
.1357	90 02		bcc $135b	        bcc 	_RH_NoEor
.1359	49 b4		eor #$b4	        eor 	#$B4
.135b					_RH_NoEor:
.135b	85 1b		sta $1b		        sta 	randomSeed
.135d	45 1c		eor $1c		        eor 	randomSeed+1
.135f	85 07		sta $07		        sta 	TOS+1
.1361	a5 1b		lda $1b		        lda 	randomSeed
.1363	85 06		sta $06		        sta 	TOS
.1365	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/data/literals.src

.1368					Constant0:
.1368	a5 06		lda $06				lda 	TOS
.136a	48		pha				pha
.136b	a5 07		lda $07				lda 	TOS+1
.136d	48		pha				pha
.136e	64 06		stz $06				stz 	TOS
.1370	64 07		stz $07				stz 	TOS+1
.1372	4c 00 00	jmp $0000			jmp 	NextCode
.1375					ConstantMinus1:
.1375	a5 06		lda $06				lda 	TOS
.1377	48		pha				pha
.1378	a5 07		lda $07				lda 	TOS+1
.137a	48		pha				pha
.137b	a9 ff		lda #$ff			lda 	#$FF
.137d	85 06		sta $06				sta 	TOS
.137f	85 07		sta $07				sta 	TOS+1
.1381	4c 00 00	jmp $0000			jmp 	NextCode
.1384					C1:
.1384	a0 01		ldy #$01			ldy 	#1
.1386	80 24		bra $13ac			bra 	Const1Byte
.1388					C2:
.1388	a0 02		ldy #$02			ldy 	#2
.138a	80 20		bra $13ac			bra 	Const1Byte
.138c					C3:
.138c	a0 03		ldy #$03			ldy 	#3
.138e	80 1c		bra $13ac			bra 	Const1Byte
.1390					C4:
.1390	a0 04		ldy #$04			ldy 	#4
.1392	80 18		bra $13ac			bra 	Const1Byte
.1394					C5:
.1394	a0 05		ldy #$05			ldy 	#5
.1396	80 14		bra $13ac			bra 	Const1Byte
.1398					C8:
.1398	a0 08		ldy #$08			ldy 	#8
.139a	80 10		bra $13ac			bra 	Const1Byte
.139c					C10:
.139c	a0 0a		ldy #$0a			ldy 	#10
.139e	80 0c		bra $13ac			bra 	Const1Byte
.13a0					C15:
.13a0	a0 0f		ldy #$0f			ldy 	#15
.13a2	80 08		bra $13ac			bra 	Const1Byte
.13a4					C16:
.13a4	a0 10		ldy #$10			ldy 	#16
.13a6	80 04		bra $13ac			bra 	Const1Byte
.13a8					C24:
.13a8	a0 18		ldy #$18			ldy 	#24
.13aa	80 00		bra $13ac			bra 	Const1Byte
.13ac					Const1Byte:
.13ac	a5 06		lda $06				lda 	TOS
.13ae	48		pha				pha
.13af	a5 07		lda $07				lda 	TOS+1
.13b1	48		pha				pha
.13b2	84 06		sty $06				sty 	TOS
.13b4	64 07		stz $07				stz 	TOS+1
.13b6	4c 00 00	jmp $0000			jmp 	NextCode
.13b9					C32:
.13b9	a0 20		ldy #$20			ldy 	#32
.13bb	80 ef		bra $13ac			bra 	Const1Byte
.13bd					C63:
.13bd	a0 3f		ldy #$3f			ldy 	#63
.13bf	80 eb		bra $13ac			bra 	Const1Byte
.13c1					C64:
.13c1	a0 40		ldy #$40			ldy 	#64
.13c3	80 e7		bra $13ac			bra 	Const1Byte
.13c5					C100:
.13c5	a0 64		ldy #$64			ldy 	#100
.13c7	80 e3		bra $13ac			bra 	Const1Byte
.13c9					C127:
.13c9	a0 7f		ldy #$7f			ldy 	#127
.13cb	80 df		bra $13ac			bra 	Const1Byte
.13cd					C128:
.13cd	a0 80		ldy #$80			ldy 	#128
.13cf	80 db		bra $13ac			bra 	Const1Byte
.13d1					C255:
.13d1	a0 ff		ldy #$ff			ldy 	#255
.13d3	80 d7		bra $13ac			bra 	Const1Byte
.13d5					Const2Byte:
.13d5	85 06		sta $06				sta 	TOS
.13d7	84 07		sty $07				sty 	TOS+1
.13d9	4c 00 00	jmp $0000			jmp 	NextCode
.13dc					C256:
.13dc	a5 06		lda $06				lda 	TOS
.13de	48		pha				pha
.13df	a5 07		lda $07				lda 	TOS+1
.13e1	48		pha				pha
.13e2	a9 00		lda #$00			lda 	#(256) & $FF
.13e4	a0 01		ldy #$01			ldy 	#(256) >> 8
.13e6	80 ed		bra $13d5			bra 	Const2Byte
.13e8					C512:
.13e8	a5 06		lda $06				lda 	TOS
.13ea	48		pha				pha
.13eb	a5 07		lda $07				lda 	TOS+1
.13ed	48		pha				pha
.13ee	a9 00		lda #$00			lda 	#(512) & $FF
.13f0	a0 02		ldy #$02			ldy 	#(512) >> 8
.13f2	80 e1		bra $13d5			bra 	Const2Byte
.13f4					C1024:
.13f4	a5 06		lda $06				lda 	TOS
.13f6	48		pha				pha
.13f7	a5 07		lda $07				lda 	TOS+1
.13f9	48		pha				pha
.13fa	a9 00		lda #$00			lda 	#(1024) & $FF
.13fc	a0 04		ldy #$04			ldy 	#(1024) >> 8
.13fe	80 d5		bra $13d5			bra 	Const2Byte
.1400					C4096:
.1400	a5 06		lda $06				lda 	TOS
.1402	48		pha				pha
.1403	a5 07		lda $07				lda 	TOS+1
.1405	48		pha				pha
.1406	a9 00		lda #$00			lda 	#(4096) & $FF
.1408	a0 10		ldy #$10			ldy 	#(4096) >> 8
.140a	80 c9		bra $13d5			bra 	Const2Byte
.140c					C32767:
.140c	a5 06		lda $06				lda 	TOS
.140e	48		pha				pha
.140f	a5 07		lda $07				lda 	TOS+1
.1411	48		pha				pha
.1412	a9 ff		lda #$ff			lda 	#(32767) & $FF
.1414	a0 7f		ldy #$7f			ldy 	#(32767) >> 8
.1416	80 bd		bra $13d5			bra 	Const2Byte
.1418					C32768:
.1418	a5 06		lda $06				lda 	TOS
.141a	48		pha				pha
.141b	a5 07		lda $07				lda 	TOS+1
.141d	48		pha				pha
.141e	a9 00		lda #$00			lda 	#(32768) & $FF
.1420	a0 80		ldy #$80			ldy 	#(32768) >> 8
.1422	80 b1		bra $13d5			bra 	Const2Byte

;******  Return to file: kernel.asm


;******  Processing file: words/data/stack.src

.1424					Drop:
.1424	68		pla				pla
.1425	85 07		sta $07				sta 	TOS+1
.1427	68		pla				pla
.1428	85 06		sta $06				sta 	TOS
.142a	4c 00 00	jmp $0000			jmp 	NextCode
.142d					TestDup:
.142d	a5 06		lda $06				lda 	TOS
.142f	05 07		ora $07				ora 	TOS+1
.1431	d0 03		bne $1436			bne 	Dup
.1433	4c 00 00	jmp $0000			jmp 	NextCode
.1436					Dup:
.1436	a5 06		lda $06				lda 	TOS
.1438	48		pha				pha
.1439	a5 07		lda $07				lda 	TOS+1
.143b	48		pha				pha
.143c	4c 00 00	jmp $0000			jmp 	NextCode
.143f					Swap:
.143f	86 10		stx $10				stx 	temp1
.1441	7a		ply				ply
.1442	fa		plx				plx
.1443	a5 06		lda $06				lda 	TOS
.1445	48		pha				pha
.1446	a5 07		lda $07				lda 	TOS+1
.1448	48		pha				pha
.1449	86 06		stx $06				stx 	TOS
.144b	84 07		sty $07				sty 	TOS+1
.144d	a6 10		ldx $10				ldx 	temp1
.144f	4c 00 00	jmp $0000			jmp 	NextCode
.1452					Over:
.1452	a5 06		lda $06				lda 	TOS
.1454	48		pha				pha
.1455	a5 07		lda $07				lda 	TOS+1
.1457	48		pha				pha
.1458	86 10		stx $10				stx 	temp1
.145a	ba		tsx				tsx
.145b	bd 04 01	lda $0104,x			lda 	stack3low,x
.145e	85 06		sta $06				sta 	TOS
.1460	bd 03 01	lda $0103,x			lda 	stack3High,x
.1463	85 07		sta $07				sta 	TOS+1
.1465	a6 10		ldx $10				ldx 	temp1
.1467	4c 00 00	jmp $0000			jmp 	NextCode
.146a					Nip:
.146a	68		pla				pla
.146b	68		pla				pla
.146c	4c 00 00	jmp $0000			jmp 	NextCode
.146f					Rot:
.146f	86 10		stx $10				stx 	temp1
.1471	ba		tsx				tsx
.1472	bd 04 01	lda $0104,x			lda 	Stack3Low,x
.1475	a8		tay				tay
.1476	bd 02 01	lda $0102,x			lda 	Stack2Low,x
.1479	9d 04 01	sta $0104,x			sta 	Stack3Low,x
.147c	a5 06		lda $06				lda 	TOS
.147e	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.1481	84 06		sty $06				sty 	TOS
.1483	bd 03 01	lda $0103,x			lda 	Stack3High,x
.1486	a8		tay				tay
.1487	bd 01 01	lda $0101,x			lda 	Stack2High,x
.148a	9d 03 01	sta $0103,x			sta 	Stack3High,x
.148d	a5 07		lda $07				lda 	TOS+1
.148f	9d 01 01	sta $0101,x			sta 	Stack2High,x
.1492	84 07		sty $07				sty 	TOS+1
.1494	a6 10		ldx $10				ldx 	temp1
.1496	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/data/memory.src

.1499					ByteRead:
.1499	b2 06		lda ($06)			lda 	(TOS)
.149b	85 06		sta $06				sta 	TOS
.149d	64 07		stz $07				stz 	TOS+1
.149f	4c 00 00	jmp $0000			jmp 	NextCode
.14a2					WordRead:
.14a2	a0 01		ldy #$01			ldy 	#1
.14a4	b1 06		lda ($06),y			lda 	(TOS),y
.14a6	a8		tay				tay
.14a7	b2 06		lda ($06)			lda 	(TOS)
.14a9	85 06		sta $06				sta 	TOS
.14ab	84 07		sty $07				sty 	TOS+1
.14ad	4c 00 00	jmp $0000			jmp 	NextCode
.14b0					ByteWrite:
.14b0	68		pla				pla
.14b1	68		pla				pla
.14b2	92 06		sta ($06)			sta 	(TOS)
.14b4	68		pla				pla
.14b5	85 07		sta $07				sta 	TOS+1
.14b7	68		pla				pla
.14b8	85 06		sta $06				sta 	TOS
.14ba	4c 00 00	jmp $0000			jmp 	NextCode
.14bd					WordWrite:
.14bd	68		pla				pla
.14be	a0 01		ldy #$01			ldy 	#1
.14c0	91 06		sta ($06),y			sta 	(TOS),y
.14c2	68		pla				pla
.14c3	92 06		sta ($06)			sta 	(TOS)
.14c5	68		pla				pla
.14c6	85 07		sta $07				sta 	TOS+1
.14c8	68		pla				pla
.14c9	85 06		sta $06				sta 	TOS
.14cb	4c 00 00	jmp $0000			jmp 	NextCode
.14ce					WordAdd:
.14ce	7a		ply				ply
.14cf	68		pla				pla
.14d0	18		clc				clc
.14d1	72 06		adc ($06)			adc 	(TOS)
.14d3	92 06		sta ($06)			sta 	(TOS)
.14d5	98		tya				tya
.14d6	a0 01		ldy #$01			ldy 	#1
.14d8	71 06		adc ($06),y			adc 	(TOS),y
.14da	91 06		sta ($06),y			sta 	(TOS),y
.14dc	68		pla				pla
.14dd	85 07		sta $07				sta 	TOS+1
.14df	68		pla				pla
.14e0	85 06		sta $06				sta 	TOS
.14e2	4c 00 00	jmp $0000			jmp 	NextCode
.14e5					AllocateMemory:
.14e5	a5 06		lda $06				lda 	TOS 						; save memory required on stack.
.14e7	48		pha				pha
.14e8	a5 07		lda $07				lda 	TOS+1
.14ea	48		pha				pha
.14eb	a5 0e		lda $0e				lda 	nextFreeMem 				; copy free mem address to TOS
.14ed	85 06		sta $06				sta 	TOS
.14ef	a5 0f		lda $0f				lda 	nextFreeMem+1
.14f1	85 07		sta $07				sta 	TOS+1
.14f3	7a		ply				ply 								; advance the free ram pointer
.14f4	68		pla				pla
.14f5	20 fd 1b	jsr $1bfd			jsr 	AdvanceFreeMem
.14f8	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/encode/encode.src

.14fb					EncodeProgram:
.14fb	48		pha				pha 								; save registers.
.14fc	da		phx				phx
.14fd	5a		phy				phy
.14fe	84 09		sty $09				sty 	srcPtr+1					; save source pointer.
.1500	85 08		sta $08				sta		srcPtr
.1502	64 05		stz $05				stz 	rsp
.1504	a6 05		ldx $05				ldx 	rsp 						; this is the current stack entry type, so $00 means
.1506	9e 40 07	stz $0740,x			stz 	returnStackHigh,x 			; an initial "until" will fail as it's looking for "R" here (repeat)
.1509	20 7b 17	jsr $177b			jsr 	EncodeTrimTrailingSpaces 	; remove trailing spaces.
.150c	a9 03		lda #$03			lda 	#3 							; reset the encode Buffer
.150e	8d 10 09	sta $0910			sta 	encodeBuffer 				; this is also the write ptr/offset
.1511	9c 11 09	stz $0911			stz 	encodeBuffer+1 				; the line number
.1514	9c 12 09	stz $0912			stz 	encodeBuffer+2 				; which is initially zero.
.1517	b2 08		lda ($08)			lda 	(srcPtr) 					; check if first character is digit
.1519	20 26 17	jsr $1726			jsr 	CheckIsDigit
.151c	90 09		bcc $1527			bcc 	_EPNoLineNumber 			; if so there is a line number
.151e	20 48 17	jsr $1748			jsr 	EncodeGetConstant 			; extract that constant from the source
.1521	8d 11 09	sta $0911			sta 	encodeBuffer+1 				; that is the line number
.1524	8c 12 09	sty $0912			sty 	encodeBuffer+2
.1527					_EPNoLineNumber:
.1527					EncodeLoop:
.1527	20 6d 17	jsr $176d			jsr 	EncSkipSpaces 				; skip over spaces
.152a	b2 08		lda ($08)			lda 	(srcPtr) 					; reached end ?
.152c	d0 21		bne $154f			bne 	_EPNotEnd
.152e					_EPEndEncode:
.152e	a9 48		lda #$48			lda 	#NextLine & $FF 			; compile $$nextline to mark eol
.1530	a0 20		ldy #$20			ldy 	#NextLine >> 8
.1532	20 fe 16	jsr $16fe			jsr 	EncodeWriteWord
.1535	a5 05		lda $05				lda 	rsp 						; is the return stack empty ?
.1537	d0 04		bne $153d			bne 	_EPIncomplete
.1539	7a		ply				ply									; restore and exit.
.153a	fa		plx				plx
.153b	68		pla				pla
.153c	60		rts				rts
.153d					_EPIncomplete:
.153d	20 e9 23	jsr $23e9			jsr 	ErrorHandler
>1540	53 54 52 55 43 54 55 52				.text 	"STRUCTURE OPEN",0
>1548	45 20 4f 50 45 4e 00
.154f					_EPNotEnd:
.154f	b2 08		lda ($08)			lda 	(srcPtr)
.1551	c9 22		cmp #$22			cmp 	#'"'						; is it a quoted string or comment ?
.1553	f0 04		beq $1559			beq 	_EPIsComStr
.1555	c9 27		cmp #$27			cmp 	#"'"
.1557	d0 05		bne $155e			bne 	_EPNotComStr
.1559					_EPIsComStr:
.1559	20 4b 16	jsr $164b			jsr 	EncodeCommentString
.155c	80 c9		bra $1527			bra 	EncodeLoop
.155e					_EPNotComStr:
.155e	38		sec				sec
.155f	20 5a 17	jsr $175a			jsr 	EncSetBit7Word
.1562	20 a2 17	jsr $17a2			jsr 	EncodeSearchDictionary		; look it up
.1565	90 45		bcc $15ac			bcc 	_EPNotInDictionary
.1567	85 10		sta $10				sta 	temp1 						; save dictionary record address
.1569	84 11		sty $11				sty 	temp1+1
.156b	a0 01		ldy #$01			ldy 	#1
.156d	b1 10		lda ($10),y			lda 	(temp1),y 					; check if has an encode bit
.156f	29 20		and #$20			and 	#$20
.1571	d0 12		bne $1585			bne 	_EPEncodeRoutine 			; if so, do special routine.
.1573	a0 02		ldy #$02			ldy 	#2 							; write out the routine address
.1575	b1 10		lda ($10),y			lda 	(temp1),y
.1577	20 08 17	jsr $1708			jsr 	EncodeWriteByte
.157a	c8		iny				iny
.157b	b1 10		lda ($10),y			lda 	(temp1),y
.157d	20 08 17	jsr $1708			jsr 	EncodeWriteByte
.1580	20 32 17	jsr $1732			jsr 	EncodeMoveNextWord 			; advance to the next and loop
.1583	80 a2		bra $1527			bra 	EncodeLoop
.1585					_EPEncodeRoutine:
.1585	a0 01		ldy #$01			ldy 	#1							; get type bit
.1587	b1 10		lda ($10),y			lda 	(temp1),y
.1589	a0 04		ldy #$04			ldy 	#4							; encoder here if no decoder
.158b	29 10		and #$10			and 	#$10 						; but decoder comes first
.158d	f0 02		beq $1591			beq 	_EPENoDecoder
.158f	c8		iny				iny 								; so if it exists, adjust for it.
.1590	c8		iny				iny
.1591					_EPENoDecoder:
.1591	b1 10		lda ($10),y			lda 	(temp1),y 					; copy exec addr to temp2
.1593	85 12		sta $12				sta 	temp2
.1595	c8		iny				iny
.1596	b1 10		lda ($10),y			lda 	(temp1),y
.1598	85 13		sta $13				sta 	temp2+1
.159a	48		pha				pha 								; call routine preserving state
.159b	da		phx				phx
.159c	5a		phy				phy
.159d	20 a9 15	jsr $15a9			jsr 	_EPECallTemp2
.15a0	7a		ply				ply
.15a1	fa		plx				plx
.15a2	68		pla				pla
.15a3	20 32 17	jsr $1732			jsr 	EncodeMoveNextWord 			; advance to the next and loop
.15a6	4c 27 15	jmp $1527			jmp 	EncodeLoop
.15a9					_EPECallTemp2:
.15a9	6c 12 00	jmp ($0012)			jmp 	(temp2)
.15ac					_EPNotInDictionary:
.15ac	20 b0 16	jsr $16b0			jsr 	EncodeSearchUserDefined 	; are there any user defined routines
.15af	90 19		bcc $15ca			bcc 	_EPNotDefined
.15b1	48		pha				pha
.15b2	a9 62		lda #$62			lda	 	#CallHandler & $FF 			; write code call handler
.15b4	20 08 17	jsr $1708			jsr 	EncodeWriteByte
.15b7	a9 1a		lda #$1a			lda	 	#CallHandler >> 8
.15b9	20 08 17	jsr $1708			jsr 	EncodeWriteByte
.15bc	68		pla				pla 								; write line number
.15bd	20 08 17	jsr $1708			jsr 	EncodeWriteByte
.15c0	98		tya				tya
.15c1	20 08 17	jsr $1708			jsr 	EncodeWriteByte
.15c4	20 32 17	jsr $1732			jsr 	EncodeMoveNextWord 			; advance to the next and loop
.15c7	4c 27 15	jmp $1527			jmp 	EncodeLoop
.15ca					_EPNotDefined:
.15ca	b2 08		lda ($08)			lda 	(srcPtr) 					; first character
.15cc	c9 3a		cmp #$3a			cmp 	#":"						; is it :<routine> ?
.15ce	f0 58		beq $1628			beq 	_EPDefinition
.15d0	c9 3c		cmp #$3c			cmp 	#"<"						; is it <line> which is call syntax
.15d2	f0 2e		beq $1602			beq 	_EPCallDirect
.15d4	c9 21		cmp #$21			cmp 	#"!"						; check for variable operators
.15d6	f0 47		beq $161f			beq 	_EPVariable
.15d8	c9 40		cmp #$40			cmp 	#"@"
.15da	f0 43		beq $161f			beq 	_EPVariable
.15dc	c9 26		cmp #$26			cmp 	#"&"
.15de	f0 3f		beq $161f			beq 	_EPVariable
.15e0	a9 52		lda #$52			lda 	#Literal2Byte & $FF 		; write out 2 byte literal
.15e2	a0 10		ldy #$10			ldy 	#Literal2Byte >> 8
.15e4	20 fe 16	jsr $16fe			jsr 	EncodeWriteWord
.15e7					_EPOutputConstant:
.15e7	20 48 17	jsr $1748			jsr 	EncodeGetConstant 			; extract that constant from the source
.15ea	90 06		bcc $15f2			bcc 	_EPFail 					; if can't find one, that's us done.
.15ec	20 fe 16	jsr $16fe			jsr 	EncodeWriteWord 			; write out the encoded value.
.15ef	4c 27 15	jmp $1527			jmp 	EncodeLoop 					; and go round again.
.15f2					_EPFail:
.15f2	20 e9 23	jsr $23e9			jsr 	ErrorHandler
>15f5	53 59 4e 54 41 58 20 45				.text 	"SYNTAX ERROR",0
>15fd	52 52 4f 52 00
.1602					_EPCallDirect:
.1602	a9 62		lda #$62			lda	 	#CallHandler & $FF 			; write code call handler
.1604	a0 1a		ldy #$1a			ldy	 	#CallHandler >> 8
.1606	20 fe 16	jsr $16fe			jsr 	EncodeWriteWord
.1609	a9 01		lda #$01			lda 	#1
.160b	20 3e 17	jsr $173e			jsr 	EncodeAddSrcPtr 			; skip over the <
.160e	a0 ff		ldy #$ff			ldy 	#255 						; scan forward for last character.
.1610					_EPToLast:
.1610	c8		iny				iny
.1611	b1 08		lda ($08),y			lda 	(srcPtr),y
.1613	10 fb		bpl $1610			bpl	 	_EPToLast
.1615	c9 be		cmp #$be			cmp 	#">"+$80 					; must be >
.1617	d0 d9		bne $15f2			bne 	_EPFail
.1619	a9 20		lda #$20			lda 	#" " 						; strip back to a number, erases last char
.161b	91 08		sta ($08),y			sta 	(srcPtr),y
.161d	80 c8		bra $15e7			bra 	_EPOutputConstant 			; borrow the number routines extract/compile constant
.161f					_EPVariable:
.161f	20 f6 17	jsr $17f6			jsr 	EncodeVariableReference
.1622	20 32 17	jsr $1732			jsr 	EncodeMoveNextWord 			; advance to the next and loop
.1625	4c 27 15	jmp $1527			jmp 	EncodeLoop
.1628					_EPDefinition:
.1628	a9 8a		lda #$8a			lda	 	#DefineCode & $FF 			; write code call handler
.162a	a0 20		ldy #$20			ldy	 	#DefineCode >> 8
.162c	20 fe 16	jsr $16fe			jsr 	EncodeWriteWord
.162f	ae 10 09	ldx $0910			ldx 	encodeBuffer 				; position
.1632	a9 01		lda #$01			lda 	#1 							; write default size
.1634	20 08 17	jsr $1708			jsr 	EncodeWriteByte
.1637	a0 00		ldy #$00			ldy 	#0 							; copy definition over.
.1639	c8		iny		_EPCopy:iny
.163a	b1 08		lda ($08),y			lda 	(srcPtr),y
.163c	20 08 17	jsr $1708			jsr 	EncodeWriteByte
.163f	fe 10 09	inc $0910,x			inc 	encodeBuffer,x 				; update length.
.1642	0a		asl a				asl 	a
.1643	90 f4		bcc $1639			bcc 	_EPCopy
.1645	20 32 17	jsr $1732			jsr 	EncodeMoveNextWord 			; advance to the next and loop
.1648	4c 27 15	jmp $1527			jmp 	EncodeLoop

;******  Return to file: kernel.asm


;******  Processing file: words/encode/comstr.src

.164b					EncodeCommentString:
.164b	b2 08		lda ($08)			lda 	(srcPtr) 					; get first character
.164d	64 10		stz $10				stz 	temp1 						; other terminator = EOL
.164f	aa		tax				tax 								; save in X
.1650	a9 5f		lda #$5f			lda 	#(SkipComment & $FF)		; get the routine to use
.1652	a0 20		ldy #$20			ldy 	#(SkipComment >> 8)
.1654	e0 27		cpx #$27			cpx 	#"'"
.1656	f0 06		beq $165e			beq 	_ECSGotCmd
.1658	86 10		stx $10				stx		temp1 						; other terminator = "
.165a	a9 7a		lda #$7a			lda 	#(LiteralString & $FF)
.165c	a0 10		ldy #$10			ldy 	#(LiteralString >> 8)
.165e					_ECSGotCmd:
.165e	20 fe 16	jsr $16fe			jsr 	EncodeWriteWord 			; write word out.
.1661	a9 01		lda #$01			lda 	#1 							; skip over ' or "
.1663	20 3e 17	jsr $173e			jsr 	EncodeAddSrcPtr
.1666	e0 27		cpx #$27			cpx 	#"'"						; if ' then skip spaces
.1668	d0 03		bne $166d			bne 	_ECNoSkipSpaces
.166a	20 6d 17	jsr $176d			jsr 	EncSkipSpaces
.166d					_ECNoSkipSpaces:
.166d	ae 10 09	ldx $0910			ldx 	encodeBuffer 				; keep offset to buffer in X.
.1670	a9 01		lda #$01			lda 	#1
.1672	20 08 17	jsr $1708			jsr 	EncodeWriteByte 			; write total length, so far 1.
.1675	a0 00		ldy #$00			ldy 	#0 							; for reading the actual text
.1677					_ECSCopyText:
.1677	b1 08		lda ($08),y			lda 	(srcPtr),y 					; get next
.1679	f0 18		beq $1693			beq 	_ECSEndOfLine 				; end of line ?
.167b	c5 10		cmp $10				cmp 	temp1						; is it the other terminator
.167d	f0 09		beq $1688			beq 	_ECSEndOfString 			; if so must be closing quote.
.167f	20 08 17	jsr $1708			jsr 	EncodeWriteByte 			; write the byte out
.1682	fe 10 09	inc $0910,x			inc 	encodeBuffer,x				; increase length
.1685	c8		iny				iny 								; next character
.1686	80 ef		bra $1677			bra 	_ECSCopyText
.1688					_ECSEndOfString:
.1688	c8		iny				iny 								; skip closing quote.
.1689	a9 00		lda #$00			lda 	#0 							; write out ASCIIZ
.168b	20 08 17	jsr $1708			jsr 	EncodeWriteByte
.168e	fe 10 09	inc $0910,x			inc 	encodeBuffer,x 				; fix the length up.
.1691	80 18		bra $16ab			bra 	_ECSComplete 				; and just patching up srcPtr to do.
.1693					_ECSEndOfLine:
.1693	a5 10		lda $10				lda 	temp1 						; missing closing quote
.1695	f0 14		beq $16ab			beq 	_ECSComplete 				; if we were doing a string.
.1697	20 e9 23	jsr $23e9			jsr 	ErrorHandler
>169a	4e 4f 20 43 4c 4f 53 49				.text 	"NO CLOSING QUOTE",0
>16a2	4e 47 20 51 55 4f 54 45 00
.16ab					_ECSComplete:
.16ab	98		tya				tya									; skip over.
.16ac	20 3e 17	jsr $173e			jsr 	EncodeAddSrcPtr
.16af	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/encode/encdef.src

.16b0					EncodeSearchUserDefined:
.16b0	38		sec				sec 								; temp1 = srcPtr-6 because the
.16b1	a5 08		lda $08				lda 	srcPtr				 		; name is 6 in (offset line# $$call len)
.16b3	e9 06		sbc #$06			sbc		#6
.16b5	85 10		sta $10				sta 	temp1
.16b7	a5 09		lda $09				lda 	srcPtr+1
.16b9	e9 00		sbc #$00			sbc 	#0
.16bb	85 11		sta $11				sta 	temp1+1
.16bd	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.16bf	85 12		sta $12				sta 	0+(temp2)
.16c1	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.16c3	85 13		sta $13				sta 	1+(temp2)
.16c5					_ESULoop:
.16c5	b2 12		lda ($12)			lda 	(temp2) 					; reached the end (offset 0)
.16c7	f0 33		beq $16fc			beq 	_ESUFail
.16c9	a0 03		ldy #$03			ldy 	#3 							; check it is $$define
.16cb	b1 12		lda ($12),y			lda 	(temp2),y
.16cd	c9 8a		cmp #$8a			cmp 	#DefineCode & $FF
.16cf	d0 1e		bne $16ef			bne 	_ESUNext
.16d1	c8		iny				iny
.16d2	b1 12		lda ($12),y			lda 	(temp2),y
.16d4	c9 20		cmp #$20			cmp 	#DefineCode >> 8
.16d6	d0 17		bne $16ef			bne 	_ESUNext
.16d8	c8		iny				iny 								; skip length byte.
.16d9					_ESUCompare:
.16d9	c8		iny				iny
.16da	b1 12		lda ($12),y			lda 	(temp2),y
.16dc	d1 10		cmp ($10),y			cmp 	(temp1),y
.16de	d0 0f		bne $16ef			bne 	_ESUNext
.16e0	0a		asl a				asl 	a 							; bit 7 set => found it.
.16e1	90 f6		bcc $16d9			bcc 	_ESUCompare
.16e3	a0 01		ldy #$01			ldy 	#1
.16e5	b1 12		lda ($12),y			lda 	(temp2),y 					; read in the line number to YA
.16e7	aa		tax				tax
.16e8	c8		iny				iny
.16e9	b1 12		lda ($12),y			lda 	(temp2),y
.16eb	a8		tay				tay
.16ec	8a		txa				txa
.16ed	38		sec				sec 								; return with carry set as found
.16ee	60		rts				rts
.16ef					_ESUNext:
.16ef	18		clc				clc
.16f0	a5 12		lda $12				lda 	temp2
.16f2	72 12		adc ($12)			adc 	(temp2)
.16f4	85 12		sta $12				sta 	temp2
.16f6	90 02		bcc $16fa			bcc 	_NoCarryAdv
.16f8	e6 13		inc $13				inc 	temp2+1
.16fa					_NoCarryAdv:
.16fa	80 c9		bra $16c5			bra 	_ESULoop 					; and loop round
.16fc					_ESUFail:
.16fc	18		clc				clc
.16fd	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/encode/encutils.src

.16fe					EncodeWriteWord:
.16fe	48		pha				pha
.16ff	20 08 17	jsr $1708			jsr 	EncodeWriteByte
.1702	98		tya				tya
.1703	20 08 17	jsr $1708			jsr 	EncodeWriteByte
.1706	68		pla				pla
.1707	60		rts				rts
.1708					EncodeWriteByte:
.1708	da		phx				phx
.1709	ae 10 09	ldx $0910			ldx 	encodeBuffer
.170c	9d 10 09	sta $0910,x			sta 	encodeBuffer,x
.170f	9e 11 09	stz $0911,x			stz 	encodeBuffer+1,x
.1712	9e 12 09	stz $0912,x			stz 	encodeBuffer+2,x
.1715	ee 10 09	inc $0910			inc 	encodeBuffer
.1718	fa		plx				plx
.1719	60		rts				rts
.171a					CheckIsLetter:
.171a	c9 41		cmp #$41			cmp 	#"A"						; return CS if A..Z
.171c	90 06		bcc $1724			bcc 	_CILFail
.171e	c9 5b		cmp #$5b			cmp 	#"Z"+1
.1720	b0 02		bcs $1724			bcs 	_CILFail
.1722	38		sec				sec
.1723	60		rts				rts
.1724					_CILFail:
.1724	18		clc				clc
.1725	60		rts				rts
.1726					CheckIsDigit:
.1726	c9 30		cmp #$30			cmp 	#"0"						; return CS if 0..9
.1728	90 06		bcc $1730			bcc 	_CIDFail
.172a	c9 3a		cmp #$3a			cmp 	#"9"+1
.172c	b0 02		bcs $1730			bcs 	_CIDFail
.172e	38		sec				sec
.172f	60		rts				rts
.1730					_CIDFail:
.1730	18		clc				clc
.1731	60		rts				rts
.1732					EncodeMoveNextWord:
.1732	a0 ff		ldy #$ff			ldy 	#255 						; search forward
.1734					_EPNWLoop:
.1734	c8		iny				iny
.1735	b1 08		lda ($08),y			lda 	(srcPtr),y
.1737	c9 21		cmp #$21			cmp 	#" "+1						; looking for <= space
.1739	b0 f9		bcs $1734			bcs 	_EPNWLoop
.173b	98		tya				tya
.173c	80 00		bra $173e			bra 	EncodeAddSrcPtr
.173e					EncodeAddSrcPtr:
.173e	18		clc				clc 								; add offset
.173f	65 08		adc $08				adc 	srcPtr
.1741	85 08		sta $08				sta 	srcPtr
.1743	90 02		bcc $1747			bcc 	_EASPNoCarry
.1745	e6 09		inc $09				inc 	srcPtr+1					; carry through
.1747					_EASPNoCarry:
.1747	60		rts				rts
.1748					EncodeGetConstant:
.1748	a5 08		lda $08				lda 	srcPtr 						; get source
.174a	a4 09		ldy $09				ldy 	srcPtr+1
.174c	20 b3 20	jsr $20b3			jsr 	ConvertToInteger 			; call converter
.174f	90 08		bcc $1759			bcc 	_EGCExit
.1751	20 3e 17	jsr $173e			jsr 	EncodeAddSrcPtr 			; if passed add chars to src ptr
.1754	a5 14		lda $14				lda 	temp3 						; get result into YA
.1756	a4 15		ldy $15				ldy 	temp3+1
.1758	38		sec				sec 								; return CS
.1759					_EGCExit:
.1759	60		rts				rts
.175a					EncSetBit7Word:
.175a	08		php				php 								; save carry
.175b	a0 ff		ldy #$ff			ldy 	#255 						; scan forward for space/NULL
.175d					_ESB7Loop:
.175d	c8		iny				iny
.175e	b1 08		lda ($08),y			lda 	(srcPtr),y
.1760	c9 21		cmp #$21			cmp 	#" "+1 						; while > ' '
.1762	b0 f9		bcs $175d			bcs 	_ESB7Loop
.1764	88		dey				dey									; previous character
.1765	b1 08		lda ($08),y			lda 	(srcPtr),y 					; read it
.1767	0a		asl a				asl 	a 							; shift bit 7 out
.1768	28		plp				plp 								; restore carry
.1769	6a		ror a				ror 	a 							; shift it in
.176a	91 08		sta ($08),y			sta 	(srcPtr),y 					; write back and exit
.176c	60		rts				rts
.176d					EncSkipSpaces:
.176d	b2 08		lda ($08)			lda 	(srcPtr) 					; skip over spaces/ reached end
.176f	c9 20		cmp #$20			cmp 	#32
.1771	d0 07		bne $177a			bne 	_ESNotSpace
.1773	a9 01		lda #$01			lda 	#1
.1775	20 3e 17	jsr $173e			jsr 	EncodeAddSrcPtr
.1778	80 f3		bra $176d			bra	 	EncSkipSpaces
.177a					_ESNotSpace:
.177a	60		rts				rts
.177b					EncodeTrimTrailingSpaces:
.177b	a0 ff		ldy #$ff			ldy 	#255 						; find EOS
.177d					_ETTFindEnd:
.177d	c8		iny				iny
.177e	b1 08		lda ($08),y			lda 	(srcPtr),y
.1780	d0 fb		bne $177d			bne 	_ETTFindEnd
.1782					_ETTRemoveSpace:
.1782	c0 00		cpy #$00			cpy 	#0 							; start of string
.1784	f0 0d		beq $1793			beq 	_ETTExit
.1786	88		dey				dey 								; previous character 1..32
.1787	b1 08		lda ($08),y			lda 	(srcPtr),y
.1789	c9 21		cmp #$21			cmp 	#32+1
.178b	b0 06		bcs $1793			bcs 	_ETTExit
.178d	a9 00		lda #$00			lda 	#0 							; erase it and go round again
.178f	91 08		sta ($08),y			sta 	(srcPtr),y
.1791	80 ef		bra $1782			bra 	_ETTRemoveSpace
.1793					_ETTExit:
.1793	60		rts				rts
.1794					EncodePushPosMarkerOnStack:
.1794	e6 05		inc $05				inc 	rsp 						; make space on rstack
.1796	a6 05		ldx $05				ldx 	rsp							; access it
.1798	9d 40 07	sta $0740,x			sta 	returnStackHigh,x			; save marker
.179b	ad 10 09	lda $0910			lda 	encodeBuffer 				; save position in encode buffer
.179e	9d 80 07	sta $0780,x			sta 	returnStackX,x
.17a1	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/encode/encsearch.src

.17a2					EncodeSearchDictionary:
.17a2	a9 27		lda #$27			lda 	#(Dictionary) & $FF
.17a4	85 10		sta $10				sta 	0+(temp1)
.17a6	a9 25		lda #$25			lda 	#(Dictionary) >> 8
.17a8	85 11		sta $11				sta 	1+(temp1)
.17aa					_ESDLoop:
.17aa	b2 10		lda ($10)			lda 	(temp1) 					; end of dictionary return with CC.
.17ac	18		clc				clc
.17ad	f0 46		beq $17f5			beq 	_ESDExit
.17af	a0 01		ldy #$01			ldy 	#1 							; get control bits, get offset to name.
.17b1	b1 10		lda ($10),y			lda 	(temp1),y
.17b3	4a		lsr a				lsr 	a 							; encode/decode bits move to 0,1
.17b4	4a		lsr a				lsr 	a
.17b5	4a		lsr a				lsr 	a
.17b6	4a		lsr a				lsr 	a
.17b7	c8		iny				iny 								; Y = 2
.17b8	4a		lsr a				lsr 	a
.17b9	90 01		bcc $17bc			bcc 	_ESDNotDec
.17bb	c8		iny				iny
.17bc					_ESDNotDec:
.17bc	4a		lsr a				lsr 	a
.17bd	90 01		bcc $17c0			bcc 	_ESDNotInc
.17bf	c8		iny				iny
.17c0					_ESDNotInc:
.17c0	98		tya				tya
.17c1	0a		asl a				asl 	a 							; A is now 4,6,8 offset to name.
.17c2	a8		tay				tay
.17c3	b1 10		lda ($10),y			lda 	(temp1),y 					; quick check of first character
.17c5	d2 08		cmp ($08)			cmp 	(srcPtr)
.17c7	d0 1f		bne $17e8			bne 	_ESDNext 					; do not match, go to next
.17c9	98		tya				tya 								; make temp2 point to the name in
.17ca	18		clc				clc 								; the dictionary.
.17cb	65 10		adc $10				adc 	temp1
.17cd	85 12		sta $12				sta 	temp2
.17cf	a5 11		lda $11				lda 	temp1+1
.17d1	69 00		adc #$00			adc 	#0
.17d3	85 13		sta $13				sta 	temp2+1
.17d5	a0 ff		ldy #$ff			ldy 	#255 						; now start matching up.
.17d7					_ESDCompare:
.17d7	c8		iny				iny
.17d8	b1 08		lda ($08),y			lda 	(srcPtr),y
.17da	d1 12		cmp ($12),y			cmp 	(temp2),y
.17dc	d0 0a		bne $17e8			bne 	_ESDNext
.17de	0a		asl a				asl 	a
.17df	90 f6		bcc $17d7			bcc 	_ESDCompare
.17e1	a5 10		lda $10				lda 	temp1 						; return address in YA and carry set.
.17e3	a4 11		ldy $11				ldy 	temp1+1
.17e5	38		sec				sec
.17e6	80 0d		bra $17f5			bra 	_ESDExit
.17e8					_ESDNext:
.17e8	18		clc				clc
.17e9	a5 10		lda $10				lda 	temp1
.17eb	72 10		adc ($10)			adc 	(temp1)
.17ed	85 10		sta $10				sta 	temp1
.17ef	90 b9		bcc $17aa			bcc 	_ESDLoop
.17f1	e6 11		inc $11				inc 	temp1+1
.17f3	80 b5		bra $17aa			bra 	_ESDLoop
.17f5					_ESDExit:
.17f5	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/encode/encvar.src

.17f6					EncodeVariableReference:
.17f6	b2 08		lda ($08)			lda 	(srcPtr)					; get the type, use it to identify the routine
.17f8	a2 ec		ldx #$ec			ldx 	#VarAddressHandler & $FF
.17fa	a0 21		ldy #$21			ldy 	#VarAddressHandler >> 8
.17fc	c9 26		cmp #$26			cmp 	#"&"
.17fe	f0 0c		beq $180c			beq 	_EVFHaveAddress
.1800	a2 09		ldx #$09			ldx 	#VarReadHandler & $FF
.1802	a0 22		ldy #$22			ldy 	#VarReadHandler >> 8
.1804	c9 40		cmp #$40			cmp 	#"@"
.1806	f0 04		beq $180c			beq 	_EVFHaveAddress
.1808	a2 28		ldx #$28			ldx 	#VarWriteHandler & $FF
.180a	a0 22		ldy #$22			ldy 	#VarWriteHandler >> 8
.180c					_EVFHaveAddress:
.180c	8a		txa				txa
.180d	20 fe 16	jsr $16fe			jsr 	EncodeWriteWord 			; write it out.
.1810	a0 01		ldy #$01			ldy 	#1 							; get the first charactere
.1812	b1 08		lda ($08),y			lda 	(srcPtr),y
.1814	29 7f		and #$7f			and 	#$7F 						; might be the last.
.1816	20 1a 17	jsr $171a			jsr 	CheckIsLetter 				; is it A-Z
.1819	90 54		bcc $186f			bcc 	EVFFail
.181b	29 1f		and #$1f			and 	#31 						; make 1-26
.181d	85 10		sta $10				sta 	temp1 						; start building the name in temp1
.181f	64 11		stz $11				stz 	temp1+1
.1821	38		sec				sec 								; possible char 2
.1822	20 84 18	jsr $1884			jsr 	EncVarAlNum
.1825	18		clc				clc 								; possible char 3
.1826	20 84 18	jsr $1884			jsr 	EncVarAlNum
.1829	5a		phy				phy
.182a	a5 10		lda $10				lda 	temp1 						; write out variable identifier.
.182c	a4 11		ldy $11				ldy 	temp1+1
.182e	20 fe 16	jsr $16fe			jsr 	EncodeWriteWord
.1831	7a		ply				ply
.1832	b1 08		lda ($08),y			lda 	(srcPtr),y 					; more text after ?
.1834	10 01		bpl $1837			bpl 	_EVFCheckArray
.1836	60		rts				rts
.1837					_EVFCheckArray:
.1837	c8		iny				iny 								; get the next character
.1838	b1 08		lda ($08),y			lda 	(srcPtr),y
.183a	c9 5b		cmp #$5b			cmp 	#"["						; array index ?
.183c	d0 31		bne $186f			bne 	EVFFail
.183e	64 10		stz $10				stz 	temp1 						; zero temp1.
.1840	c8		iny				iny  								; point to index
.1841					_EVFGetIndex:
.1841	06 10		asl $10				asl 	temp1 						; temp1 x 10
.1843	a5 10		lda $10				lda 	temp1
.1845	0a		asl a				asl 	a
.1846	0a		asl a				asl		a
.1847	65 10		adc $10				adc 	temp1
.1849	85 10		sta $10				sta 	temp1
.184b	b1 08		lda ($08),y			lda 	(srcPtr),y 					; get the digit
.184d	20 26 17	jsr $1726			jsr 	CheckIsDigit
.1850	90 1d		bcc $186f			bcc 	EVFFail 					; failed, not digit
.1852	29 0f		and #$0f			and 	#15
.1854	18		clc				clc
.1855	65 10		adc $10				adc 	temp1
.1857	30 16		bmi $186f			bmi 	EVFFail 					; failed, bad index.
.1859	85 10		sta $10				sta 	temp1
.185b	c8		iny				iny
.185c	b1 08		lda ($08),y			lda 	(srcPtr),y
.185e	c9 dd		cmp #$dd			cmp 	#"]"+$80
.1860	d0 df		bne $1841			bne 	_EVFGetIndex 				; index now in temp1.
.1862	a9 47		lda #$47			lda 	#IndexHandler & $FF 		; output code
.1864	a0 22		ldy #$22			ldy 	#IndexHandler >> 8
.1866	20 fe 16	jsr $16fe			jsr 	EncodeWriteWord
.1869	a5 10		lda $10				lda 	temp1	 					; write index
.186b	20 08 17	jsr $1708			jsr 	EncodeWriteByte
.186e	60		rts				rts
.186f					EVFFail:
.186f	20 e9 23	jsr $23e9			jsr 	ErrorHandler
>1872	42 41 44 20 56 41 52 49				.text 	"BAD VARIABLE NAME",0
>187a	41 42 4c 45 20 4e 41 4d 45 00
.1884					EncVarAlNum:
.1884	b1 08		lda ($08),y			lda 	(srcPtr),y 					; points to the  last char processed.
.1886	10 01		bpl $1889			bpl 	_EVAContinue
.1888	60		rts				rts
.1889					_EVAContinue:
.1889	08		php				php 								; CS x 32 ; CC x 32 x 40
.188a	c8		iny				iny 								; get the next character, strip bit 7
.188b	b1 08		lda ($08),y			lda 	(srcPtr),y
.188d	88		dey				dey
.188e	29 7f		and #$7f			and 	#$7F
.1890	20 1a 17	jsr $171a			jsr 	CheckIsLetter 				; letter ?
.1893	b0 08		bcs $189d			bcs 	_EVACharOkay
.1895	20 26 17	jsr $1726			jsr 	CheckIsDigit				; fail if not digit.
.1898	90 32		bcc $18cc			bcc 	_EVAExit
.189a	18		clc				clc
.189b	69 2b		adc #$2b			adc 	#"Z"+1-"0"					; shift 0 so after Z
.189d					_EVACharOkay:
.189d	c8		iny				iny 								; char okay advance to it.
.189e	38		sec				sec 								; range 1-36
.189f	e9 40		sbc #$40			sbc 	#64
.18a1	28		plp				plp 								; which multiplier ?
.18a2	90 0f		bcc $18b3			bcc 	_EVATimes32x40
.18a4	85 12		sta $12				sta 	temp2 						; save in temp2 - A x 32
.18a6	64 13		stz $13				stz 	temp2+1
.18a8	a2 05		ldx #$05			ldx 	#5
.18aa	06 12		asl $12		_EVA32:	asl 	temp2
.18ac	26 13		rol $13				rol 	temp2+1
.18ae	ca		dex				dex
.18af	d0 f9		bne $18aa			bne 	_EVA32
.18b1	80 0b		bra $18be			bra 	_EVAAddVar
.18b3					_EVATimes32x40:
.18b3	85 13		sta $13				sta 	temp2+1						; 32 x 40 = 1280 or $500, so temp2 = A x 256 x 5
.18b5	64 12		stz $12				stz 	temp2
.18b7	0a		asl a				asl 	a
.18b8	0a		asl a				asl 	a
.18b9	18		clc				clc
.18ba	65 13		adc $13				adc 	temp2+1
.18bc	85 13		sta $13				sta 	temp2+1
.18be					_EVAAddVar:
.18be	18		clc				clc
.18bf	a5 10		lda $10				lda 	temp1
.18c1	65 12		adc $12				adc 	temp2
.18c3	85 10		sta $10				sta 	temp1
.18c5	a5 11		lda $11				lda 	temp1+1
.18c7	65 13		adc $13				adc 	temp2+1
.18c9	85 11		sta $11				sta 	temp1+1
.18cb	08		php				php
.18cc					_EVAExit:
.18cc	28		plp				plp
.18cd	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/structures/fornext.src

.18ce					ForHandler:
.18ce	e6 05		inc $05				inc 	rsp 						; bump the RSP
.18d0	a4 05		ldy $05				ldy 	rsp 						; get return stack and push TOS/$FF on it.
.18d2	c0 40		cpy #$40			cpy 	#$40 						; overflow
.18d4	f0 18		beq $18ee			beq 	_FHOverflow
.18d6	a5 07		lda $07				lda 	TOS+1
.18d8	99 40 07	sta $0740,y			sta 	returnStackHigh,y
.18db	a5 06		lda $06				lda 	TOS
.18dd	99 00 07	sta $0700,y			sta 	returnStackLow,y
.18e0	a9 ff		lda #$ff			lda 	#$FF
.18e2	99 80 07	sta $0780,y			sta 	returnStackX,y
.18e5	68		pla				pla
.18e6	85 07		sta $07				sta 	TOS+1
.18e8	68		pla				pla
.18e9	85 06		sta $06				sta 	TOS
.18eb	4c 00 00	jmp $0000			jmp 	NextCode
.18ee					_FHOverflow:
.18ee	20 e9 23	jsr $23e9			jsr 	ErrorHandler
>18f1	53 54 52 55 43 54 55 52				.text 	"STRUCTURE OVERFLOW",0
>18f9	45 20 4f 56 45 52 46 4c 4f 57 00
.1904					ForEncoder:
.1904	a9 ce		lda #$ce			lda 	#ForHandler & $FF 			; for handler
.1906	a0 18		ldy #$18			ldy 	#ForHandler >> 8
.1908	20 fe 16	jsr $16fe			jsr 	EncodeWriteWord
.190b	a9 46		lda #$46			lda 	#"F" 						; for marker
.190d	20 94 17	jsr $1794			jsr 	EncodePushPosMarkerOnStack
.1910	60		rts				rts
.1911					NextHandler:
.1911	da		phx				phx
.1912	a6 05		ldx $05				ldx 	rsp 						; get current stack ptr
.1914	bd 80 07	lda $0780,x			lda 	returnStackX,x 				; check it's a FOR Loop
.1917	c9 ff		cmp #$ff			cmp 	#$FF
.1919	d0 21		bne $193c			bne 	NHNoFor
.191b	bd 00 07	lda $0700,x			lda 	returnStackLow,x 			; decrement the count
.191e	d0 03		bne $1923			bne 	_NHNoBorrow
.1920	de 40 07	dec $0740,x			dec 	returnStackHigh,x
.1923					_NHNoBorrow:
.1923	de 00 07	dec $0700,x			dec 	returnStackLow,x
.1926	bd 00 07	lda $0700,x			lda 	returnStackLow,x 			; have we reached the end ?
.1929	1d 40 07	ora $0740,x			ora 	returnStackHigh,x
.192c	fa		plx				plx 								; restore X and re-test
.192d	09 00		ora #$00			ora 	#0
.192f	f0 05		beq $1936			beq 	_NHComplete 				; if so then complete, else loop.
.1931	e8		inx				inx 								; advance to branch
.1932	e8		inx				inx
.1933	4c 58 1a	jmp $1a58			jmp 	BranchAlways
.1936					_NHComplete:
.1936	e8		inx				inx 								; skip over the branch quantity
.1937	c6 05		dec $05				dec 	rsp 						; drop the indx
.1939	4c 00 00	jmp $0000			jmp 	NextCode
.193c					NHNoFor:
.193c	20 e9 23	jsr $23e9			jsr 	ErrorHandler
>193f	4f 55 54 20 4f 46 20 46				.text 	"OUT OF FOR SCOPE",0
>1947	4f 52 20 53 43 4f 50 45 00
.1950					NextEncoder:
.1950	a9 11		lda #$11			lda 	#NextHandler & $FF 			; next code
.1952	a0 19		ldy #$19			ldy 	#NextHandler >> 8
.1954	20 fe 16	jsr $16fe			jsr 	EncodeWriteWord
.1957	a6 05		ldx $05				ldx 	rsp 						; get stack offset and pop
.1959	c6 05		dec $05				dec 	rsp
.195b	bd 40 07	lda $0740,x			lda 	returnStackHigh,x 			; check it is a for
.195e	c9 46		cmp #$46			cmp 	#"F"
.1960	d0 07		bne $1969			bne 	_NENoFor
.1962	bd 80 07	lda $0780,x			lda 	returnStackX,x 				; write the branch
.1965	20 08 17	jsr $1708			jsr 	EncodeWriteByte
.1968	60		rts				rts
.1969					_NENoFor:
.1969	20 e9 23	jsr $23e9			jsr 	ErrorHandler
>196c	4d 49 53 53 49 4e 47 20				.text 	"MISSING FOR",0
>1974	46 4f 52 00
.1978					GetIndex:
.1978	a4 05		ldy $05				ldy 	rsp 						; get current stack ptr
.197a	b9 80 07	lda $0780,y			lda 	returnStackX,y 				; check it's a FOR Loop
.197d	c9 ff		cmp #$ff			cmp 	#$FF
.197f	d0 bb		bne $193c			bne 	NHNoFor
.1981	a5 06		lda $06				lda 	TOS
.1983	48		pha				pha
.1984	a5 07		lda $07				lda 	TOS+1
.1986	48		pha				pha
.1987	b9 00 07	lda $0700,y			lda 	returnStackLow,y 			; put counter-1 out
.198a	38		sec				sec
.198b	e9 01		sbc #$01			sbc 	#1
.198d	85 06		sta $06				sta 	TOS
.198f	b9 40 07	lda $0740,y			lda 	returnStackHigh,y
.1992	e9 00		sbc #$00			sbc 	#0
.1994	85 07		sta $07				sta 	TOS+1
.1996	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/structures/ifelseendif.src

.1999					IfHandler:
.1999	4c 40 1a	jmp $1a40			jmp 	BranchIfZero
.199c					IfEncoder:
.199c	a9 99		lda #$99			lda 	#IfHandler & $FF 			; if handler
.199e	a0 19		ldy #$19			ldy 	#IfHandler >> 8
.19a0	20 fe 16	jsr $16fe			jsr 	EncodeWriteWord
.19a3	a9 49		lda #$49			lda 	#"I" 						; if marker
.19a5	20 94 17	jsr $1794			jsr 	EncodePushPosMarkerOnStack
.19a8	a9 00		lda #$00			lda 	#0
.19aa	20 08 17	jsr $1708			jsr 	EncodeWriteByte 			; dummy write.
.19ad	60		rts				rts
.19ae					ElseHandler:
.19ae	4c 56 1a	jmp $1a56			jmp 	BranchTestSucceedsNoPop
.19b1					ElseEncoder:
.19b1	a9 ae		lda #$ae			lda 	#ElseHandler & $FF 			; else handler
.19b3	a0 19		ldy #$19			ldy 	#ElseHandler >> 8
.19b5	20 fe 16	jsr $16fe			jsr 	EncodeWriteWord
.19b8	ad 10 09	lda $0910			lda 	encodeBuffer 				; push current position
.19bb	48		pha				pha
.19bc	a9 00		lda #$00			lda 	#0 							; zero branch
.19be	20 08 17	jsr $1708			jsr 	EncodeWriteByte
.19c1	20 de 19	jsr $19de			jsr 	IfPatch 					; fix up the branch.
.19c4	a9 49		lda #$49			lda 	#"I" 						; recreate if marker
.19c6	20 94 17	jsr $1794			jsr 	EncodePushPosMarkerOnStack
.19c9	68		pla				pla 								; address to patch
.19ca	a6 05		ldx $05				ldx 	rsp
.19cc	9d 80 07	sta $0780,x			sta 	returnStackX,x 				; and overwrite the target address
.19cf	60		rts				rts
.19d0					EndIfHandler:
.19d0	4c 00 00	jmp $0000			jmp 	NextCode
.19d3					EndIfEncoder:
.19d3	a9 d0		lda #$d0			lda 	#EndIfHandler & $FF 		; endif handler
.19d5	a0 19		ldy #$19			ldy 	#EndIfHandler >> 8
.19d7	20 fe 16	jsr $16fe			jsr 	EncodeWriteWord
.19da	20 de 19	jsr $19de			jsr 	IfPatch
.19dd	60		rts				rts
.19de					IfPatch:
.19de	a6 05		ldx $05				ldx 	rsp 						; get stack offset and pop
.19e0	c6 05		dec $05				dec 	rsp
.19e2	bd 40 07	lda $0740,x			lda 	returnStackHigh,x 			; check it is an if.
.19e5	c9 49		cmp #$49			cmp 	#"I"
.19e7	d0 0b		bne $19f4			bne 	_NENoIf
.19e9	bd 80 07	lda $0780,x			lda 	returnStackX,x 				; this is what you patch.
.19ec	aa		tax				tax
.19ed	ad 10 09	lda $0910			lda 	encodeBuffer 				; with the current position.
.19f0	9d 10 09	sta $0910,x			sta 	encodeBuffer,x
.19f3	60		rts				rts
.19f4					_NENoIf:
.19f4	20 e9 23	jsr $23e9			jsr 	ErrorHandler
>19f7	4d 49 53 53 49 4e 47 20				.text 	"MISSING IF",0
>19ff	49 46 00

;******  Return to file: kernel.asm


;******  Processing file: words/structures/repeatuntil.src

.1a02					RepeatHandler:
.1a02	4c 00 00	jmp $0000			jmp 	NextCode
.1a05					RepeatEncoder:
.1a05	a9 02		lda #$02			lda 	#RepeatHandler & $FF 		; repeat marker
.1a07	a0 1a		ldy #$1a			ldy 	#RepeatHandler >> 8
.1a09	20 fe 16	jsr $16fe			jsr 	EncodeWriteWord
.1a0c	a9 52		lda #$52			lda 	#"R" 						; repeat marker
.1a0e	20 94 17	jsr $1794			jsr 	EncodePushPosMarkerOnStack
.1a11	60		rts				rts
.1a12					UntilHandler:
.1a12	4c 40 1a	jmp $1a40			jmp 	BranchIfZero
.1a15					UntilEncoder:
.1a15	a9 12		lda #$12			lda 	#UntilHandler & $FF 		; until code
.1a17	a0 1a		ldy #$1a			ldy 	#UntilHandler >> 8
.1a19	20 fe 16	jsr $16fe			jsr 	EncodeWriteWord
.1a1c	a6 05		ldx $05				ldx 	rsp 						; get stack offset and pop
.1a1e	c6 05		dec $05				dec 	rsp
.1a20	bd 40 07	lda $0740,x			lda 	returnStackHigh,x 			; check it is a repeat
.1a23	c9 52		cmp #$52			cmp 	#"R"
.1a25	d0 07		bne $1a2e			bne 	_UENoRepeat
.1a27	bd 80 07	lda $0780,x			lda 	returnStackX,x 				; write the branch
.1a2a	20 08 17	jsr $1708			jsr 	EncodeWriteByte
.1a2d	60		rts				rts
.1a2e					_UENoRepeat:
.1a2e	20 e9 23	jsr $23e9			jsr 	ErrorHandler
>1a31	4d 49 53 53 49 4e 47 20				.text 	"MISSING REPEAT",0
>1a39	52 45 50 45 41 54 00

;******  Return to file: kernel.asm


;******  Processing file: words/system/branch.src

.1a40					BranchIfZero:
.1a40	a5 06		lda $06				lda 	TOS 						; check TOS = 0
.1a42	05 07		ora $07				ora 	TOS+1
.1a44	f0 0a		beq $1a50			beq 	BranchTestSucceeds
.1a46					BranchTestFails:
.1a46	68		pla				pla
.1a47	85 07		sta $07				sta 	TOS+1
.1a49	68		pla				pla
.1a4a	85 06		sta $06				sta 	TOS
.1a4c	e8		inx				inx 								; skip over the relative branch.
.1a4d	4c 00 00	jmp $0000			jmp 	NextCode
.1a50					BranchTestSucceeds:
.1a50	68		pla				pla
.1a51	85 07		sta $07				sta 	TOS+1
.1a53	68		pla				pla
.1a54	85 06		sta $06				sta 	TOS
.1a56					BranchTestSucceedsNoPop:
.1a56	e8		inx				inx 								; advance by two, to the offset
.1a57	e8		inx				inx
.1a58					BranchAlways:
.1a58	8a		txa				txa 								; A = Y = position
.1a59	a8		tay				tay 								; (IP),Y now points to the branch target
.1a5a	b1 03		lda ($03),y			lda 	(IP),y 						; adjust the position
.1a5c	aa		tax				tax 								; position back in this line.
.1a5d	ca		dex				dex
.1a5e	ca		dex				dex
.1a5f	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/system/callhandler.src

.1a62					CallHandler:
.1a62	e8		inx				inx									; bump X to the call address.
.1a63	e8		inx				inx
.1a64	e6 05		inc $05				inc 	rsp 						; bump the RSP (first time to zero)
.1a66	a4 05		ldy $05				ldy 	rsp 						; get return stack and push IP/X on it.
.1a68	c0 40		cpy #$40			cpy 	#$40 						; overflow
.1a6a	f0 54		beq $1ac0			beq 	_CHOverflow
.1a6c	a5 04		lda $04				lda 	IP+1
.1a6e	99 40 07	sta $0740,y			sta 	returnStackHigh,y
.1a71	a5 03		lda $03				lda 	IP
.1a73	99 00 07	sta $0700,y			sta 	returnStackLow,y
.1a76	8a		txa				txa
.1a77	99 80 07	sta $0780,y			sta 	returnStackX,y
.1a7a	8a		txa				txa 								; get the line number into temp1.
.1a7b	a8		tay				tay
.1a7c	b1 03		lda ($03),y			lda 	(IP),y
.1a7e	85 10		sta $10				sta 	temp1
.1a80	c8		iny				iny
.1a81	b1 03		lda ($03),y			lda 	(IP),y
.1a83	85 11		sta $11				sta 	temp1+1
.1a85	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.1a87	85 03		sta $03				sta 	0+(IP)
.1a89	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.1a8b	85 04		sta $04				sta 	1+(IP)
.1a8d	b2 03		lda ($03)			lda 	(IP)						; no program code ?
.1a8f	f0 17		beq $1aa8			beq 	_CHFail
.1a91	a0 01		ldy #$01			ldy 	#1 							; Y = 1 throughout.
.1a93					_CHSearch:
.1a93	b1 03		lda ($03),y			lda 	(IP),y 						; check LSB of line number
.1a95	c5 10		cmp $10				cmp 	temp1
.1a97	f0 3e		beq $1ad7			beq 	_CHFoundLSB
.1a99					_CHSearchNext:
.1a99	18		clc				clc
.1a9a	a5 03		lda $03				lda 	IP
.1a9c	72 03		adc ($03)			adc 	(IP)
.1a9e	85 03		sta $03				sta 	IP
.1aa0	90 02		bcc $1aa4			bcc 	_NoCarryAdv
.1aa2	e6 04		inc $04				inc 	IP+1
.1aa4					_NoCarryAdv:
.1aa4	b2 03		lda ($03)			lda 	(IP)						; check reached the end.
.1aa6	d0 eb		bne $1a93			bne 	_CHSearch
.1aa8					_CHFail:
.1aa8	20 e9 23	jsr $23e9			jsr 	ErrorHandler
>1aab	43 41 4e 54 20 46 49 4e				.text 	"CANT FIND DEFINITION",0
>1ab3	44 20 44 45 46 49 4e 49 54 49 4f 4e 00
.1ac0					_CHOverflow:
.1ac0	20 e9 23	jsr $23e9			jsr 	ErrorHandler
>1ac3	43 41 4c 4c 20 53 54 41				.text 	"CALL STACK OVERFLOW",0
>1acb	43 4b 20 4f 56 45 52 46 4c 4f 57 00
.1ad7					_CHFoundLSB:
.1ad7	c8		iny				iny 								; get MSB
.1ad8	b1 03		lda ($03),y			lda 	(IP),y
.1ada	88		dey				dey
.1adb	c5 11		cmp $11				cmp 	temp1+1 					; matches, if not contineu
.1add	d0 ba		bne $1a99			bne 	_CHSearchNext
.1adf	a0 03		ldy #$03			ldy 	#3	 						; check it begins with $$define
.1ae1	b1 03		lda ($03),y			lda 	(IP),y
.1ae3	c9 8a		cmp #$8a			cmp 	#DefineCode & $FF
.1ae5	d0 c1		bne $1aa8			bne 	_CHFail
.1ae7	c8		iny				iny
.1ae8	b1 03		lda ($03),y			lda 	(IP),y
.1aea	c9 20		cmp #$20			cmp 	#DefineCode >> 8
.1aec	d0 ba		bne $1aa8			bne 	_CHFail
.1aee	c8		iny				iny
.1aef	b1 03		lda ($03),y			lda 	(IP),y 						; this is the length of the define name
.1af1	18		clc				clc
.1af2	69 03		adc #$03			adc 	#5-2 						; $$define token, line number, offset - 2 for Next
.1af4	aa		tax				tax
.1af5	4c 00 00	jmp $0000			jmp 	NextCode
.1af8					ReturnHandler:
.1af8	a4 05		ldy $05				ldy 	rsp 						; get rsp
.1afa	f0 15		beq $1b11			beq 	_RHUnderflow 				; if -ve underflowed
.1afc	c6 05		dec $05				dec 	rsp 						; decrement rsp
.1afe	b9 40 07	lda $0740,y			lda 	returnStackHigh,y 			; restore IP/X
.1b01	85 04		sta $04				sta 	IP+1
.1b03	b9 00 07	lda $0700,y			lda 	returnStackLow,y
.1b06	85 03		sta $03				sta 	IP
.1b08	b9 80 07	lda $0780,y			lda 	returnStackX,y
.1b0b	aa		tax				tax
.1b0c	f0 15		beq $1b23			beq 	_RHInLoop 					; this means you have done :something for ; next
.1b0e	4c 00 00	jmp $0000			jmp 	NextCode
.1b11					_RHUnderflow:
.1b11	20 e9 23	jsr $23e9			jsr 	ErrorHandler
>1b14	4d 49 53 53 49 4e 47 20				.text 	"MISSING RETURN",0
>1b1c	52 45 54 55 52 4e 00
.1b23					_RHInLoop:
.1b23	20 e9 23	jsr $23e9			jsr 	ErrorHandler
>1b26	52 45 54 55 52 4e 20 49				.text 	"RETURN IN LOOP ERROR",0
>1b2e	4e 20 4c 4f 4f 50 20 45 52 52 4f 52 00
.1b3b					CallHandlerDecode:
.1b3b	a9 03		lda #$03			lda 	#CTH_Call					; space
.1b3d	20 04 1d	jsr $1d04			jsr 	DecodeWriteBuffer
.1b40	b1 08		lda ($08),y			lda 	(srcPtr),y 					; get line number into YA
.1b42	aa		tax				tax
.1b43	c8		iny				iny
.1b44	b1 08		lda ($08),y			lda 	(srcPtr),y
.1b46	a8		tay				tay
.1b47	8a		txa				txa
.1b48	20 85 1b	jsr $1b85			jsr 	FindLine 					; try to locate that line.
.1b4b	b0 11		bcs $1b5e			bcs 	_CHDFound 					; if found .....
.1b4d					_CHDLineOnly:
.1b4d	48		pha				pha
.1b4e	a9 3c		lda #$3c			lda 	#"<"
.1b50	20 04 1d	jsr $1d04			jsr 	DecodeWriteBuffer
.1b53	68		pla				pla
.1b54	18		clc				clc 								; output unsigned
.1b55	20 26 1d	jsr $1d26			jsr 	DecodeYAToBuffer
.1b58	a9 3e		lda #$3e			lda 	#">"
.1b5a	20 04 1d	jsr $1d04			jsr 	DecodeWriteBuffer
.1b5d	60		rts				rts
.1b5e					_CHDFound:
.1b5e	48		pha				pha 								; save YA
.1b5f	5a		phy				phy
.1b60	a0 03		ldy #$03			ldy 	#3 							; check first is $$define
.1b62	b1 10		lda ($10),y			lda 	(temp1),y
.1b64	c9 8a		cmp #$8a			cmp 	#DefineCode & 255
.1b66	d0 07		bne $1b6f			bne 	_CHDNoDefine
.1b68	c8		iny				iny
.1b69	b1 10		lda ($10),y			lda 	(temp1),y
.1b6b	c9 20		cmp #$20			cmp 	#DefineCode >> 8
.1b6d	f0 04		beq $1b73			beq 	_CHDFoundDefine
.1b6f					_CHDNoDefine:
.1b6f	7a		ply				ply									; restore the line number and print it in <>
.1b70	68		pla				pla
.1b71	80 da		bra $1b4d			bra 	_CHDLineOnly
.1b73					_CHDFoundDefine:
.1b73	68		pla				pla 								; throw saved line number.
.1b74	68		pla				pla
.1b75	a0 05		ldy #$05			ldy 	#5 							; 3,4 $$define 5 length, name has bit 7 set at end
.1b77					_CHDOutName:
.1b77	c8		iny				iny 								; next
.1b78	b1 10		lda ($10),y			lda 	(temp1),y 					; print char no bit 7
.1b7a	48		pha				pha
.1b7b	29 7f		and #$7f			and 	#$7F
.1b7d	20 04 1d	jsr $1d04			jsr 	DecodeWriteBuffer
.1b80	68		pla				pla
.1b81	0a		asl a				asl 	a 							; bit 7 to carry
.1b82	90 f3		bcc $1b77			bcc 	_CHDOutName
.1b84	60		rts				rts
.1b85					FindLine:
.1b85	48		pha				pha 								; save registers
.1b86	da		phx				phx
.1b87	5a		phy				phy
.1b88	85 12		sta $12				sta 	temp2 						; temp2 = target line#
.1b8a	84 13		sty $13				sty 	temp2+1
.1b8c	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.1b8e	85 10		sta $10				sta 	0+(temp1)
.1b90	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.1b92	85 11		sta $11				sta 	1+(temp1)
.1b94					_FLLoop:
.1b94	b2 10		lda ($10)			lda 	(temp1) 					; found end ?
.1b96	18		clc				clc									; if so exit with CC.
.1b97	f0 1d		beq $1bb6			beq 	_FLExit
.1b99	a0 01		ldy #$01			ldy 	#1 							; check line # match
.1b9b	b1 10		lda ($10),y			lda 	(temp1),y
.1b9d	c5 12		cmp $12				cmp 	temp2
.1b9f	d0 08		bne $1ba9			bne 	_FLNext
.1ba1	c8		iny				iny
.1ba2	b1 10		lda ($10),y			lda 	(temp1),y
.1ba4	c5 13		cmp $13				cmp 	temp2+1
.1ba6	38		sec				sec 								; if so exit with CS
.1ba7	f0 0d		beq $1bb6			beq 	_FLExit
.1ba9					_FLNext:
.1ba9	18		clc				clc
.1baa	a5 10		lda $10				lda 	temp1
.1bac	72 10		adc ($10)			adc 	(temp1)
.1bae	85 10		sta $10				sta 	temp1
.1bb0	90 02		bcc $1bb4			bcc 	_NoCarryAdv
.1bb2	e6 11		inc $11				inc 	temp1+1
.1bb4					_NoCarryAdv:
.1bb4	80 de		bra $1b94			bra 	_FLLoop 					; keep looking.
.1bb6					_FLExit:
.1bb6	7a		ply				ply
.1bb7	fa		plx				plx
.1bb8	68		pla				pla
.1bb9	60		rts				rts
.1bba	18		clc				clc
.1bbb	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/clrnew.src

.1bbc					NewHandler:
.1bbc	9c 00 40	stz $4000			stz 	ProgramMemory 				; Make the first offset zero.
.1bbf	20 d2 1b	jsr $1bd2			jsr 	ClearVariableSpace 			; clear variables, reset pointers
.1bc2	4c 0d 10	jmp $100d			jmp 	WarmStartBlankStack
.1bc5					ClrHandler:
.1bc5	86 10		stx $10				stx 	temp1
.1bc7	a2 80		ldx #$80			ldx 	#NumberStackBase
.1bc9	9a		txs				txs
.1bca	a6 10		ldx $10				ldx 	temp1
.1bcc	20 d2 1b	jsr $1bd2			jsr 	ClearVariableSpace 			; clear variables, reset pointers
.1bcf	4c 00 00	jmp $0000			jmp 	NextCode
.1bd2					ClearVariableSpace:
.1bd2	64 05		stz $05				stz 	rsp
.1bd4	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.1bd6	85 0e		sta $0e				sta 	0+(nextFreeMem)
.1bd8	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.1bda	85 0f		sta $0f				sta 	1+(nextFreeMem)
.1bdc	a0 1f		ldy #$1f			ldy 	#hashTableSize*2-1 			; erase the hash table (used for variables)
.1bde					_CVSHashClear:
.1bde	a9 00		lda #$00			lda 	#0 							; all the first record pointers are $00
.1be0	99 40 06	sta $0640,y			sta 	hashTable,y
.1be3	88		dey				dey
.1be4	10 f8		bpl $1bde			bpl 	_CVSHashClear
.1be6					_CVSFindEnd:
.1be6	18		clc				clc
.1be7	a5 0e		lda $0e				lda 	nextFreeMem
.1be9	72 0e		adc ($0e)			adc 	(nextFreeMem)
.1beb	85 0e		sta $0e				sta 	nextFreeMem
.1bed	90 02		bcc $1bf1			bcc 	_NoCarryAdv
.1bef	e6 0f		inc $0f				inc 	nextFreeMem+1
.1bf1					_NoCarryAdv:
.1bf1	b2 0e		lda ($0e)			lda 	(nextFreeMem)
.1bf3	d0 f1		bne $1be6			bne 	_CVSFindEnd
.1bf5	a9 08		lda #$08			lda 	#8 							; this puts a gap in, more for clarity than anything.
.1bf7	a0 00		ldy #$00			ldy 	#0
.1bf9	20 fd 1b	jsr $1bfd			jsr 	AdvanceFreeMem				; we need +1 because the previous code leaves the
.1bfc	60		rts				rts 								; free mem pointer pointing to the last zero offset
.1bfd					AdvanceFreeMem:
.1bfd	18		clc				clc
.1bfe	65 0e		adc $0e				adc 	nextFreeMem
.1c00	85 0e		sta $0e				sta 	nextFreeMem
.1c02	98		tya				tya
.1c03	65 0f		adc $0f				adc 	nextFreeMem+1
.1c05	85 0f		sta $0f				sta 	nextFreeMem+1
.1c07	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/debug.src

.1c08					ExitDump:
.1c08	ba		tsx				tsx 								; save Data Stack in temp1
.1c09	86 10		stx $10				stx 	temp1
.1c0b	4c ff ff	jmp $ffff			jmp 	$FFFF 						; makes the X16-Emulator dump-exit.
.1c0e					BreakCmd:
>1c0e	ff						.byte 	$FF
.1c0f	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/system/decode.src

.1c12					DecodeLineIntoBufPtr:
.1c12	48		pha				pha
.1c13	da		phx				phx
.1c14	5a		phy				phy
.1c15	85 08		sta $08				sta 	srcPtr 						; save the source line.
.1c17	84 09		sty $09				sty 	srcPtr+1
.1c19	90 1b		bcc $1c36			bcc 	_DecodeNoLineNumber
.1c1b	a0 01		ldy #$01			ldy 	#1 							; get line # to YA
.1c1d	b1 08		lda ($08),y			lda 	(srcPtr),y
.1c1f	aa		tax				tax
.1c20	c8		iny				iny
.1c21	b1 08		lda ($08),y			lda 	(srcPtr),y
.1c23	a8		tay				tay
.1c24	8a		txa				txa
.1c25	18		clc				clc
.1c26	20 26 1d	jsr $1d26			jsr 	DecodeYAToBuffer 			; convert to string in buffer
.1c29	aa		tax				tax 								; count in X
.1c2a					_DecodeLineSpace:
.1c2a	e0 05		cpx #$05			cpx 	#5
.1c2c	f0 08		beq $1c36			beq 	_DecodeNoLineNumber
.1c2e	a9 20		lda #$20			lda 	#" " 						; pad to 5 spaces
.1c30	20 04 1d	jsr $1d04			jsr 	DecodeWriteBuffer
.1c33	e8		inx				inx
.1c34	80 f4		bra $1c2a			bra 	_DecodeLineSpace
.1c36					_DecodeNoLineNumber:
.1c36	a0 03		ldy #$03			ldy 	#3 							; initial position.
.1c38					_DecodeLoop:
.1c38	b1 08		lda ($08),y			lda 	(srcPtr),y 					; copy the current character to temp1
.1c3a	85 10		sta $10				sta 	temp1 						; must be an execution address.
.1c3c	c8		iny				iny
.1c3d	b1 08		lda ($08),y			lda 	(srcPtr),y
.1c3f	85 11		sta $11				sta 	temp1+1
.1c41	c8		iny				iny 								; y points to the byte after it.
.1c42	a5 10		lda $10				lda 	temp1
.1c44	c9 48		cmp #$48			cmp 	#NextLine & $FF
.1c46	d0 06		bne $1c4e			bne 	_DecodeNotEOL
.1c48	a5 11		lda $11				lda 	temp1+1
.1c4a	c9 20		cmp #$20			cmp 	#NextLine >> 8
.1c4c	f0 0b		beq $1c59			beq 	_DecodeEOL
.1c4e					_DecodeNotEOL:
.1c4e	20 61 1c	jsr $1c61			jsr 	IdentifyCodeWord
.1c51	20 af 1c	jsr $1caf			jsr 	DecodeFoundWord
.1c54	20 99 1c	jsr $1c99			jsr 	AdvanceToNext 				; advance to next entry in the line.
.1c57	80 df		bra $1c38			bra 	_DecodeLoop 				; and go round again
.1c59					_DecodeEOL:
.1c59	a9 00		lda #$00			lda 	#0
.1c5b	92 0a		sta ($0a)			sta 	(bufPtr)
.1c5d	7a		ply				ply 								; restore registers and exit
.1c5e	fa		plx				plx
.1c5f	68		pla				pla
.1c60	60		rts				rts
.1c61					IdentifyCodeWord:
.1c61	5a		phy				phy 								; save current position on the stack.
.1c62	a9 27		lda #$27			lda 	#(Dictionary) & $FF
.1c64	85 0c		sta $0c				sta 	0+(matchPtr)
.1c66	a9 25		lda #$25			lda 	#(Dictionary) >> 8
.1c68	85 0d		sta $0d				sta 	1+(matchPtr)
.1c6a					_DecodeIdentify:
.1c6a	a0 02		ldy #$02			ldy 	#2 							; have we found a match ?
.1c6c	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.1c6e	c5 10		cmp $10				cmp 	temp1
.1c70	d0 07		bne $1c79			bne 	_DecodeIdNext
.1c72	c8		iny				iny
.1c73	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.1c75	c5 11		cmp $11				cmp 	temp1+1
.1c77	f0 1e		beq $1c97			beq 	_DecodeIdFound
.1c79					_DecodeIdNext:
.1c79	18		clc				clc
.1c7a	b2 0c		lda ($0c)			lda 	(matchPtr)
.1c7c	f0 0a		beq $1c88			beq 	_DecodeIdIssue
.1c7e	65 0c		adc $0c				adc 	matchPtr
.1c80	85 0c		sta $0c				sta 	matchPtr
.1c82	90 e6		bcc $1c6a			bcc 	_DecodeIdentify
.1c84	e6 0d		inc $0d				inc 	matchPtr+1
.1c86	80 e2		bra $1c6a			bra 	_DecodeIdentify
.1c88					_DecodeIdIssue:
.1c88	20 e9 23	jsr $23e9			jsr 	ErrorHandler
>1c8b	42 41 44 20 50 52 4f 47				.text 	"BAD PROGRAM",0
>1c93	52 41 4d 00
.1c97					_DecodeIdFound:
.1c97	7a		ply				ply 								; restore position.
.1c98	60		rts				rts
.1c99					AdvanceToNext:
.1c99	5a		phy				phy 								; get the parameter count from bits 0-1 of the type byte
.1c9a	a0 01		ldy #$01			ldy 	#1
.1c9c	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.1c9e	29 03		and #$03			and 	#3 							; bits 0-1.
.1ca0	7a		ply				ply
.1ca1	c9 03		cmp #$03			cmp 	#3 							; is it n-bytes e.g. specified by the next byte
.1ca3	d0 02		bne $1ca7			bne 	_ATN012
.1ca5	b1 08		lda ($08),y			lda 	(srcPtr),y 					; if so, use that byte as the overall length.
.1ca7					_ATN012:
.1ca7	85 12		sta $12				sta 	temp2 						; now add that to Y
.1ca9	98		tya				tya
.1caa	18		clc				clc
.1cab	65 12		adc $12				adc 	temp2
.1cad	a8		tay				tay
.1cae	60		rts				rts
.1caf					DecodeFoundWord:
.1caf	5a		phy				phy 								; save current position
.1cb0	84 12		sty $12				sty		temp2 						; put it in temp2 as well.
.1cb2	a0 01		ldy #$01			ldy 	#1 							; get the type byte
.1cb4	b1 0c		lda ($0c),y			lda 	(matchPtr),y 				; is there a special decoder check (bit 4 set) ?
.1cb6	29 10		and #$10			and 	#$10
.1cb8	d0 0e		bne $1cc8			bne 	_DFWSpecialDecoder
.1cba	b1 0c		lda ($0c),y			lda 	(matchPtr),y 				; reget it.
.1cbc	30 08		bmi $1cc6			bmi 	_DFWExit 					; if hidden word (bit 7 set)
.1cbe	a9 06		lda #$06			lda 	#CTH_Keyword				; output a space to the buffer
.1cc0	20 04 1d	jsr $1d04			jsr 	DecodeWriteBuffer
.1cc3	20 e1 1c	jsr $1ce1			jsr 	DecodeCurrentWord 			; expand that.
.1cc6					_DFWExit:
.1cc6	7a		ply				ply 								; restore current position
.1cc7	60		rts				rts
.1cc8					_DFWSpecialDecoder:
.1cc8	a0 04		ldy #$04			ldy 	#4 							; the decode word address is at offset 4,5
.1cca	b1 0c		lda ($0c),y			lda 	(matchPtr),y 				; copy this into temp2
.1ccc	85 12		sta $12				sta 	temp2
.1cce	c8		iny				iny
.1ccf	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.1cd1	85 13		sta $13				sta 	temp2+1
.1cd3	7a		ply				ply 	 							; restore current position into Y
.1cd4	48		pha				pha 								; save registers
.1cd5	da		phx				phx
.1cd6	5a		phy				phy
.1cd7	20 de 1c	jsr $1cde			jsr 	_DFWCallDecoder				; call the decoder routine
.1cda	7a		ply				ply 								; restore registers and exit
.1cdb	fa		plx				plx
.1cdc	68		pla				pla
.1cdd	60		rts				rts
.1cde					_DFWCallDecoder:
.1cde	6c 12 00	jmp ($0012)			jmp 	(temp2)
.1ce1					DecodeCurrentWord:
.1ce1	5a		phy				phy
.1ce2	a0 01		ldy #$01			ldy 	#1 							; read type byte
.1ce4	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.1ce6	a0 04		ldy #$04			ldy 	#4 							; original offset
.1ce8	4a		lsr a				lsr 	a 							; encoder/decoder bits in 0-1
.1ce9	4a		lsr a				lsr 	a 							; add 2 to Y for each encoder/decoder
.1cea	4a		lsr a				lsr 	a 							; bit set.
.1ceb	4a		lsr a				lsr 	a
.1cec	4a		lsr a				lsr 	a 							; decoder bit
.1ced	90 02		bcc $1cf1			bcc 	_DWBNoDec
.1cef	c8		iny				iny
.1cf0	c8		iny				iny
.1cf1					_DWBNoDec:
.1cf1	4a		lsr a				lsr 	a
.1cf2	90 02		bcc $1cf6			bcc 	_DWBNoEnc
.1cf4	c8		iny				iny
.1cf5	c8		iny				iny
.1cf6					_DWBNoEnc:
.1cf6					_DWBWordOut:
.1cf6	b1 0c		lda ($0c),y			lda 	(matchPtr),y 				; output until bit 7 set.
.1cf8	48		pha				pha
.1cf9	29 7f		and #$7f			and 	#$7F
.1cfb	20 04 1d	jsr $1d04			jsr		DecodeWriteBuffer
.1cfe	c8		iny				iny
.1cff	68		pla				pla
.1d00	10 f4		bpl $1cf6			bpl 	_DWBWordOut
.1d02	7a		ply				ply 								; restore Y and exit
.1d03	60		rts				rts
.1d04					DecodeWriteBuffer:
.1d04	92 0a		sta ($0a)			sta 	(bufPtr)
.1d06	e6 0a		inc $0a				inc 	bufPtr
.1d08	d0 02		bne $1d0c			bne 	_DWBNoCarry
.1d0a	e6 0b		inc $0b				inc 	bufPtr+1
.1d0c					_DWBNoCarry:
.1d0c	60		rts				rts
.1d0d					DecodeOutputData:
.1d0d	48		pha				pha
.1d0e	da		phx				phx
.1d0f	5a		phy				phy
.1d10	b1 08		lda ($08),y			lda 	(srcPtr),y 					; length + 1
.1d12	aa		tax				tax
.1d13					_DODLoop:
.1d13	ca		dex				dex 								; done it all ?
.1d14	f0 0c		beq $1d22			beq		_DODExit
.1d16	c8		iny				iny 								; output next character
.1d17	b1 08		lda ($08),y			lda 	(srcPtr),y
.1d19	29 7f		and #$7f			and 	#$7F
.1d1b	f0 f6		beq $1d13			beq 	_DODLoop 					; don't print NULL
.1d1d	20 04 1d	jsr $1d04			jsr 	DecodeWriteBuffer
.1d20	80 f1		bra $1d13			bra 	_DODLoop
.1d22					_DODExit:
.1d22	7a		ply				ply
.1d23	fa		plx				plx
.1d24	68		pla				pla
.1d25	60		rts				rts
.1d26					DecodeYAToBuffer:
.1d26	da		phx				phx
.1d27	5a		phy				phy
.1d28	48		pha				pha
.1d29	a5 0a		lda $0a				lda 	bufPtr 						; copy bufPtr to temp2
.1d2b	85 12		sta $12				sta 	temp2
.1d2d	a5 0b		lda $0b				lda 	bufPtr+1
.1d2f	85 13		sta $13				sta 	temp2+1
.1d31	68		pla				pla
.1d32	20 81 21	jsr $2181			jsr 	ConvertToStringMain 		; convert YA to string there
.1d35	aa		tax				tax 								; chars output to X
.1d36	18		clc				clc
.1d37	65 0a		adc $0a				adc 	bufPtr 						; add to buffer pointer
.1d39	85 0a		sta $0a				sta 	bufPtr
.1d3b	90 02		bcc $1d3f			bcc 	_DYABNoCarry
.1d3d	e6 0b		inc $0b				inc 	bufPtr+1
.1d3f					_DYABNoCarry:
.1d3f	8a		txa				txa 								; count in A
.1d40	7a		ply				ply									; restore and exit.
.1d41	fa		plx				plx
.1d42	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/edit.src

.1d43					EditProgram:
.1d43	20 c0 1d	jsr $1dc0			jsr 	EDFindLine					; find line address -> temp1
.1d46	90 0f		bcc $1d57			bcc 	_EPNotFound 				; if missing don't delete it.
.1d48	a5 10		lda $10				lda 	temp1 						; save line address
.1d4a	48		pha				pha
.1d4b	a5 11		lda $11				lda 	temp1+1
.1d4d	48		pha				pha
.1d4e	20 65 1d	jsr $1d65			jsr 	EDDeleteLine 				; delete the line
.1d51	68		pla				pla 								; restore line address
.1d52	85 11		sta $11				sta 	temp1+1
.1d54	68		pla				pla
.1d55	85 10		sta $10				sta 	temp1
.1d57					_EPNotFound:
.1d57	ad 10 09	lda $0910			lda 	encodeBuffer 				; is there anything in the line.
.1d5a	c9 05		cmp #$05			cmp 	#5 							; <offset> <line#> <next line>
.1d5c	f0 03		beq $1d61			beq 	_EPNoInsert
.1d5e	20 88 1d	jsr $1d88			jsr 	EDInsertLine 				; insert line back in.
.1d61					_EPNoInsert:
.1d61	20 d2 1b	jsr $1bd2			jsr 	ClearVariableSpace
.1d64	60		rts				rts
.1d65					EDDeleteLine:
.1d65	20 d2 1b	jsr $1bd2			jsr 	ClearVariableSpace
.1d68	a0 00		ldy #$00			ldy 	#0 							; this is the offset to copy down.
.1d6a	a2 00		ldx #$00			ldx 	#0
.1d6c	b1 10		lda ($10),y			lda 	(temp1),y
.1d6e	a8		tay				tay 								; put in Y
.1d6f					_EDDelLoop:
.1d6f	b1 10		lda ($10),y			lda 	(temp1),y 					; get it
.1d71	81 10		sta ($10,x)			sta 	(temp1,x) 					; write it.
.1d73	a5 10		lda $10				lda 	temp1 						; check if pointer has reached the end of
.1d75	c5 0e		cmp $0e				cmp		nextFreeMem 				; low memory. We will have copied down an
.1d77	d0 06		bne $1d7f			bne 	_EDDelNext 					; extra pile of stuff - technically should
.1d79	a5 11		lda $11				lda 	temp1+1 					; check the upper value (e.g. temp1+y)
.1d7b	c5 0f		cmp $0f				cmp 	nextFreeMem+1				; doesn't really matter.
.1d7d	f0 08		beq $1d87			beq		_EDDelExit
.1d7f					_EDDelNext:
.1d7f	e6 10		inc $10				inc 	temp1 						; go to next byte.
.1d81	d0 ec		bne $1d6f			bne 	_EDDelLoop
.1d83	e6 11		inc $11				inc 	temp1+1
.1d85	80 e8		bra $1d6f			bra 	_EDDelLoop
.1d87					_EDDelExit:
.1d87	60		rts				rts
.1d88					EDInsertLine:
.1d88	20 d2 1b	jsr $1bd2			jsr 	ClearVariableSpace
.1d8b	a5 0e		lda $0e				lda 	nextFreeMem 				; copy high memory to temp3
.1d8d	85 14		sta $14				sta 	temp3
.1d8f	a5 0f		lda $0f				lda 	nextFreeMem+1
.1d91	85 15		sta $15				sta 	temp3+1
.1d93	ac 10 09	ldy $0910			ldy 	encodeBuffer 				; space to move it to in Y
.1d96	a2 00		ldx #$00			ldx 	#0
.1d98					_EDInsLoop:
.1d98	a1 14		lda ($14,x)			lda 	(temp3,x)					; copy it up
.1d9a	91 14		sta ($14),y			sta 	(temp3),y
.1d9c	a5 14		lda $14				lda 	temp3 						; reached the insert point (temp1)
.1d9e	c5 10		cmp $10				cmp 	temp1
.1da0	d0 06		bne $1da8			bne 	_EDINextShift
.1da2	a5 15		lda $15				lda 	temp3+1
.1da4	c5 11		cmp $11				cmp 	temp1+1
.1da6	f0 0a		beq $1db2			beq 	_EDIShiftOver
.1da8					_EDINextShift:
.1da8	a5 14		lda $14				lda 	temp3 						; decrement the copy pointer.
.1daa	d0 02		bne $1dae			bne 	_EDINoBorrow
.1dac	c6 15		dec $15				dec 	temp3+1
.1dae					_EDINoBorrow:
.1dae	c6 14		dec $14				dec 	temp3
.1db0	80 e6		bra $1d98			bra 	_EDInsLoop
.1db2					_EDIShiftOver:
.1db2	a0 00		ldy #$00			ldy 	#0
.1db4					_EDICopyCode:
.1db4	b9 10 09	lda $0910,y			lda 	encodeBuffer,y				; read from the current line
.1db7	91 10		sta ($10),y			sta 	(temp1),y 					; write out
.1db9	c8		iny				iny 								; bump pointers
.1dba	cc 10 09	cpy $0910			cpy 	encodeBuffer 				; done the whole lot ?
.1dbd	d0 f5		bne $1db4			bne 	_EDICopyCode
.1dbf	60		rts				rts
.1dc0					EDFindLine:
.1dc0	a9 00		lda #$00			lda 	#(programMemory) & $FF
.1dc2	85 10		sta $10				sta 	0+(temp1)
.1dc4	a9 40		lda #$40			lda 	#(programMemory) >> 8
.1dc6	85 11		sta $11				sta 	1+(temp1)
.1dc8					_EDFLLoop:
.1dc8	b2 10		lda ($10)			lda 	(temp1) 					; check offset
.1dca	f0 24		beq $1df0			beq 	_EDFLFail 					; then obviously that's the end ;-) (great comment !)
.1dcc	a0 01		ldy #$01			ldy 	#1							; look at line #
.1dce	38		sec				sec
.1dcf	ad 11 09	lda $0911			lda 	encodeBuffer+1				; subtract the current from the target
.1dd2	f1 10		sbc ($10),y			sbc 	(temp1),y 					; so if searching for 100 and this one is 90,
.1dd4	aa		tax				tax	 								; this will return 10.
.1dd5	ad 12 09	lda $0912			lda 	encodeBuffer+2
.1dd8	c8		iny				iny
.1dd9	f1 10		sbc ($10),y			sbc 	(temp1),y
.1ddb	90 13		bcc $1df0			bcc 	_EDFLFail					; if target < current then failed.
.1ddd	d0 04		bne $1de3			bne 	_EDFLNext 					; if non-zero then goto next
.1ddf	e0 00		cpx #$00			cpx 	#0 							; same for the LSB - zero if match found.
.1de1	f0 0f		beq $1df2			beq 	_EDFLFound
.1de3					_EDFLNext:
.1de3	18		clc				clc
.1de4	a5 10		lda $10				lda 	temp1
.1de6	72 10		adc ($10)			adc 	(temp1)
.1de8	85 10		sta $10				sta 	temp1
.1dea	90 02		bcc $1dee			bcc 	_NoCarryAdv
.1dec	e6 11		inc $11				inc 	temp1+1
.1dee					_NoCarryAdv:
.1dee	80 d8		bra $1dc8			bra 	_EDFLLoop
.1df0					_EDFLFail:
.1df0	18		clc				clc
.1df1	60		rts				rts
.1df2					_EDFLFound:
.1df2	38		sec				sec
.1df3	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/list.src

.1df4					ListCode:
.1df4	64 1e		stz $1e				stz 	ListLowest 					; zero lowest line#
.1df6	64 1f		stz $1f				stz 	ListLowest+1
.1df8	a9 18		lda #$18			lda 	#24 						; show max 24 after lowest line
.1dfa	85 1d		sta $1d				sta 	ListCount
.1dfc	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.1dfe	85 18		sta $18				sta 	0+(listPtr)
.1e00	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.1e02	85 19		sta $19				sta 	1+(listPtr)
.1e04	86 10		stx $10				stx 	temp1						; S->A
.1e06	ba		tsx				tsx
.1e07	8a		txa				txa
.1e08	a6 10		ldx $10				ldx 	temp1
.1e0a	c9 80		cmp #$80			cmp 	#NumberStackBase
.1e0c	f0 0e		beq $1e1c			beq 	_LCLoop
.1e0e	a5 06		lda $06				lda 	TOS 						; copy TOS to lowest
.1e10	85 1e		sta $1e				sta 	ListLowest
.1e12	a5 07		lda $07				lda 	TOS+1
.1e14	85 1f		sta $1f				sta 	ListLowest+1
.1e16	68		pla				pla
.1e17	85 07		sta $07				sta 	TOS+1
.1e19	68		pla				pla
.1e1a	85 06		sta $06				sta 	TOS
.1e1c					_LCLoop:
.1e1c	b2 18		lda ($18)			lda 	(listPtr)					; reached end ?
.1e1e	f0 4c		beq $1e6c			beq 	_LCExit
.1e20	a0 01		ldy #$01			ldy 	#1							; >= list lowest
.1e22	b1 18		lda ($18),y			lda 	(listPtr),y
.1e24	c5 1e		cmp $1e				cmp 	ListLowest
.1e26	c8		iny				iny
.1e27	b1 18		lda ($18),y			lda 	(listPtr),y
.1e29	e5 1f		sbc $1f				sbc 	ListLowest+1
.1e2b	90 32		bcc $1e5f			bcc 	_LCNext
.1e2d	a9 10		lda #$10			lda 	#(textBuffer) & $FF
.1e2f	85 0a		sta $0a				sta 	0+(bufPtr)
.1e31	a9 08		lda #$08			lda 	#(textBuffer) >> 8
.1e33	85 0b		sta $0b				sta 	1+(bufPtr)
.1e35	a5 18		lda $18				lda 	listPtr 					; output the line.
.1e37	a4 19		ldy $19				ldy 	listPtr+1
.1e39	38		sec				sec
.1e3a	20 12 1c	jsr $1c12			jsr 	DecodeLineIntoBufPtr
.1e3d	a9 02		lda #$02			lda 	#CTH_LineNo
.1e3f	20 55 24	jsr $2455			jsr 	ExternColour
.1e42	a0 ff		ldy #$ff			ldy 	#255
.1e44					_LCLoop2:
.1e44	c8		iny				iny
.1e45	b9 10 08	lda $0810,y			lda 	textBuffer,y
.1e48	f0 0e		beq $1e58			beq 	_LCEnd
.1e4a	c9 20		cmp #$20			cmp 	#32
.1e4c	b0 05		bcs $1e53			bcs 	_LCPrint
.1e4e	20 55 24	jsr $2455			jsr 	ExternColour
.1e51	a9 20		lda #$20			lda 	#32
.1e53					_LCPrint:
.1e53	20 49 24	jsr $2449			jsr 	ExternPrint
.1e56	80 ec		bra $1e44			bra 	_LCLoop2
.1e58	a9 0d		lda #$0d	_LCEnd:	lda 	#13 						; new line
.1e5a	20 49 24	jsr $2449			jsr 	ExternPrint
.1e5d	c6 1d		dec $1d				dec 	ListCount					; done all the lines allowed
.1e5f					_LCNext:
.1e5f	18		clc				clc
.1e60	a5 18		lda $18				lda 	listPtr
.1e62	72 18		adc ($18)			adc 	(listPtr)
.1e64	85 18		sta $18				sta 	listPtr
.1e66	90 02		bcc $1e6a			bcc 	_NoCarryAdv
.1e68	e6 19		inc $19				inc 	listPtr+1
.1e6a					_NoCarryAdv:
.1e6a	80 b0		bra $1e1c			bra 	_LCLoop 					; go round again.
.1e6c					_LCExit:
.1e6c	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/system/miscellany.src

.1e6f					RunProgram:
.1e6f	86 10		stx $10				stx 	temp1
.1e71	a2 80		ldx #$80			ldx 	#NumberStackBase
.1e73	9a		txs				txs
.1e74	a6 10		ldx $10				ldx 	temp1
.1e76	20 d2 1b	jsr $1bd2			jsr 	ClearVariableSpace 			; clear variables etc.
.1e79	a2 00		ldx #$00			ldx		#ProgramMemory & $FF		; boot address
.1e7b	a0 40		ldy #$40			ldy 	#ProgramMemory >>8
.1e7d	20 41 10	jsr $1041			jsr 	InitialiseCoreCode 			; initialise the NEXT routine at $00
.1e80	4c 00 00	jmp $0000			jmp 	NextCode
.1e83					Call6502:
.1e83	a5 06		lda $06				lda 	TOS 						; copy call address
.1e85	85 10		sta $10				sta 	temp1
.1e87	a5 07		lda $07				lda 	TOS+1
.1e89	85 11		sta $11				sta 	temp1+1
.1e8b	68		pla				pla
.1e8c	85 07		sta $07				sta 	TOS+1
.1e8e	68		pla				pla
.1e8f	85 06		sta $06				sta 	TOS
.1e91	20 97 1e	jsr $1e97			jsr 	_CallTemp1 					; call it
.1e94	4c 00 00	jmp $0000			jmp 	NextCode
.1e97					_CallTemp1:
.1e97	6c 10 00	jmp ($0010)			jmp 	(temp1)
.1e9a					AssertCode:
.1e9a	a5 06		lda $06				lda 	TOS 						; TOS = 0
.1e9c	05 07		ora $07				ora 	TOS+1
.1e9e	f0 09		beq $1ea9			beq 	_ASFail 					; if zero fail
.1ea0	68		pla				pla
.1ea1	85 07		sta $07				sta 	TOS+1
.1ea3	68		pla				pla
.1ea4	85 06		sta $06				sta 	TOS
.1ea6	4c 00 00	jmp $0000			jmp 	NextCode
.1ea9					_ASFail:
.1ea9	20 e9 23	jsr $23e9			jsr 	ErrorHandler
>1eac	41 53 53 45 52 54 00				.text 	"ASSERT",0
.1eb3					StopCode:
.1eb3	20 e9 23	jsr $23e9			jsr 	ErrorHandler
>1eb6	53 54 4f 50 00					.text 	"STOP",0
.1ebb					EndProgram:
.1ebb	4c 14 10	jmp $1014			jmp 	WarmStart
.1ebe					VlistCode:
.1ebe	a9 27		lda #$27			lda 	#(Dictionary) & $FF
.1ec0	85 10		sta $10				sta 	0+(temp1)
.1ec2	a9 25		lda #$25			lda 	#(Dictionary) >> 8
.1ec4	85 11		sta $11				sta 	1+(temp1)
.1ec6	a0 01		ldy #$01	_VLLoop:ldy 	#1							; type byte
.1ec8	b1 10		lda ($10),y			lda 	(temp1),y
.1eca	a0 04		ldy #$04			ldy 	#4 							; Y = 4
.1ecc	4a		lsr a				lsr 	a 							; shift bits 4 and 5 to 0,1
.1ecd	4a		lsr a				lsr 	a
.1ece	4a		lsr a				lsr		a
.1ecf	4a		lsr a				lsr 	a
.1ed0	4a		lsr a				lsr 	a 							; add those bits in
.1ed1	90 02		bcc $1ed5			bcc 	_VLNoDec
.1ed3	c8		iny				iny
.1ed4	c8		iny				iny
.1ed5					_VLNoDec:
.1ed5	4a		lsr a				lsr 	a
.1ed6	90 02		bcc $1eda			bcc 	_VLNoEnc
.1ed8	c8		iny				iny
.1ed9	c8		iny				iny
.1eda					_VLNoEnc:
.1eda	b1 10		lda ($10),y			lda 	(temp1),y 					; remove $$ words
.1edc	c9 24		cmp #$24			cmp 	#"$"
.1ede	d0 06		bne $1ee6			bne 	_VLPrint
.1ee0	c8		iny				iny
.1ee1	51 10		eor ($10),y			eor 	(temp1),y
.1ee3	f0 13		beq $1ef8			beq 	_VLNext
.1ee5	88		dey				dey
.1ee6					_VLPrint:
.1ee6	b1 10		lda ($10),y			lda 	(temp1),y
.1ee8	48		pha				pha
.1ee9	c8		iny				iny
.1eea	29 7f		and #$7f			and 	#$7F
.1eec	20 49 24	jsr $2449			jsr 	ExternPrint
.1eef	68		pla				pla
.1ef0	0a		asl a				asl 	a
.1ef1	90 f3		bcc $1ee6			bcc 	_VLPrint
.1ef3	a9 20		lda #$20			lda 	#32
.1ef5	20 49 24	jsr $2449			jsr 	ExternPrint
.1ef8					_VLNext:
.1ef8	18		clc				clc 								; go to next
.1ef9	b2 10		lda ($10)			lda 	(temp1)
.1efb	65 10		adc $10				adc 	temp1
.1efd	85 10		sta $10				sta 	temp1
.1eff	90 02		bcc $1f03			bcc 	_VLNoCarry
.1f01	e6 11		inc $11				inc 	temp1+1
.1f03					_VLNoCarry:
.1f03	b2 10		lda ($10)			lda 	(temp1)
.1f05	d0 bf		bne $1ec6			bne 	_VLLoop
.1f07	a9 0d		lda #$0d			lda 	#13
.1f09	20 49 24	jsr $2449			jsr 	ExternPrint
.1f0c	4c 00 00	jmp $0000			jmp 	NextCode
.1f0f					DumpStack:
.1f0f	a9 5b		lda #$5b			lda		#"["
.1f11	20 49 24	jsr $2449			jsr 	ExternPrint
.1f14	86 10		stx $10				stx 	temp1 						; X -> A
.1f16	ba		tsx				tsx
.1f17	8a		txa				txa
.1f18	a6 10		ldx $10				ldx 	temp1
.1f1a	c9 80		cmp #$80			cmp 	#NumberStackBase 			; out of range, exit
.1f1c	f0 2f		beq $1f4d			beq 	_DSExit
.1f1e	48		pha				pha 								; save it
.1f1f	a9 07		lda #$07			lda 	#COL_WHITE
.1f21	20 55 24	jsr $2455			jsr 	ExternColour
.1f24	a5 06		lda $06				lda 	TOS 						; print TOS then stack values backwards
.1f26	a4 07		ldy $07				ldy 	TOS+1
.1f28	38		sec				sec 								; print unsigned.
.1f29	20 5b 21	jsr $215b			jsr 	PrintYA
.1f2c	a9 06		lda #$06			lda 	#COL_CYAN
.1f2e	20 55 24	jsr $2455			jsr 	ExternColour
.1f31	7a		ply				ply 								; restore offset
.1f32					_DSLoop:
.1f32	c0 7e		cpy #$7e			cpy 	#NumberStackBase-2 			; till done whole stack.
.1f34	f0 17		beq $1f4d			beq 	_DSExit
.1f36	a9 20		lda #$20			lda 	#" " 						; space
.1f38	20 49 24	jsr $2449			jsr 	ExternPrint
.1f3b	5a		phy				phy 								; save pos
.1f3c	b9 01 01	lda $0101,y			lda 	$0101,y 					; read stack item
.1f3f	48		pha				pha
.1f40	b9 02 01	lda $0102,y			lda 	$0102,y
.1f43	7a		ply				ply
.1f44	38		sec				sec
.1f45	20 5b 21	jsr $215b			jsr 	PrintYA 					; print it
.1f48	7a		ply				ply 								; restore and advance pos
.1f49	c8		iny				iny
.1f4a	c8		iny				iny
.1f4b	80 e5		bra $1f32			bra 	_DSLoop
.1f4d					_DSExit:
.1f4d	a9 5d		lda #$5d			lda		#"]"
.1f4f	20 49 24	jsr $2449			jsr 	ExternPrint
.1f52	a9 0d		lda #$0d			lda 	#13
.1f54	20 49 24	jsr $2449			jsr 	ExternPrint
.1f57	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/system/old.src

.1f5a					OldCode:
.1f5a	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.1f5c	85 08		sta $08				sta 	0+(srcPtr)
.1f5e	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.1f60	85 09		sta $09				sta 	1+(srcPtr)
.1f62	a0 03		ldy #$03			ldy 	#3 							; start after line# / offset
.1f64					_OldLoop:
.1f64	b1 08		lda ($08),y			lda 	(srcPtr),y 					; copy the current character to temp1
.1f66	85 10		sta $10				sta 	temp1 						; must be an execution address.
.1f68	c8		iny				iny
.1f69	b1 08		lda ($08),y			lda 	(srcPtr),y
.1f6b	85 11		sta $11				sta 	temp1+1
.1f6d	c8		iny				iny
.1f6e	a5 10		lda $10				lda 	temp1 						; have we reached the end ?
.1f70	c9 48		cmp #$48			cmp 	#NextLine & $FF
.1f72	d0 06		bne $1f7a			bne 	_OldNotEOL
.1f74	a5 11		lda $11				lda 	temp1+1
.1f76	c9 20		cmp #$20			cmp 	#NextLine >> 8
.1f78	f0 08		beq $1f82			beq 	_OldEOL
.1f7a					_OldNotEOL:
.1f7a	20 61 1c	jsr $1c61			jsr 	IdentifyCodeWord			; what is it ?
.1f7d	20 99 1c	jsr $1c99			jsr 	AdvanceToNext 				; advance to next entry in the line.
.1f80	80 e2		bra $1f64			bra	 	_OldLoop
.1f82					_OldEOL:
.1f82	8c 00 40	sty $4000			sty 	ProgramMemory 				; Y is the offset.
.1f85	20 d2 1b	jsr $1bd2			jsr 	ClearVariableSpace 			; clear variables, reset pointers
.1f88	4c 0d 10	jmp $100d			jmp 	WarmStartBlankStack

;******  Return to file: kernel.asm


;******  Processing file: words/system/saveload.src

.1f8b					System_Save:
.1f8b	20 d2 1b	jsr $1bd2			jsr 	ClearVariableSpace  		; make sure start/end are right
.1f8e	20 0d 20	jsr $200d			jsr 	ExtendWithDictionary 		; attach the dictionary addresses.
.1f91	20 b9 1f	jsr $1fb9			jsr 	SLGetFileName 				; get filename -> temp3
.1f94	a5 0e		lda $0e				lda 	nextFreeMem 				; end address
.1f96	85 10		sta $10				sta 	temp1
.1f98	a5 0f		lda $0f				lda 	nextFreeMem+1
.1f9a	85 11		sta $11				sta 	temp1+1
.1f9c	a9 00		lda #$00			lda 	#ProgramMemory & $FF 		; program start to YA
.1f9e	a0 40		ldy #$40			ldy 	#ProgramMemory >> 8
.1fa0	20 9d 24	jsr $249d			jsr 	ExternSave
.1fa3	20 d2 1b	jsr $1bd2			jsr 	ClearVariableSpace  		; make sure start/end are right
.1fa6	4c 0d 10	jmp $100d			jmp 	WarmStartBlankStack
.1fa9					System_Load:
.1fa9	20 b9 1f	jsr $1fb9			jsr 	SLGetFileName 				; get filename -> temp3
.1fac	a9 00		lda #$00			lda 	#ProgramMemory & $FF 		; program start to YA
.1fae	a0 40		ldy #$40			ldy 	#ProgramMemory >> 8
.1fb0	20 d3 24	jsr $24d3			jsr 	ExternLoad
.1fb3	20 d2 1b	jsr $1bd2			jsr 	ClearVariableSpace 			; reset everything.
.1fb6	4c 0d 10	jmp $100d			jmp 	WarmStartBlankStack
.1fb9					SLGetFileName:
.1fb9	ba		tsx				tsx
.1fba	e0 80		cpx #$80			cpx 	#NumberStackBase
.1fbc	f0 3a		beq $1ff8			beq 	_SLFNFail
.1fbe	a9 10		lda #$10			lda 	#textBuffer & $FF 			; f/n in input buffer.
.1fc0	85 14		sta $14				sta 	temp3
.1fc2	a9 08		lda #$08			lda 	#textBuffer >> 8
.1fc4	85 15		sta $15				sta 	temp3+1
.1fc6	a0 00		ldy #$00			ldy 	#0
.1fc8	b1 06		lda ($06),y	_SLCopy:lda 	(TOS),y
.1fca	91 14		sta ($14),y			sta 	(temp3),y
.1fcc	c8		iny				iny
.1fcd	c9 00		cmp #$00			cmp		#0
.1fcf	d0 f7		bne $1fc8			bne 	_SLCopy
.1fd1	88		dey				dey
.1fd2	a2 03		ldx #$03			ldx 	#3 							; check if it ends in .RPL
.1fd4					_SLCheckEnd:
.1fd4	88		dey				dey
.1fd5	bd 08 20	lda $2008,x			lda 	_SLFNExtension,x
.1fd8	d1 14		cmp ($14),y			cmp 	(temp3),y
.1fda	d0 05		bne $1fe1			bne 	_SLNoExtension
.1fdc	ca		dex				dex
.1fdd	10 f5		bpl $1fd4			bpl 	_SLCheckEnd
.1fdf	80 16		bra $1ff7			bra 	_SLExit
.1fe1					_SLNoExtension:
.1fe1	a0 ff		ldy #$ff			ldy 	#255						; add the extension.
.1fe3					_SLFindend:
.1fe3	c8		iny				iny
.1fe4	b9 10 08	lda $0810,y			lda 	textBuffer,y
.1fe7	d0 fa		bne $1fe3			bne 	_SLFindend
.1fe9	a2 00		ldx #$00			ldx 	#0
.1feb					_SLAppend:
.1feb	bd 08 20	lda $2008,x			lda 	_SLFNExtension,x
.1fee	99 10 08	sta $0810,y			sta 	textBuffer,y
.1ff1	e8		inx				inx
.1ff2	c8		iny				iny
.1ff3	c9 00		cmp #$00			cmp 	#0
.1ff5	d0 f4		bne $1feb			bne 	_SLAppend
.1ff7					_SLExit:
.1ff7	60		rts				rts
.1ff8					_SLFNFail:
.1ff8	20 e9 23	jsr $23e9			jsr 	ErrorHandler
>1ffb	42 41 44 20 46 49 4c 45				.text 	"BAD FILENAME",0
>2003	4e 41 4d 45 00
.2008					_SLFNExtension:
>2008	2e 52 50 4c 00					.text 	".RPL",0
.200d					ExtendWithDictionary:
.200d	20 36 20	jsr $2036			jsr 	_EWDMarker 					; 8 bytes after the final offset write a marker
.2010	a9 27		lda #$27			lda 	#(Dictionary) & $FF
.2012	85 10		sta $10				sta 	0+(temp1)
.2014	a9 25		lda #$25			lda 	#(Dictionary) >> 8
.2016	85 11		sta $11				sta 	1+(temp1)
.2018					_EWDLoop:
.2018	b2 10		lda ($10)			lda 	(temp1)						; end
.201a	f0 1a		beq $2036			beq 	_EWDMarker
.201c	a0 02		ldy #$02			ldy 	#2 							; output the address
.201e	b1 10		lda ($10),y			lda 	(temp1),y
.2020	20 3f 20	jsr $203f			jsr 	_EWDWrite
.2023	c8		iny				iny
.2024	b1 10		lda ($10),y			lda 	(temp1),y
.2026	20 3f 20	jsr $203f			jsr 	_EWDWrite
.2029	18		clc				clc 								; next entry.
.202a	a5 10		lda $10				lda 	temp1
.202c	72 10		adc ($10)			adc 	(temp1)
.202e	85 10		sta $10				sta 	temp1
.2030	90 e6		bcc $2018			bcc 	_EWDLoop
.2032	e6 11		inc $11				inc 	temp1+1
.2034	80 e2		bra $2018			bra 	_EWDLoop
.2036					_EWDMarker:
.2036	a9 ff		lda #$ff			lda 	#$FF
.2038	20 3f 20	jsr $203f			jsr 	_EWDWrite
.203b	20 3f 20	jsr $203f			jsr 	_EWDWrite
.203e	60		rts				rts
.203f					_EWDWrite:
.203f	92 0e		sta ($0e)			sta 	(nextFreeMem)
.2041	e6 0e		inc $0e				inc 	nextFreeMem
.2043	d0 02		bne $2047			bne 	_EWDExit
.2045	e6 0f		inc $0f				inc 	nextFreeMem+1
.2047					_EWDExit:
.2047	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/skipper.src

.2048					NextLine:
.2048	18		clc				clc
.2049	a5 03		lda $03				lda 	IP
.204b	72 03		adc ($03)			adc 	(IP)
.204d	85 03		sta $03				sta 	IP
.204f	90 02		bcc $2053			bcc 	_NoCarryAdv
.2051	e6 04		inc $04				inc 	IP+1
.2053					_NoCarryAdv:
.2053	b2 03		lda ($03)			lda 	(IP)						; is there any following program ?
.2055	f0 05		beq $205c			beq 	_NLGoEnd
.2057	a2 01		ldx #$01			ldx 	#1 							; start 3 in (-2 for Next)
.2059	4c 00 00	jmp $0000			jmp 	NextCode
.205c					_NLGoEnd:
.205c	4c 14 10	jmp $1014			jmp 	WarmStart
.205f					SkipComment:
.205f	e8		inx				inx									; (IP),X points to the length.
.2060	e8		inx				inx
.2061	8a		txa				txa
.2062	a8		tay				tay 								; put into Y
.2063	18		clc				clc
.2064	71 03		adc ($03),y			adc 	(IP),y 						; add the length to X
.2066	aa		tax				tax 								; put back in X
.2067	ca		dex				dex
.2068	ca		dex				dex
.2069	4c 00 00	jmp $0000			jmp 	NextCode
.206c					CommentDecoder:
.206c	a9 06		lda #$06			lda 	#CTH_Keyword
.206e	20 04 1d	jsr $1d04			jsr 	DecodeWriteBuffer
.2071	a9 27		lda #$27			lda 	#"'"
.2073	20 04 1d	jsr $1d04			jsr 	DecodeWriteBuffer
.2076	b1 08		lda ($08),y			lda 	(srcPtr),y 					; check if there is no data
.2078	c9 01		cmp #$01			cmp 	#1
.207a	f0 0d		beq $2089			beq 	_CDEmpty 					; if so print nothing.
.207c	a9 0b		lda #$0b			lda 	#CTH_Comment
.207e	20 04 1d	jsr $1d04			jsr 	DecodeWriteBuffer
.2081	20 0d 1d	jsr $1d0d			jsr 	DecodeOutputData
.2084	a9 20		lda #$20			lda 	#32
.2086	20 04 1d	jsr $1d04			jsr 	DecodeWriteBuffer
.2089					_CDEmpty
.2089	60		rts				rts
.208a					DefineCode:
.208a	20 e9 23	jsr $23e9			jsr 	ErrorHandler
>208d	52 45 41 43 48 45 44 20				.text 	"REACHED DEFINITION",0
>2095	44 45 46 49 4e 49 54 49 4f 4e 00
.20a0					DefineDecoder:
.20a0	a9 07		lda #$07			lda 	#CTH_Definition
.20a2	20 04 1d	jsr $1d04			jsr 	DecodeWriteBuffer
.20a5	a9 3a		lda #$3a			lda 	#":"
.20a7	20 04 1d	jsr $1d04			jsr 	DecodeWriteBuffer
.20aa	20 0d 1d	jsr $1d0d			jsr 	DecodeOutputData
.20ad	a9 20		lda #$20			lda 	#32
.20af	20 04 1d	jsr $1d04			jsr 	DecodeWriteBuffer
.20b2	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/toint.src

.20b3					ConvertToInteger:
.20b3	84 17		sty $17				sty 	temp4+1
.20b5	85 16		sta $16				sta 	temp4
.20b7	64 14		stz $14				stz 	temp3 						; reset value
.20b9	64 15		stz $15				stz 	temp3+1
.20bb	64 10		stz $10				stz 	temp1 						; temp1 = 0 (decimal) 255 (hex)
.20bd	a0 00		ldy #$00			ldy 	#0 							; look at first character
.20bf	b1 16		lda ($16),y			lda 	(temp4),y
.20c1	49 2d		eor #$2d			eor 	#"-"						; zero if '-'
.20c3	85 11		sta $11				sta 	temp1+1 					; save this in temp1+1
.20c5	d0 01		bne $20c8			bne 	_CTINotMinus
.20c7	c8		iny				iny									; skip -
.20c8					_CTINotMinus:
.20c8	b1 16		lda ($16),y			lda 	(temp4),y
.20ca	c9 24		cmp #$24			cmp		#'$'						; if $ then skip it and set hex flag
.20cc	d0 03		bne $20d1			bne 	_CTILoop
.20ce	c6 10		dec $10				dec 	temp1
.20d0	c8		iny				iny
.20d1					_CTILoop:
.20d1	b1 16		lda ($16),y			lda 	(temp4),y 					; next digit
.20d3	29 7f		and #$7f			and 	#$7F 						; drop end of word flag
.20d5	38		sec				sec
.20d6	e9 30		sbc #$30			sbc 	#'0' 						; put in range '0'+
.20d8	90 65		bcc $213f			bcc 	_CTIFail 					; out of range.
.20da	c9 0a		cmp #$0a			cmp 	#10 						; in 0-9 ?
.20dc	90 0b		bcc $20e9			bcc 	_CTILegal
.20de	c9 11		cmp #$11			cmp 	#'A'-'0'					; between 9 and A ?
.20e0	90 5d		bcc $213f			bcc 	_CTIFail
.20e2	38		sec				sec
.20e3	e9 07		sbc #$07			sbc 	#7 							; hex adjust
.20e5	c9 10		cmp #$10			cmp 	#16 						; out of range ?
.20e7	b0 56		bcs $213f			bcs 	_CTIFail
.20e9					_CTILegal:
.20e9	48		pha				pha 								; save digit value.
.20ea	06 14		asl $14				asl 	temp3
.20ec	26 15		rol $15				rol 	temp3+1
.20ee	a5 14		lda $14				lda 	temp3 						; copy x2 into temp2
.20f0	85 12		sta $12				sta 	temp2
.20f2	a5 15		lda $15				lda 	temp3+1
.20f4	85 13		sta $13				sta 	temp2+1
.20f6	06 14		asl $14				asl 	temp3
.20f8	26 15		rol $15				rol 	temp3+1
.20fa	06 14		asl $14				asl 	temp3
.20fc	26 15		rol $15				rol 	temp3+1
.20fe	24 10		bit $10				bit 	temp1 						; hexadecimal
.2100	10 07		bpl $2109			bpl 	_CTIDecimal
.2102	06 14		asl $14				asl 	temp3
.2104	26 15		rol $15				rol 	temp3+1
.2106	68		pla				pla 								; get digit back
.2107	80 12		bra $211b			bra 	_CTIAddLoop
.2109					_CTIDecimal:
.2109	18		clc				clc 								; x 8 + x 2 = x 10
.210a	a5 14		lda $14				lda 	temp3
.210c	65 12		adc $12				adc 	temp2
.210e	85 14		sta $14				sta 	temp3
.2110	a5 15		lda $15				lda 	temp3+1
.2112	65 13		adc $13				adc 	temp2+1
.2114	85 15		sta $15				sta 	temp3+1
.2116	68		pla				pla 								; check digit 0-9
.2117	c9 0a		cmp #$0a			cmp 	#10
.2119	b0 24		bcs $213f			bcs 	_CTIFail
.211b					_CTIAddLoop:
.211b	18		clc				clc
.211c	65 14		adc $14				adc 	temp3
.211e	85 14		sta $14				sta 	temp3
.2120	90 02		bcc $2124			bcc 	_CTINoCarry
.2122	e6 15		inc $15				inc 	temp3+1
.2124					_CTINoCarry:
.2124	c8		iny				iny
.2125	b1 16		lda ($16),y			lda 	(temp4),y 					; was this the last character
.2127	c9 21		cmp #$21			cmp 	#32+1
.2129	b0 a6		bcs $20d1			bcs 	_CTILoop 					; no, go back.
.212b	a5 11		lda $11				lda 	temp1+1 					; was it - ?
.212d	d0 0d		bne $213c			bne 	_CTIOkay
.212f	38		sec				sec
.2130	a9 00		lda #$00			lda 	#0 							; negate temp3.
.2132	e5 14		sbc $14				sbc 	temp3
.2134	85 14		sta $14				sta 	temp3
.2136	a9 00		lda #$00			lda 	#0
.2138	e5 15		sbc $15				sbc 	temp3+1
.213a	85 15		sta $15				sta 	temp3+1
.213c					_CTIOkay:
.213c	98		tya				tya
.213d	38		sec				sec
.213e	60		rts				rts
.213f					_CTIFail:
.213f	18		clc				clc
.2140	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/tostr.src

.2141					IntToString:
.2141	a9 10		lda #$10			lda 	#(textBuffer) & $FF
.2143	85 12		sta $12				sta 	0+(temp2)
.2145	a9 08		lda #$08			lda 	#(textBuffer) >> 8
.2147	85 13		sta $13				sta 	1+(temp2)
.2149	a5 06		lda $06				lda 	TOS 						; value in YA
.214b	a4 07		ldy $07				ldy 	TOS+1
.214d	20 7d 21	jsr $217d			jsr 	ConvertToString
.2150	a9 10		lda #$10			lda 	#(textBuffer) & $FF
.2152	85 06		sta $06				sta 	0+(TOS)
.2154	a9 08		lda #$08			lda 	#(textBuffer) >> 8
.2156	85 07		sta $07				sta 	1+(TOS)
.2158	4c 00 00	jmp $0000			jmp 	NextCode
.215b					PrintYA:
.215b	48		pha				pha
.215c	da		phx				phx
.215d	5a		phy				phy
.215e	48		pha				pha
.215f	a9 10		lda #$10			lda 	#(textBuffer) & $FF
.2161	85 12		sta $12				sta 	0+(temp2)
.2163	a9 08		lda #$08			lda 	#(textBuffer) >> 8
.2165	85 13		sta $13				sta 	1+(temp2)
.2167	68		pla				pla
.2168	20 81 21	jsr $2181			jsr 	ConvertToStringMain
.216b	a2 00		ldx #$00			ldx 	#0
.216d					_PrintYALoop:
.216d	bd 10 08	lda $0810,x			lda 	textBuffer,x
.2170	20 49 24	jsr $2449			jsr 	ExternPrint
.2173	e8		inx				inx
.2174	bd 10 08	lda $0810,x			lda 	textBuffer,x
.2177	d0 f4		bne $216d			bne 	_PrintYALoop
.2179	7a		ply				ply
.217a	fa		plx				plx
.217b	68		pla				pla
.217c	60		rts				rts
.217d					ConvertToString:
.217d	38		sec				sec
.217e	80 01		bra $2181			bra 	ConvertToStringMain
.2180					ConvertToStringUnsigned:
.2180	18		clc				clc
.2181					ConvertToStringMain:
.2181	da		phx				phx									; save XY
.2182	5a		phy				phy
.2183	64 1a		stz $1a				stz 	SignCount 					; this is zero suppression
.2185	85 10		sta $10				sta 	temp1 						; save YA in temp1
.2187	84 11		sty $11				sty 	temp1+1
.2189	a0 00		ldy #$00			ldy 	#0 							; index to result.
.218b	90 16		bcc $21a3			bcc 	_CTSUnsigned 				; if carry clear do not adjust for -
.218d	a5 11		lda $11				lda 	temp1+1 					; is it negative
.218f	10 12		bpl $21a3			bpl 	_CTSUnsigned
.2191	a9 2d		lda #$2d			lda 	#"-"						; output - sign
.2193	91 12		sta ($12),y			sta 	(temp2),y
.2195	c8		iny				iny
.2196	38		sec				sec 								; negate temp1
.2197	a9 00		lda #$00			lda 	#0
.2199	e5 10		sbc $10				sbc 	temp1
.219b	85 10		sta $10				sta 	temp1
.219d	a9 00		lda #$00			lda 	#0
.219f	e5 11		sbc $11				sbc 	temp1+1
.21a1	85 11		sta $11				sta 	temp1+1
.21a3					_CTSUnsigned:
.21a3	a2 00		ldx #$00			ldx 	#0 							; index into subtraction table
.21a5					_CTSLoop:
.21a5	a9 2f		lda #$2f			lda 	#"0"-1						; set the digit to '0' code.
.21a7	91 12		sta ($12),y			sta 	(temp2),y
.21a9					_CTSSubLoop:
.21a9	b1 12		lda ($12),y			lda 	(temp2),y 					; bump the count
.21ab	1a		inc a				inc 	a
.21ac	91 12		sta ($12),y			sta 	(temp2),y
.21ae	38		sec				sec 								; do subtraction saving interim result
.21af	a5 10		lda $10				lda 	temp1
.21b1	fd e4 21	sbc $21e4,x			sbc 	_CTSTable,x
.21b4	48		pha				pha
.21b5	a5 11		lda $11				lda 	temp1+1
.21b7	fd e5 21	sbc $21e5,x			sbc 	_CTSTable+1,x
.21ba	90 07		bcc $21c3			bcc 	_CTSCantSubtract 			; end of subtraction.
.21bc	85 11		sta $11				sta 	temp1+1 					; save result back
.21be	68		pla				pla
.21bf	85 10		sta $10				sta 	temp1
.21c1	80 e6		bra $21a9			bra 	_CTSSubLoop
.21c3					_CTSCantSubtract:
.21c3	68		pla				pla 								; throw away interim
.21c4	e8		inx				inx 								; next subtractor
.21c5	e8		inx				inx
.21c6	b1 12		lda ($12),y			lda 	(temp2),y 					; update leading zero
.21c8	49 30		eor #$30			eor 	#"0"
.21ca	05 1a		ora $1a				ora 	SignCount
.21cc	85 1a		sta $1a				sta 	SignCount
.21ce	f0 01		beq $21d1			beq		_CTSLZ 						; if all zeros so far suppress.
.21d0	c8		iny				iny 								; next character
.21d1					_CTSLZ:
.21d1	e0 08		cpx #$08			cpx 	#_CTSTableEnd-_CTSTable 	; done them all ?
.21d3	d0 d0		bne $21a5			bne 	_CTSLoop
.21d5					_CTSComplete:
.21d5	a5 10		lda $10				lda		temp1 						; get remainder 0-9
.21d7	09 30		ora #$30			ora 	#48 						; ASCII
.21d9	91 12		sta ($12),y			sta 	(temp2),y					; write out
.21db	c8		iny				iny
.21dc	a9 00		lda #$00			lda 	#0							; make ASCIIZ
.21de	91 12		sta ($12),y			sta 	(temp2),y
.21e0	98		tya				tya 								; size in A
.21e1	7a		ply				ply									; pull and exit.
.21e2	fa		plx				plx
.21e3	60		rts				rts
.21e4					_CTSTable:
>21e4	10 27 e8 03 64 00 0a 00				.word 	10000,1000,100,10 			; subtractors, this is a simple version.
.21ec					_CTSTableEnd:

;******  Return to file: kernel.asm


;******  Processing file: words/system/varhandlers.src

.21ec					VarAddressHandler:
.21ec	18		clc				clc 								; find variable, error if it doesn't exist.
.21ed	20 8f 22	jsr $228f			jsr 	VariableFind
.21f0	20 69 22	jsr $2269			jsr 	VariableCheckIndex
.21f3	a5 06		lda $06				lda 	TOS
.21f5	48		pha				pha
.21f6	a5 07		lda $07				lda 	TOS+1
.21f8	48		pha				pha
.21f9	a5 10		lda $10				lda 	temp1 						; the address is the new value
.21fb	85 06		sta $06				sta 	TOS
.21fd	a5 11		lda $11				lda		temp1+1
.21ff	85 07		sta $07				sta 	TOS+1
.2201	4c 00 00	jmp $0000			jmp 	NextCode
.2204					VarAddrHandlerDecode:
.2204	a9 26		lda #$26			lda 	#"&"
.2206	4c 44 23	jmp $2344			jmp 	VarHandlerDecode
.2209					VarReadHandler:
.2209	18		clc				clc 								; find variable, error if it doesn't exist.
.220a	20 8f 22	jsr $228f			jsr 	VariableFind
.220d	20 69 22	jsr $2269			jsr 	VariableCheckIndex
.2210	a5 06		lda $06				lda 	TOS
.2212	48		pha				pha
.2213	a5 07		lda $07				lda 	TOS+1
.2215	48		pha				pha
.2216	b2 10		lda ($10)			lda 	(temp1)						; read variable address to TOS
.2218	85 06		sta $06				sta 	TOS
.221a	a0 01		ldy #$01			ldy 	#1
.221c	b1 10		lda ($10),y			lda 	(temp1),y
.221e	85 07		sta $07				sta 	TOS+1
.2220	4c 00 00	jmp $0000			jmp 	NextCode
.2223					VarReadHandlerDecode:
.2223	a9 40		lda #$40			lda 	#"@"
.2225	4c 44 23	jmp $2344			jmp 	VarHandlerDecode
.2228					VarWriteHandler:
.2228	38		sec				sec 								; find variable, create it if it doesn't exist.
.2229	20 8f 22	jsr $228f			jsr 	VariableFind
.222c	20 69 22	jsr $2269			jsr 	VariableCheckIndex
.222f	a5 06		lda $06				lda 	TOS 						; write TOS to that address.
.2231	92 10		sta ($10)			sta 	(temp1)
.2233	a5 07		lda $07				lda 	TOS+1
.2235	a0 01		ldy #$01			ldy 	#1
.2237	91 10		sta ($10),y			sta 	(temp1),y
.2239	68		pla				pla
.223a	85 07		sta $07				sta 	TOS+1
.223c	68		pla				pla
.223d	85 06		sta $06				sta 	TOS
.223f	4c 00 00	jmp $0000			jmp 	NextCode
.2242					VarWriteHandlerDecode:
.2242	a9 21		lda #$21			lda 	#"!"
.2244	4c 44 23	jmp $2344			jmp 	VarHandlerDecode
.2247					IndexHandler:
.2247	20 e9 23	jsr $23e9			jsr 	ErrorHandler
>224a	24 24 49 4e 44 45 58 3a				.text 	"$$INDEX:BUG",0
>2252	42 55 47 00
.2256					IndexHandlerDecode:
.2256	a9 5b		lda #$5b			lda 	#"["
.2258	20 04 1d	jsr $1d04			jsr 	DecodeWriteBuffer
.225b	b1 08		lda ($08),y			lda 	(srcPtr),y
.225d	a0 00		ldy #$00			ldy 	#0
.225f	38		sec				sec
.2260	20 26 1d	jsr $1d26			jsr 	DecodeYAToBuffer
.2263	a9 5d		lda #$5d			lda 	#"]"
.2265	20 04 1d	jsr $1d04			jsr 	DecodeWriteBuffer
.2268	60		rts				rts
.2269					VariableCheckIndex:
.2269	8a		txa				txa 								; next is $$index ?
.226a	a8		tay				tay
.226b	c8		iny				iny
.226c	c8		iny				iny
.226d	b1 03		lda ($03),y			lda 	(IP),y
.226f	c9 47		cmp #$47			cmp 	#IndexHandler & $FF
.2271	d0 1b		bne $228e			bne 	_VCIExit
.2273	c8		iny				iny
.2274	b1 03		lda ($03),y			lda 	(IP),y
.2276	c9 22		cmp #$22			cmp 	#IndexHandler >> 8
.2278	d0 14		bne $228e			bne 	_VCIExit
.227a	98		tya				tya 								; fix X backup 3 on from where we started
.227b	aa		tax				tax
.227c	c8		iny				iny 								; get the index
.227d	b1 03		lda ($03),y			lda 	(IP),y
.227f	0a		asl a				asl 	a 							; double it, add to (temp1) -> temp1
.2280	a0 01		ldy #$01			ldy 	#1
.2282	72 10		adc ($10)			adc 	(temp1) 					; do the indirection e.g. the look up.
.2284	48		pha				pha
.2285	b1 10		lda ($10),y			lda 	(temp1),y
.2287	69 00		adc #$00			adc 	#0
.2289	85 11		sta $11				sta 	temp1+1
.228b	68		pla				pla
.228c	85 10		sta $10				sta 	temp1
.228e					_VCIExit:
.228e	60		rts				rts
.228f					VariableFind:
.228f	08		php				php 								; save autocreate flag.
.2290	e8		inx				inx 								; advance to/over the variable name.
.2291	e8		inx				inx
.2292	8a		txa				txa 								; put in Y
.2293	a8		tay				tay
.2294	b1 03		lda ($03),y			lda 	(IP),y 						; copy name word into temp2
.2296	85 12		sta $12				sta 	temp2
.2298	c8		iny				iny
.2299	b1 03		lda ($03),y			lda 	(IP),y
.229b	85 13		sta $13				sta 	temp2+1
.229d	c9 1b		cmp #$1b			cmp 	#27 						; check for A-Z
.229f	b0 0f		bcs $22b0			bcs 	_VFLong
.22a1	a5 13		lda $13				lda 	temp2+1
.22a3	d0 0b		bne $22b0			bne 	_VFLong
.22a5	a5 12		lda $12				lda 	temp2						; this is the index
.22a7	0a		asl a				asl 	a 							; double it
.22a8	85 10		sta $10				sta 	temp1
.22aa	a9 06		lda #$06			lda 	#azVariables >> 8			; set the MSB
.22ac	85 11		sta $11				sta 	temp1+1
.22ae	28		plp				plp 								; throw creation flag, it always exists.
.22af	60		rts				rts
.22b0					_VFLong:
.22b0	a5 12		lda $12				lda 	temp2 						; built a hash table index into temp3/temp4
.22b2	6a		ror a				ror 	a
.22b3	6a		ror a				ror 	a
.22b4	6a		ror a				ror 	a
.22b5	6a		ror a				ror 	a
.22b6	45 12		eor $12				eor 	temp2
.22b8	45 13		eor $13				eor 	temp2+1
.22ba	29 0f		and #$0f			and 	#(hashTableSize-1)			; force into range
.22bc	0a		asl a				asl 	a
.22bd	69 40		adc #$40			adc 	#hashTable & $FF 			; make an address of the head => temp1/3
.22bf	85 10		sta $10				sta 	temp1
.22c1	85 14		sta $14				sta 	temp3
.22c3	a9 06		lda #$06			lda 	#hashTable >> 8
.22c5	85 11		sta $11				sta 	temp1+1
.22c7	85 15		sta $15				sta 	temp3+1
.22c9					_VFSearch:
.22c9	a0 01		ldy #$01			ldy 	#1							; read MSB of first record
.22cb	b1 10		lda ($10),y			lda 	(temp1),y
.22cd	f0 23		beq $22f2			beq 	_VFNotFound 				; is MSB is zero, can't be a variable record
.22cf	a8		tay				tay 								; follow the link through.
.22d0	b2 10		lda ($10)			lda 	(temp1)
.22d2	85 10		sta $10				sta 	temp1
.22d4	84 11		sty $11				sty 	temp1+1
.22d6	a0 04		ldy #$04			ldy 	#4							; check if the name matches
.22d8	b1 10		lda ($10),y			lda 	(temp1),y
.22da	c5 12		cmp $12				cmp 	temp2
.22dc	d0 eb		bne $22c9			bne 	_VFSearch 					; if it doesn't, follow the next link.
.22de	c8		iny				iny 								; same for 2nd byte of name
.22df	b1 10		lda ($10),y			lda 	(temp1),y
.22e1	c5 13		cmp $13				cmp 	temp2+1
.22e3	d0 e4		bne $22c9			bne 	_VFSearch
.22e5	18		clc				clc
.22e6	a5 10		lda $10				lda 	temp1 						; make temp1 point to the data at offset 2
.22e8	69 02		adc #$02			adc 	#2
.22ea	85 10		sta $10				sta 	temp1
.22ec	90 02		bcc $22f0			bcc 	_VFNoPage1
.22ee	e6 11		inc $11				inc 	temp1+1
.22f0					_VFNoPage1:
.22f0	28		plp				plp 								; don't need to worry about creation flag
.22f1	60		rts				rts
.22f2					_VFNotFound:
.22f2	28		plp				plp 								; was carry set, e.g. create a new record if not found ?
.22f3	b0 14		bcs $2309			bcs 	_VFCreate
.22f5	20 e9 23	jsr $23e9			jsr 	ErrorHandler
>22f8	4e 4f 20 53 55 43 48 20				.text 	"NO SUCH VARIABLE",0
>2300	56 41 52 49 41 42 4c 45 00
.2309					_VFCreate:
.2309	a0 01		ldy #$01			ldy 	#1
.230b	b2 14		lda ($14)			lda 	(temp3) 					; copy the head link to the first 2 bytes
.230d	92 0e		sta ($0e)			sta 	(nextFreeMem)
.230f	b1 14		lda ($14),y			lda 	(temp3),y
.2311	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.2313	c8		iny				iny
.2314	a9 00		lda #$00			lda 	#0	 						; write zero initialised data out.
.2316	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.2318	c8		iny				iny
.2319	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.231b	c8		iny				iny
.231c	a5 12		lda $12				lda 	temp2 						; copy the name out
.231e	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.2320	c8		iny				iny
.2321	a5 13		lda $13				lda 	temp2+1
.2323	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.2325	a0 01		ldy #$01			ldy 	#1
.2327	a5 0e		lda $0e				lda 	nextFreeMem 				; update the head link
.2329	92 14		sta ($14)			sta 	(temp3)
.232b	a5 0f		lda $0f				lda 	nextFreeMem+1
.232d	91 14		sta ($14),y			sta 	(temp3),y
.232f	18		clc				clc
.2330	a5 0e		lda $0e				lda 	nextFreeMem 				; put nextFreeMem+2 in temp1 (data pointer)
.2332	69 02		adc #$02			adc 	#2
.2334	85 10		sta $10				sta 	temp1
.2336	a5 0f		lda $0f				lda 	nextFreeMem+1
.2338	69 00		adc #$00			adc 	#0
.233a	85 11		sta $11				sta 	temp1+1
.233c	a9 06		lda #$06			lda 	#6							; shift freemem pointer up 6
.233e	a0 00		ldy #$00			ldy 	#0
.2340	20 fd 1b	jsr $1bfd			jsr 	AdvanceFreeMem
.2343	60		rts				rts
.2344					VarHandlerDecode:
.2344	48		pha				pha 								; save, leading space
.2345	a9 07		lda #$07			lda 	#CTH_Variable
.2347	20 04 1d	jsr $1d04			jsr 	DecodeWriteBuffer
.234a	68		pla				pla 								; restore and write type
.234b	20 04 1d	jsr $1d04			jsr 	DecodeWriteBuffer
.234e	b1 08		lda ($08),y			lda 	(srcPtr),y 					; copy to temp1
.2350	85 10		sta $10				sta 	temp1
.2352	c8		iny				iny
.2353	b1 08		lda ($08),y			lda 	(srcPtr),y
.2355	85 11		sta $11				sta 	temp1+1
.2357	a5 10		lda $10				lda 	temp1 						; output the first character
.2359	29 1f		and #$1f			and 	#31
.235b	20 86 23	jsr $2386			jsr 	VHOutVarChar
.235e	a2 05		ldx #$05			ldx 	#5 							; divide temp1 by 32
.2360					_VHDShift:
.2360	46 11		lsr $11				lsr 	temp1+1
.2362	66 10		ror $10				ror 	temp1
.2364	ca		dex				dex
.2365	d0 f9		bne $2360			bne 	_VHDShift
.2367	a2 ff		ldx #$ff			ldx 	#255 						; now divide that by 40 by repeated subtraction.
.2369					_VHDDiv40:
.2369	e8		inx				inx
.236a	38		sec				sec
.236b	a5 10		lda $10				lda 	temp1
.236d	e9 28		sbc #$28			sbc 	#40
.236f	a8		tay				tay
.2370	a5 11		lda $11				lda 	temp1+1
.2372	e9 00		sbc #$00			sbc 	#0
.2374	90 06		bcc $237c			bcc 	_VHDivDone
.2376	85 11		sta $11				sta 	temp1+1
.2378	84 10		sty $10				sty 	temp1
.237a	80 ed		bra $2369			bra 	_VHDDiv40
.237c					_VHDivDone:
.237c	a5 10		lda $10				lda 	temp1 						; remainder
.237e	20 86 23	jsr $2386			jsr 	VHOutVarChar
.2381	8a		txa				txa
.2382	20 86 23	jsr $2386			jsr 	VHOutVarChar 				; and result.
.2385	60		rts				rts
.2386					VHOutVarChar:
.2386	c9 00		cmp #$00			cmp 	#0
.2388	f0 0c		beq $2396			beq 	_VHOExit
.238a	18		clc				clc
.238b	69 40		adc #$40			adc 	#64 						; 65-90 A-Z 91-100 0-9
.238d	c9 5b		cmp #$5b			cmp 	#91 						; convert back ?
.238f	90 02		bcc $2393			bcc 	_VHOOut
.2391	e9 2b		sbc #$2b			sbc 	#91-48 						; adjust to digit
.2393					_VHOOut:
.2393	20 04 1d	jsr $1d04			jsr 	DecodeWriteBuffer
.2396					_VHOExit:
.2396	60		rts				rts

;******  Return to file: kernel.asm

.2397					BootMsg:
>2397	2a 2a 2a 20 52 50 4c 2f				.text 	"*** RPL/C INTERPRETER ***",13,13
>239f	43 20 49 4e 54 45 52 50 52 45 54 45 52 20 2a 2a
>23af	2a 0d 0d
>23b2	57 52 49 54 54 45 4e 20				.text	"WRITTEN BY PAUL ROBSON 2020",13,13
>23ba	42 59 20 50 41 55 4c 20 52 4f 42 53 4f 4e 20 32
>23ca	30 32 30 0d 0d
>23cf	42 55 49 4c 44 3a 20				.text 	"BUILD: "

;******  Processing file: generated/timestamp.inc

>23d6	5b 32 30 2d 30 31 2d 31			.text	"[20-01-16 12:17]"
>23de	36 20 31 32 3a 31 37 5d

;******  Return to file: kernel.asm

>23e6	0d 0d 00					.byte 	13,13,0

;******  Processing file: code/error.asm

.23e9					ErrorHandler:
.23e9	68		pla				pla 								; get message address
.23ea	7a		ply				ply
.23eb	1a		inc a				inc 	a
.23ec	d0 01		bne $23ef			bne 	_EHNoCarry
.23ee	c8		iny				iny
.23ef					_EHNoCarry:
.23ef	20 10 25	jsr $2510			jsr 	EXPrintString
.23f2	a0 01		ldy #$01			ldy 	#1 							; check if there is a line #
.23f4	b1 03		lda ($03),y			lda 	(IP),y
.23f6	c8		iny				iny
.23f7	11 03		ora ($03),y			ora 	(IP),y
.23f9	f0 14		beq $240f			beq 	_EHNoLine
.23fb	a9 17		lda #$17			lda 	#_EHMsg2 & $FF 				; print " at "
.23fd	a0 24		ldy #$24			ldy 	#_EHMsg2 >> 8
.23ff	20 10 25	jsr $2510			jsr 	EXPrintString
.2402	a0 02		ldy #$02			ldy 	#2 							; print line number
.2404	b1 03		lda ($03),y			lda 	(IP),y
.2406	48		pha				pha
.2407	88		dey				dey
.2408	b1 03		lda ($03),y			lda 	(IP),y
.240a	7a		ply				ply
.240b	18		clc				clc
.240c	20 5b 21	jsr $215b			jsr 	PrintYA
.240f					_EHNoLine:
.240f	a9 0d		lda #$0d			lda 	#13
.2411	20 49 24	jsr $2449			jsr 	ExternPrint
.2414	4c 0d 10	jmp $100d			jmp 	WarmStartBlankStack			; S is indeterminate
>2417	20 41 54 20 00			_EHMsg2:.text 	" AT ",0

;******  Return to file: kernel.asm


;******  Processing file: code/extern.asm

.241c					ExternInitialise:
.241c	a9 90		lda #$90			lda 	#144 						; set colour
.241e	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.2421	a9 01		lda #$01			lda 	#$01
.2423	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.2426	a9 0e		lda #$0e			lda 	#14							; lower case
.2428	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.242b	a9 93		lda #$93			lda 	#147 						; clear screen
.242d	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.2430	a9 07		lda #$07			lda 	#COL_WHITE 					; white text.
.2432	4c 55 24	jmp $2455			jmp 	ExternColour
.2435					ExternCheckBreak:
.2435	da		phx				phx 								; make sure we keep XY
.2436	5a		phy				phy
.2437	20 e1 ff	jsr $ffe1			jsr 	$FFE1						; STOP check on CBM KERNAL
.243a	f0 03		beq $243f			beq		_ECBExit 					; stopped
.243c	7a		ply				ply 								; restore and exit.
.243d	fa		plx				plx
.243e	60		rts				rts
.243f					_ECBExit:
.243f	20 e9 23	jsr $23e9			jsr 	ErrorHandler
>2442	45 53 43 41 50 45 00				.text 	"ESCAPE",0
.2449					ExternPrint:
.2449	48		pha				pha
.244a	da		phx				phx
.244b	5a		phy				phy
.244c	29 7f		and #$7f			and 	#$7F
.244e	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.2451	7a		ply				ply
.2452	fa		plx				plx
.2453	68		pla				pla
.2454	60		rts				rts
.2455					ExternColour:
.2455	48		pha				pha
.2456	da		phx				phx
.2457	48		pha				pha
.2458	29 08		and #$08			and 	#8
.245a	0a		asl a				asl 	a
.245b	0a		asl a				asl 	a
.245c	0a		asl a				asl 	a
.245d	0a		asl a				asl 	a
.245e	49 92		eor #$92			eor 	#$92
.2460	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.2463	68		pla				pla
.2464	29 07		and #$07			and 	#7
.2466	aa		tax				tax
.2467	bd 70 24	lda $2470,x			lda 	_ECTable,x
.246a	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.246d	fa		plx				plx
.246e	68		pla				pla
.246f	60		rts				rts
.2470					_ECTable:
>2470	90						.byte 	144
>2471	1c						.byte 	28
>2472	1e						.byte 	30
>2473	9e						.byte 	158
>2474	1f						.byte 	31
>2475	9c						.byte 	156
>2476	9f						.byte 	159
>2477	05						.byte 	5
.2478					ExternInput:
.2478	a9 10		lda #$10			lda 	#(textBuffer & $FF)
.247a	85 14		sta $14				sta 	temp3
.247c	a9 08		lda #$08			lda 	#(textBuffer >> 8)
.247e	85 15		sta $15				sta 	temp3+1
.2480	20 cf ff	jsr $ffcf	_EIRead:jsr 	$FFCF
.2483	c9 0d		cmp #$0d			cmp 	#13
.2485	f0 0c		beq $2493			beq 	_EIExit
.2487	29 7f		and #$7f			and 	#$7F
.2489	92 14		sta ($14)			sta 	(temp3)
.248b	e6 14		inc $14				inc 	temp3
.248d	d0 f1		bne $2480			bne 	_EIRead
.248f	e6 15		inc $15				inc 	temp3+1
.2491	80 ed		bra $2480			bra 	_EIRead
.2493	a9 00		lda #$00	_EIExit:lda 	#0
.2495	92 14		sta ($14)			sta 	(temp3)
.2497	a9 0d		lda #$0d			lda 	#13
.2499	20 49 24	jsr $2449			jsr 	ExternPrint
.249c	60		rts				rts
.249d					ExternSave:
.249d	da		phx				phx
.249e	5a		phy				phy
.249f	85 12		sta $12				sta 	temp2 						; save start
.24a1	84 13		sty $13				sty 	temp2+1
.24a3	20 05 25	jsr $2505			jsr 	EXGetLength 				; get length of file into A
.24a6	a6 14		ldx $14				ldx 	temp3
.24a8	a4 15		ldy $15				ldy 	temp3+1
.24aa	20 bd ff	jsr $ffbd			jsr 	$FFBD 						; set name
.24ad	a9 01		lda #$01			lda 	#1
.24af	a2 08		ldx #$08			ldx 	#8	 						; device #8
.24b1	a0 00		ldy #$00			ldy 	#0
.24b3	20 ba ff	jsr $ffba			jsr 	$FFBA 						; set LFS
.24b6	a6 10		ldx $10				ldx 	temp1 						; end address
.24b8	a4 11		ldy $11				ldy 	temp1+1
.24ba	a9 12		lda #$12			lda 	#temp2
.24bc	20 d8 ff	jsr $ffd8			jsr 	$FFD8 						; save
.24bf	b0 03		bcs $24c4			bcs 	_ESSave
.24c1	7a		ply				ply
.24c2	fa		plx				plx
.24c3	60		rts				rts
.24c4					_ESSave:
.24c4	20 e9 23	jsr $23e9			jsr 	ErrorHandler
>24c7	53 41 56 45 20 46 41 49				.text 	"SAVE FAILED",0
>24cf	4c 45 44 00
.24d3					ExternLoad:
.24d3	da		phx				phx 								; save XY
.24d4	5a		phy				phy
.24d5	48		pha				pha 								; save target
.24d6	5a		phy				phy
.24d7	20 05 25	jsr $2505			jsr 	EXGetLength 				; get length of file into A
.24da	a6 14		ldx $14				ldx 	temp3
.24dc	a4 15		ldy $15				ldy 	temp3+1
.24de	20 bd ff	jsr $ffbd			jsr 	$FFBD 						; set name
.24e1	a9 01		lda #$01			lda 	#1
.24e3	a2 08		ldx #$08			ldx 	#8	 						; device #8
.24e5	a0 00		ldy #$00			ldy 	#0
.24e7	20 ba ff	jsr $ffba			jsr 	$FFBA 						; set LFS
.24ea	7a		ply				ply 								; restore target to YX and call load
.24eb	fa		plx				plx
.24ec	a9 00		lda #$00			lda 	#0 							; load command
.24ee	20 d5 ff	jsr $ffd5			jsr 	$FFD5
.24f1	b0 03		bcs $24f6			bcs 	_ESLoad
.24f3	7a		ply				ply
.24f4	fa		plx				plx
.24f5	60		rts				rts
.24f6					_ESLoad:
.24f6	20 e9 23	jsr $23e9			jsr 	ErrorHandler
>24f9	4c 4f 41 44 20 46 41 49				.text 	"LOAD FAILED",0
>2501	4c 45 44 00
.2505					EXGetLength:
.2505	5a		phy				phy
.2506	a0 ff		ldy #$ff			ldy 	#255
.2508	c8		iny		_EXGL0:	iny
.2509	b1 14		lda ($14),y			lda 	(temp3),y
.250b	d0 fb		bne $2508			bne 	_EXGL0
.250d	98		tya				tya
.250e	7a		ply				ply
.250f	60		rts				rts
.2510					EXPrintString:
.2510	48		pha				pha
.2511	5a		phy				phy
.2512	84 11		sty $11				sty 	temp1+1
.2514	85 10		sta $10				sta 	temp1
.2516	a0 00		ldy #$00			ldy 	#0
.2518					_EXPSLoop:
.2518	b1 10		lda ($10),y			lda 	(temp1),y
.251a	f0 08		beq $2524			beq 	_EXPSExit
.251c	29 7f		and #$7f			and 	#$7F
.251e	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.2521	c8		iny				iny
.2522	80 f4		bra $2518			bra 	_EXPSLoop
.2524					_EXPSExit:
.2524	7a		ply				ply
.2525	68		pla				pla
.2526	60		rts				rts

;******  Return to file: kernel.asm

.2527					Dictionary:

;******  Processing file: generated/dictionary.inc

>2527	05					.byte	_end0-*
>2528	00					.byte	$00
>2529	bd 14					.word	WordWrite
>252b	a1					.byte	$a1
.252c					_end0:
>252c	10					.byte	_end1-*
>252d	52					.byte	$52
>252e	28 22					.word	VarWriteHandler
>2530	42 22					.word	VarWriteHandlerDecode
>2532	24 24 21 48 41 4e 44 4c			.byte	$24,$24,$21,$48,$41,$4e,$44,$4c,$45,$d2
>253a	45 d2
.253c					_end1:
>253c	10					.byte	_end2-*
>253d	52					.byte	$52
>253e	ec 21					.word	VarAddressHandler
>2540	04 22					.word	VarAddrHandlerDecode
>2542	24 24 26 48 41 4e 44 4c			.byte	$24,$24,$26,$48,$41,$4e,$44,$4c,$45,$d2
>254a	45 d2
.254c					_end2:
>254c	10					.byte	_end3-*
>254d	52					.byte	$52
>254e	09 22					.word	VarReadHandler
>2550	23 22					.word	VarReadHandlerDecode
>2552	24 24 40 48 41 4e 44 4c			.byte	$24,$24,$40,$48,$41,$4e,$44,$4c,$45,$d2
>255a	45 d2
.255c					_end3:
>255c	0c					.byte	_end4-*
>255d	52					.byte	$52
>255e	62 1a					.word	CallHandler
>2560	3b 1b					.word	CallHandlerDecode
>2562	24 24 43 41 4c cc			.byte	$24,$24,$43,$41,$4c,$cc
.2568					_end4:
>2568	0f					.byte	_end5-*
>2569	53					.byte	$53
>256a	5f 20					.word	SkipComment
>256c	6c 20					.word	CommentDecoder
>256e	24 24 43 4f 4d 4d 45 4e			.byte	$24,$24,$43,$4f,$4d,$4d,$45,$4e,$d4
>2576	d4
.2577					_end5:
>2577	0e					.byte	_end6-*
>2578	53					.byte	$53
>2579	8a 20					.word	DefineCode
>257b	a0 20					.word	DefineDecoder
>257d	24 24 44 45 46 49 4e c5			.byte	$24,$24,$44,$45,$46,$49,$4e,$c5
.2585					_end6:
>2585	0f					.byte	_end7-*
>2586	52					.byte	$52
>2587	52 10					.word	Literal2Byte
>2589	68 10					.word	Literal2ByteDecode
>258b	24 24 4c 49 54 45 52 41			.byte	$24,$24,$4c,$49,$54,$45,$52,$41,$cc
>2593	cc
.2594					_end7:
>2594	0e					.byte	_end8-*
>2595	80					.byte	$80
>2596	48 20					.word	NextLine
>2598	24 24 4e 45 58 54 4c 49			.byte	$24,$24,$4e,$45,$58,$54,$4c,$49,$4e,$c5
>25a0	4e c5
.25a2					_end8:
>25a2	0e					.byte	_end9-*
>25a3	53					.byte	$53
>25a4	7a 10					.word	LiteralString
>25a6	99 10					.word	LiteralStringDecoder
>25a8	24 24 53 54 52 49 4e c7			.byte	$24,$24,$53,$54,$52,$49,$4e,$c7
.25b0					_end9:
>25b0	05					.byte	_end10-*
>25b1	00					.byte	$00
>25b2	39 12					.word	Multiply16x16
>25b4	aa					.byte	$aa
.25b5					_end10:
>25b5	05					.byte	_end11-*
>25b6	00					.byte	$00
>25b7	aa 10					.word	Add
>25b9	ab					.byte	$ab
.25ba					_end11:
>25ba	06					.byte	_end12-*
>25bb	00					.byte	$00
>25bc	ce 14					.word	WordAdd
>25be	2b a1					.byte	$2b,$a1
.25c0					_end12:
>25c0	05					.byte	_end13-*
>25c1	00					.byte	$00
>25c2	b9 10					.word	Subtract
>25c4	ad					.byte	$ad
.25c5					_end13:
>25c5	06					.byte	_end14-*
>25c6	00					.byte	$00
>25c7	75 13					.word	ConstantMinus1
>25c9	2d b1					.byte	$2d,$b1
.25cb					_end14:
>25cb	06					.byte	_end15-*
>25cc	00					.byte	$00
>25cd	0f 1f					.word	DumpStack
>25cf	2e ae					.byte	$2e,$ae
.25d1					_end15:
>25d1	05					.byte	_end16-*
>25d2	00					.byte	$00
>25d3	8a 11					.word	Divide16x16
>25d5	af					.byte	$af
.25d6					_end16:
>25d6	05					.byte	_end17-*
>25d7	00					.byte	$00
>25d8	68 13					.word	Constant0
>25da	b0					.byte	$b0
.25db					_end17:
>25db	06					.byte	_end18-*
>25dc	00					.byte	$00
>25dd	ce 12					.word	CheckMinus
>25df	30 bc					.byte	$30,$bc
.25e1					_end18:
>25e1	06					.byte	_end19-*
>25e2	00					.byte	$00
>25e3	e2 12					.word	CheckZero
>25e5	30 bd					.byte	$30,$bd
.25e7					_end19:
>25e7	05					.byte	_end20-*
>25e8	00					.byte	$00
>25e9	84 13					.word	C1
>25eb	b1					.byte	$b1
.25ec					_end20:
>25ec	06					.byte	_end21-*
>25ed	00					.byte	$00
>25ee	78 12					.word	Unary1Plus
>25f0	31 ab					.byte	$31,$ab
.25f2					_end21:
>25f2	06					.byte	_end22-*
>25f3	00					.byte	$00
>25f4	8f 12					.word	Unary1Minus
>25f6	31 ad					.byte	$31,$ad
.25f8					_end22:
>25f8	06					.byte	_end23-*
>25f9	00					.byte	$00
>25fa	9c 13					.word	C10
>25fc	31 b0					.byte	$31,$b0
.25fe					_end23:
>25fe	07					.byte	_end24-*
>25ff	00					.byte	$00
>2600	c5 13					.word	C100
>2602	31 30 b0				.byte	$31,$30,$b0
.2605					_end24:
>2605	08					.byte	_end25-*
>2606	00					.byte	$00
>2607	f4 13					.word	C1024
>2609	31 30 32 b4				.byte	$31,$30,$32,$b4
.260d					_end25:
>260d	07					.byte	_end26-*
>260e	00					.byte	$00
>260f	c9 13					.word	C127
>2611	31 32 b7				.byte	$31,$32,$b7
.2614					_end26:
>2614	07					.byte	_end27-*
>2615	00					.byte	$00
>2616	cd 13					.word	C128
>2618	31 32 b8				.byte	$31,$32,$b8
.261b					_end27:
>261b	06					.byte	_end28-*
>261c	00					.byte	$00
>261d	a0 13					.word	C15
>261f	31 b5					.byte	$31,$b5
.2621					_end28:
>2621	06					.byte	_end29-*
>2622	00					.byte	$00
>2623	a4 13					.word	C16
>2625	31 b6					.byte	$31,$b6
.2627					_end29:
>2627	07					.byte	_end30-*
>2628	00					.byte	$00
>2629	06 13					.word	Times16
>262b	31 36 aa				.byte	$31,$36,$aa
.262e					_end30:
>262e	07					.byte	_end31-*
>262f	00					.byte	$00
>2630	19 13					.word	Divide16
>2632	31 36 af				.byte	$31,$36,$af
.2635					_end31:
>2635	05					.byte	_end32-*
>2636	00					.byte	$00
>2637	88 13					.word	C2
>2639	b2					.byte	$b2
.263a					_end32:
>263a	06					.byte	_end33-*
>263b	00					.byte	$00
>263c	12 13					.word	Times2
>263e	32 aa					.byte	$32,$aa
.2640					_end33:
>2640	06					.byte	_end34-*
>2641	00					.byte	$00
>2642	81 12					.word	Unary2Plus
>2644	32 ab					.byte	$32,$ab
.2646					_end34:
>2646	06					.byte	_end35-*
>2647	00					.byte	$00
>2648	9a 12					.word	Unary2Minus
>264a	32 ad					.byte	$32,$ad
.264c					_end35:
>264c	06					.byte	_end36-*
>264d	00					.byte	$00
>264e	25 13					.word	Divide2
>2650	32 af					.byte	$32,$af
.2652					_end36:
>2652	06					.byte	_end37-*
>2653	00					.byte	$00
>2654	a8 13					.word	C24
>2656	32 b4					.byte	$32,$b4
.2658					_end37:
>2658	07					.byte	_end38-*
>2659	00					.byte	$00
>265a	d1 13					.word	C255
>265c	32 35 b5				.byte	$32,$35,$b5
.265f					_end38:
>265f	07					.byte	_end39-*
>2660	00					.byte	$00
>2661	dc 13					.word	C256
>2663	32 35 b6				.byte	$32,$35,$b6
.2666					_end39:
>2666	08					.byte	_end40-*
>2667	00					.byte	$00
>2668	2c 13					.word	Times256
>266a	32 35 36 aa				.byte	$32,$35,$36,$aa
.266e					_end40:
>266e	08					.byte	_end41-*
>266f	00					.byte	$00
>2670	35 13					.word	Divide256
>2672	32 35 36 af				.byte	$32,$35,$36,$af
.2676					_end41:
>2676	05					.byte	_end42-*
>2677	00					.byte	$00
>2678	8c 13					.word	C3
>267a	b3					.byte	$b3
.267b					_end42:
>267b	06					.byte	_end43-*
>267c	00					.byte	$00
>267d	b9 13					.word	C32
>267f	33 b2					.byte	$33,$b2
.2681					_end43:
>2681	09					.byte	_end44-*
>2682	00					.byte	$00
>2683	0c 14					.word	C32767
>2685	33 32 37 36 b7				.byte	$33,$32,$37,$36,$b7
.268a					_end44:
>268a	09					.byte	_end45-*
>268b	00					.byte	$00
>268c	18 14					.word	C32768
>268e	33 32 37 36 b8				.byte	$33,$32,$37,$36,$b8
.2693					_end45:
>2693	05					.byte	_end46-*
>2694	00					.byte	$00
>2695	90 13					.word	C4
>2697	b4					.byte	$b4
.2698					_end46:
>2698	06					.byte	_end47-*
>2699	00					.byte	$00
>269a	0e 13					.word	Times4
>269c	34 aa					.byte	$34,$aa
.269e					_end47:
>269e	06					.byte	_end48-*
>269f	00					.byte	$00
>26a0	21 13					.word	Divide4
>26a2	34 af					.byte	$34,$af
.26a4					_end48:
>26a4	08					.byte	_end49-*
>26a5	00					.byte	$00
>26a6	00 14					.word	C4096
>26a8	34 30 39 b6				.byte	$34,$30,$39,$b6
.26ac					_end49:
>26ac	05					.byte	_end50-*
>26ad	00					.byte	$00
>26ae	94 13					.word	C5
>26b0	b5					.byte	$b5
.26b1					_end50:
>26b1	07					.byte	_end51-*
>26b2	00					.byte	$00
>26b3	e8 13					.word	C512
>26b5	35 31 b2				.byte	$35,$31,$b2
.26b8					_end51:
>26b8	06					.byte	_end52-*
>26b9	00					.byte	$00
>26ba	bd 13					.word	C63
>26bc	36 b3					.byte	$36,$b3
.26be					_end52:
>26be	06					.byte	_end53-*
>26bf	00					.byte	$00
>26c0	c1 13					.word	C64
>26c2	36 b4					.byte	$36,$b4
.26c4					_end53:
>26c4	05					.byte	_end54-*
>26c5	00					.byte	$00
>26c6	98 13					.word	C8
>26c8	b8					.byte	$b8
.26c9					_end54:
>26c9	06					.byte	_end55-*
>26ca	00					.byte	$00
>26cb	0a 13					.word	Times8
>26cd	38 aa					.byte	$38,$aa
.26cf					_end55:
>26cf	06					.byte	_end56-*
>26d0	00					.byte	$00
>26d1	1d 13					.word	Divide8
>26d3	38 af					.byte	$38,$af
.26d5					_end56:
>26d5	05					.byte	_end57-*
>26d6	40					.byte	$40
>26d7	f8 1a					.word	ReturnHandler
>26d9	bb					.byte	$bb
.26da					_end57:
>26da	05					.byte	_end58-*
>26db	00					.byte	$00
>26dc	26 11					.word	CheckLess
>26de	bc					.byte	$bc
.26df					_end58:
>26df	06					.byte	_end59-*
>26e0	00					.byte	$00
>26e1	3f 11					.word	CheckLessEq
>26e3	3c bd					.byte	$3c,$bd
.26e5					_end59:
>26e5	06					.byte	_end60-*
>26e6	00					.byte	$00
>26e7	ef 10					.word	CheckNotEqual
>26e9	3c be					.byte	$3c,$be
.26eb					_end60:
>26eb	05					.byte	_end61-*
>26ec	00					.byte	$00
>26ed	f2 10					.word	CheckEqual
>26ef	bd					.byte	$bd
.26f0					_end61:
>26f0	05					.byte	_end62-*
>26f1	00					.byte	$00
>26f2	42 11					.word	CheckGreater
>26f4	be					.byte	$be
.26f5					_end62:
>26f5	06					.byte	_end63-*
>26f6	00					.byte	$00
>26f7	23 11					.word	CheckGreaterEq
>26f9	3e bd					.byte	$3e,$bd
.26fb					_end63:
>26fb	08					.byte	_end64-*
>26fc	00					.byte	$00
>26fd	2d 14					.word	TestDup
>26ff	3f 44 55 d0				.byte	$3f,$44,$55,$d0
.2703					_end64:
>2703	05					.byte	_end65-*
>2704	00					.byte	$00
>2705	a2 14					.word	WordRead
>2707	c0					.byte	$c0
.2708					_end65:
>2708	07					.byte	_end66-*
>2709	00					.byte	$00
>270a	a8 12					.word	Absolute
>270c	41 42 d3				.byte	$41,$42,$d3
.270f					_end66:
>270f	09					.byte	_end67-*
>2710	00					.byte	$00
>2711	e5 14					.word	AllocateMemory
>2713	41 4c 4c 4f c3				.byte	$41,$4c,$4c,$4f,$c3
.2718					_end67:
>2718	07					.byte	_end68-*
>2719	00					.byte	$00
>271a	c8 10					.word	And
>271c	41 4e c4				.byte	$41,$4e,$c4
.271f					_end68:
>271f	0a					.byte	_end69-*
>2720	00					.byte	$00
>2721	9a 1e					.word	AssertCode
>2723	41 53 53 45 52 d4			.byte	$41,$53,$53,$45,$52,$d4
.2729					_end69:
>2729	09					.byte	_end70-*
>272a	00					.byte	$00
>272b	fb 12					.word	ByteSwap
>272d	42 53 57 41 d0				.byte	$42,$53,$57,$41,$d0
.2732					_end70:
>2732	06					.byte	_end71-*
>2733	00					.byte	$00
>2734	b0 14					.word	ByteWrite
>2736	43 a1					.byte	$43,$a1
.2738					_end71:
>2738	06					.byte	_end72-*
>2739	00					.byte	$00
>273a	99 14					.word	ByteRead
>273c	43 c0					.byte	$43,$c0
.273e					_end72:
>273e	07					.byte	_end73-*
>273f	00					.byte	$00
>2740	c5 1b					.word	ClrHandler
>2742	43 4c d2				.byte	$43,$4c,$d2
.2745					_end73:
>2745	08					.byte	_end74-*
>2746	00					.byte	$00
>2747	24 14					.word	Drop
>2749	44 52 4f d0				.byte	$44,$52,$4f,$d0
.274d					_end74:
>274d	07					.byte	_end75-*
>274e	00					.byte	$00
>274f	36 14					.word	Dup
>2751	44 55 d0				.byte	$44,$55,$d0
.2754					_end75:
>2754	0a					.byte	_end76-*
>2755	21					.byte	$21
>2756	ae 19					.word	ElseHandler
>2758	b1 19					.word	ElseEncoder
>275a	45 4c 53 c5				.byte	$45,$4c,$53,$c5
.275e					_end76:
>275e	07					.byte	_end77-*
>275f	00					.byte	$00
>2760	bb 1e					.word	EndProgram
>2762	45 4e c4				.byte	$45,$4e,$c4
.2765					_end77:
>2765	0b					.byte	_end78-*
>2766	20					.byte	$20
>2767	d0 19					.word	EndIfHandler
>2769	d3 19					.word	EndIfEncoder
>276b	45 4e 44 49 c6				.byte	$45,$4e,$44,$49,$c6
.2770					_end78:
>2770	09					.byte	_end79-*
>2771	20					.byte	$20
>2772	ce 18					.word	ForHandler
>2774	04 19					.word	ForEncoder
>2776	46 4f d2				.byte	$46,$4f,$d2
.2779					_end79:
>2779	08					.byte	_end80-*
>277a	21					.byte	$21
>277b	99 19					.word	IfHandler
>277d	9c 19					.word	IfEncoder
>277f	49 c6					.byte	$49,$c6
.2781					_end80:
>2781	09					.byte	_end81-*
>2782	00					.byte	$00
>2783	78 19					.word	GetIndex
>2785	49 4e 44 45 d8				.byte	$49,$4e,$44,$45,$d8
.278a					_end81:
>278a	08					.byte	_end82-*
>278b	00					.byte	$00
>278c	f4 1d					.word	ListCode
>278e	4c 49 53 d4				.byte	$4c,$49,$53,$d4
.2792					_end82:
>2792	07					.byte	_end83-*
>2793	00					.byte	$00
>2794	5f 11					.word	Maximum
>2796	4d 41 d8				.byte	$4d,$41,$d8
.2799					_end83:
>2799	07					.byte	_end84-*
>279a	00					.byte	$00
>279b	5b 11					.word	Minimum
>279d	4d 49 ce				.byte	$4d,$49,$ce
.27a0					_end84:
>27a0	07					.byte	_end85-*
>27a1	00					.byte	$00
>27a2	9b 11					.word	Modulus16x16
>27a4	4d 4f c4				.byte	$4d,$4f,$c4
.27a7					_end85:
>27a7	0a					.byte	_end86-*
>27a8	00					.byte	$00
>27a9	af 12					.word	Negate
>27ab	4e 45 47 41 54 c5			.byte	$4e,$45,$47,$41,$54,$c5
.27b1					_end86:
>27b1	07					.byte	_end87-*
>27b2	00					.byte	$00
>27b3	bc 1b					.word	NewHandler
>27b5	4e 45 d7				.byte	$4e,$45,$d7
.27b8					_end87:
>27b8	0a					.byte	_end88-*
>27b9	21					.byte	$21
>27ba	11 19					.word	NextHandler
>27bc	50 19					.word	NextEncoder
>27be	4e 45 58 d4				.byte	$4e,$45,$58,$d4
.27c2					_end88:
>27c2	07					.byte	_end89-*
>27c3	00					.byte	$00
>27c4	6a 14					.word	Nip
>27c6	4e 49 d0				.byte	$4e,$49,$d0
.27c9					_end89:
>27c9	07					.byte	_end90-*
>27ca	00					.byte	$00
>27cb	bf 12					.word	OneComplement
>27cd	4e 4f d4				.byte	$4e,$4f,$d4
.27d0					_end90:
>27d0	06					.byte	_end91-*
>27d1	00					.byte	$00
>27d2	e2 10					.word	LogOr
>27d4	4f d2					.byte	$4f,$d2
.27d6					_end91:
>27d6	08					.byte	_end92-*
>27d7	00					.byte	$00
>27d8	52 14					.word	Over
>27da	4f 56 45 d2				.byte	$4f,$56,$45,$d2
.27de					_end92:
>27de	0c					.byte	_end93-*
>27df	20					.byte	$20
>27e0	02 1a					.word	RepeatHandler
>27e2	05 1a					.word	RepeatEncoder
>27e4	52 45 50 45 41 d4			.byte	$52,$45,$50,$45,$41,$d4
.27ea					_end93:
>27ea	07					.byte	_end94-*
>27eb	00					.byte	$00
>27ec	3e 13					.word	RandomNumber
>27ee	52 4e c4				.byte	$52,$4e,$c4
.27f1					_end94:
>27f1	07					.byte	_end95-*
>27f2	00					.byte	$00
>27f3	6f 14					.word	Rot
>27f5	52 4f d4				.byte	$52,$4f,$d4
.27f8					_end95:
>27f8	07					.byte	_end96-*
>27f9	00					.byte	$00
>27fa	6f 1e					.word	RunProgram
>27fc	52 55 ce				.byte	$52,$55,$ce
.27ff					_end96:
>27ff	07					.byte	_end97-*
>2800	00					.byte	$00
>2801	ea 12					.word	SignTOS
>2803	53 47 ce				.byte	$53,$47,$ce
.2806					_end97:
>2806	08					.byte	_end98-*
>2807	00					.byte	$00
>2808	b3 1e					.word	StopCode
>280a	53 54 4f d0				.byte	$53,$54,$4f,$d0
.280e					_end98:
>280e	08					.byte	_end99-*
>280f	00					.byte	$00
>2810	3f 14					.word	Swap
>2812	53 57 41 d0				.byte	$53,$57,$41,$d0
.2816					_end99:
>2816	07					.byte	_end100-*
>2817	00					.byte	$00
>2818	83 1e					.word	Call6502
>281a	53 59 d3				.byte	$53,$59,$d3
.281d					_end100:
>281d	0d					.byte	_end101-*
>281e	00					.byte	$00
>281f	41 21					.word	IntToString
>2821	54 4f 2e 53 54 52 49 4e			.byte	$54,$4f,$2e,$53,$54,$52,$49,$4e,$c7
>2829	c7
.282a					_end101:
>282a	0b					.byte	_end102-*
>282b	21					.byte	$21
>282c	12 1a					.word	UntilHandler
>282e	15 1a					.word	UntilEncoder
>2830	55 4e 54 49 cc				.byte	$55,$4e,$54,$49,$cc
.2835					_end102:
>2835	09					.byte	_end103-*
>2836	00					.byte	$00
>2837	be 1e					.word	VlistCode
>2839	56 4c 49 53 d4				.byte	$56,$4c,$49,$53,$d4
.283e					_end103:
>283e	0a					.byte	_end104-*
>283f	40					.byte	$40
>2840	0e 1c					.word	BreakCmd
>2842	58 42 52 45 41 cb			.byte	$58,$42,$52,$45,$41,$cb
.2848					_end104:
>2848	09					.byte	_end105-*
>2849	00					.byte	$00
>284a	08 1c					.word	ExitDump
>284c	58 44 55 4d d0				.byte	$58,$44,$55,$4d,$d0
.2851					_end105:
>2851	07					.byte	_end106-*
>2852	00					.byte	$00
>2853	d5 10					.word	Xor
>2855	58 4f d2				.byte	$58,$4f,$d2
.2858					_end106:
>2858	08					.byte	_end107-*
>2859	00					.byte	$00
>285a	8b 1f					.word	System_Save
>285c	53 41 56 c5				.byte	$53,$41,$56,$c5
.2860					_end107:
>2860	08					.byte	_end108-*
>2861	00					.byte	$00
>2862	a9 1f					.word	System_Load
>2864	4c 4f 41 c4				.byte	$4c,$4f,$41,$c4
.2868					_end108:
>2868	0d					.byte	_end109-*
>2869	11					.byte	$11
>286a	47 22					.word	IndexHandler
>286c	56 22					.word	IndexHandlerDecode
>286e	24 24 49 4e 44 45 d8			.byte	$24,$24,$49,$4e,$44,$45,$d8
.2875					_end109:
>2875	07					.byte	_end110-*
>2876	00					.byte	$00
>2877	5a 1f					.word	OldCode
>2879	4f 4c c4				.byte	$4f,$4c,$c4
.287c					_end110:
>287c	00					.byte	0

;******  Return to file: kernel.asm


;******  Processing file: code/enctest.asm


;******  Return to file: kernel.asm

>3fff	ff						.byte 	$FF
.4000					ProgramMemory:

;******  End of listing
