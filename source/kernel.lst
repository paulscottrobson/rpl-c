
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -q -D encode=0 -c -o kernel_nocode.prg -L kernel.lst -l kernel.lbl kernel.asm
; Mon Jan 13 16:56:05 2020

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=0					encode=0

;******  Processing input file: kernel.asm

=$1000					RplBuild = $1000 							; code starts here.

;******  Processing file: data.asm

.0000					NextCode:
>0000							.fill 	5
=3					IP = NextCode+3 							; the IP which points to the current instruction
.0005					rsp:
>0005							.byte 	?
.0006					tos:
>0006							.word 	?
.0008					srcPtr:
>0008							.word 	?
.000a					bufPtr:
>000a							.word 	?
.000c					matchPtr:
>000c							.word 	?
.000e					nextFreeMem:
>000e							.word 	?
.0010					temp1:
>0010							.word 	?
.0012					temp2:
>0012							.word 	?
.0014					temp3:
>0014							.word 	?
.0016					temp4:
>0016							.word 	?
.0018					listPtr:
>0018							.word 	?
.001a					SignCount:
>001a							.byte 	?
.001b					RandomSeed:
>001b							.word 	?
.001d					ListCount:
>001d							.byte 	?
.001e					ListLowest:
>001e							.word 	?
=$102					stack2Low = $102							; access other stack members following tsx
=$101					stack2High = $101							; (which requires saving X, not on the stack !)
=$104					stack3Low = $104
=$103					stack3High = $103
=$600					azVariables = $600 							; 26 x 2 variables occupying 52 bytes * PAGE BOUNDARY *
=16					hashTableSize = 16 							; hash tables for variables.
=$640					hashTable = $640 							; hash tables start here * ALL ON ONE PAGE *
=$810					textBuffer = $810 							; buffer for text.
=$700					returnStack = $700							; return stack (1 page)
=$700					returnStackLow = returnStack
=1856					returnStackHigh = returnStack+$40
=1920					returnStackX = returnStack+$80
=$80					NumberStackBase = $80 						; number stack down from here.
=$910					encodeBuffer = $910 						; buffer for encoded program
=0					COL_BLACK = 0
=1					COL_RED = 1
=2					COL_GREEN = 2
=3					COL_YELLOW = 3
=4					COL_BLUE = 4
=5					COL_MAGENTA = 5
=6					COL_CYAN = 6
=7					COL_WHITE = 7
=8					COL_RVS = 8
=2					CTH_LineNo = COL_Green
=6					CTH_Keyword = COL_Cyan
=11					CTH_Comment = COL_Yellow+COL_Rvs
=7					CTH_Definition = COL_White
=5					CTH_String = COL_Magenta
=3					CTH_Call = COL_Yellow

;******  Return to file: kernel.asm

.1000	a2 ff		ldx #$ff			ldx 	#$FF 						; reset the stack
.1002	9a		txs				txs
.1003	20 01 11	jsr $1101			jsr 	ExternInitialise
.1006	a9 46		lda #$46			lda 	#BootMsg & $FF
.1008	a0 10		ldy #$10			ldy 	#BootMsg >> 8
.100a	20 f1 11	jsr $11f1			jsr 	EXPrintString
.100d					WarmStartBlankStack:
.100d	86 10		stx $10				stx 	temp1
.100f	a2 80		ldx #$80			ldx 	#NumberStackBase
.1011	9a		txs				txs
.1012	a6 10		ldx $10				ldx 	temp1
.1014					WarmStart:
.1014	a9 03		lda #$03			lda 	#COL_Yellow
.1016	20 38 11	jsr $1138			jsr 	ExternColour
.1019	20 5b 11	jsr $115b			jsr 	ExternInput
.101c	a9 06		lda #$06			lda 	#COL_Cyan
.101e	20 38 11	jsr $1138			jsr 	ExternColour
.1021	a9 10		lda #$10			lda 	#textBuffer & $FF
.1023	a0 08		ldy #$08			ldy 	#textBuffer >> 8
.1025	20 5d 16	jsr $165d			jsr 	EncodeProgram
.1028	ad 11 09	lda $0911			lda 	encodeBuffer+1 				; has a line number been entered ?
.102b	0d 12 09	ora $0912			ora 	encodeBuffer+2
.102e	d0 0e		bne $103e			bne 	LineEditor 					; if so, do the line editing code.
.1030	a9 ff		lda #$ff			lda 	#$FF
.1032	85 05		sta $05				sta 	rsp
.1034	a2 10		ldx #$10			ldx 	#encodeBuffer & $FF 		; run what is in the encode buffer.
.1036	a0 09		ldy #$09			ldy 	#encodeBuffer >> 8
.1038	20 98 10	jsr $1098			jsr 	InitialiseCoreCode 			; initialise the NEXT routine at $00
.103b	4c 00 00	jmp $0000			jmp 	NextCode
.103e					LineEditor:
.103e	20 00 1d	jsr $1d00			jsr 	EditProgram
.1041	80 ca		bra $100d			bra 	WarmStartBlankStack
.1043					ErrorHandler:
>1043	ff						.byte 	$FF
.1044	a2 5e		ldx #$5e			ldx 	#$5E
.1046					BootMsg:
>1046	2a 2a 2a 20 52 50 4c 2f				.text 	"*** RPL/C INTERPRETER ***",13,13
>104e	43 20 49 4e 54 45 52 50 52 45 54 45 52 20 2a 2a
>105e	2a 0d 0d
>1061	57 52 49 54 54 45 4e 20				.text	"WRITTEN BY PAUL ROBSON 2020",13,13
>1069	42 59 20 50 41 55 4c 20 52 4f 42 53 4f 4e 20 32
>1079	30 32 30 0d 0d
>107e	42 55 49 4c 44 3a 20				.text 	"BUILD: "

;******  Processing file: generated/timestamp.inc

>1085	5b 32 30 2d 30 31 2d 31			.text	"[20-01-13 16:56]"
>108d	33 20 31 36 3a 35 36 5d

;******  Return to file: kernel.asm

>1095	0d 0d 00					.byte 	13,13,0

;******  Processing file: core.src

.1098					InitialiseCoreCode:
.1098	a9 e8		lda #$e8			lda 	#$E8 					; Copy INX INX 			4 cycles when run
.109a	85 00		sta $00				sta 	NextCode
.109c	85 01		sta $01				sta 	NextCode+1
.109e	a9 7c		lda #$7c			lda 	#$7C 					; Copy JMP ($aaaa,x) 	6 cycles when run
.10a0	85 02		sta $02				sta 	NextCode+2
.10a2	86 03		stx $03				stx 	NextCode+3 				; set the indirect address (IP)
.10a4	84 04		sty $04				sty 	NextCode+4
.10a6	a2 01		ldx #$01			ldx 	#1 						; set up to run from provided word.
.10a8	60		rts				rts								; (2 INX skip offset and line#)
.10a9					Literal2Byte:
.10a9	a5 06		lda $06				lda 	TOS
.10ab	48		pha				pha
.10ac	a5 07		lda $07				lda 	TOS+1
.10ae	48		pha				pha
.10af	e8		inx				inx  							; point X to the word
.10b0	e8		inx				inx
.10b1	8a		txa				txa 							; copy into Y
.10b2	a8		tay				tay
.10b3	b1 03		lda ($03),y			lda 	(IP),y 					; read it. the LSB
.10b5	85 06		sta $06				sta 	TOS
.10b7	c8		iny				iny 							; read and push the MSB
.10b8	b1 03		lda ($03),y			lda 	(IP),y
.10ba	85 07		sta $07				sta 	TOS+1
.10bc	4c 00 00	jmp $0000			jmp 	NextCode
.10bf					Literal2ByteDecode:
.10bf	a9 06		lda #$06			lda 	#CTH_Keyword
.10c1	20 c1 1c	jsr $1cc1			jsr 	DecodeWriteBuffer
.10c4	b1 08		lda ($08),y			lda 	(srcPtr),y
.10c6	aa		tax				tax
.10c7	c8		iny				iny
.10c8	b1 08		lda ($08),y			lda 	(srcPtr),y
.10ca	a8		tay				tay
.10cb	8a		txa				txa
.10cc	38		sec				sec 							; output signed
.10cd	20 e3 1c	jsr $1ce3			jsr 	DecodeYAToBuffer
.10d0	60		rts				rts
.10d1					LiteralString:
.10d1	a5 06		lda $06				lda 	TOS
.10d3	48		pha				pha
.10d4	a5 07		lda $07				lda 	TOS+1
.10d6	48		pha				pha
.10d7	e8		inx				inx
.10d8	e8		inx				inx 							; skip over current word
.10d9	8a		txa				txa 							; add to IP + 1 to give string address
.10da	a8		tay				tay 							; put in Y
.10db	38		sec				sec 							; make that TOS
.10dc	65 03		adc $03				adc 	IP
.10de	85 06		sta $06				sta 	TOS
.10e0	a5 04		lda $04				lda 	IP+1
.10e2	69 00		adc #$00			adc 	#0
.10e4	85 07		sta $07				sta 	TOS+1
.10e6	8a		txa				txa 							; add data length to X
.10e7	18		clc				clc
.10e8	71 03		adc ($03),y			adc 	(IP),y
.10ea	aa		tax				tax
.10eb	ca		dex				dex
.10ec	ca		dex				dex
.10ed	4c 00 00	jmp $0000			jmp 	NextCode
.10f0					LiteralStringDecoder:
.10f0	a9 05		lda #$05			lda 	#CTH_String
.10f2	20 c1 1c	jsr $1cc1			jsr 	DecodeWriteBuffer
.10f5	a9 22		lda #$22			lda 	#'"'
.10f7	20 c1 1c	jsr $1cc1			jsr 	DecodeWriteBuffer
.10fa	20 ca 1c	jsr $1cca			jsr 	DecodeOutputData
.10fd	20 c1 1c	jsr $1cc1			jsr 	DecodeWriteBuffer
.1100	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: extern.asm

.1101					ExternInitialise:
.1101	a9 90		lda #$90			lda 	#144 						; set colour
.1103	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.1106	a9 01		lda #$01			lda 	#$01
.1108	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.110b	a9 0e		lda #$0e			lda 	#14							; lower case
.110d	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.1110	a9 93		lda #$93			lda 	#147 						; clear screen
.1112	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.1115	a9 07		lda #$07			lda 	#COL_WHITE 					; white text.
.1117	4c 38 11	jmp $1138			jmp 	ExternColour
.111a					ExternCheckBreak:
.111a	da		phx				phx 								; make sure we keep XY
.111b	5a		phy				phy
.111c	20 e1 ff	jsr $ffe1			jsr 	$FFE1						; STOP check on CBM KERNAL
.111f	f0 03		beq $1124			beq		_ECBExit 					; stopped
.1121	7a		ply				ply 								; restore and exit.
.1122	fa		plx				plx
.1123	60		rts				rts
.1124					_ECBExit:
.1124	20 43 10	jsr $1043			jsr 	ErrorHandler
>1127	45 53 43 41 50 45 00				.text 	"ESCAPE",0
.112e					ExternPrint:
.112e	48		pha				pha
.112f	da		phx				phx
.1130	5a		phy				phy
.1131	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.1134	7a		ply				ply
.1135	fa		plx				plx
.1136	68		pla				pla
.1137	60		rts				rts
.1138					ExternColour:
.1138	48		pha				pha
.1139	da		phx				phx
.113a	48		pha				pha
.113b	29 08		and #$08			and 	#8
.113d	0a		asl a				asl 	a
.113e	0a		asl a				asl 	a
.113f	0a		asl a				asl 	a
.1140	0a		asl a				asl 	a
.1141	49 92		eor #$92			eor 	#$92
.1143	20 2e 11	jsr $112e			jsr 	ExternPrint
.1146	68		pla				pla
.1147	29 07		and #$07			and 	#7
.1149	aa		tax				tax
.114a	bd 53 11	lda $1153,x			lda 	_ECTable,x
.114d	20 2e 11	jsr $112e			jsr 	ExternPrint
.1150	fa		plx				plx
.1151	68		pla				pla
.1152	60		rts				rts
.1153					_ECTable:
>1153	90						.byte 	144
>1154	1c						.byte 	28
>1155	1e						.byte 	30
>1156	9e						.byte 	158
>1157	1f						.byte 	31
>1158	9c						.byte 	156
>1159	9f						.byte 	159
>115a	05						.byte 	5
.115b					ExternInput:
.115b	a9 10		lda #$10			lda 	#(textBuffer & $FF)
.115d	85 14		sta $14				sta 	temp3
.115f	a9 08		lda #$08			lda 	#(textBuffer >> 8)
.1161	85 15		sta $15				sta 	temp3+1
.1163	20 cf ff	jsr $ffcf	_EIRead:jsr 	$FFCF
.1166	29 7f		and #$7f			and 	#$7F
.1168	c9 0d		cmp #$0d			cmp 	#13
.116a	f0 0a		beq $1176			beq 	_EIExit
.116c	92 14		sta ($14)			sta 	(temp3)
.116e	e6 14		inc $14				inc 	temp3
.1170	d0 f1		bne $1163			bne 	_EIRead
.1172	e6 15		inc $15				inc 	temp3+1
.1174	80 ed		bra $1163			bra 	_EIRead
.1176	a9 00		lda #$00	_EIExit:lda 	#0
.1178	92 14		sta ($14)			sta 	(temp3)
.117a	a9 0d		lda #$0d			lda 	#13
.117c	20 2e 11	jsr $112e			jsr 	ExternPrint
.117f	60		rts				rts
.1180					ExternSave:
.1180	da		phx				phx
.1181	5a		phy				phy
.1182	85 12		sta $12				sta 	temp2 						; save start
.1184	84 13		sty $13				sty 	temp2+1
.1186	20 e8 11	jsr $11e8			jsr 	EXGetLength 				; get length of file into A
.1189	a6 14		ldx $14				ldx 	temp3
.118b	a4 15		ldy $15				ldy 	temp3+1
.118d	20 bd ff	jsr $ffbd			jsr 	$FFBD 						; set name
.1190	a9 01		lda #$01			lda 	#1
.1192	a2 08		ldx #$08			ldx 	#8	 						; device #8
.1194	a0 00		ldy #$00			ldy 	#0
.1196	20 ba ff	jsr $ffba			jsr 	$FFBA 						; set LFS
.1199	a6 10		ldx $10				ldx 	temp1 						; end address
.119b	a4 11		ldy $11				ldy 	temp1+1
.119d	a9 12		lda #$12			lda 	#temp2
.119f	20 d8 ff	jsr $ffd8			jsr 	$FFD8 						; save
.11a2	b0 03		bcs $11a7			bcs 	_ESSave
.11a4	7a		ply				ply
.11a5	fa		plx				plx
.11a6	60		rts				rts
.11a7					_ESSave:
.11a7	20 43 10	jsr $1043			jsr 	ErrorHandler
>11aa	53 41 56 45 20 46 41 49				.text 	"SAVE FAILED",0
>11b2	4c 45 44 00
.11b6					ExternLoad:
.11b6	da		phx				phx 								; save XY
.11b7	5a		phy				phy
.11b8	48		pha				pha 								; save target
.11b9	5a		phy				phy
.11ba	20 e8 11	jsr $11e8			jsr 	EXGetLength 				; get length of file into A
.11bd	a6 14		ldx $14				ldx 	temp3
.11bf	a4 15		ldy $15				ldy 	temp3+1
.11c1	20 bd ff	jsr $ffbd			jsr 	$FFBD 						; set name
.11c4	a9 01		lda #$01			lda 	#1
.11c6	a2 08		ldx #$08			ldx 	#8	 						; device #8
.11c8	a0 00		ldy #$00			ldy 	#0
.11ca	20 ba ff	jsr $ffba			jsr 	$FFBA 						; set LFS
.11cd	7a		ply				ply 								; restore target to YX and call load
.11ce	fa		plx				plx
.11cf	a9 00		lda #$00			lda 	#0 							; load command
.11d1	20 d5 ff	jsr $ffd5			jsr 	$FFD5
.11d4	b0 03		bcs $11d9			bcs 	_ESLoad
.11d6	7a		ply				ply
.11d7	fa		plx				plx
.11d8	60		rts				rts
.11d9					_ESLoad:
.11d9	20 43 10	jsr $1043			jsr 	ErrorHandler
>11dc	4c 4f 41 44 20 46 41 49				.text 	"LOAD FAILED",0
>11e4	4c 45 44 00
.11e8					EXGetLength:
.11e8	b2 14		lda ($14)			lda 	(temp3) 					; get name length
.11ea	e6 14		inc $14				inc 	temp3 						; bump ptr past it
.11ec	d0 02		bne $11f0			bne 	_EXGLExit
.11ee	e6 15		inc $15				inc 	temp3+1
.11f0					_EXGLExit:
.11f0	60		rts				rts
.11f1					EXPrintString:
.11f1	48		pha				pha
.11f2	5a		phy				phy
.11f3	84 11		sty $11				sty 	temp1+1
.11f5	85 10		sta $10				sta 	temp1
.11f7	a0 00		ldy #$00			ldy 	#0
.11f9					_EXPSLoop:
.11f9	b1 10		lda ($10),y			lda 	(temp1),y
.11fb	f0 08		beq $1205			beq 	_EXPSExit
.11fd	29 7f		and #$7f			and 	#$7F
.11ff	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.1202	c8		iny				iny
.1203	80 f4		bra $11f9			bra 	_EXPSLoop
.1205					_EXPSExit:
.1205	7a		ply				ply
.1206	68		pla				pla
.1207	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/binary.src

.1208					Add:
.1208	7a		ply				ply
.1209	68		pla				pla
.120a	18		clc				clc
.120b	65 06		adc $06				adc 	TOS
.120d	85 06		sta $06				sta 	TOS
.120f	98		tya				tya
.1210	65 07		adc $07				adc 	TOS+1
.1212	85 07		sta $07				sta 	TOS+1
.1214	4c 00 00	jmp $0000			jmp 	NextCode
.1217					Subtract:
.1217	7a		ply				ply
.1218	68		pla				pla
.1219	38		sec				sec
.121a	49 ff		eor #$ff			eor 	#$FF
.121c	65 06		adc $06				adc 	TOS
.121e	85 06		sta $06				sta 	TOS
.1220	98		tya				tya
.1221	49 ff		eor #$ff			eor 	#$FF
.1223	65 07		adc $07				adc 	TOS+1
.1225	85 07		sta $07				sta 	TOS+1
.1227	4c 00 00	jmp $0000			jmp 	NextCode
.122a					And:
.122a	68		pla				pla
.122b	25 07		and $07				and 	TOS+1
.122d	85 07		sta $07				sta 	TOS+1
.122f	68		pla				pla
.1230	25 06		and $06				and 	TOS
.1232	85 06		sta $06				sta 	TOS
.1234	4c 00 00	jmp $0000			jmp 	NextCode
.1237					Xor:
.1237	68		pla				pla
.1238	45 07		eor $07				eor 	TOS+1
.123a	85 07		sta $07				sta 	TOS+1
.123c	68		pla				pla
.123d	45 06		eor $06				eor 	TOS
.123f	85 06		sta $06				sta 	TOS
.1241	4c 00 00	jmp $0000			jmp 	NextCode
.1244					LogOr:
.1244	68		pla				pla
.1245	05 07		ora $07				ora 	TOS+1
.1247	85 07		sta $07				sta 	TOS+1
.1249	68		pla				pla
.124a	05 06		ora $06				ora 	TOS
.124c	85 06		sta $06				sta 	TOS
.124e	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/compare.src

.1251					CheckNotEqual:
.1251	38		sec				sec
.1252	80 01		bra $1255			bra 	CECode
.1254					CheckEqual:
.1254	18		clc				clc
.1255					CECode:
.1255	86 10		stx $10				stx 	temp1
.1257	ba		tsx				tsx
.1258	08		php				php
.1259	a5 06		lda $06				lda 	TOS
.125b	5d 02 01	eor $0102,x			eor 	Stack2Low,x
.125e	d0 17		bne $1277			bne	 	CompareFalse
.1260	a5 07		lda $07				lda 	TOS+1
.1262	5d 01 01	eor $0101,x			eor 	Stack2High,x
.1265	d0 10		bne $1277			bne 	CompareFalse
.1267					CompareTrue:
.1267	a6 10		ldx $10				ldx 	temp1
.1269	28		plp				plp
.126a	b0 10		bcs $127c			bcs		CompareFalse2
.126c					CompareTrue2:
.126c	68		pla				pla
.126d	68		pla				pla
.126e	a9 ff		lda #$ff			lda 	#$FF
.1270	85 06		sta $06				sta 	TOS
.1272	85 07		sta $07				sta 	TOS+1
.1274	4c 00 00	jmp $0000			jmp 	NextCode
.1277					CompareFalse:
.1277	a6 10		ldx $10				ldx 	temp1
.1279	28		plp				plp
.127a	b0 f0		bcs $126c			bcs		CompareTrue2
.127c					CompareFalse2:
.127c	68		pla				pla
.127d	68		pla				pla
.127e	64 06		stz $06				stz 	TOS
.1280	64 07		stz $07				stz 	TOS+1
.1282	4c 00 00	jmp $0000			jmp 	NextCode
.1285					CheckGreaterEq:
.1285	38		sec				sec
.1286	80 01		bra $1289			bra		CLCode
.1288					CheckLess:
.1288	18		clc				clc
.1289	86 10		stx $10		CLCode:	stx 	temp1
.128b	ba		tsx				tsx
.128c	08		php				php
.128d	18		clc				clc
.128e	a5 06		lda $06				lda 	TOS
.1290	fd 02 01	sbc $0102,x			sbc 	Stack2Low,x
.1293	a5 07		lda $07				lda 	TOS+1
.1295	fd 01 01	sbc $0101,x			sbc 	Stack2High,x
.1298	50 02		bvc $129c			bvc 	_CLNoFlip
.129a	49 80		eor #$80			eor 	#$80
.129c					_CLNoFlip:
.129c	0a		asl a				asl 	a
.129d	b0 d8		bcs $1277			bcs 	CompareFalse
.129f	80 c6		bra $1267			bra 	CompareTrue
.12a1					CheckLessEq:
.12a1	38		sec				sec
.12a2	80 01		bra $12a5			bra		CGCode
.12a4					CheckGreater:
.12a4	18		clc				clc
.12a5					CGCode:
.12a5	86 10		stx $10				stx 	temp1
.12a7	ba		tsx				tsx
.12a8	08		php				php
.12a9	18		clc				clc
.12aa	bd 02 01	lda $0102,x			lda 	Stack2Low,x
.12ad	e5 06		sbc $06				sbc 	TOS
.12af	bd 01 01	lda $0101,x			lda 	Stack2High,x
.12b2	e5 07		sbc $07				sbc 	TOS+1
.12b4	50 02		bvc $12b8			bvc 	_CGNoFlip
.12b6	49 80		eor #$80			eor 	#$80
.12b8					_CGNoFlip:
.12b8	0a		asl a				asl 	a
.12b9	b0 bc		bcs $1277			bcs 	CompareFalse
.12bb	80 aa		bra $1267			bra 	CompareTrue
.12bd					Minimum:
.12bd	a9 00		lda #$00			lda 	#0
.12bf	80 02		bra $12c3			bra 	MinMaxCode
.12c1					Maximum:
.12c1	a9 80		lda #$80			lda 	#$80
.12c3					MinMaxCode:
.12c3	85 11		sta $11				sta 	temp1+1
.12c5	86 10		stx $10				stx 	temp1
.12c7	ba		tsx				tsx
.12c8	38		sec				sec
.12c9	a5 06		lda $06				lda 	TOS
.12cb	fd 02 01	sbc $0102,x			sbc 	Stack2Low,x
.12ce	a5 07		lda $07				lda 	TOS+1
.12d0	fd 01 01	sbc $0101,x			sbc 	Stack2High,x
.12d3	50 02		bvc $12d7			bvc 	_MMNoFlip
.12d5	49 80		eor #$80			eor 	#$80
.12d7					_MMNoFlip:
.12d7	45 11		eor $11				eor 	temp1+1
.12d9	30 0a		bmi $12e5			bmi 	_MMNoCopy
.12db	bd 02 01	lda $0102,x			lda 	Stack2Low,x
.12de	85 06		sta $06				sta 	TOS
.12e0	bd 01 01	lda $0101,x			lda 	Stack2High,x
.12e3	85 07		sta $07				sta 	TOS+1
.12e5					_MMNoCopy:
.12e5	a6 10		ldx $10				ldx 	temp1
.12e7	68		pla				pla
.12e8	68		pla				pla
.12e9	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/divide.src

.12ec					Divide16x16:
.12ec	86 12		stx $12				stx 	temp2
.12ee	ba		tsx				tsx
.12ef	20 12 13	jsr $1312			jsr 	IntegerDivide
.12f2	68		pla				pla
.12f3	85 07		sta $07				sta 	TOS+1
.12f5	68		pla				pla
.12f6	85 06		sta $06				sta 	TOS
.12f8	a6 12		ldx $12				ldx 	temp2
.12fa	4c 00 00	jmp $0000			jmp 	NextCode
.12fd					Modulus16x16:
.12fd	86 12		stx $12				stx 	temp2
.12ff	ba		tsx				tsx
.1300	20 12 13	jsr $1312			jsr 	IntegerDivide
.1303	a6 12		ldx $12				ldx 	temp2
.1305	68		pla				pla
.1306	68		pla				pla
.1307	a5 10		lda $10				lda 	temp1
.1309	85 06		sta $06				sta 	TOS
.130b	a5 11		lda $11				lda 	temp1+1
.130d	85 07		sta $07				sta 	TOS+1
.130f	4c 00 00	jmp $0000			jmp 	NextCode
.1312					IntegerDivide:
.1312	a5 06		lda $06				lda 	TOS 				; check for division by zero.
.1314	05 07		ora $07				ora 	TOS+1
.1316	d0 14		bne $132c			bne 	_BFDOkay
.1318	20 43 10	jsr $1043			jsr 	ErrorHandler
>131b	44 49 56 49 53 49 4f 4e				.text 	"DIVISION BY ZERO",0
>1323	20 42 59 20 5a 45 52 4f 00
.132c					_BFDOkay:
.132c	64 10		stz $10				stz 	temp1 						; Q/Dividend/Left in +0
.132e	64 11		stz $11				stz 	temp1+1 					; M/Divisor/Right in +2
.1330	64 1a		stz $1a				stz 	SignCount 					; Count of signs.
.1332	20 6d 13	jsr $136d			jsr 	CheckIntegerNegate 			; negate 2nd (and bump sign count)
.1335	20 87 13	jsr $1387			jsr 	CheckTOSNegate 				; negate TOS (and bump sign count)
.1338	5a		phy				phy 								; Y is the counter
.1339	a0 10		ldy #$10			ldy 	#16 						; 16 iterations of the loop.
.133b					_BFDLoop:
.133b	1e 02 01	asl $0102,x			asl 	Stack2Low,x 				; shift AQ left.
.133e	3e 01 01	rol $0101,x			rol 	Stack2High,x
.1341	26 10		rol $10				rol 	temp1
.1343	26 11		rol $11				rol 	temp1+1
.1345	38		sec				sec
.1346	a5 10		lda $10				lda 	temp1+0 					; Calculate A-M on stack.
.1348	e5 06		sbc $06				sbc 	TOS
.134a	48		pha				pha
.134b	a5 11		lda $11				lda 	temp1+1
.134d	e5 07		sbc $07				sbc 	TOS+1
.134f	90 0f		bcc $1360			bcc 	_BFDNoAdd
.1351	85 11		sta $11				sta 	temp1+1
.1353	68		pla				pla
.1354	85 10		sta $10				sta 	temp1+0
.1356	bd 02 01	lda $0102,x			lda 	Stack2Low,x 				; set Q bit 1.
.1359	09 01		ora #$01			ora 	#1
.135b	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.135e	80 01		bra $1361			bra 	_BFDNext
.1360					_BFDNoAdd:
.1360	68		pla				pla 								; Throw away the intermediate calculations
.1361					_BFDNext:
.1361	88		dey				dey
.1362	d0 d7		bne $133b			bne 	_BFDLoop
.1364	7a		ply				ply 								; restore Y
.1365	46 1a		lsr $1a				lsr 	SignCount 					; if sign count odd,
.1367	90 03		bcc $136c			bcc 	_BFDUnsigned 				; then the result is signed
.1369	20 73 13	jsr $1373			jsr		IntegerNegateAlways 		; negate the result
.136c					_BFDUnsigned:
.136c	60		rts				rts
.136d					CheckIntegerNegate:
.136d	bd 01 01	lda $0101,x			lda 	Stack2High,x 				; is it -ve = MSB set ?
.1370	30 01		bmi $1373			bmi 	IntegerNegateAlways 		; if so negate it
.1372	60		rts				rts
.1373					IntegerNegateAlways:
.1373	e6 1a		inc $1a				inc 	SignCount 					; bump the count of signs
.1375	38		sec				sec 								; negate
.1376	a9 00		lda #$00			lda 	#0
.1378	fd 02 01	sbc $0102,x			sbc 	Stack2Low,x
.137b	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.137e	a9 00		lda #$00			lda 	#0
.1380	fd 01 01	sbc $0101,x			sbc 	Stack2High,x
.1383	9d 01 01	sta $0101,x			sta 	Stack2High,x
.1386	60		rts				rts
.1387					CheckTOSNegate:
.1387	a5 07		lda $07				lda 	TOS+1
.1389	10 0f		bpl $139a			bpl		CTNNoChange
.138b	e6 1a		inc $1a				inc 	SignCount
.138d					TOSNegateAlways:
.138d	38		sec				sec
.138e	a9 00		lda #$00			lda 	#0
.1390	e5 06		sbc $06				sbc 	TOS
.1392	85 06		sta $06				sta 	TOS
.1394	a9 00		lda #$00			lda 	#0
.1396	e5 07		sbc $07				sbc 	TOS+1
.1398	85 07		sta $07				sta 	TOS+1
.139a					CTNNoChange:
.139a	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/multiply.src

.139b					Multiply16x16:
.139b	86 10		stx $10				stx 	temp1
.139d	ba		tsx				tsx
.139e	bd 02 01	lda $0102,x			lda 	Stack2Low,x 				; 2nd value on stack to temp1
.13a1	85 12		sta $12				sta 	temp2
.13a3	bd 01 01	lda $0101,x			lda		Stack2High,x
.13a6	85 13		sta $13				sta 	temp2+1
.13a8	9e 02 01	stz $0102,x			stz 	Stack2Low,x 				; zero 2nd value on stack
.13ab	9e 01 01	stz $0101,x			stz 	Stack2High,x
.13ae					_MultLoop:
.13ae	46 13		lsr $13				lsr 	temp2+1 					; ror temp2 into C
.13b0	66 12		ror $12				ror 	temp2
.13b2	90 11		bcc $13c5			bcc 	_MultNoAdd
.13b4	18		clc				clc 								; add 1st to 2nd
.13b5	a5 06		lda $06				lda 	TOS
.13b7	7d 02 01	adc $0102,x			adc 	Stack2Low,x
.13ba	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.13bd	a5 07		lda $07				lda 	TOS+1
.13bf	7d 01 01	adc $0101,x			adc 	Stack2High,x
.13c2	9d 01 01	sta $0101,x			sta 	Stack2High,x
.13c5					_MultNoAdd:
.13c5	06 06		asl $06				asl 	TOS 						; shift 1st left
.13c7	26 07		rol $07				rol 	TOS+1
.13c9	a5 12		lda $12				lda 	temp2	 					; until zero
.13cb	05 13		ora $13				ora 	temp2+1
.13cd	d0 df		bne $13ae			bne 	_MultLoop
.13cf	a6 10		ldx $10				ldx 	temp1 						; restore X load result
.13d1	68		pla				pla
.13d2	85 07		sta $07				sta 	TOS+1
.13d4	68		pla				pla
.13d5	85 06		sta $06				sta 	TOS
.13d7	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/unary.src

.13da					Unary1Plus:
.13da	e6 06		inc $06				inc 	TOS
.13dc	d0 02		bne $13e0			bne 	_U1PSkip
.13de	e6 07		inc $07				inc 	TOS+1
.13e0					_U1PSkip:
.13e0	4c 00 00	jmp $0000			jmp 	NextCode
.13e3					Unary2Plus:
.13e3	18		clc				clc
.13e4	a5 06		lda $06				lda 	TOS
.13e6	69 02		adc #$02			adc 	#2
.13e8	85 06		sta $06				sta 	TOS
.13ea	90 02		bcc $13ee			bcc 	_U1PSkip
.13ec	e6 07		inc $07				inc 	TOS+1
.13ee					_U1PSkip:
.13ee	4c 00 00	jmp $0000			jmp 	NextCode
.13f1					Unary1Minus:
.13f1	a5 06		lda $06				lda 	TOS
.13f3	d0 02		bne $13f7			bne 	_U1MSkip
.13f5	c6 07		dec $07				dec 	TOS+1
.13f7					_U1MSkip:
.13f7	c6 06		dec $06				dec 	TOS
.13f9	4c 00 00	jmp $0000			jmp 	NextCode
.13fc					Unary2Minus:
.13fc	38		sec				sec
.13fd	a5 06		lda $06				lda 	TOS
.13ff	e9 02		sbc #$02			sbc 	#2
.1401	85 06		sta $06				sta 	TOS
.1403	b0 02		bcs $1407			bcs 	_U1PSkip
.1405	c6 07		dec $07				dec 	TOS+1
.1407					_U1PSkip:
.1407	4c 00 00	jmp $0000			jmp 	NextCode
.140a					Absolute:
.140a	a5 07		lda $07				lda 	TOS+1
.140c	30 03		bmi $1411			bmi 	Negate
.140e	4c 00 00	jmp $0000			jmp 	NextCode
.1411					Negate:
.1411	38		sec				sec
.1412	a9 00		lda #$00			lda 	#0
.1414	e5 06		sbc $06				sbc 	TOS
.1416	85 06		sta $06				sta 	TOS
.1418	a9 00		lda #$00			lda 	#0
.141a	e5 07		sbc $07				sbc 	TOS+1
.141c	85 07		sta $07				sta 	TOS+1
.141e	4c 00 00	jmp $0000			jmp 	NextCode
.1421					OneComplement:
.1421	a5 06		lda $06				lda 	TOS
.1423	49 ff		eor #$ff			eor 	#$FF
.1425	85 06		sta $06				sta 	TOS
.1427	a5 07		lda $07				lda 	TOS+1
.1429	49 ff		eor #$ff			eor 	#$FF
.142b	85 07		sta $07				sta 	TOS+1
.142d	4c 00 00	jmp $0000			jmp 	NextCode
.1430					CheckMinus:
.1430	a5 07		lda $07				lda 	TOS+1
.1432	30 07		bmi $143b			bmi 	UnaryTrue
.1434					UnaryFalse:
.1434	64 06		stz $06				stz 	TOS
.1436	64 07		stz $07				stz 	TOS+1
.1438	4c 00 00	jmp $0000			jmp 	NextCode
.143b					UnaryTrue:
.143b	a9 ff		lda #$ff			lda 	#$FF
.143d	85 06		sta $06				sta 	TOS
.143f	85 07		sta $07				sta 	TOS+1
.1441	4c 00 00	jmp $0000			jmp 	NextCode
.1444					CheckZero:
.1444	a5 06		lda $06				lda 	TOS
.1446	05 07		ora $07				ora 	TOS+1
.1448	d0 ea		bne $1434			bne 	UnaryFalse
.144a	80 ef		bra $143b			bra 	UnaryTrue
.144c					SignTOS:
.144c	a5 07		lda $07				lda 	TOS+1
.144e	30 eb		bmi $143b			bmi		UnaryTrue
.1450	05 06		ora $06				ora 	TOS
.1452	f0 e0		beq $1434			beq 	UnaryFalse
.1454	a9 01		lda #$01			lda 	#1
.1456	85 06		sta $06				sta 	TOS
.1458	64 07		stz $07				stz		TOS+1
.145a	4c 00 00	jmp $0000			jmp 	NextCode
.145d					ByteSwap:
.145d	a5 06		lda $06				lda 	TOS
.145f	a4 07		ldy $07				ldy 	TOS+1
.1461	85 07		sta $07				sta 	TOS+1
.1463	84 06		sty $06				sty 	TOS
.1465	4c 00 00	jmp $0000			jmp 	NextCode
.1468					Times16:
.1468	06 06		asl $06				asl 	TOS
.146a	26 07		rol $07				rol 	TOS+1
.146c					Times8:
.146c	06 06		asl $06				asl 	TOS
.146e	26 07		rol $07				rol 	TOS+1
.1470					Times4:
.1470	06 06		asl $06				asl 	TOS
.1472	26 07		rol $07				rol 	TOS+1
.1474					Times2:
.1474	06 06		asl $06				asl 	TOS
.1476	26 07		rol $07				rol 	TOS+1
.1478	4c 00 00	jmp $0000			jmp 	NextCode
.147b					Divide16:
.147b	46 07		lsr $07				lsr 	TOS+1
.147d	66 06		ror $06				ror 	TOS
.147f					Divide8:
.147f	46 07		lsr $07				lsr 	TOS+1
.1481	66 06		ror $06				ror 	TOS
.1483					Divide4:
.1483	46 07		lsr $07				lsr 	TOS+1
.1485	66 06		ror $06				ror 	TOS
.1487					Divide2:
.1487	46 07		lsr $07				lsr 	TOS+1
.1489	66 06		ror $06				ror 	TOS
.148b	4c 00 00	jmp $0000			jmp 	NextCode
.148e					Times256:
.148e	a5 06		lda $06				lda 	TOS
.1490	85 07		sta $07				sta 	TOS+1
.1492	64 06		stz $06				stz 	TOS
.1494	4c 00 00	jmp $0000			jmp 	NextCode
.1497					Divide256:
.1497	a5 07		lda $07				lda 	TOS+1
.1499	85 06		sta $06				sta 	TOS
.149b	64 07		stz $07				stz 	TOS+1
.149d	4c 00 00	jmp $0000			jmp 	NextCode
.14a0					RandomNumber:
.14a0	a5 06		lda $06				lda 	TOS
.14a2	48		pha				pha
.14a3	a5 07		lda $07				lda 	TOS+1
.14a5	48		pha				pha
.14a6	a5 1b		lda $1b				lda 	randomSeed
.14a8	05 1c		ora $1c				ora 	randomSeed+1
.14aa	d0 08		bne $14b4			bne 	_RH_NoInit
.14ac	a9 7c		lda #$7c			lda 	#$7C
.14ae	85 1b		sta $1b				sta 	randomSeed
.14b0	a9 a1		lda #$a1			lda 	#$A1
.14b2	85 1c		sta $1c				sta 	randomSeed+1
.14b4					_RH_NoInit:
.14b4	a5 1b		lda $1b				lda 	randomSeed
.14b6	4a		lsr a		        lsr		a
.14b7	26 1c		rol $1c		        rol 	randomSeed+1
.14b9	90 02		bcc $14bd	        bcc 	_RH_NoEor
.14bb	49 b4		eor #$b4	        eor 	#$B4
.14bd					_RH_NoEor:
.14bd	85 1b		sta $1b		        sta 	randomSeed
.14bf	45 1c		eor $1c		        eor 	randomSeed+1
.14c1	85 07		sta $07		        sta 	TOS+1
.14c3	a5 1b		lda $1b		        lda 	randomSeed
.14c5	85 06		sta $06		        sta 	TOS
.14c7	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/data/literals.src

.14ca					Constant0:
.14ca	a5 06		lda $06				lda 	TOS
.14cc	48		pha				pha
.14cd	a5 07		lda $07				lda 	TOS+1
.14cf	48		pha				pha
.14d0	64 06		stz $06				stz 	TOS
.14d2	64 07		stz $07				stz 	TOS+1
.14d4	4c 00 00	jmp $0000			jmp 	NextCode
.14d7					ConstantMinus1:
.14d7	a5 06		lda $06				lda 	TOS
.14d9	48		pha				pha
.14da	a5 07		lda $07				lda 	TOS+1
.14dc	48		pha				pha
.14dd	a9 ff		lda #$ff			lda 	#$FF
.14df	85 06		sta $06				sta 	TOS
.14e1	85 07		sta $07				sta 	TOS+1
.14e3	4c 00 00	jmp $0000			jmp 	NextCode
.14e6					C1:
.14e6	a0 01		ldy #$01			ldy 	#1
.14e8	80 24		bra $150e			bra 	Const1Byte
.14ea					C2:
.14ea	a0 02		ldy #$02			ldy 	#2
.14ec	80 20		bra $150e			bra 	Const1Byte
.14ee					C3:
.14ee	a0 03		ldy #$03			ldy 	#3
.14f0	80 1c		bra $150e			bra 	Const1Byte
.14f2					C4:
.14f2	a0 04		ldy #$04			ldy 	#4
.14f4	80 18		bra $150e			bra 	Const1Byte
.14f6					C5:
.14f6	a0 05		ldy #$05			ldy 	#5
.14f8	80 14		bra $150e			bra 	Const1Byte
.14fa					C8:
.14fa	a0 08		ldy #$08			ldy 	#8
.14fc	80 10		bra $150e			bra 	Const1Byte
.14fe					C10:
.14fe	a0 0a		ldy #$0a			ldy 	#10
.1500	80 0c		bra $150e			bra 	Const1Byte
.1502					C15:
.1502	a0 0f		ldy #$0f			ldy 	#15
.1504	80 08		bra $150e			bra 	Const1Byte
.1506					C16:
.1506	a0 10		ldy #$10			ldy 	#16
.1508	80 04		bra $150e			bra 	Const1Byte
.150a					C24:
.150a	a0 18		ldy #$18			ldy 	#24
.150c	80 00		bra $150e			bra 	Const1Byte
.150e					Const1Byte:
.150e	a5 06		lda $06				lda 	TOS
.1510	48		pha				pha
.1511	a5 07		lda $07				lda 	TOS+1
.1513	48		pha				pha
.1514	84 06		sty $06				sty 	TOS
.1516	64 07		stz $07				stz 	TOS+1
.1518	4c 00 00	jmp $0000			jmp 	NextCode
.151b					C32:
.151b	a0 20		ldy #$20			ldy 	#32
.151d	80 ef		bra $150e			bra 	Const1Byte
.151f					C63:
.151f	a0 3f		ldy #$3f			ldy 	#63
.1521	80 eb		bra $150e			bra 	Const1Byte
.1523					C64:
.1523	a0 40		ldy #$40			ldy 	#64
.1525	80 e7		bra $150e			bra 	Const1Byte
.1527					C100:
.1527	a0 64		ldy #$64			ldy 	#100
.1529	80 e3		bra $150e			bra 	Const1Byte
.152b					C127:
.152b	a0 7f		ldy #$7f			ldy 	#127
.152d	80 df		bra $150e			bra 	Const1Byte
.152f					C128:
.152f	a0 80		ldy #$80			ldy 	#128
.1531	80 db		bra $150e			bra 	Const1Byte
.1533					C255:
.1533	a0 ff		ldy #$ff			ldy 	#255
.1535	80 d7		bra $150e			bra 	Const1Byte
.1537					Const2Byte:
.1537	85 06		sta $06				sta 	TOS
.1539	84 07		sty $07				sty 	TOS+1
.153b	4c 00 00	jmp $0000			jmp 	NextCode
.153e					C256:
.153e	a5 06		lda $06				lda 	TOS
.1540	48		pha				pha
.1541	a5 07		lda $07				lda 	TOS+1
.1543	48		pha				pha
.1544	a9 00		lda #$00			lda 	#(256) & $FF
.1546	a0 01		ldy #$01			ldy 	#(256) >> 8
.1548	80 ed		bra $1537			bra 	Const2Byte
.154a					C512:
.154a	a5 06		lda $06				lda 	TOS
.154c	48		pha				pha
.154d	a5 07		lda $07				lda 	TOS+1
.154f	48		pha				pha
.1550	a9 00		lda #$00			lda 	#(512) & $FF
.1552	a0 02		ldy #$02			ldy 	#(512) >> 8
.1554	80 e1		bra $1537			bra 	Const2Byte
.1556					C1024:
.1556	a5 06		lda $06				lda 	TOS
.1558	48		pha				pha
.1559	a5 07		lda $07				lda 	TOS+1
.155b	48		pha				pha
.155c	a9 00		lda #$00			lda 	#(1024) & $FF
.155e	a0 04		ldy #$04			ldy 	#(1024) >> 8
.1560	80 d5		bra $1537			bra 	Const2Byte
.1562					C4096:
.1562	a5 06		lda $06				lda 	TOS
.1564	48		pha				pha
.1565	a5 07		lda $07				lda 	TOS+1
.1567	48		pha				pha
.1568	a9 00		lda #$00			lda 	#(4096) & $FF
.156a	a0 10		ldy #$10			ldy 	#(4096) >> 8
.156c	80 c9		bra $1537			bra 	Const2Byte
.156e					C32767:
.156e	a5 06		lda $06				lda 	TOS
.1570	48		pha				pha
.1571	a5 07		lda $07				lda 	TOS+1
.1573	48		pha				pha
.1574	a9 ff		lda #$ff			lda 	#(32767) & $FF
.1576	a0 7f		ldy #$7f			ldy 	#(32767) >> 8
.1578	80 bd		bra $1537			bra 	Const2Byte
.157a					C32768:
.157a	a5 06		lda $06				lda 	TOS
.157c	48		pha				pha
.157d	a5 07		lda $07				lda 	TOS+1
.157f	48		pha				pha
.1580	a9 00		lda #$00			lda 	#(32768) & $FF
.1582	a0 80		ldy #$80			ldy 	#(32768) >> 8
.1584	80 b1		bra $1537			bra 	Const2Byte

;******  Return to file: kernel.asm


;******  Processing file: words/data/stack.src

.1586					Drop:
.1586	68		pla				pla
.1587	85 07		sta $07				sta 	TOS+1
.1589	68		pla				pla
.158a	85 06		sta $06				sta 	TOS
.158c	4c 00 00	jmp $0000			jmp 	NextCode
.158f					TestDup:
.158f	a5 06		lda $06				lda 	TOS
.1591	05 07		ora $07				ora 	TOS+1
.1593	d0 03		bne $1598			bne 	Dup
.1595	4c 00 00	jmp $0000			jmp 	NextCode
.1598					Dup:
.1598	a5 06		lda $06				lda 	TOS
.159a	48		pha				pha
.159b	a5 07		lda $07				lda 	TOS+1
.159d	48		pha				pha
.159e	4c 00 00	jmp $0000			jmp 	NextCode
.15a1					Swap:
.15a1	86 10		stx $10				stx 	temp1
.15a3	7a		ply				ply
.15a4	fa		plx				plx
.15a5	a5 06		lda $06				lda 	TOS
.15a7	48		pha				pha
.15a8	a5 07		lda $07				lda 	TOS+1
.15aa	48		pha				pha
.15ab	86 06		stx $06				stx 	TOS
.15ad	84 07		sty $07				sty 	TOS+1
.15af	a6 10		ldx $10				ldx 	temp1
.15b1	4c 00 00	jmp $0000			jmp 	NextCode
.15b4					Over:
.15b4	a5 06		lda $06				lda 	TOS
.15b6	48		pha				pha
.15b7	a5 07		lda $07				lda 	TOS+1
.15b9	48		pha				pha
.15ba	86 10		stx $10				stx 	temp1
.15bc	ba		tsx				tsx
.15bd	bd 04 01	lda $0104,x			lda 	stack3low,x
.15c0	85 06		sta $06				sta 	TOS
.15c2	bd 03 01	lda $0103,x			lda 	stack3High,x
.15c5	85 07		sta $07				sta 	TOS+1
.15c7	a6 10		ldx $10				ldx 	temp1
.15c9	4c 00 00	jmp $0000			jmp 	NextCode
.15cc					Nip:
.15cc	68		pla				pla
.15cd	68		pla				pla
.15ce	4c 00 00	jmp $0000			jmp 	NextCode
.15d1					Rot:
.15d1	86 10		stx $10				stx 	temp1
.15d3	ba		tsx				tsx
.15d4	bd 04 01	lda $0104,x			lda 	Stack3Low,x
.15d7	a8		tay				tay
.15d8	bd 02 01	lda $0102,x			lda 	Stack2Low,x
.15db	9d 04 01	sta $0104,x			sta 	Stack3Low,x
.15de	a5 06		lda $06				lda 	TOS
.15e0	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.15e3	84 06		sty $06				sty 	TOS
.15e5	bd 03 01	lda $0103,x			lda 	Stack3High,x
.15e8	a8		tay				tay
.15e9	bd 01 01	lda $0101,x			lda 	Stack2High,x
.15ec	9d 03 01	sta $0103,x			sta 	Stack3High,x
.15ef	a5 07		lda $07				lda 	TOS+1
.15f1	9d 01 01	sta $0101,x			sta 	Stack2High,x
.15f4	84 07		sty $07				sty 	TOS+1
.15f6	a6 10		ldx $10				ldx 	temp1
.15f8	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/data/memory.src

.15fb					ByteRead:
.15fb	b2 06		lda ($06)			lda 	(TOS)
.15fd	85 06		sta $06				sta 	TOS
.15ff	64 07		stz $07				stz 	TOS+1
.1601	4c 00 00	jmp $0000			jmp 	NextCode
.1604					WordRead:
.1604	a0 01		ldy #$01			ldy 	#1
.1606	b1 06		lda ($06),y			lda 	(TOS),y
.1608	a8		tay				tay
.1609	b2 06		lda ($06)			lda 	(TOS)
.160b	85 06		sta $06				sta 	TOS
.160d	84 07		sty $07				sty 	TOS+1
.160f	4c 00 00	jmp $0000			jmp 	NextCode
.1612					ByteWrite:
.1612	68		pla				pla
.1613	68		pla				pla
.1614	92 06		sta ($06)			sta 	(TOS)
.1616	68		pla				pla
.1617	85 07		sta $07				sta 	TOS+1
.1619	68		pla				pla
.161a	85 06		sta $06				sta 	TOS
.161c	4c 00 00	jmp $0000			jmp 	NextCode
.161f					WordWrite:
.161f	68		pla				pla
.1620	a0 01		ldy #$01			ldy 	#1
.1622	91 06		sta ($06),y			sta 	(TOS),y
.1624	68		pla				pla
.1625	92 06		sta ($06)			sta 	(TOS)
.1627	68		pla				pla
.1628	85 07		sta $07				sta 	TOS+1
.162a	68		pla				pla
.162b	85 06		sta $06				sta 	TOS
.162d	4c 00 00	jmp $0000			jmp 	NextCode
.1630					WordAdd:
.1630	7a		ply				ply
.1631	68		pla				pla
.1632	18		clc				clc
.1633	72 06		adc ($06)			adc 	(TOS)
.1635	92 06		sta ($06)			sta 	(TOS)
.1637	98		tya				tya
.1638	a0 01		ldy #$01			ldy 	#1
.163a	71 06		adc ($06),y			adc 	(TOS),y
.163c	91 06		sta ($06),y			sta 	(TOS),y
.163e	68		pla				pla
.163f	85 07		sta $07				sta 	TOS+1
.1641	68		pla				pla
.1642	85 06		sta $06				sta 	TOS
.1644	4c 00 00	jmp $0000			jmp 	NextCode
.1647					AllocateMemory:
.1647	a5 06		lda $06				lda 	TOS 						; save memory required on stack.
.1649	48		pha				pha
.164a	a5 07		lda $07				lda 	TOS+1
.164c	48		pha				pha
.164d	a5 0e		lda $0e				lda 	nextFreeMem 				; copy free mem address to TOS
.164f	85 06		sta $06				sta 	TOS
.1651	a5 0f		lda $0f				lda 	nextFreeMem+1
.1653	85 07		sta $07				sta 	TOS+1
.1655	7a		ply				ply 								; advance the free ram pointer
.1656	68		pla				pla
.1657	20 be 1b	jsr $1bbe			jsr 	AdvanceFreeMem
.165a	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/encode/encode.src

.165d					EncodeProgram:
.165d	48		pha				pha 								; save registers.
.165e	da		phx				phx
.165f	5a		phy				phy
.1660	84 09		sty $09				sty 	srcPtr+1					; save source pointer.
.1662	85 08		sta $08				sta		srcPtr
.1664	20 89 18	jsr $1889			jsr 	EncodeTrimTrailingSpaces 	; remove trailing spaces.
.1667	a9 03		lda #$03			lda 	#3 							; reset the encode Buffer
.1669	8d 10 09	sta $0910			sta 	encodeBuffer 				; this is also the write ptr/offset
.166c	9c 11 09	stz $0911			stz 	encodeBuffer+1 				; the line number
.166f	9c 12 09	stz $0912			stz 	encodeBuffer+2 				; which is initially zero.
.1672	b2 08		lda ($08)			lda 	(srcPtr) 					; check if first character is digit
.1674	20 34 18	jsr $1834			jsr 	CheckIsDigit
.1677	90 09		bcc $1682			bcc 	_EPNoLineNumber 			; if so there is a line number
.1679	20 56 18	jsr $1856			jsr 	EncodeGetConstant 			; extract that constant from the source
.167c	8d 11 09	sta $0911			sta 	encodeBuffer+1 				; that is the line number
.167f	8c 12 09	sty $0912			sty 	encodeBuffer+2
.1682					_EPNoLineNumber:
.1682					EncodeLoop:
.1682	20 7b 18	jsr $187b			jsr 	EncSkipSpaces 				; skip over spaces
.1685	b2 08		lda ($08)			lda 	(srcPtr) 					; reached end ?
.1687	d0 0b		bne $1694			bne 	_EPNotEnd
.1689					_EPEndEncode:
.1689	a9 a9		lda #$a9			lda 	#NextLine & $FF 			; compile $$nextline to mark eol
.168b	a0 1f		ldy #$1f			ldy 	#NextLine >> 8
.168d	20 0c 18	jsr $180c			jsr 	EncodeWriteWord
.1690	7a		ply				ply									; restore and exit.
.1691	fa		plx				plx
.1692	68		pla				pla
.1693	60		rts				rts
.1694					_EPNotEnd:
.1694	b2 08		lda ($08)			lda 	(srcPtr)
.1696	c9 22		cmp #$22			cmp 	#'"'						; is it a quoted string or comment ?
.1698	f0 04		beq $169e			beq 	_EPIsComStr
.169a	c9 27		cmp #$27			cmp 	#"'"
.169c	d0 05		bne $16a3			bne 	_EPNotComStr
.169e					_EPIsComStr:
.169e	20 63 17	jsr $1763			jsr 	EncodeCommentString
.16a1	80 df		bra $1682			bra 	EncodeLoop
.16a3					_EPNotComStr:
.16a3	38		sec				sec
.16a4	20 68 18	jsr $1868			jsr 	EncSetBit7Word
.16a7	20 a2 18	jsr $18a2			jsr 	EncodeSearchDictionary		; look it up
.16aa	90 44		bcc $16f0			bcc 	_EPNotInDictionary
.16ac	85 10		sta $10				sta 	temp1 						; save dictionary record address
.16ae	84 11		sty $11				sty 	temp1+1
.16b0	a0 01		ldy #$01			ldy 	#1
.16b2	b1 10		lda ($10),y			lda 	(temp1),y 					; check if has an encode bit
.16b4	29 20		and #$20			and 	#$20
.16b6	d0 12		bne $16ca			bne 	_EPEncodeRoutine 			; if so, do special routine.
.16b8	a0 02		ldy #$02			ldy 	#2 							; write out the routine address
.16ba	b1 10		lda ($10),y			lda 	(temp1),y
.16bc	20 16 18	jsr $1816			jsr 	EncodeWriteByte
.16bf	c8		iny				iny
.16c0	b1 10		lda ($10),y			lda 	(temp1),y
.16c2	20 16 18	jsr $1816			jsr 	EncodeWriteByte
.16c5	20 40 18	jsr $1840			jsr 	EncodeMoveNextWord 			; advance to the next and loop
.16c8	80 b8		bra $1682			bra 	EncodeLoop
.16ca					_EPEncodeRoutine:
.16ca	a0 01		ldy #$01			ldy 	#1							; get type bit
.16cc	b1 10		lda ($10),y			lda 	(temp1),y
.16ce	a0 04		ldy #$04			ldy 	#4							; encoder here if no decoder
.16d0	29 10		and #$10			and 	#$10 						; but decoder comes first
.16d2	f0 02		beq $16d6			beq 	_EPENoDecoder
.16d4	c8		iny				iny 								; so if it exists, adjust for it.
.16d5	c8		iny				iny
.16d6					_EPENoDecoder:
.16d6	b1 10		lda ($10),y			lda 	(temp1),y 					; copy exec addr to temp2
.16d8	85 12		sta $12				sta 	temp2
.16da	c8		iny				iny
.16db	b1 10		lda ($10),y			lda 	(temp1),y
.16dd	85 13		sta $13				sta 	temp2+1
.16df	48		pha				pha 								; call routine preserving state
.16e0	da		phx				phx
.16e1	5a		phy				phy
.16e2	20 ed 16	jsr $16ed			jsr 	_EPECallTemp2
.16e5	7a		ply				ply
.16e6	fa		plx				plx
.16e7	68		pla				pla
.16e8	20 40 18	jsr $1840			jsr 	EncodeMoveNextWord 			; advance to the next and loop
.16eb	80 95		bra $1682			bra 	EncodeLoop
.16ed					_EPECallTemp2:
.16ed	6c 12 00	jmp ($0012)			jmp 	(temp2)
.16f0					_EPNotInDictionary:
.16f0	20 be 17	jsr $17be			jsr 	EncodeSearchUserDefined 	; are there any user defined routines
.16f3	90 19		bcc $170e			bcc 	_EPNotDefined
.16f5	48		pha				pha
.16f6	a9 3e		lda #$3e			lda	 	#CallHandler & $FF 			; write code call handler
.16f8	20 16 18	jsr $1816			jsr 	EncodeWriteByte
.16fb	a9 1a		lda #$1a			lda	 	#CallHandler >> 8
.16fd	20 16 18	jsr $1816			jsr 	EncodeWriteByte
.1700	68		pla				pla 								; write line number
.1701	20 16 18	jsr $1816			jsr 	EncodeWriteByte
.1704	98		tya				tya
.1705	20 16 18	jsr $1816			jsr 	EncodeWriteByte
.1708	20 40 18	jsr $1840			jsr 	EncodeMoveNextWord 			; advance to the next and loop
.170b	4c 82 16	jmp $1682			jmp 	EncodeLoop
.170e					_EPNotDefined:
.170e	b2 08		lda ($08)			lda 	(srcPtr) 					; first character
.1710	c9 3c		cmp #$3c			cmp 	#"<"						; is it <line> which is call syntax
.1712	f0 29		beq $173d			beq 	_EPCallDirect
.1714	c9 21		cmp #$21			cmp 	#"!"						; check for variable operators
.1716	f0 42		beq $175a			beq 	_EPVariable
.1718	c9 40		cmp #$40			cmp 	#"@"
.171a	f0 3e		beq $175a			beq 	_EPVariable
.171c	c9 26		cmp #$26			cmp 	#"&"
.171e	f0 3a		beq $175a			beq 	_EPVariable
.1720	a9 a9		lda #$a9			lda 	#Literal2Byte & $FF 		; write out 2 byte literal
.1722	a0 10		ldy #$10			ldy 	#Literal2Byte >> 8
.1724	20 0c 18	jsr $180c			jsr 	EncodeWriteWord
.1727					_EPOutputConstant:
.1727	20 56 18	jsr $1856			jsr 	EncodeGetConstant 			; extract that constant from the source
.172a	90 06		bcc $1732			bcc 	_EPFail 					; if can't find one, that's us done.
.172c	20 0c 18	jsr $180c			jsr 	EncodeWriteWord 			; write out the encoded value.
.172f	4c 82 16	jmp $1682			jmp 	EncodeLoop 					; and go round again.
.1732					_EPFail:
.1732	20 43 10	jsr $1043			jsr 	ErrorHandler
>1735	53 59 4e 54 41 58 3f 00				.text 	"SYNTAX?",0
.173d					_EPCallDirect:
.173d	a9 3e		lda #$3e			lda	 	#CallHandler & $FF 			; write code call handler
.173f	a0 1a		ldy #$1a			ldy	 	#CallHandler >> 8
.1741	20 0c 18	jsr $180c			jsr 	EncodeWriteWord
.1744	a9 01		lda #$01			lda 	#1
.1746	20 4c 18	jsr $184c			jsr 	EncodeAddSrcPtr 			; skip over the <
.1749	a0 ff		ldy #$ff			ldy 	#255 						; scan forward for last character.
.174b					_EPToLast:
.174b	c8		iny				iny
.174c	b1 08		lda ($08),y			lda 	(srcPtr),y
.174e	10 fb		bpl $174b			bpl	 	_EPToLast
.1750	c9 be		cmp #$be			cmp 	#">"+$80 					; must be >
.1752	d0 de		bne $1732			bne 	_EPFail
.1754	a9 20		lda #$20			lda 	#" " 						; strip back to a number, erases last char
.1756	91 08		sta ($08),y			sta 	(srcPtr),y
.1758	80 cd		bra $1727			bra 	_EPOutputConstant 			; borrow the number routines extract/compile constant
.175a					_EPVariable:
.175a	20 f6 18	jsr $18f6			jsr 	EncodeVariableReference
.175d	20 40 18	jsr $1840			jsr 	EncodeMoveNextWord 			; advance to the next and loop
.1760	4c 82 16	jmp $1682			jmp 	EncodeLoop

;******  Return to file: kernel.asm


;******  Processing file: words/encode/comstr.src

.1763					EncodeCommentString:
.1763	b2 08		lda ($08)			lda 	(srcPtr) 					; get first character
.1765	64 10		stz $10				stz 	temp1 						; other terminator = EOL
.1767	aa		tax				tax 								; save in X
.1768	a9 c0		lda #$c0			lda 	#(SkipComment & $FF)		; get the routine to use
.176a	a0 1f		ldy #$1f			ldy 	#(SkipComment >> 8)
.176c	e0 27		cpx #$27			cpx 	#"'"
.176e	f0 06		beq $1776			beq 	_ECSGotCmd
.1770	86 10		stx $10				stx		temp1 						; other terminator = "
.1772	a9 d1		lda #$d1			lda 	#(LiteralString & $FF)
.1774	a0 10		ldy #$10			ldy 	#(LiteralString >> 8)
.1776					_ECSGotCmd:
.1776	20 0c 18	jsr $180c			jsr 	EncodeWriteWord 			; write word out.
.1779	a9 01		lda #$01			lda 	#1 							; skip over ' or "
.177b	20 4c 18	jsr $184c			jsr 	EncodeAddSrcPtr
.177e	e0 27		cpx #$27			cpx 	#"'"						; if ' then skip spaces
.1780	d0 03		bne $1785			bne 	_ECNoSkipSpaces
.1782	20 7b 18	jsr $187b			jsr 	EncSkipSpaces
.1785					_ECNoSkipSpaces:
.1785	ae 10 09	ldx $0910			ldx 	encodeBuffer 				; keep offset to buffer in X.
.1788	a9 01		lda #$01			lda 	#1
.178a	20 16 18	jsr $1816			jsr 	EncodeWriteByte 			; write total length, so far 1.
.178d	a0 00		ldy #$00			ldy 	#0 							; for reading the actual text
.178f					_ECSCopyText:
.178f	b1 08		lda ($08),y			lda 	(srcPtr),y 					; get next
.1791	f0 18		beq $17ab			beq 	_ECSEndOfLine 				; end of line ?
.1793	c5 10		cmp $10				cmp 	temp1						; is it the other terminator
.1795	f0 09		beq $17a0			beq 	_ECSEndOfString 			; if so must be closing quote.
.1797	20 16 18	jsr $1816			jsr 	EncodeWriteByte 			; write the byte out
.179a	fe 10 09	inc $0910,x			inc 	encodeBuffer,x				; increase length
.179d	c8		iny				iny 								; next character
.179e	80 ef		bra $178f			bra 	_ECSCopyText
.17a0					_ECSEndOfString:
.17a0	c8		iny				iny 								; skip closing quote.
.17a1	a9 00		lda #$00			lda 	#0 							; write out ASCIIZ
.17a3	20 16 18	jsr $1816			jsr 	EncodeWriteByte
.17a6	fe 10 09	inc $0910,x			inc 	encodeBuffer,x 				; fix the length up.
.17a9	80 0e		bra $17b9			bra 	_ECSComplete 				; and just patching up srcPtr to do.
.17ab					_ECSEndOfLine:
.17ab	a5 10		lda $10				lda 	temp1 						; missing closing quote
.17ad	f0 0a		beq $17b9			beq 	_ECSComplete 				; if we were doing a string.
.17af	20 43 10	jsr $1043			jsr 	ErrorHandler
>17b2	51 55 4f 54 45 3f 00				.text 	"QUOTE?",0
.17b9					_ECSComplete:
.17b9	98		tya				tya									; skip over.
.17ba	20 4c 18	jsr $184c			jsr 	EncodeAddSrcPtr
.17bd	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/encode/encdef.src

.17be					EncodeSearchUserDefined:
.17be	38		sec				sec 								; temp1 = srcPtr-6 because the
.17bf	a5 08		lda $08				lda 	srcPtr				 		; name is 6 in (offset line# $$call len)
.17c1	e9 06		sbc #$06			sbc		#6
.17c3	85 10		sta $10				sta 	temp1
.17c5	a5 09		lda $09				lda 	srcPtr+1
.17c7	e9 00		sbc #$00			sbc 	#0
.17c9	85 11		sta $11				sta 	temp1+1
.17cb	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.17cd	85 12		sta $12				sta 	0+(temp2)
.17cf	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.17d1	85 13		sta $13				sta 	1+(temp2)
.17d3					_ESULoop:
.17d3	b2 12		lda ($12)			lda 	(temp2) 					; reached the end (offset 0)
.17d5	f0 33		beq $180a			beq 	_ESUFail
.17d7	a0 03		ldy #$03			ldy 	#3 							; check it is $$define
.17d9	b1 12		lda ($12),y			lda 	(temp2),y
.17db	c9 e5		cmp #$e5			cmp 	#DefineCode & $FF
.17dd	d0 1e		bne $17fd			bne 	_ESUNext
.17df	c8		iny				iny
.17e0	b1 12		lda ($12),y			lda 	(temp2),y
.17e2	c9 1f		cmp #$1f			cmp 	#DefineCode >> 8
.17e4	d0 17		bne $17fd			bne 	_ESUNext
.17e6	c8		iny				iny 								; skip length byte.
.17e7					_ESUCompare:
.17e7	c8		iny				iny
.17e8	b1 12		lda ($12),y			lda 	(temp2),y
.17ea	d1 10		cmp ($10),y			cmp 	(temp1),y
.17ec	d0 0f		bne $17fd			bne 	_ESUNext
.17ee	0a		asl a				asl 	a 							; bit 7 set => found it.
.17ef	90 f6		bcc $17e7			bcc 	_ESUCompare
.17f1	a0 01		ldy #$01			ldy 	#1
.17f3	b1 12		lda ($12),y			lda 	(temp2),y 					; read in the line number to YA
.17f5	aa		tax				tax
.17f6	c8		iny				iny
.17f7	b1 12		lda ($12),y			lda 	(temp2),y
.17f9	a8		tay				tay
.17fa	8a		txa				txa
.17fb	38		sec				sec 								; return with carry set as found
.17fc	60		rts				rts
.17fd					_ESUNext:
.17fd	18		clc				clc
.17fe	a5 12		lda $12				lda 	temp2
.1800	72 12		adc ($12)			adc 	(temp2)
.1802	85 12		sta $12				sta 	temp2
.1804	90 02		bcc $1808			bcc 	_NoCarryAdv
.1806	e6 13		inc $13				inc 	temp2+1
.1808					_NoCarryAdv:
.1808	80 c9		bra $17d3			bra 	_ESULoop 					; and loop round
.180a					_ESUFail:
.180a	18		clc				clc
.180b	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/encode/encutils.src

.180c					EncodeWriteWord:
.180c	48		pha				pha
.180d	20 16 18	jsr $1816			jsr 	EncodeWriteByte
.1810	98		tya				tya
.1811	20 16 18	jsr $1816			jsr 	EncodeWriteByte
.1814	68		pla				pla
.1815	60		rts				rts
.1816					EncodeWriteByte:
.1816	da		phx				phx
.1817	ae 10 09	ldx $0910			ldx 	encodeBuffer
.181a	9d 10 09	sta $0910,x			sta 	encodeBuffer,x
.181d	9e 11 09	stz $0911,x			stz 	encodeBuffer+1,x
.1820	9e 12 09	stz $0912,x			stz 	encodeBuffer+2,x
.1823	ee 10 09	inc $0910			inc 	encodeBuffer
.1826	fa		plx				plx
.1827	60		rts				rts
.1828					CheckIsLetter:
.1828	c9 41		cmp #$41			cmp 	#"A"						; return CS if A..Z
.182a	90 06		bcc $1832			bcc 	_CILFail
.182c	c9 5b		cmp #$5b			cmp 	#"Z"+1
.182e	b0 02		bcs $1832			bcs 	_CILFail
.1830	38		sec				sec
.1831	60		rts				rts
.1832					_CILFail:
.1832	18		clc				clc
.1833	60		rts				rts
.1834					CheckIsDigit:
.1834	c9 30		cmp #$30			cmp 	#"0"						; return CS if 0..9
.1836	90 06		bcc $183e			bcc 	_CIDFail
.1838	c9 3a		cmp #$3a			cmp 	#"9"+1
.183a	b0 02		bcs $183e			bcs 	_CIDFail
.183c	38		sec				sec
.183d	60		rts				rts
.183e					_CIDFail:
.183e	18		clc				clc
.183f	60		rts				rts
.1840					EncodeMoveNextWord:
.1840	a0 ff		ldy #$ff			ldy 	#255 						; search forward
.1842					_EPNWLoop:
.1842	c8		iny				iny
.1843	b1 08		lda ($08),y			lda 	(srcPtr),y
.1845	c9 21		cmp #$21			cmp 	#" "+1						; looking for <= space
.1847	b0 f9		bcs $1842			bcs 	_EPNWLoop
.1849	98		tya				tya
.184a	80 00		bra $184c			bra 	EncodeAddSrcPtr
.184c					EncodeAddSrcPtr:
.184c	18		clc				clc 								; add offset
.184d	65 08		adc $08				adc 	srcPtr
.184f	85 08		sta $08				sta 	srcPtr
.1851	90 02		bcc $1855			bcc 	_EASPNoCarry
.1853	e6 09		inc $09				inc 	srcPtr+1					; carry through
.1855					_EASPNoCarry:
.1855	60		rts				rts
.1856					EncodeGetConstant:
.1856	a5 08		lda $08				lda 	srcPtr 						; get source
.1858	a4 09		ldy $09				ldy 	srcPtr+1
.185a	20 1b 1f	jsr $1f1b			jsr 	ConvertToInteger 			; call converter
.185d	90 08		bcc $1867			bcc 	_EGCExit
.185f	20 4c 18	jsr $184c			jsr 	EncodeAddSrcPtr 			; if passed add chars to src ptr
.1862	a5 14		lda $14				lda 	temp3 						; get result into YA
.1864	a4 15		ldy $15				ldy 	temp3+1
.1866	38		sec				sec 								; return CS
.1867					_EGCExit:
.1867	60		rts				rts
.1868					EncSetBit7Word:
.1868	08		php				php 								; save carry
.1869	a0 ff		ldy #$ff			ldy 	#255 						; scan forward for space/NULL
.186b					_ESB7Loop:
.186b	c8		iny				iny
.186c	b1 08		lda ($08),y			lda 	(srcPtr),y
.186e	c9 21		cmp #$21			cmp 	#" "+1 						; while > ' '
.1870	b0 f9		bcs $186b			bcs 	_ESB7Loop
.1872	88		dey				dey									; previous character
.1873	b1 08		lda ($08),y			lda 	(srcPtr),y 					; read it
.1875	0a		asl a				asl 	a 							; shift bit 7 out
.1876	28		plp				plp 								; restore carry
.1877	6a		ror a				ror 	a 							; shift it in
.1878	91 08		sta ($08),y			sta 	(srcPtr),y 					; write back and exit
.187a	60		rts				rts
.187b					EncSkipSpaces:
.187b	b2 08		lda ($08)			lda 	(srcPtr) 					; skip over spaces/ reached end
.187d	c9 20		cmp #$20			cmp 	#32
.187f	d0 07		bne $1888			bne 	_ESNotSpace
.1881	a9 01		lda #$01			lda 	#1
.1883	20 4c 18	jsr $184c			jsr 	EncodeAddSrcPtr
.1886	80 f3		bra $187b			bra	 	EncSkipSpaces
.1888					_ESNotSpace:
.1888	60		rts				rts
.1889					EncodeTrimTrailingSpaces:
.1889	a0 ff		ldy #$ff			ldy 	#255 						; find EOS
.188b					_ETTFindEnd:
.188b	c8		iny				iny
.188c	b1 08		lda ($08),y			lda 	(srcPtr),y
.188e	d0 fb		bne $188b			bne 	_ETTFindEnd
.1890					_ETTRemoveSpace:
.1890	c0 00		cpy #$00			cpy 	#0 							; start of string
.1892	f0 0d		beq $18a1			beq 	_ETTExit
.1894	88		dey				dey 								; previous character 1..32
.1895	b1 08		lda ($08),y			lda 	(srcPtr),y
.1897	c9 21		cmp #$21			cmp 	#32+1
.1899	b0 06		bcs $18a1			bcs 	_ETTExit
.189b	a9 00		lda #$00			lda 	#0 							; erase it and go round again
.189d	91 08		sta ($08),y			sta 	(srcPtr),y
.189f	80 ef		bra $1890			bra 	_ETTRemoveSpace
.18a1					_ETTExit:
.18a1	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/encode/encsearch.src

.18a2					EncodeSearchDictionary:
.18a2	a9 05		lda #$05			lda 	#(Dictionary) & $FF
.18a4	85 10		sta $10				sta 	0+(temp1)
.18a6	a9 22		lda #$22			lda 	#(Dictionary) >> 8
.18a8	85 11		sta $11				sta 	1+(temp1)
.18aa					_ESDLoop:
.18aa	b2 10		lda ($10)			lda 	(temp1) 					; end of dictionary return with CC.
.18ac	18		clc				clc
.18ad	f0 46		beq $18f5			beq 	_ESDExit
.18af	a0 01		ldy #$01			ldy 	#1 							; get control bits, get offset to name.
.18b1	b1 10		lda ($10),y			lda 	(temp1),y
.18b3	4a		lsr a				lsr 	a 							; encode/decode bits move to 0,1
.18b4	4a		lsr a				lsr 	a
.18b5	4a		lsr a				lsr 	a
.18b6	4a		lsr a				lsr 	a
.18b7	c8		iny				iny 								; Y = 2
.18b8	4a		lsr a				lsr 	a
.18b9	90 01		bcc $18bc			bcc 	_ESDNotDec
.18bb	c8		iny				iny
.18bc					_ESDNotDec:
.18bc	4a		lsr a				lsr 	a
.18bd	90 01		bcc $18c0			bcc 	_ESDNotInc
.18bf	c8		iny				iny
.18c0					_ESDNotInc:
.18c0	98		tya				tya
.18c1	0a		asl a				asl 	a 							; A is now 4,6,8 offset to name.
.18c2	a8		tay				tay
.18c3	b1 10		lda ($10),y			lda 	(temp1),y 					; quick check of first character
.18c5	d2 08		cmp ($08)			cmp 	(srcPtr)
.18c7	d0 1f		bne $18e8			bne 	_ESDNext 					; do not match, go to next
.18c9	98		tya				tya 								; make temp2 point to the name in
.18ca	18		clc				clc 								; the dictionary.
.18cb	65 10		adc $10				adc 	temp1
.18cd	85 12		sta $12				sta 	temp2
.18cf	a5 11		lda $11				lda 	temp1+1
.18d1	69 00		adc #$00			adc 	#0
.18d3	85 13		sta $13				sta 	temp2+1
.18d5	a0 ff		ldy #$ff			ldy 	#255 						; now start matching up.
.18d7					_ESDCompare:
.18d7	c8		iny				iny
.18d8	b1 08		lda ($08),y			lda 	(srcPtr),y
.18da	d1 12		cmp ($12),y			cmp 	(temp2),y
.18dc	d0 0a		bne $18e8			bne 	_ESDNext
.18de	0a		asl a				asl 	a
.18df	90 f6		bcc $18d7			bcc 	_ESDCompare
.18e1	a5 10		lda $10				lda 	temp1 						; return address in YA and carry set.
.18e3	a4 11		ldy $11				ldy 	temp1+1
.18e5	38		sec				sec
.18e6	80 0d		bra $18f5			bra 	_ESDExit
.18e8					_ESDNext:
.18e8	18		clc				clc
.18e9	a5 10		lda $10				lda 	temp1
.18eb	72 10		adc ($10)			adc 	(temp1)
.18ed	85 10		sta $10				sta 	temp1
.18ef	90 b9		bcc $18aa			bcc 	_ESDLoop
.18f1	e6 11		inc $11				inc 	temp1+1
.18f3	80 b5		bra $18aa			bra 	_ESDLoop
.18f5					_ESDExit:
.18f5	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/encode/encvar.src

.18f6					EncodeVariableReference:
.18f6	b2 08		lda ($08)			lda 	(srcPtr)					; get the type, use it to identify the routine
.18f8	a2 b2		ldx #$b2			ldx 	#VarAddressHandler & $FF
.18fa	a0 20		ldy #$20			ldy 	#VarAddressHandler >> 8
.18fc	c9 26		cmp #$26			cmp 	#"&"
.18fe	f0 0c		beq $190c			beq 	_EVFHaveAddress
.1900	a2 cc		ldx #$cc			ldx 	#VarReadHandler & $FF
.1902	a0 20		ldy #$20			ldy 	#VarReadHandler >> 8
.1904	c9 40		cmp #$40			cmp 	#"@"
.1906	f0 04		beq $190c			beq 	_EVFHaveAddress
.1908	a2 e8		ldx #$e8			ldx 	#VarWriteHandler & $FF
.190a	a0 20		ldy #$20			ldy 	#VarWriteHandler >> 8
.190c					_EVFHaveAddress:
.190c	8a		txa				txa
.190d	20 0c 18	jsr $180c			jsr 	EncodeWriteWord 			; write it out.
.1910	a0 01		ldy #$01			ldy 	#1 							; get the first charactere
.1912	b1 08		lda ($08),y			lda 	(srcPtr),y
.1914	29 7f		and #$7f			and 	#$7F 						; might be the last.
.1916	20 28 18	jsr $1828			jsr 	CheckIsLetter 				; is it A-Z
.1919	90 1a		bcc $1935			bcc 	EVFFail
.191b	29 1f		and #$1f			and 	#31 						; make 1-26
.191d	85 10		sta $10				sta 	temp1 						; start building the name in temp1
.191f	64 11		stz $11				stz 	temp1+1
.1921	38		sec				sec 								; possible char 2
.1922	20 42 19	jsr $1942			jsr 	EncVarAlNum
.1925	18		clc				clc 								; possible char 3
.1926	20 42 19	jsr $1942			jsr 	EncVarAlNum
.1929	b1 08		lda ($08),y			lda 	(srcPtr),y 					; more text after ?
.192b	10 08		bpl $1935			bpl 	EVFFail
.192d	a5 10		lda $10				lda 	temp1 						; write out variable identifier.
.192f	a4 11		ldy $11				ldy 	temp1+1
.1931	20 0c 18	jsr $180c			jsr 	EncodeWriteWord
.1934	60		rts				rts
.1935					EVFFail:
.1935	20 43 10	jsr $1043			jsr 	ErrorHandler
>1938	56 41 52 49 41 42 4c 45				.text 	"VARIABLE?",0
>1940	3f 00
.1942					EncVarAlNum:
.1942	b1 08		lda ($08),y			lda 	(srcPtr),y 					; points to the  last char processed.
.1944	10 01		bpl $1947			bpl 	_EVAContinue
.1946	60		rts				rts
.1947					_EVAContinue:
.1947	08		php				php 								; CS x 32 ; CC x 32 x 40
.1948	c8		iny				iny 								; get the next character, strip bit 7
.1949	b1 08		lda ($08),y			lda 	(srcPtr),y
.194b	29 7f		and #$7f			and 	#$7F
.194d	20 28 18	jsr $1828			jsr 	CheckIsLetter 				; letter ?
.1950	b0 08		bcs $195a			bcs 	_EVACharOkay
.1952	20 34 18	jsr $1834			jsr 	CheckIsDigit				; fail if not digit.
.1955	90 de		bcc $1935			bcc 	EVFFail
.1957	18		clc				clc
.1958	69 2b		adc #$2b			adc 	#"Z"+1-"0"					; shift 0 so after Z
.195a					_EVACharOkay:
.195a	38		sec				sec 								; range 1-36
.195b	e9 40		sbc #$40			sbc 	#64
.195d	28		plp				plp 								; which multiplier ?
.195e	90 0f		bcc $196f			bcc 	_EVATimes32x40
.1960	85 12		sta $12				sta 	temp2 						; save in temp2 - A x 32
.1962	64 13		stz $13				stz 	temp2+1
.1964	a2 05		ldx #$05			ldx 	#5
.1966	06 12		asl $12		_EVA32:	asl 	temp2
.1968	26 13		rol $13				rol 	temp2+1
.196a	ca		dex				dex
.196b	d0 f9		bne $1966			bne 	_EVA32
.196d	80 0b		bra $197a			bra 	_EVAAddVar
.196f					_EVATimes32x40:
.196f	85 13		sta $13				sta 	temp2+1						; 32 x 40 = 1280 or $500, so temp2 = A x 256 x 5
.1971	64 12		stz $12				stz 	temp2
.1973	0a		asl a				asl 	a
.1974	0a		asl a				asl 	a
.1975	18		clc				clc
.1976	65 13		adc $13				adc 	temp2+1
.1978	85 13		sta $13				sta 	temp2+1
.197a					_EVAAddVar:
.197a	18		clc				clc
.197b	a5 10		lda $10				lda 	temp1
.197d	65 12		adc $12				adc 	temp2
.197f	85 10		sta $10				sta 	temp1
.1981	a5 11		lda $11				lda 	temp1+1
.1983	65 13		adc $13				adc 	temp2+1
.1985	85 11		sta $11				sta 	temp1+1
.1987	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/structures/fornext.src

.1988					ForHandler:
.1988	e6 05		inc $05				inc 	rsp 						; bump the RSP
.198a	a4 05		ldy $05				ldy 	rsp 						; get return stack and push TOS/$FF on it.
.198c	c0 40		cpy #$40			cpy 	#$40 						; overflow
.198e	f0 18		beq $19a8			beq 	_FHOverflow
.1990	a5 07		lda $07				lda 	TOS+1
.1992	99 40 07	sta $0740,y			sta 	returnStackHigh,y
.1995	a5 06		lda $06				lda 	TOS
.1997	99 00 07	sta $0700,y			sta 	returnStackLow,y
.199a	a9 ff		lda #$ff			lda 	#$FF
.199c	99 80 07	sta $0780,y			sta 	returnStackX,y
.199f	68		pla				pla
.19a0	85 07		sta $07				sta 	TOS+1
.19a2	68		pla				pla
.19a3	85 06		sta $06				sta 	TOS
.19a5	4c 00 00	jmp $0000			jmp 	NextCode
.19a8					_FHOverflow:
.19a8	20 43 10	jsr $1043			jsr 	ErrorHandler
>19ab	46 4f 52 20 53 54 41 43				.text 	"FOR STACK?",0
>19b3	4b 3f 00
.19b6					NextHandler:
.19b6	da		phx				phx
.19b7	a6 05		ldx $05				ldx 	rsp 						; get current stack ptr
.19b9	bd 80 07	lda $0780,x			lda 	returnStackX,x 				; check it's a FOR Loop
.19bc	c9 ff		cmp #$ff			cmp 	#$FF
.19be	d0 21		bne $19e1			bne 	NHNoFor
.19c0	bd 00 07	lda $0700,x			lda 	returnStackLow,x 			; decrement the count
.19c3	d0 03		bne $19c8			bne 	_NHNoBorrow
.19c5	de 40 07	dec $0740,x			dec 	returnStackHigh,x
.19c8					_NHNoBorrow:
.19c8	de 00 07	dec $0700,x			dec 	returnStackLow,x
.19cb	bd 00 07	lda $0700,x			lda 	returnStackLow,x 			; have we reached the end ?
.19ce	1d 40 07	ora $0740,x			ora 	returnStackHigh,x
.19d1	fa		plx				plx 								; restore X and re-test
.19d2	09 00		ora #$00			ora 	#0
.19d4	f0 05		beq $19db			beq 	_NHComplete 				; if so then complete, else loop.
.19d6	e8		inx				inx 								; advance to branch
.19d7	e8		inx				inx
.19d8	4c 34 1a	jmp $1a34			jmp 	BranchAlways
.19db					_NHComplete:
.19db	e8		inx				inx 								; skip over the branch quantity
.19dc	c6 05		dec $05				dec 	rsp 						; drop the indx
.19de	4c 00 00	jmp $0000			jmp 	NextCode
.19e1					NHNoFor:
.19e1	20 43 10	jsr $1043			jsr 	ErrorHandler
>19e4	4e 4f 20 46 4f 52 3f 00				.text 	"NO FOR?",0
.19ec					GetIndex:
.19ec	a4 05		ldy $05				ldy 	rsp 						; get current stack ptr
.19ee	b9 80 07	lda $0780,y			lda 	returnStackX,y 				; check it's a FOR Loop
.19f1	c9 ff		cmp #$ff			cmp 	#$FF
.19f3	d0 ec		bne $19e1			bne 	NHNoFor
.19f5	a5 06		lda $06				lda 	TOS
.19f7	48		pha				pha
.19f8	a5 07		lda $07				lda 	TOS+1
.19fa	48		pha				pha
.19fb	b9 00 07	lda $0700,y			lda 	returnStackLow,y 			; put counter-1 out
.19fe	38		sec				sec
.19ff	e9 01		sbc #$01			sbc 	#1
.1a01	85 06		sta $06				sta 	TOS
.1a03	b9 40 07	lda $0740,y			lda 	returnStackHigh,y
.1a06	e9 00		sbc #$00			sbc 	#0
.1a08	85 07		sta $07				sta 	TOS+1
.1a0a	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/structures/ifelseendif.src

.1a0d					IfHandler:
.1a0d	4c 1c 1a	jmp $1a1c			jmp 	BranchIfZero
.1a10					ElseHandler:
.1a10	4c 32 1a	jmp $1a32			jmp 	BranchTestSucceedsNoPop
.1a13					EndIfHandler:
.1a13	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/structures/repeatuntil.src

.1a16					RepeatHandler:
.1a16	4c 00 00	jmp $0000			jmp 	NextCode
.1a19					UntilHandler:
.1a19	4c 1c 1a	jmp $1a1c			jmp 	BranchIfZero

;******  Return to file: kernel.asm


;******  Processing file: words/system/branch.src

.1a1c					BranchIfZero:
.1a1c	a5 06		lda $06				lda 	TOS 						; check TOS = 0
.1a1e	05 07		ora $07				ora 	TOS+1
.1a20	f0 0a		beq $1a2c			beq 	BranchTestSucceeds
.1a22					BranchTestFails:
.1a22	68		pla				pla
.1a23	85 07		sta $07				sta 	TOS+1
.1a25	68		pla				pla
.1a26	85 06		sta $06				sta 	TOS
.1a28	e8		inx				inx 								; skip over the relative branch.
.1a29	4c 00 00	jmp $0000			jmp 	NextCode
.1a2c					BranchTestSucceeds:
.1a2c	68		pla				pla
.1a2d	85 07		sta $07				sta 	TOS+1
.1a2f	68		pla				pla
.1a30	85 06		sta $06				sta 	TOS
.1a32					BranchTestSucceedsNoPop:
.1a32	e8		inx				inx 								; advance by two, to the offset
.1a33	e8		inx				inx
.1a34					BranchAlways:
.1a34	8a		txa				txa 								; A = Y = position
.1a35	a8		tay				tay 								; (IP),Y now points to the branch target
.1a36	b1 03		lda ($03),y			lda 	(IP),y 						; adjust the position
.1a38	aa		tax				tax 								; position back in this line.
.1a39	ca		dex				dex
.1a3a	ca		dex				dex
.1a3b	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/system/callhandler.src

.1a3e					CallHandler:
.1a3e	e8		inx				inx									; bump X to the call address.
.1a3f	e8		inx				inx
.1a40	e6 05		inc $05				inc 	rsp 						; bump the RSP (first time to zero)
.1a42	a4 05		ldy $05				ldy 	rsp 						; get return stack and push IP/X on it.
.1a44	c0 40		cpy #$40			cpy 	#$40 						; overflow
.1a46	f0 4b		beq $1a93			beq 	_CHOverflow
.1a48	a5 04		lda $04				lda 	IP+1
.1a4a	99 40 07	sta $0740,y			sta 	returnStackHigh,y
.1a4d	a5 03		lda $03				lda 	IP
.1a4f	99 00 07	sta $0700,y			sta 	returnStackLow,y
.1a52	8a		txa				txa
.1a53	99 80 07	sta $0780,y			sta 	returnStackX,y
.1a56	8a		txa				txa 								; get the line number into temp1.
.1a57	a8		tay				tay
.1a58	b1 03		lda ($03),y			lda 	(IP),y
.1a5a	85 10		sta $10				sta 	temp1
.1a5c	c8		iny				iny
.1a5d	b1 03		lda ($03),y			lda 	(IP),y
.1a5f	85 11		sta $11				sta 	temp1+1
.1a61	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.1a63	85 03		sta $03				sta 	0+(IP)
.1a65	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.1a67	85 04		sta $04				sta 	1+(IP)
.1a69	b2 03		lda ($03)			lda 	(IP)						; no program code ?
.1a6b	f0 17		beq $1a84			beq 	_CHFail
.1a6d	a0 01		ldy #$01			ldy 	#1 							; Y = 1 throughout.
.1a6f					_CHSearch:
.1a6f	b1 03		lda ($03),y			lda 	(IP),y 						; check LSB of line number
.1a71	c5 10		cmp $10				cmp 	temp1
.1a73	f0 2d		beq $1aa2			beq 	_CHFoundLSB
.1a75					_CHSearchNext:
.1a75	18		clc				clc
.1a76	a5 03		lda $03				lda 	IP
.1a78	72 03		adc ($03)			adc 	(IP)
.1a7a	85 03		sta $03				sta 	IP
.1a7c	90 02		bcc $1a80			bcc 	_NoCarryAdv
.1a7e	e6 04		inc $04				inc 	IP+1
.1a80					_NoCarryAdv:
.1a80	b2 03		lda ($03)			lda 	(IP)						; check reached the end.
.1a82	d0 eb		bne $1a6f			bne 	_CHSearch
.1a84					_CHFail:
.1a84	20 43 10	jsr $1043			jsr 	ErrorHandler
>1a87	44 45 46 49 4e 49 54 49				.text 	"DEFINITION?",0
>1a8f	4f 4e 3f 00
.1a93					_CHOverflow:
.1a93	20 43 10	jsr $1043			jsr 	ErrorHandler
>1a96	53 54 41 43 4b 44 45 50				.text 	"STACKDEPTH?",0
>1a9e	54 48 3f 00
.1aa2					_CHFoundLSB:
.1aa2	c8		iny				iny 								; get MSB
.1aa3	b1 03		lda ($03),y			lda 	(IP),y
.1aa5	88		dey				dey
.1aa6	c5 11		cmp $11				cmp 	temp1+1 					; matches, if not contineu
.1aa8	d0 cb		bne $1a75			bne 	_CHSearchNext
.1aaa	a0 03		ldy #$03			ldy 	#3	 						; check it begins with $$define
.1aac	b1 03		lda ($03),y			lda 	(IP),y
.1aae	c9 e5		cmp #$e5			cmp 	#DefineCode & $FF
.1ab0	d0 d2		bne $1a84			bne 	_CHFail
.1ab2	c8		iny				iny
.1ab3	b1 03		lda ($03),y			lda 	(IP),y
.1ab5	c9 1f		cmp #$1f			cmp 	#DefineCode >> 8
.1ab7	d0 cb		bne $1a84			bne 	_CHFail
.1ab9	c8		iny				iny
.1aba	b1 03		lda ($03),y			lda 	(IP),y 						; this is the length of the define name
.1abc	18		clc				clc
.1abd	69 03		adc #$03			adc 	#5-2 						; $$define token, line number, offset - 2 for Next
.1abf	aa		tax				tax
.1ac0	4c 00 00	jmp $0000			jmp 	NextCode
.1ac3					ReturnHandler:
.1ac3	a4 05		ldy $05				ldy 	rsp 						; get rsp
.1ac5	30 15		bmi $1adc			bmi 	_RHUnderflow 				; if -ve underflowed
.1ac7	c6 05		dec $05				dec 	rsp 						; decrement rsp
.1ac9	b9 40 07	lda $0740,y			lda 	returnStackHigh,y 			; restore IP/X
.1acc	85 04		sta $04				sta 	IP+1
.1ace	b9 00 07	lda $0700,y			lda 	returnStackLow,y
.1ad1	85 03		sta $03				sta 	IP
.1ad3	b9 80 07	lda $0780,y			lda 	returnStackX,y
.1ad6	aa		tax				tax
.1ad7	f0 0e		beq $1ae7			beq 	_RHInLoop 					; this means you have done :something for ; next
.1ad9	4c 00 00	jmp $0000			jmp 	NextCode
.1adc					_RHUnderflow:
.1adc	20 43 10	jsr $1043			jsr 	ErrorHandler
>1adf	52 45 54 55 52 4e 3f 00				.text 	"RETURN?",0
.1ae7					_RHInLoop:
.1ae7	20 43 10	jsr $1043			jsr 	ErrorHandler
>1aea	52 45 54 55 52 4e 20 49				.text 	"RETURN IN LOOP?",0
>1af2	4e 20 4c 4f 4f 50 3f 00
.1afa					CallHandlerDecode:
.1afa	a9 03		lda #$03			lda 	#CTH_Call					; space
.1afc	20 c1 1c	jsr $1cc1			jsr 	DecodeWriteBuffer
.1aff	b1 08		lda ($08),y			lda 	(srcPtr),y 					; get line number into YA
.1b01	aa		tax				tax
.1b02	c8		iny				iny
.1b03	b1 08		lda ($08),y			lda 	(srcPtr),y
.1b05	a8		tay				tay
.1b06	8a		txa				txa
.1b07	20 44 1b	jsr $1b44			jsr 	FindLine 					; try to locate that line.
.1b0a	b0 11		bcs $1b1d			bcs 	_CHDFound 					; if found .....
.1b0c					_CHDLineOnly:
.1b0c	48		pha				pha
.1b0d	a9 3c		lda #$3c			lda 	#"<"
.1b0f	20 c1 1c	jsr $1cc1			jsr 	DecodeWriteBuffer
.1b12	68		pla				pla
.1b13	18		clc				clc 								; output unsigned
.1b14	20 e3 1c	jsr $1ce3			jsr 	DecodeYAToBuffer
.1b17	a9 3e		lda #$3e			lda 	#">"
.1b19	20 c1 1c	jsr $1cc1			jsr 	DecodeWriteBuffer
.1b1c	60		rts				rts
.1b1d					_CHDFound:
.1b1d	48		pha				pha 								; save YA
.1b1e	5a		phy				phy
.1b1f	a0 03		ldy #$03			ldy 	#3 							; check first is $$define
.1b21	b1 10		lda ($10),y			lda 	(temp1),y
.1b23	c9 e5		cmp #$e5			cmp 	#DefineCode & 255
.1b25	d0 07		bne $1b2e			bne 	_CHDNoDefine
.1b27	c8		iny				iny
.1b28	b1 10		lda ($10),y			lda 	(temp1),y
.1b2a	c9 1f		cmp #$1f			cmp 	#DefineCode >> 8
.1b2c	f0 04		beq $1b32			beq 	_CHDFoundDefine
.1b2e					_CHDNoDefine:
.1b2e	7a		ply				ply									; restore the line number and print it in <>
.1b2f	68		pla				pla
.1b30	80 da		bra $1b0c			bra 	_CHDLineOnly
.1b32					_CHDFoundDefine:
.1b32	68		pla				pla 								; throw saved line number.
.1b33	68		pla				pla
.1b34	a0 05		ldy #$05			ldy 	#5 							; 3,4 $$define 5 length, name has bit 7 set at end
.1b36					_CHDOutName:
.1b36	c8		iny				iny 								; next
.1b37	b1 10		lda ($10),y			lda 	(temp1),y 					; print char no bit 7
.1b39	48		pha				pha
.1b3a	29 7f		and #$7f			and 	#$7F
.1b3c	20 c1 1c	jsr $1cc1			jsr 	DecodeWriteBuffer
.1b3f	68		pla				pla
.1b40	0a		asl a				asl 	a 							; bit 7 to carry
.1b41	90 f3		bcc $1b36			bcc 	_CHDOutName
.1b43	60		rts				rts
.1b44					FindLine:
.1b44	48		pha				pha 								; save registers
.1b45	da		phx				phx
.1b46	5a		phy				phy
.1b47	85 12		sta $12				sta 	temp2 						; temp2 = target line#
.1b49	84 13		sty $13				sty 	temp2+1
.1b4b	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.1b4d	85 10		sta $10				sta 	0+(temp1)
.1b4f	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.1b51	85 11		sta $11				sta 	1+(temp1)
.1b53					_FLLoop:
.1b53	b2 10		lda ($10)			lda 	(temp1) 					; found end ?
.1b55	18		clc				clc									; if so exit with CC.
.1b56	f0 1d		beq $1b75			beq 	_FLExit
.1b58	a0 01		ldy #$01			ldy 	#1 							; check line # match
.1b5a	b1 10		lda ($10),y			lda 	(temp1),y
.1b5c	c5 12		cmp $12				cmp 	temp2
.1b5e	d0 08		bne $1b68			bne 	_FLNext
.1b60	c8		iny				iny
.1b61	b1 10		lda ($10),y			lda 	(temp1),y
.1b63	c5 13		cmp $13				cmp 	temp2+1
.1b65	38		sec				sec 								; if so exit with CS
.1b66	f0 0d		beq $1b75			beq 	_FLExit
.1b68					_FLNext:
.1b68	18		clc				clc
.1b69	a5 10		lda $10				lda 	temp1
.1b6b	72 10		adc ($10)			adc 	(temp1)
.1b6d	85 10		sta $10				sta 	temp1
.1b6f	90 02		bcc $1b73			bcc 	_NoCarryAdv
.1b71	e6 11		inc $11				inc 	temp1+1
.1b73					_NoCarryAdv:
.1b73	80 de		bra $1b53			bra 	_FLLoop 					; keep looking.
.1b75					_FLExit:
.1b75	7a		ply				ply
.1b76	fa		plx				plx
.1b77	68		pla				pla
.1b78	60		rts				rts
.1b79	18		clc				clc
.1b7a	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/clrnew.src

.1b7b					NewHandler:
.1b7b	9c 00 40	stz $4000			stz 	ProgramMemory 				; Make the first offset zero.
.1b7e	20 91 1b	jsr $1b91			jsr 	ClearVariableSpace 			; clear variables, reset pointers
.1b81	4c 00 00	jmp $0000			jmp 	NextCode
.1b84					ClrHandler:
.1b84	86 10		stx $10				stx 	temp1
.1b86	a2 80		ldx #$80			ldx 	#NumberStackBase
.1b88	9a		txs				txs
.1b89	a6 10		ldx $10				ldx 	temp1
.1b8b	20 91 1b	jsr $1b91			jsr 	ClearVariableSpace 			; clear variables, reset pointers
.1b8e	4c 00 00	jmp $0000			jmp 	NextCode
.1b91					ClearVariableSpace:
.1b91	a9 ff		lda #$ff			lda 	#$FF
.1b93	85 05		sta $05				sta 	rsp
.1b95	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.1b97	85 0e		sta $0e				sta 	0+(nextFreeMem)
.1b99	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.1b9b	85 0f		sta $0f				sta 	1+(nextFreeMem)
.1b9d	a0 1f		ldy #$1f			ldy 	#hashTableSize*2-1 			; erase the hash table (used for variables)
.1b9f					_CVSHashClear:
.1b9f	a9 00		lda #$00			lda 	#0 							; all the first record pointers are $00
.1ba1	99 40 06	sta $0640,y			sta 	hashTable,y
.1ba4	88		dey				dey
.1ba5	10 f8		bpl $1b9f			bpl 	_CVSHashClear
.1ba7					_CVSFindEnd:
.1ba7	18		clc				clc
.1ba8	a5 0e		lda $0e				lda 	nextFreeMem
.1baa	72 0e		adc ($0e)			adc 	(nextFreeMem)
.1bac	85 0e		sta $0e				sta 	nextFreeMem
.1bae	90 02		bcc $1bb2			bcc 	_NoCarryAdv
.1bb0	e6 0f		inc $0f				inc 	nextFreeMem+1
.1bb2					_NoCarryAdv:
.1bb2	b2 0e		lda ($0e)			lda 	(nextFreeMem)
.1bb4	d0 f1		bne $1ba7			bne 	_CVSFindEnd
.1bb6	a9 08		lda #$08			lda 	#8 							; this puts a gap in, more for clarity than anything.
.1bb8	a0 00		ldy #$00			ldy 	#0
.1bba	20 be 1b	jsr $1bbe			jsr 	AdvanceFreeMem				; we need +1 because the previous code leaves the
.1bbd	60		rts				rts 								; free mem pointer pointing to the last zero offset
.1bbe					AdvanceFreeMem:
.1bbe	18		clc				clc
.1bbf	65 0e		adc $0e				adc 	nextFreeMem
.1bc1	85 0e		sta $0e				sta 	nextFreeMem
.1bc3	98		tya				tya
.1bc4	65 0f		adc $0f				adc 	nextFreeMem+1
.1bc6	85 0f		sta $0f				sta 	nextFreeMem+1
.1bc8	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/debug.src

.1bc9					ExitDump:
.1bc9	ba		tsx				tsx 								; save Data Stack in temp1
.1bca	86 10		stx $10				stx 	temp1
.1bcc	4c ff ff	jmp $ffff			jmp 	$FFFF 						; makes the X16-Emulator dump-exit.
.1bcf					BreakCmd:
>1bcf	ff						.byte 	$FF
.1bd0	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/system/decode.src

.1bd3					DecodeLineIntoBufPtr:
.1bd3	48		pha				pha
.1bd4	da		phx				phx
.1bd5	5a		phy				phy
.1bd6	85 08		sta $08				sta 	srcPtr 						; save the source line.
.1bd8	84 09		sty $09				sty 	srcPtr+1
.1bda	90 1b		bcc $1bf7			bcc 	_DecodeNoLineNumber
.1bdc	a0 01		ldy #$01			ldy 	#1 							; get line # to YA
.1bde	b1 08		lda ($08),y			lda 	(srcPtr),y
.1be0	aa		tax				tax
.1be1	c8		iny				iny
.1be2	b1 08		lda ($08),y			lda 	(srcPtr),y
.1be4	a8		tay				tay
.1be5	8a		txa				txa
.1be6	18		clc				clc
.1be7	20 e3 1c	jsr $1ce3			jsr 	DecodeYAToBuffer 			; convert to string in buffer
.1bea	aa		tax				tax 								; count in X
.1beb					_DecodeLineSpace:
.1beb	e0 05		cpx #$05			cpx 	#5
.1bed	f0 08		beq $1bf7			beq 	_DecodeNoLineNumber
.1bef	a9 20		lda #$20			lda 	#" " 						; pad to 5 spaces
.1bf1	20 c1 1c	jsr $1cc1			jsr 	DecodeWriteBuffer
.1bf4	e8		inx				inx
.1bf5	80 f4		bra $1beb			bra 	_DecodeLineSpace
.1bf7					_DecodeNoLineNumber:
.1bf7	a0 03		ldy #$03			ldy 	#3 							; initial position.
.1bf9					_DecodeLoop:
.1bf9	b1 08		lda ($08),y			lda 	(srcPtr),y 					; copy the current character to temp1
.1bfb	85 10		sta $10				sta 	temp1 						; must be an execution address.
.1bfd	c8		iny				iny
.1bfe	b1 08		lda ($08),y			lda 	(srcPtr),y
.1c00	85 11		sta $11				sta 	temp1+1
.1c02	c8		iny				iny 								; y points to the byte after it.
.1c03	a5 10		lda $10				lda 	temp1
.1c05	c9 a9		cmp #$a9			cmp 	#NextLine & $FF
.1c07	d0 06		bne $1c0f			bne 	_DecodeNotEOL
.1c09	a5 11		lda $11				lda 	temp1+1
.1c0b	c9 1f		cmp #$1f			cmp 	#NextLine >> 8
.1c0d	f0 0b		beq $1c1a			beq 	_DecodeEOL
.1c0f					_DecodeNotEOL:
.1c0f	20 22 1c	jsr $1c22			jsr 	IdentifyCodeWord
.1c12	20 6c 1c	jsr $1c6c			jsr 	DecodeFoundWord
.1c15	20 56 1c	jsr $1c56			jsr 	AdvanceToNext 				; advance to next entry in the line.
.1c18	80 df		bra $1bf9			bra 	_DecodeLoop 				; and go round again
.1c1a					_DecodeEOL:
.1c1a	a9 00		lda #$00			lda 	#0
.1c1c	92 0a		sta ($0a)			sta 	(bufPtr)
.1c1e	7a		ply				ply 								; restore registers and exit
.1c1f	fa		plx				plx
.1c20	68		pla				pla
.1c21	60		rts				rts
.1c22					IdentifyCodeWord:
.1c22	5a		phy				phy 								; save current position on the stack.
.1c23	a9 05		lda #$05			lda 	#(Dictionary) & $FF
.1c25	85 0c		sta $0c				sta 	0+(matchPtr)
.1c27	a9 22		lda #$22			lda 	#(Dictionary) >> 8
.1c29	85 0d		sta $0d				sta 	1+(matchPtr)
.1c2b					_DecodeIdentify:
.1c2b	a0 02		ldy #$02			ldy 	#2 							; have we found a match ?
.1c2d	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.1c2f	c5 10		cmp $10				cmp 	temp1
.1c31	d0 07		bne $1c3a			bne 	_DecodeIdNext
.1c33	c8		iny				iny
.1c34	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.1c36	c5 11		cmp $11				cmp 	temp1+1
.1c38	f0 1a		beq $1c54			beq 	_DecodeIdFound
.1c3a					_DecodeIdNext:
.1c3a	18		clc				clc
.1c3b	b2 0c		lda ($0c)			lda 	(matchPtr)
.1c3d	f0 0a		beq $1c49			beq 	_DecodeIdIssue
.1c3f	65 0c		adc $0c				adc 	matchPtr
.1c41	85 0c		sta $0c				sta 	matchPtr
.1c43	90 e6		bcc $1c2b			bcc 	_DecodeIdentify
.1c45	e6 0d		inc $0d				inc 	matchPtr+1
.1c47	80 e2		bra $1c2b			bra 	_DecodeIdentify
.1c49					_DecodeIdIssue:
.1c49	20 43 10	jsr $1043			jsr 	ErrorHandler
>1c4c	44 45 43 4f 44 45 3f 00				.text 	"DECODE?",0
.1c54					_DecodeIdFound:
.1c54	7a		ply				ply 								; restore position.
.1c55	60		rts				rts
.1c56					AdvanceToNext:
.1c56	5a		phy				phy 								; get the parameter count from bits 0-1 of the type byte
.1c57	a0 01		ldy #$01			ldy 	#1
.1c59	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.1c5b	29 03		and #$03			and 	#3 							; bits 0-1.
.1c5d	7a		ply				ply
.1c5e	c9 03		cmp #$03			cmp 	#3 							; is it n-bytes e.g. specified by the next byte
.1c60	d0 02		bne $1c64			bne 	_ATN012
.1c62	b1 08		lda ($08),y			lda 	(srcPtr),y 					; if so, use that byte as the overall length.
.1c64					_ATN012:
.1c64	85 12		sta $12				sta 	temp2 						; now add that to Y
.1c66	98		tya				tya
.1c67	18		clc				clc
.1c68	65 12		adc $12				adc 	temp2
.1c6a	a8		tay				tay
.1c6b	60		rts				rts
.1c6c					DecodeFoundWord:
.1c6c	5a		phy				phy 								; save current position
.1c6d	84 12		sty $12				sty		temp2 						; put it in temp2 as well.
.1c6f	a0 01		ldy #$01			ldy 	#1 							; get the type byte
.1c71	b1 0c		lda ($0c),y			lda 	(matchPtr),y 				; is there a special decoder check (bit 4 set) ?
.1c73	29 10		and #$10			and 	#$10
.1c75	d0 0e		bne $1c85			bne 	_DFWSpecialDecoder
.1c77	b1 0c		lda ($0c),y			lda 	(matchPtr),y 				; reget it.
.1c79	30 08		bmi $1c83			bmi 	_DFWExit 					; if hidden word (bit 7 set)
.1c7b	a9 06		lda #$06			lda 	#CTH_Keyword				; output a space to the buffer
.1c7d	20 c1 1c	jsr $1cc1			jsr 	DecodeWriteBuffer
.1c80	20 9e 1c	jsr $1c9e			jsr 	DecodeCurrentWord 			; expand that.
.1c83					_DFWExit:
.1c83	7a		ply				ply 								; restore current position
.1c84	60		rts				rts
.1c85					_DFWSpecialDecoder:
.1c85	a0 04		ldy #$04			ldy 	#4 							; the decode word address is at offset 4,5
.1c87	b1 0c		lda ($0c),y			lda 	(matchPtr),y 				; copy this into temp2
.1c89	85 12		sta $12				sta 	temp2
.1c8b	c8		iny				iny
.1c8c	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.1c8e	85 13		sta $13				sta 	temp2+1
.1c90	7a		ply				ply 	 							; restore current position into Y
.1c91	48		pha				pha 								; save registers
.1c92	da		phx				phx
.1c93	5a		phy				phy
.1c94	20 9b 1c	jsr $1c9b			jsr 	_DFWCallDecoder				; call the decoder routine
.1c97	7a		ply				ply 								; restore registers and exit
.1c98	fa		plx				plx
.1c99	68		pla				pla
.1c9a	60		rts				rts
.1c9b					_DFWCallDecoder:
.1c9b	6c 12 00	jmp ($0012)			jmp 	(temp2)
.1c9e					DecodeCurrentWord:
.1c9e	5a		phy				phy
.1c9f	a0 01		ldy #$01			ldy 	#1 							; read type byte
.1ca1	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.1ca3	a0 04		ldy #$04			ldy 	#4 							; original offset
.1ca5	4a		lsr a				lsr 	a 							; encoder/decoder bits in 0-1
.1ca6	4a		lsr a				lsr 	a 							; add 2 to Y for each encoder/decoder
.1ca7	4a		lsr a				lsr 	a 							; bit set.
.1ca8	4a		lsr a				lsr 	a
.1ca9	4a		lsr a				lsr 	a 							; decoder bit
.1caa	90 02		bcc $1cae			bcc 	_DWBNoDec
.1cac	c8		iny				iny
.1cad	c8		iny				iny
.1cae					_DWBNoDec:
.1cae	4a		lsr a				lsr 	a
.1caf	90 02		bcc $1cb3			bcc 	_DWBNoEnc
.1cb1	c8		iny				iny
.1cb2	c8		iny				iny
.1cb3					_DWBNoEnc:
.1cb3					_DWBWordOut:
.1cb3	b1 0c		lda ($0c),y			lda 	(matchPtr),y 				; output until bit 7 set.
.1cb5	48		pha				pha
.1cb6	29 7f		and #$7f			and 	#$7F
.1cb8	20 c1 1c	jsr $1cc1			jsr		DecodeWriteBuffer
.1cbb	c8		iny				iny
.1cbc	68		pla				pla
.1cbd	10 f4		bpl $1cb3			bpl 	_DWBWordOut
.1cbf	7a		ply				ply 								; restore Y and exit
.1cc0	60		rts				rts
.1cc1					DecodeWriteBuffer:
.1cc1	92 0a		sta ($0a)			sta 	(bufPtr)
.1cc3	e6 0a		inc $0a				inc 	bufPtr
.1cc5	d0 02		bne $1cc9			bne 	_DWBNoCarry
.1cc7	e6 0b		inc $0b				inc 	bufPtr+1
.1cc9					_DWBNoCarry:
.1cc9	60		rts				rts
.1cca					DecodeOutputData:
.1cca	48		pha				pha
.1ccb	da		phx				phx
.1ccc	5a		phy				phy
.1ccd	b1 08		lda ($08),y			lda 	(srcPtr),y 					; length + 1
.1ccf	aa		tax				tax
.1cd0					_DODLoop:
.1cd0	ca		dex				dex 								; done it all ?
.1cd1	f0 0c		beq $1cdf			beq		_DODExit
.1cd3	c8		iny				iny 								; output next character
.1cd4	b1 08		lda ($08),y			lda 	(srcPtr),y
.1cd6	29 7f		and #$7f			and 	#$7F
.1cd8	f0 f6		beq $1cd0			beq 	_DODLoop 					; don't print NULL
.1cda	20 c1 1c	jsr $1cc1			jsr 	DecodeWriteBuffer
.1cdd	80 f1		bra $1cd0			bra 	_DODLoop
.1cdf					_DODExit:
.1cdf	7a		ply				ply
.1ce0	fa		plx				plx
.1ce1	68		pla				pla
.1ce2	60		rts				rts
.1ce3					DecodeYAToBuffer:
.1ce3	da		phx				phx
.1ce4	5a		phy				phy
.1ce5	48		pha				pha
.1ce6	a5 0a		lda $0a				lda 	bufPtr 						; copy bufPtr to temp2
.1ce8	85 12		sta $12				sta 	temp2
.1cea	a5 0b		lda $0b				lda 	bufPtr+1
.1cec	85 13		sta $13				sta 	temp2+1
.1cee	68		pla				pla
.1cef	20 47 20	jsr $2047			jsr 	ConvertToStringMain 		; convert YA to string there
.1cf2	aa		tax				tax 								; chars output to X
.1cf3	18		clc				clc
.1cf4	65 0a		adc $0a				adc 	bufPtr 						; add to buffer pointer
.1cf6	85 0a		sta $0a				sta 	bufPtr
.1cf8	90 02		bcc $1cfc			bcc 	_DYABNoCarry
.1cfa	e6 0b		inc $0b				inc 	bufPtr+1
.1cfc					_DYABNoCarry:
.1cfc	8a		txa				txa 								; count in A
.1cfd	7a		ply				ply									; restore and exit.
.1cfe	fa		plx				plx
.1cff	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/edit.src

.1d00					EditProgram:
.1d00	20 7f 1d	jsr $1d7f			jsr 	EDFindLine					; find line address -> temp1
.1d03	90 0f		bcc $1d14			bcc 	_EPNotFound 				; if missing don't delete it.
.1d05	a5 10		lda $10				lda 	temp1 						; save line address
.1d07	48		pha				pha
.1d08	a5 11		lda $11				lda 	temp1+1
.1d0a	48		pha				pha
.1d0b	20 22 1d	jsr $1d22			jsr 	EDDeleteLine 				; delete the line
.1d0e	68		pla				pla 								; restore line address
.1d0f	85 11		sta $11				sta 	temp1+1
.1d11	68		pla				pla
.1d12	85 10		sta $10				sta 	temp1
.1d14					_EPNotFound:
.1d14	ad 10 09	lda $0910			lda 	encodeBuffer 				; is there anything in the line.
.1d17	c9 05		cmp #$05			cmp 	#5 							; <offset> <line#> <next line>
.1d19	f0 03		beq $1d1e			beq 	_EPNoInsert
.1d1b	20 45 1d	jsr $1d45			jsr 	EDInsertLine 				; insert line back in.
.1d1e					_EPNoInsert:
.1d1e	20 91 1b	jsr $1b91			jsr 	ClearVariableSpace
.1d21	60		rts				rts
.1d22					EDDeleteLine:
.1d22	20 91 1b	jsr $1b91			jsr 	ClearVariableSpace
.1d25	a0 00		ldy #$00			ldy 	#0 							; this is the offset to copy down.
.1d27	a2 00		ldx #$00			ldx 	#0
.1d29	b1 10		lda ($10),y			lda 	(temp1),y
.1d2b	a8		tay				tay 								; put in Y
.1d2c					_EDDelLoop:
.1d2c	b1 10		lda ($10),y			lda 	(temp1),y 					; get it
.1d2e	81 10		sta ($10,x)			sta 	(temp1,x) 					; write it.
.1d30	a5 10		lda $10				lda 	temp1 						; check if pointer has reached the end of
.1d32	c5 0e		cmp $0e				cmp		nextFreeMem 				; low memory. We will have copied down an
.1d34	d0 06		bne $1d3c			bne 	_EDDelNext 					; extra pile of stuff - technically should
.1d36	a5 11		lda $11				lda 	temp1+1 					; check the upper value (e.g. temp1+y)
.1d38	c5 0f		cmp $0f				cmp 	nextFreeMem+1				; doesn't really matter.
.1d3a	f0 08		beq $1d44			beq		_EDDelExit
.1d3c					_EDDelNext:
.1d3c	e6 10		inc $10				inc 	temp1 						; go to next byte.
.1d3e	d0 ec		bne $1d2c			bne 	_EDDelLoop
.1d40	e6 11		inc $11				inc 	temp1+1
.1d42	80 e8		bra $1d2c			bra 	_EDDelLoop
.1d44					_EDDelExit:
.1d44	60		rts				rts
.1d45					EDInsertLine:
.1d45	20 91 1b	jsr $1b91			jsr 	ClearVariableSpace
.1d48	a5 0e		lda $0e				lda 	nextFreeMem 				; copy high memory to temp3
.1d4a	85 14		sta $14				sta 	temp3
.1d4c	a5 0f		lda $0f				lda 	nextFreeMem+1
.1d4e	85 15		sta $15				sta 	temp3+1
.1d50	ac 10 09	ldy $0910			ldy 	encodeBuffer 				; space to move it to in Y
.1d53	a2 00		ldx #$00			ldx 	#0
.1d55					_EDInsLoop:
.1d55	a1 14		lda ($14,x)			lda 	(temp3,x)					; copy it up
.1d57	91 14		sta ($14),y			sta 	(temp3),y
.1d59	a5 14		lda $14				lda 	temp3 						; reached the insert point (temp1)
.1d5b	c5 10		cmp $10				cmp 	temp1
.1d5d	d0 06		bne $1d65			bne 	_EDINextShift
.1d5f	a5 15		lda $15				lda 	temp3+1
.1d61	c5 11		cmp $11				cmp 	temp1+1
.1d63	f0 0a		beq $1d6f			beq 	_EDIShiftOver
.1d65					_EDINextShift:
.1d65	a5 14		lda $14				lda 	temp3 						; decrement the copy pointer.
.1d67	d0 02		bne $1d6b			bne 	_EDINoBorrow
.1d69	c6 15		dec $15				dec 	temp3+1
.1d6b					_EDINoBorrow:
.1d6b	c6 14		dec $14				dec 	temp3
.1d6d	80 e6		bra $1d55			bra 	_EDInsLoop
.1d6f					_EDIShiftOver:
.1d6f	a0 00		ldy #$00			ldy 	#0
.1d71					_EDICopyCode:
.1d71	b9 10 09	lda $0910,y			lda 	encodeBuffer,y				; read from the current line
.1d74	91 10		sta ($10),y			sta 	(temp1),y 					; write out
.1d76	c8		iny				iny 								; bump pointers
.1d77	cc 10 09	cpy $0910			cpy 	encodeBuffer 				; done the whole lot ?
.1d7a	90 f5		bcc $1d71			bcc 	_EDICopyCode
.1d7c	f0 f3		beq $1d71			beq 	_EDICopyCode
.1d7e	60		rts				rts
.1d7f					EDFindLine:
.1d7f	a9 00		lda #$00			lda 	#(programMemory) & $FF
.1d81	85 10		sta $10				sta 	0+(temp1)
.1d83	a9 40		lda #$40			lda 	#(programMemory) >> 8
.1d85	85 11		sta $11				sta 	1+(temp1)
.1d87					_EDFLLoop:
.1d87	b2 10		lda ($10)			lda 	(temp1) 					; check offset
.1d89	f0 24		beq $1daf			beq 	_EDFLFail 					; then obviously that's the end ;-) (great comment !)
.1d8b	a0 01		ldy #$01			ldy 	#1							; look at line #
.1d8d	38		sec				sec
.1d8e	ad 11 09	lda $0911			lda 	encodeBuffer+1				; subtract the current from the target
.1d91	f1 10		sbc ($10),y			sbc 	(temp1),y 					; so if searching for 100 and this one is 90,
.1d93	aa		tax				tax	 								; this will return 10.
.1d94	ad 12 09	lda $0912			lda 	encodeBuffer+2
.1d97	c8		iny				iny
.1d98	f1 10		sbc ($10),y			sbc 	(temp1),y
.1d9a	90 13		bcc $1daf			bcc 	_EDFLFail					; if target < current then failed.
.1d9c	d0 04		bne $1da2			bne 	_EDFLNext 					; if non-zero then goto next
.1d9e	e0 00		cpx #$00			cpx 	#0 							; same for the LSB - zero if match found.
.1da0	f0 0f		beq $1db1			beq 	_EDFLFound
.1da2					_EDFLNext:
.1da2	18		clc				clc
.1da3	a5 10		lda $10				lda 	temp1
.1da5	72 10		adc ($10)			adc 	(temp1)
.1da7	85 10		sta $10				sta 	temp1
.1da9	90 02		bcc $1dad			bcc 	_NoCarryAdv
.1dab	e6 11		inc $11				inc 	temp1+1
.1dad					_NoCarryAdv:
.1dad	80 d8		bra $1d87			bra 	_EDFLLoop
.1daf					_EDFLFail:
.1daf	18		clc				clc
.1db0	60		rts				rts
.1db1					_EDFLFound:
.1db1	38		sec				sec
.1db2	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/list.src

.1db3					ListCode:
.1db3	64 1e		stz $1e				stz 	ListLowest 					; zero lowest line#
.1db5	64 1f		stz $1f				stz 	ListLowest+1
.1db7	a9 14		lda #$14			lda 	#20 						; show max 20 after lowest line
.1db9	85 1d		sta $1d				sta 	ListCount
.1dbb	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.1dbd	85 18		sta $18				sta 	0+(listPtr)
.1dbf	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.1dc1	85 19		sta $19				sta 	1+(listPtr)
.1dc3	86 10		stx $10				stx 	temp1						; S->A
.1dc5	ba		tsx				tsx
.1dc6	8a		txa				txa
.1dc7	a6 10		ldx $10				ldx 	temp1
.1dc9	c9 80		cmp #$80			cmp 	#NumberStackBase
.1dcb	f0 0e		beq $1ddb			beq 	_LCLoop
.1dcd	a5 06		lda $06				lda 	TOS 						; copy TOS to lowest
.1dcf	85 1e		sta $1e				sta 	ListLowest
.1dd1	a5 07		lda $07				lda 	TOS+1
.1dd3	85 1f		sta $1f				sta 	ListLowest+1
.1dd5	68		pla				pla
.1dd6	85 07		sta $07				sta 	TOS+1
.1dd8	68		pla				pla
.1dd9	85 06		sta $06				sta 	TOS
.1ddb					_LCLoop:
.1ddb	b2 18		lda ($18)			lda 	(listPtr)					; reached end ?
.1ddd	f0 4e		beq $1e2d			beq 	_LCExit
.1ddf	a0 01		ldy #$01			ldy 	#1							; >= list lowest
.1de1	b1 18		lda ($18),y			lda 	(listPtr),y
.1de3	c5 1e		cmp $1e				cmp 	ListLowest
.1de5	c8		iny				iny
.1de6	b1 18		lda ($18),y			lda 	(listPtr),y
.1de8	e5 1f		sbc $1f				sbc 	ListLowest+1
.1dea	90 34		bcc $1e20			bcc 	_LCNext
.1dec	a9 10		lda #$10			lda 	#(textBuffer) & $FF
.1dee	85 0a		sta $0a				sta 	0+(bufPtr)
.1df0	a9 08		lda #$08			lda 	#(textBuffer) >> 8
.1df2	85 0b		sta $0b				sta 	1+(bufPtr)
.1df4	a5 18		lda $18				lda 	listPtr 					; output the line.
.1df6	a4 19		ldy $19				ldy 	listPtr+1
.1df8	38		sec				sec
.1df9	20 d3 1b	jsr $1bd3			jsr 	DecodeLineIntoBufPtr
.1dfc	a9 02		lda #$02			lda 	#CTH_LineNo
.1dfe	20 38 11	jsr $1138			jsr 	ExternColour
.1e01	a0 ff		ldy #$ff			ldy 	#255
.1e03					_LCLoop2:
.1e03	c8		iny				iny
.1e04	b9 10 08	lda $0810,y			lda 	textBuffer,y
.1e07	f0 0e		beq $1e17			beq 	_LCEnd
.1e09	c9 20		cmp #$20			cmp 	#32
.1e0b	b0 05		bcs $1e12			bcs 	_LCPrint
.1e0d	20 38 11	jsr $1138			jsr 	ExternColour
.1e10	a9 20		lda #$20			lda 	#32
.1e12					_LCPrint:
.1e12	20 2e 11	jsr $112e			jsr 	ExternPrint
.1e15	80 ec		bra $1e03			bra 	_LCLoop2
.1e17	a9 0d		lda #$0d	_LCEnd:	lda 	#13 						; new line
.1e19	20 2e 11	jsr $112e			jsr 	ExternPrint
.1e1c	c6 1d		dec $1d				dec 	ListCount					; done all the lines allowed
.1e1e	f0 0d		beq $1e2d			beq 	_LCExit
.1e20					_LCNext:
.1e20	18		clc				clc
.1e21	a5 18		lda $18				lda 	listPtr
.1e23	72 18		adc ($18)			adc 	(listPtr)
.1e25	85 18		sta $18				sta 	listPtr
.1e27	90 02		bcc $1e2b			bcc 	_NoCarryAdv
.1e29	e6 19		inc $19				inc 	listPtr+1
.1e2b					_NoCarryAdv:
.1e2b	80 ae		bra $1ddb			bra 	_LCLoop 					; go round again.
.1e2d					_LCExit:
.1e2d	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/system/miscellany.src

.1e30					RunProgram:
.1e30	86 10		stx $10				stx 	temp1
.1e32	a2 80		ldx #$80			ldx 	#NumberStackBase
.1e34	9a		txs				txs
.1e35	a6 10		ldx $10				ldx 	temp1
.1e37	20 91 1b	jsr $1b91			jsr 	ClearVariableSpace 			; clear variables etc.
.1e3a	a2 00		ldx #$00			ldx		#ProgramMemory & $FF		; boot address
.1e3c	a0 40		ldy #$40			ldy 	#ProgramMemory >>8
.1e3e	20 98 10	jsr $1098			jsr 	InitialiseCoreCode 			; initialise the NEXT routine at $00
.1e41	4c 00 00	jmp $0000			jmp 	NextCode
.1e44					Call6502:
.1e44	a5 06		lda $06				lda 	TOS 						; copy call address
.1e46	85 10		sta $10				sta 	temp1
.1e48	a5 07		lda $07				lda 	TOS+1
.1e4a	85 11		sta $11				sta 	temp1+1
.1e4c	68		pla				pla
.1e4d	85 07		sta $07				sta 	TOS+1
.1e4f	68		pla				pla
.1e50	85 06		sta $06				sta 	TOS
.1e52	20 58 1e	jsr $1e58			jsr 	_CallTemp1 					; call it
.1e55	4c 00 00	jmp $0000			jmp 	NextCode
.1e58					_CallTemp1:
.1e58	6c 10 00	jmp ($0010)			jmp 	(temp1)
.1e5b					AssertCode:
.1e5b	a5 06		lda $06				lda 	TOS 						; TOS = 0
.1e5d	05 07		ora $07				ora 	TOS+1
.1e5f	f0 09		beq $1e6a			beq 	_ASFail 					; if zero fail
.1e61	68		pla				pla
.1e62	85 07		sta $07				sta 	TOS+1
.1e64	68		pla				pla
.1e65	85 06		sta $06				sta 	TOS
.1e67	4c 00 00	jmp $0000			jmp 	NextCode
.1e6a					_ASFail:
.1e6a	20 43 10	jsr $1043			jsr 	ErrorHandler
>1e6d	41 53 53 45 52 54 00				.text 	"ASSERT",0
.1e74					StopCode:
.1e74	20 43 10	jsr $1043			jsr 	ErrorHandler
>1e77	53 54 4f 50 00					.text 	"STOP",0
.1e7c					EndProgram:
.1e7c	4c 14 10	jmp $1014			jmp 	WarmStart
.1e7f					VlistCode:
.1e7f	a9 05		lda #$05			lda 	#(Dictionary) & $FF
.1e81	85 10		sta $10				sta 	0+(temp1)
.1e83	a9 22		lda #$22			lda 	#(Dictionary) >> 8
.1e85	85 11		sta $11				sta 	1+(temp1)
.1e87	a0 01		ldy #$01	_VLLoop:ldy 	#1							; type byte
.1e89	b1 10		lda ($10),y			lda 	(temp1),y
.1e8b	a0 04		ldy #$04			ldy 	#4 							; Y = 4
.1e8d	4a		lsr a				lsr 	a 							; shift bits 4 and 5 to 0,1
.1e8e	4a		lsr a				lsr 	a
.1e8f	4a		lsr a				lsr		a
.1e90	4a		lsr a				lsr 	a
.1e91	4a		lsr a				lsr 	a 							; add those bits in
.1e92	90 02		bcc $1e96			bcc 	_VLNoDec
.1e94	c8		iny				iny
.1e95	c8		iny				iny
.1e96					_VLNoDec:
.1e96	4a		lsr a				lsr 	a
.1e97	90 02		bcc $1e9b			bcc 	_VLNoEnc
.1e99	c8		iny				iny
.1e9a	c8		iny				iny
.1e9b					_VLNoEnc:
.1e9b	b1 10		lda ($10),y			lda 	(temp1),y 					; remove $$ words
.1e9d	c9 24		cmp #$24			cmp 	#"$"
.1e9f	d0 06		bne $1ea7			bne 	_VLPrint
.1ea1	c8		iny				iny
.1ea2	51 10		eor ($10),y			eor 	(temp1),y
.1ea4	f0 13		beq $1eb9			beq 	_VLNext
.1ea6	88		dey				dey
.1ea7					_VLPrint:
.1ea7	b1 10		lda ($10),y			lda 	(temp1),y
.1ea9	48		pha				pha
.1eaa	c8		iny				iny
.1eab	29 7f		and #$7f			and 	#$7F
.1ead	20 2e 11	jsr $112e			jsr 	ExternPrint
.1eb0	68		pla				pla
.1eb1	0a		asl a				asl 	a
.1eb2	90 f3		bcc $1ea7			bcc 	_VLPrint
.1eb4	a9 20		lda #$20			lda 	#32
.1eb6	20 2e 11	jsr $112e			jsr 	ExternPrint
.1eb9					_VLNext:
.1eb9	18		clc				clc 								; go to next
.1eba	b2 10		lda ($10)			lda 	(temp1)
.1ebc	65 10		adc $10				adc 	temp1
.1ebe	85 10		sta $10				sta 	temp1
.1ec0	90 02		bcc $1ec4			bcc 	_VLNoCarry
.1ec2	e6 11		inc $11				inc 	temp1+1
.1ec4					_VLNoCarry:
.1ec4	b2 10		lda ($10)			lda 	(temp1)
.1ec6	d0 bf		bne $1e87			bne 	_VLLoop
.1ec8	a9 0d		lda #$0d			lda 	#13
.1eca	20 2e 11	jsr $112e			jsr 	ExternPrint
.1ecd	4c 00 00	jmp $0000			jmp 	NextCode
.1ed0					DumpStack:
.1ed0	a9 5b		lda #$5b			lda		#"["
.1ed2	20 2e 11	jsr $112e			jsr 	ExternPrint
.1ed5	86 10		stx $10				stx 	temp1 						; X -> A
.1ed7	ba		tsx				tsx
.1ed8	8a		txa				txa
.1ed9	a6 10		ldx $10				ldx 	temp1
.1edb	c9 80		cmp #$80			cmp 	#NumberStackBase 			; out of range, exit
.1edd	f0 2f		beq $1f0e			beq 	_DSExit
.1edf	48		pha				pha 								; save it
.1ee0	a9 07		lda #$07			lda 	#COL_WHITE
.1ee2	20 38 11	jsr $1138			jsr 	ExternColour
.1ee5	a5 06		lda $06				lda 	TOS 						; print TOS then stack values backwards
.1ee7	a4 07		ldy $07				ldy 	TOS+1
.1ee9	38		sec				sec 								; print unsigned.
.1eea	20 21 20	jsr $2021			jsr 	PrintYA
.1eed	a9 06		lda #$06			lda 	#COL_CYAN
.1eef	20 38 11	jsr $1138			jsr 	ExternColour
.1ef2	7a		ply				ply 								; restore offset
.1ef3					_DSLoop:
.1ef3	c0 7e		cpy #$7e			cpy 	#NumberStackBase-2 			; till done whole stack.
.1ef5	f0 17		beq $1f0e			beq 	_DSExit
.1ef7	a9 20		lda #$20			lda 	#" " 						; space
.1ef9	20 2e 11	jsr $112e			jsr 	ExternPrint
.1efc	5a		phy				phy 								; save pos
.1efd	b9 01 01	lda $0101,y			lda 	$0101,y 					; read stack item
.1f00	48		pha				pha
.1f01	b9 02 01	lda $0102,y			lda 	$0102,y
.1f04	7a		ply				ply
.1f05	38		sec				sec
.1f06	20 21 20	jsr $2021			jsr 	PrintYA 					; print it
.1f09	7a		ply				ply 								; restore and advance pos
.1f0a	c8		iny				iny
.1f0b	c8		iny				iny
.1f0c	80 e5		bra $1ef3			bra 	_DSLoop
.1f0e					_DSExit:
.1f0e	a9 5d		lda #$5d			lda		#"]"
.1f10	20 2e 11	jsr $112e			jsr 	ExternPrint
.1f13	a9 0d		lda #$0d			lda 	#13
.1f15	20 2e 11	jsr $112e			jsr 	ExternPrint
.1f18	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/system/toint.src

.1f1b					ConvertToInteger:
.1f1b	84 17		sty $17				sty 	temp4+1
.1f1d	85 16		sta $16				sta 	temp4
.1f1f	64 14		stz $14				stz 	temp3 						; reset value
.1f21	64 15		stz $15				stz 	temp3+1
.1f23	64 10		stz $10				stz 	temp1 						; temp1 = 0 (decimal) 255 (hex)
.1f25	a0 00		ldy #$00			ldy 	#0 							; look at first character
.1f27	b1 16		lda ($16),y			lda 	(temp4),y
.1f29	49 2d		eor #$2d			eor 	#"-"						; zero if '-'
.1f2b	85 11		sta $11				sta 	temp1+1 					; save this in temp1+1
.1f2d	d0 01		bne $1f30			bne 	_CTINotMinus
.1f2f	c8		iny				iny									; skip -
.1f30					_CTINotMinus:
.1f30	b1 16		lda ($16),y			lda 	(temp4),y
.1f32	c9 24		cmp #$24			cmp		#'$'						; if $ then skip it and set hex flag
.1f34	d0 03		bne $1f39			bne 	_CTILoop
.1f36	c6 10		dec $10				dec 	temp1
.1f38	c8		iny				iny
.1f39					_CTILoop:
.1f39	b1 16		lda ($16),y			lda 	(temp4),y 					; next digit
.1f3b	29 7f		and #$7f			and 	#$7F 						; drop end of word flag
.1f3d	38		sec				sec
.1f3e	e9 30		sbc #$30			sbc 	#'0' 						; put in range '0'+
.1f40	90 65		bcc $1fa7			bcc 	_CTIFail 					; out of range.
.1f42	c9 0a		cmp #$0a			cmp 	#10 						; in 0-9 ?
.1f44	90 0b		bcc $1f51			bcc 	_CTILegal
.1f46	c9 11		cmp #$11			cmp 	#'A'-'0'					; between 9 and A ?
.1f48	90 5d		bcc $1fa7			bcc 	_CTIFail
.1f4a	38		sec				sec
.1f4b	e9 07		sbc #$07			sbc 	#7 							; hex adjust
.1f4d	c9 10		cmp #$10			cmp 	#16 						; out of range ?
.1f4f	b0 56		bcs $1fa7			bcs 	_CTIFail
.1f51					_CTILegal:
.1f51	48		pha				pha 								; save digit value.
.1f52	06 14		asl $14				asl 	temp3
.1f54	26 15		rol $15				rol 	temp3+1
.1f56	a5 14		lda $14				lda 	temp3 						; copy x2 into temp2
.1f58	85 12		sta $12				sta 	temp2
.1f5a	a5 15		lda $15				lda 	temp3+1
.1f5c	85 13		sta $13				sta 	temp2+1
.1f5e	06 14		asl $14				asl 	temp3
.1f60	26 15		rol $15				rol 	temp3+1
.1f62	06 14		asl $14				asl 	temp3
.1f64	26 15		rol $15				rol 	temp3+1
.1f66	24 10		bit $10				bit 	temp1 						; hexadecimal
.1f68	10 07		bpl $1f71			bpl 	_CTIDecimal
.1f6a	06 14		asl $14				asl 	temp3
.1f6c	26 15		rol $15				rol 	temp3+1
.1f6e	68		pla				pla 								; get digit back
.1f6f	80 12		bra $1f83			bra 	_CTIAddLoop
.1f71					_CTIDecimal:
.1f71	18		clc				clc 								; x 8 + x 2 = x 10
.1f72	a5 14		lda $14				lda 	temp3
.1f74	65 12		adc $12				adc 	temp2
.1f76	85 14		sta $14				sta 	temp3
.1f78	a5 15		lda $15				lda 	temp3+1
.1f7a	65 13		adc $13				adc 	temp2+1
.1f7c	85 15		sta $15				sta 	temp3+1
.1f7e	68		pla				pla 								; check digit 0-9
.1f7f	c9 0a		cmp #$0a			cmp 	#10
.1f81	b0 24		bcs $1fa7			bcs 	_CTIFail
.1f83					_CTIAddLoop:
.1f83	18		clc				clc
.1f84	65 14		adc $14				adc 	temp3
.1f86	85 14		sta $14				sta 	temp3
.1f88	90 02		bcc $1f8c			bcc 	_CTINoCarry
.1f8a	e6 15		inc $15				inc 	temp3+1
.1f8c					_CTINoCarry:
.1f8c	c8		iny				iny
.1f8d	b1 16		lda ($16),y			lda 	(temp4),y 					; was this the last character
.1f8f	c9 21		cmp #$21			cmp 	#32+1
.1f91	b0 a6		bcs $1f39			bcs 	_CTILoop 					; no, go back.
.1f93	a5 11		lda $11				lda 	temp1+1 					; was it - ?
.1f95	d0 0d		bne $1fa4			bne 	_CTIOkay
.1f97	38		sec				sec
.1f98	a9 00		lda #$00			lda 	#0 							; negate temp3.
.1f9a	e5 14		sbc $14				sbc 	temp3
.1f9c	85 14		sta $14				sta 	temp3
.1f9e	a9 00		lda #$00			lda 	#0
.1fa0	e5 15		sbc $15				sbc 	temp3+1
.1fa2	85 15		sta $15				sta 	temp3+1
.1fa4					_CTIOkay:
.1fa4	98		tya				tya
.1fa5	38		sec				sec
.1fa6	60		rts				rts
.1fa7					_CTIFail:
.1fa7	18		clc				clc
.1fa8	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/skipper.src

.1fa9					NextLine:
.1fa9	18		clc				clc
.1faa	a5 03		lda $03				lda 	IP
.1fac	72 03		adc ($03)			adc 	(IP)
.1fae	85 03		sta $03				sta 	IP
.1fb0	90 02		bcc $1fb4			bcc 	_NoCarryAdv
.1fb2	e6 04		inc $04				inc 	IP+1
.1fb4					_NoCarryAdv:
.1fb4	b2 03		lda ($03)			lda 	(IP)						; is there any following program ?
.1fb6	f0 05		beq $1fbd			beq 	_NLGoEnd
.1fb8	a2 01		ldx #$01			ldx 	#1 							; start 3 in (-2 for Next)
.1fba	4c 00 00	jmp $0000			jmp 	NextCode
.1fbd					_NLGoEnd:
.1fbd	4c 14 10	jmp $1014			jmp 	WarmStart
.1fc0					SkipComment:
.1fc0	e8		inx				inx									; (IP),X points to the length.
.1fc1	e8		inx				inx
.1fc2	8a		txa				txa
.1fc3	a8		tay				tay 								; put into Y
.1fc4	18		clc				clc
.1fc5	71 03		adc ($03),y			adc 	(IP),y 						; add the length to X
.1fc7	aa		tax				tax 								; put back in X
.1fc8	ca		dex				dex
.1fc9	ca		dex				dex
.1fca	4c 00 00	jmp $0000			jmp 	NextCode
.1fcd					CommentDecoder:
.1fcd	a9 06		lda #$06			lda 	#CTH_Keyword
.1fcf	20 c1 1c	jsr $1cc1			jsr 	DecodeWriteBuffer
.1fd2	a9 27		lda #$27			lda 	#"'"
.1fd4	20 c1 1c	jsr $1cc1			jsr 	DecodeWriteBuffer
.1fd7	a9 0b		lda #$0b			lda 	#CTH_Comment
.1fd9	20 c1 1c	jsr $1cc1			jsr 	DecodeWriteBuffer
.1fdc	20 ca 1c	jsr $1cca			jsr 	DecodeOutputData
.1fdf	a9 20		lda #$20			lda 	#32
.1fe1	20 c1 1c	jsr $1cc1			jsr 	DecodeWriteBuffer
.1fe4	60		rts				rts
.1fe5					DefineCode:
.1fe5	20 43 10	jsr $1043			jsr 	ErrorHandler
>1fe8	44 45 46 49 4e 49 54 49				.text 	"DEFINITION?",0
>1ff0	4f 4e 3f 00
.1ff4					DefineDecoder:
.1ff4	a9 07		lda #$07			lda 	#CTH_Definition
.1ff6	20 c1 1c	jsr $1cc1			jsr 	DecodeWriteBuffer
.1ff9	a9 3a		lda #$3a			lda 	#":"
.1ffb	20 c1 1c	jsr $1cc1			jsr 	DecodeWriteBuffer
.1ffe	20 ca 1c	jsr $1cca			jsr 	DecodeOutputData
.2001	a9 20		lda #$20			lda 	#32
.2003	20 c1 1c	jsr $1cc1			jsr 	DecodeWriteBuffer
.2006	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/tostr.src

.2007					IntToString:
.2007	a9 10		lda #$10			lda 	#(textBuffer) & $FF
.2009	85 12		sta $12				sta 	0+(temp2)
.200b	a9 08		lda #$08			lda 	#(textBuffer) >> 8
.200d	85 13		sta $13				sta 	1+(temp2)
.200f	a5 06		lda $06				lda 	TOS 						; value in YA
.2011	a4 07		ldy $07				ldy 	TOS+1
.2013	20 43 20	jsr $2043			jsr 	ConvertToString
.2016	a9 10		lda #$10			lda 	#(textBuffer) & $FF
.2018	85 06		sta $06				sta 	0+(TOS)
.201a	a9 08		lda #$08			lda 	#(textBuffer) >> 8
.201c	85 07		sta $07				sta 	1+(TOS)
.201e	4c 00 00	jmp $0000			jmp 	NextCode
.2021					PrintYA:
.2021	48		pha				pha
.2022	da		phx				phx
.2023	5a		phy				phy
.2024	48		pha				pha
.2025	a9 10		lda #$10			lda 	#(textBuffer) & $FF
.2027	85 12		sta $12				sta 	0+(temp2)
.2029	a9 08		lda #$08			lda 	#(textBuffer) >> 8
.202b	85 13		sta $13				sta 	1+(temp2)
.202d	68		pla				pla
.202e	20 43 20	jsr $2043			jsr 	ConvertToString
.2031	a2 00		ldx #$00			ldx 	#0
.2033					_PrintYALoop:
.2033	bd 10 08	lda $0810,x			lda 	textBuffer,x
.2036	20 2e 11	jsr $112e			jsr 	ExternPrint
.2039	e8		inx				inx
.203a	bd 10 08	lda $0810,x			lda 	textBuffer,x
.203d	d0 f4		bne $2033			bne 	_PrintYALoop
.203f	7a		ply				ply
.2040	fa		plx				plx
.2041	68		pla				pla
.2042	60		rts				rts
.2043					ConvertToString:
.2043	38		sec				sec
.2044	80 01		bra $2047			bra 	ConvertToStringMain
.2046					ConvertToStringUnsigned:
.2046	18		clc				clc
.2047					ConvertToStringMain:
.2047	da		phx				phx									; save XY
.2048	5a		phy				phy
.2049	64 1a		stz $1a				stz 	SignCount 					; this is zero suppression
.204b	85 10		sta $10				sta 	temp1 						; save YA in temp1
.204d	84 11		sty $11				sty 	temp1+1
.204f	a0 00		ldy #$00			ldy 	#0 							; index to result.
.2051	90 16		bcc $2069			bcc 	_CTSUnsigned 				; if carry clear do not adjust for -
.2053	a5 11		lda $11				lda 	temp1+1 					; is it negative
.2055	10 12		bpl $2069			bpl 	_CTSUnsigned
.2057	a9 2d		lda #$2d			lda 	#"-"						; output - sign
.2059	91 12		sta ($12),y			sta 	(temp2),y
.205b	c8		iny				iny
.205c	38		sec				sec 								; negate temp1
.205d	a9 00		lda #$00			lda 	#0
.205f	e5 10		sbc $10				sbc 	temp1
.2061	85 10		sta $10				sta 	temp1
.2063	a9 00		lda #$00			lda 	#0
.2065	e5 11		sbc $11				sbc 	temp1+1
.2067	85 11		sta $11				sta 	temp1+1
.2069					_CTSUnsigned:
.2069	a2 00		ldx #$00			ldx 	#0 							; index into subtraction table
.206b					_CTSLoop:
.206b	a9 2f		lda #$2f			lda 	#"0"-1						; set the digit to '0' code.
.206d	91 12		sta ($12),y			sta 	(temp2),y
.206f					_CTSSubLoop:
.206f	b1 12		lda ($12),y			lda 	(temp2),y 					; bump the count
.2071	1a		inc a				inc 	a
.2072	91 12		sta ($12),y			sta 	(temp2),y
.2074	38		sec				sec 								; do subtraction saving interim result
.2075	a5 10		lda $10				lda 	temp1
.2077	fd aa 20	sbc $20aa,x			sbc 	_CTSTable,x
.207a	48		pha				pha
.207b	a5 11		lda $11				lda 	temp1+1
.207d	fd ab 20	sbc $20ab,x			sbc 	_CTSTable+1,x
.2080	90 07		bcc $2089			bcc 	_CTSCantSubtract 			; end of subtraction.
.2082	85 11		sta $11				sta 	temp1+1 					; save result back
.2084	68		pla				pla
.2085	85 10		sta $10				sta 	temp1
.2087	80 e6		bra $206f			bra 	_CTSSubLoop
.2089					_CTSCantSubtract:
.2089	68		pla				pla 								; throw away interim
.208a	e8		inx				inx 								; next subtractor
.208b	e8		inx				inx
.208c	b1 12		lda ($12),y			lda 	(temp2),y 					; update leading zero
.208e	49 30		eor #$30			eor 	#"0"
.2090	05 1a		ora $1a				ora 	SignCount
.2092	85 1a		sta $1a				sta 	SignCount
.2094	f0 01		beq $2097			beq		_CTSLZ 						; if all zeros so far suppress.
.2096	c8		iny				iny 								; next character
.2097					_CTSLZ:
.2097	e0 08		cpx #$08			cpx 	#_CTSTableEnd-_CTSTable 	; done them all ?
.2099	d0 d0		bne $206b			bne 	_CTSLoop
.209b					_CTSComplete:
.209b	a5 10		lda $10				lda		temp1 						; get remainder 0-9
.209d	09 30		ora #$30			ora 	#48 						; ASCII
.209f	91 12		sta ($12),y			sta 	(temp2),y					; write out
.20a1	c8		iny				iny
.20a2	a9 00		lda #$00			lda 	#0							; make ASCIIZ
.20a4	91 12		sta ($12),y			sta 	(temp2),y
.20a6	98		tya				tya 								; size in A
.20a7	7a		ply				ply									; pull and exit.
.20a8	fa		plx				plx
.20a9	60		rts				rts
.20aa					_CTSTable:
>20aa	10 27 e8 03 64 00 0a 00				.word 	10000,1000,100,10 			; subtractors, this is a simple version.
.20b2					_CTSTableEnd:

;******  Return to file: kernel.asm


;******  Processing file: words/system/varhandlers.src

.20b2					VarAddressHandler:
.20b2	18		clc				clc 								; find variable, error if it doesn't exist.
.20b3	20 04 21	jsr $2104			jsr 	VariableFind
.20b6	a5 06		lda $06				lda 	TOS
.20b8	48		pha				pha
.20b9	a5 07		lda $07				lda 	TOS+1
.20bb	48		pha				pha
.20bc	a5 10		lda $10				lda 	temp1 						; the address is the new value
.20be	85 06		sta $06				sta 	TOS
.20c0	a5 11		lda $11				lda		temp1+1
.20c2	85 07		sta $07				sta 	TOS+1
.20c4	4c 00 00	jmp $0000			jmp 	NextCode
.20c7					VarAddrHandlerDecode:
.20c7	a9 26		lda #$26			lda 	#"&"
.20c9	4c b2 21	jmp $21b2			jmp 	VarHandlerDecode
.20cc					VarReadHandler:
.20cc	18		clc				clc 								; find variable, error if it doesn't exist.
.20cd	20 04 21	jsr $2104			jsr 	VariableFind
.20d0	a5 06		lda $06				lda 	TOS
.20d2	48		pha				pha
.20d3	a5 07		lda $07				lda 	TOS+1
.20d5	48		pha				pha
.20d6	b2 10		lda ($10)			lda 	(temp1)						; read variable address to TOS
.20d8	85 06		sta $06				sta 	TOS
.20da	a0 01		ldy #$01			ldy 	#1
.20dc	b1 10		lda ($10),y			lda 	(temp1),y
.20de	85 07		sta $07				sta 	TOS+1
.20e0	4c 00 00	jmp $0000			jmp 	NextCode
.20e3					VarReadHandlerDecode:
.20e3	a9 40		lda #$40			lda 	#"@"
.20e5	4c b2 21	jmp $21b2			jmp 	VarHandlerDecode
.20e8					VarWriteHandler:
.20e8	38		sec				sec 								; find variable, create it if it doesn't exist.
.20e9	20 04 21	jsr $2104			jsr 	VariableFind
.20ec	a5 06		lda $06				lda 	TOS 						; write TOS to that address.
.20ee	92 10		sta ($10)			sta 	(temp1)
.20f0	a5 07		lda $07				lda 	TOS+1
.20f2	a0 01		ldy #$01			ldy 	#1
.20f4	91 10		sta ($10),y			sta 	(temp1),y
.20f6	68		pla				pla
.20f7	85 07		sta $07				sta 	TOS+1
.20f9	68		pla				pla
.20fa	85 06		sta $06				sta 	TOS
.20fc	4c 00 00	jmp $0000			jmp 	NextCode
.20ff					VarWriteHandlerDecode:
.20ff	a9 21		lda #$21			lda 	#"!"
.2101	4c b2 21	jmp $21b2			jmp 	VarHandlerDecode
.2104					VariableFind:
.2104	08		php				php 								; save autocreate flag.
.2105	e8		inx				inx 								; advance to/over the variable name.
.2106	e8		inx				inx
.2107	8a		txa				txa 								; put in Y
.2108	a8		tay				tay
.2109	b1 03		lda ($03),y			lda 	(IP),y 						; copy name word into temp2
.210b	85 12		sta $12				sta 	temp2
.210d	c8		iny				iny
.210e	b1 03		lda ($03),y			lda 	(IP),y
.2110	85 13		sta $13				sta 	temp2+1
.2112	c9 1b		cmp #$1b			cmp 	#27 						; check for A-Z
.2114	b0 0f		bcs $2125			bcs 	_VFLong
.2116	a5 13		lda $13				lda 	temp2+1
.2118	d0 0b		bne $2125			bne 	_VFLong
.211a	a5 12		lda $12				lda 	temp2						; this is the index
.211c	0a		asl a				asl 	a 							; double it
.211d	85 10		sta $10				sta 	temp1
.211f	a9 06		lda #$06			lda 	#azVariables >> 8			; set the MSB
.2121	85 11		sta $11				sta 	temp1+1
.2123	28		plp				plp 								; throw creation flag, it always exists.
.2124	60		rts				rts
.2125					_VFLong:
.2125	a5 12		lda $12				lda 	temp2 						; built a hash table index into temp3/temp4
.2127	6a		ror a				ror 	a
.2128	6a		ror a				ror 	a
.2129	6a		ror a				ror 	a
.212a	6a		ror a				ror 	a
.212b	45 12		eor $12				eor 	temp2
.212d	45 13		eor $13				eor 	temp2+1
.212f	29 0f		and #$0f			and 	#(hashTableSize-1)			; force into range
.2131	0a		asl a				asl 	a
.2132	69 40		adc #$40			adc 	#hashTable & $FF 			; make an address of the head => temp1/3
.2134	85 10		sta $10				sta 	temp1
.2136	85 14		sta $14				sta 	temp3
.2138	a9 06		lda #$06			lda 	#hashTable >> 8
.213a	85 11		sta $11				sta 	temp1+1
.213c	85 15		sta $15				sta 	temp3+1
.213e					_VFSearch:
.213e	a0 01		ldy #$01			ldy 	#1							; read MSB of first record
.2140	b1 10		lda ($10),y			lda 	(temp1),y
.2142	f0 23		beq $2167			beq 	_VFNotFound 				; is MSB is zero, can't be a variable record
.2144	a8		tay				tay 								; follow the link through.
.2145	b2 10		lda ($10)			lda 	(temp1)
.2147	85 10		sta $10				sta 	temp1
.2149	84 11		sty $11				sty 	temp1+1
.214b	a0 04		ldy #$04			ldy 	#4							; check if the name matches
.214d	b1 10		lda ($10),y			lda 	(temp1),y
.214f	c5 12		cmp $12				cmp 	temp2
.2151	d0 eb		bne $213e			bne 	_VFSearch 					; if it doesn't, follow the next link.
.2153	c8		iny				iny 								; same for 2nd byte of name
.2154	b1 10		lda ($10),y			lda 	(temp1),y
.2156	c5 13		cmp $13				cmp 	temp2+1
.2158	d0 e4		bne $213e			bne 	_VFSearch
.215a	18		clc				clc
.215b	a5 10		lda $10				lda 	temp1 						; make temp1 point to the data at offset 2
.215d	69 02		adc #$02			adc 	#2
.215f	85 10		sta $10				sta 	temp1
.2161	90 02		bcc $2165			bcc 	_VFNoPage1
.2163	e6 11		inc $11				inc 	temp1+1
.2165					_VFNoPage1:
.2165	28		plp				plp 								; don't need to worry about creation flag
.2166	60		rts				rts
.2167					_VFNotFound:
.2167	28		plp				plp 								; was carry set, e.g. create a new record if not found ?
.2168	b0 0d		bcs $2177			bcs 	_VFCreate
.216a	20 43 10	jsr $1043			jsr 	ErrorHandler
>216d	56 41 52 49 41 42 4c 45				.text 	"VARIABLE?",0
>2175	3f 00
.2177					_VFCreate:
.2177	a0 01		ldy #$01			ldy 	#1
.2179	b2 14		lda ($14)			lda 	(temp3) 					; copy the head link to the first 2 bytes
.217b	92 0e		sta ($0e)			sta 	(nextFreeMem)
.217d	b1 14		lda ($14),y			lda 	(temp3),y
.217f	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.2181	c8		iny				iny
.2182	a9 00		lda #$00			lda 	#0	 						; write zero initialised data out.
.2184	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.2186	c8		iny				iny
.2187	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.2189	c8		iny				iny
.218a	a5 12		lda $12				lda 	temp2 						; copy the name out
.218c	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.218e	c8		iny				iny
.218f	a5 13		lda $13				lda 	temp2+1
.2191	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.2193	a0 01		ldy #$01			ldy 	#1
.2195	a5 0e		lda $0e				lda 	nextFreeMem 				; update the head link
.2197	92 14		sta ($14)			sta 	(temp3)
.2199	a5 0f		lda $0f				lda 	nextFreeMem+1
.219b	91 14		sta ($14),y			sta 	(temp3),y
.219d	18		clc				clc
.219e	a5 0e		lda $0e				lda 	nextFreeMem 				; put nextFreeMem+2 in temp1 (data pointer)
.21a0	69 02		adc #$02			adc 	#2
.21a2	85 10		sta $10				sta 	temp1
.21a4	a5 0f		lda $0f				lda 	nextFreeMem+1
.21a6	69 00		adc #$00			adc 	#0
.21a8	85 11		sta $11				sta 	temp1+1
.21aa	a9 06		lda #$06			lda 	#6							; shift freemem pointer up 6
.21ac	a0 00		ldy #$00			ldy 	#0
.21ae	20 be 1b	jsr $1bbe			jsr 	AdvanceFreeMem
.21b1	60		rts				rts
.21b2					VarHandlerDecode:
.21b2	48		pha				pha 								; save, leading space
.21b3	a9 20		lda #$20			lda 	#" "
.21b5	20 c1 1c	jsr $1cc1			jsr 	DecodeWriteBuffer
.21b8	68		pla				pla 								; restore and write type
.21b9	20 c1 1c	jsr $1cc1			jsr 	DecodeWriteBuffer
.21bc	b1 08		lda ($08),y			lda 	(srcPtr),y 					; copy to temp1
.21be	85 10		sta $10				sta 	temp1
.21c0	c8		iny				iny
.21c1	b1 08		lda ($08),y			lda 	(srcPtr),y
.21c3	85 11		sta $11				sta 	temp1+1
.21c5	a5 10		lda $10				lda 	temp1 						; output the first character
.21c7	29 1f		and #$1f			and 	#31
.21c9	20 f4 21	jsr $21f4			jsr 	VHOutVarChar
.21cc	a2 05		ldx #$05			ldx 	#5 							; divide temp1 by 32
.21ce					_VHDShift:
.21ce	46 11		lsr $11				lsr 	temp1+1
.21d0	66 10		ror $10				ror 	temp1
.21d2	ca		dex				dex
.21d3	d0 f9		bne $21ce			bne 	_VHDShift
.21d5	a2 ff		ldx #$ff			ldx 	#255 						; now divide that by 40 by repeated subtraction.
.21d7					_VHDDiv40:
.21d7	e8		inx				inx
.21d8	38		sec				sec
.21d9	a5 10		lda $10				lda 	temp1
.21db	e9 28		sbc #$28			sbc 	#40
.21dd	a8		tay				tay
.21de	a5 11		lda $11				lda 	temp1+1
.21e0	e9 00		sbc #$00			sbc 	#0
.21e2	90 06		bcc $21ea			bcc 	_VHDivDone
.21e4	85 11		sta $11				sta 	temp1+1
.21e6	84 10		sty $10				sty 	temp1
.21e8	80 ed		bra $21d7			bra 	_VHDDiv40
.21ea					_VHDivDone:
.21ea	a5 10		lda $10				lda 	temp1 						; remainder
.21ec	20 f4 21	jsr $21f4			jsr 	VHOutVarChar
.21ef	8a		txa				txa
.21f0	20 f4 21	jsr $21f4			jsr 	VHOutVarChar 				; and result.
.21f3	60		rts				rts
.21f4					VHOutVarChar:
.21f4	c9 00		cmp #$00			cmp 	#0
.21f6	f0 0c		beq $2204			beq 	_VHOExit
.21f8	18		clc				clc
.21f9	69 40		adc #$40			adc 	#64 						; 65-90 A-Z 91-100 0-9
.21fb	c9 5b		cmp #$5b			cmp 	#91 						; convert back ?
.21fd	90 02		bcc $2201			bcc 	_VHOOut
.21ff	e9 2b		sbc #$2b			sbc 	#91-48 						; adjust to digit
.2201					_VHOOut:
.2201	20 c1 1c	jsr $1cc1			jsr 	DecodeWriteBuffer
.2204					_VHOExit:
.2204	60		rts				rts

;******  Return to file: kernel.asm

.2205					Dictionary:

;******  Processing file: generated/dictionary.inc

>2205	05					.byte	_end1-*
>2206	00					.byte	$00
>2207	1f 16					.word	WordWrite
>2209	a1					.byte	$a1
.220a					_end1:
>220a	10					.byte	_end2-*
>220b	52					.byte	$52
>220c	e8 20					.word	VarWriteHandler
>220e	ff 20					.word	VarWriteHandlerDecode
>2210	24 24 21 48 41 4e 44 4c			.byte	$24,$24,$21,$48,$41,$4e,$44,$4c,$45,$d2
>2218	45 d2
.221a					_end2:
>221a	10					.byte	_end3-*
>221b	52					.byte	$52
>221c	b2 20					.word	VarAddressHandler
>221e	c7 20					.word	VarAddrHandlerDecode
>2220	24 24 26 48 41 4e 44 4c			.byte	$24,$24,$26,$48,$41,$4e,$44,$4c,$45,$d2
>2228	45 d2
.222a					_end3:
>222a	10					.byte	_end4-*
>222b	52					.byte	$52
>222c	cc 20					.word	VarReadHandler
>222e	e3 20					.word	VarReadHandlerDecode
>2230	24 24 40 48 41 4e 44 4c			.byte	$24,$24,$40,$48,$41,$4e,$44,$4c,$45,$d2
>2238	45 d2
.223a					_end4:
>223a	0c					.byte	_end5-*
>223b	52					.byte	$52
>223c	3e 1a					.word	CallHandler
>223e	fa 1a					.word	CallHandlerDecode
>2240	24 24 43 41 4c cc			.byte	$24,$24,$43,$41,$4c,$cc
.2246					_end5:
>2246	0f					.byte	_end6-*
>2247	53					.byte	$53
>2248	c0 1f					.word	SkipComment
>224a	cd 1f					.word	CommentDecoder
>224c	24 24 43 4f 4d 4d 45 4e			.byte	$24,$24,$43,$4f,$4d,$4d,$45,$4e,$d4
>2254	d4
.2255					_end6:
>2255	0e					.byte	_end7-*
>2256	53					.byte	$53
>2257	e5 1f					.word	DefineCode
>2259	f4 1f					.word	DefineDecoder
>225b	24 24 44 45 46 49 4e c5			.byte	$24,$24,$44,$45,$46,$49,$4e,$c5
.2263					_end7:
>2263	0f					.byte	_end8-*
>2264	52					.byte	$52
>2265	a9 10					.word	Literal2Byte
>2267	bf 10					.word	Literal2ByteDecode
>2269	24 24 4c 49 54 45 52 41			.byte	$24,$24,$4c,$49,$54,$45,$52,$41,$cc
>2271	cc
.2272					_end8:
>2272	0e					.byte	_end9-*
>2273	80					.byte	$80
>2274	a9 1f					.word	NextLine
>2276	24 24 4e 45 58 54 4c 49			.byte	$24,$24,$4e,$45,$58,$54,$4c,$49,$4e,$c5
>227e	4e c5
.2280					_end9:
>2280	0e					.byte	_end10-*
>2281	53					.byte	$53
>2282	d1 10					.word	LiteralString
>2284	f0 10					.word	LiteralStringDecoder
>2286	24 24 53 54 52 49 4e c7			.byte	$24,$24,$53,$54,$52,$49,$4e,$c7
.228e					_end10:
>228e	05					.byte	_end11-*
>228f	00					.byte	$00
>2290	9b 13					.word	Multiply16x16
>2292	aa					.byte	$aa
.2293					_end11:
>2293	05					.byte	_end12-*
>2294	00					.byte	$00
>2295	08 12					.word	Add
>2297	ab					.byte	$ab
.2298					_end12:
>2298	06					.byte	_end13-*
>2299	00					.byte	$00
>229a	30 16					.word	WordAdd
>229c	2b a1					.byte	$2b,$a1
.229e					_end13:
>229e	05					.byte	_end14-*
>229f	00					.byte	$00
>22a0	17 12					.word	Subtract
>22a2	ad					.byte	$ad
.22a3					_end14:
>22a3	06					.byte	_end15-*
>22a4	00					.byte	$00
>22a5	d7 14					.word	ConstantMinus1
>22a7	2d b1					.byte	$2d,$b1
.22a9					_end15:
>22a9	06					.byte	_end16-*
>22aa	00					.byte	$00
>22ab	d0 1e					.word	DumpStack
>22ad	2e ae					.byte	$2e,$ae
.22af					_end16:
>22af	05					.byte	_end17-*
>22b0	00					.byte	$00
>22b1	ec 12					.word	Divide16x16
>22b3	af					.byte	$af
.22b4					_end17:
>22b4	05					.byte	_end18-*
>22b5	00					.byte	$00
>22b6	ca 14					.word	Constant0
>22b8	b0					.byte	$b0
.22b9					_end18:
>22b9	06					.byte	_end19-*
>22ba	00					.byte	$00
>22bb	30 14					.word	CheckMinus
>22bd	30 bc					.byte	$30,$bc
.22bf					_end19:
>22bf	06					.byte	_end20-*
>22c0	00					.byte	$00
>22c1	44 14					.word	CheckZero
>22c3	30 bd					.byte	$30,$bd
.22c5					_end20:
>22c5	05					.byte	_end21-*
>22c6	00					.byte	$00
>22c7	e6 14					.word	C1
>22c9	b1					.byte	$b1
.22ca					_end21:
>22ca	06					.byte	_end22-*
>22cb	00					.byte	$00
>22cc	da 13					.word	Unary1Plus
>22ce	31 ab					.byte	$31,$ab
.22d0					_end22:
>22d0	06					.byte	_end23-*
>22d1	00					.byte	$00
>22d2	f1 13					.word	Unary1Minus
>22d4	31 ad					.byte	$31,$ad
.22d6					_end23:
>22d6	06					.byte	_end24-*
>22d7	00					.byte	$00
>22d8	fe 14					.word	C10
>22da	31 b0					.byte	$31,$b0
.22dc					_end24:
>22dc	07					.byte	_end25-*
>22dd	00					.byte	$00
>22de	27 15					.word	C100
>22e0	31 30 b0				.byte	$31,$30,$b0
.22e3					_end25:
>22e3	08					.byte	_end26-*
>22e4	00					.byte	$00
>22e5	56 15					.word	C1024
>22e7	31 30 32 b4				.byte	$31,$30,$32,$b4
.22eb					_end26:
>22eb	07					.byte	_end27-*
>22ec	00					.byte	$00
>22ed	2b 15					.word	C127
>22ef	31 32 b7				.byte	$31,$32,$b7
.22f2					_end27:
>22f2	07					.byte	_end28-*
>22f3	00					.byte	$00
>22f4	2f 15					.word	C128
>22f6	31 32 b8				.byte	$31,$32,$b8
.22f9					_end28:
>22f9	06					.byte	_end29-*
>22fa	00					.byte	$00
>22fb	02 15					.word	C15
>22fd	31 b5					.byte	$31,$b5
.22ff					_end29:
>22ff	06					.byte	_end30-*
>2300	00					.byte	$00
>2301	06 15					.word	C16
>2303	31 b6					.byte	$31,$b6
.2305					_end30:
>2305	07					.byte	_end31-*
>2306	00					.byte	$00
>2307	68 14					.word	Times16
>2309	31 36 aa				.byte	$31,$36,$aa
.230c					_end31:
>230c	07					.byte	_end32-*
>230d	00					.byte	$00
>230e	7b 14					.word	Divide16
>2310	31 36 af				.byte	$31,$36,$af
.2313					_end32:
>2313	05					.byte	_end33-*
>2314	00					.byte	$00
>2315	ea 14					.word	C2
>2317	b2					.byte	$b2
.2318					_end33:
>2318	06					.byte	_end34-*
>2319	00					.byte	$00
>231a	74 14					.word	Times2
>231c	32 aa					.byte	$32,$aa
.231e					_end34:
>231e	06					.byte	_end35-*
>231f	00					.byte	$00
>2320	e3 13					.word	Unary2Plus
>2322	32 ab					.byte	$32,$ab
.2324					_end35:
>2324	06					.byte	_end36-*
>2325	00					.byte	$00
>2326	fc 13					.word	Unary2Minus
>2328	32 ad					.byte	$32,$ad
.232a					_end36:
>232a	06					.byte	_end37-*
>232b	00					.byte	$00
>232c	87 14					.word	Divide2
>232e	32 af					.byte	$32,$af
.2330					_end37:
>2330	06					.byte	_end38-*
>2331	00					.byte	$00
>2332	0a 15					.word	C24
>2334	32 b4					.byte	$32,$b4
.2336					_end38:
>2336	07					.byte	_end39-*
>2337	00					.byte	$00
>2338	33 15					.word	C255
>233a	32 35 b5				.byte	$32,$35,$b5
.233d					_end39:
>233d	07					.byte	_end40-*
>233e	00					.byte	$00
>233f	3e 15					.word	C256
>2341	32 35 b6				.byte	$32,$35,$b6
.2344					_end40:
>2344	08					.byte	_end41-*
>2345	00					.byte	$00
>2346	8e 14					.word	Times256
>2348	32 35 36 aa				.byte	$32,$35,$36,$aa
.234c					_end41:
>234c	08					.byte	_end42-*
>234d	00					.byte	$00
>234e	97 14					.word	Divide256
>2350	32 35 36 af				.byte	$32,$35,$36,$af
.2354					_end42:
>2354	05					.byte	_end43-*
>2355	00					.byte	$00
>2356	ee 14					.word	C3
>2358	b3					.byte	$b3
.2359					_end43:
>2359	06					.byte	_end44-*
>235a	00					.byte	$00
>235b	1b 15					.word	C32
>235d	33 b2					.byte	$33,$b2
.235f					_end44:
>235f	09					.byte	_end45-*
>2360	00					.byte	$00
>2361	6e 15					.word	C32767
>2363	33 32 37 36 b7				.byte	$33,$32,$37,$36,$b7
.2368					_end45:
>2368	09					.byte	_end46-*
>2369	00					.byte	$00
>236a	7a 15					.word	C32768
>236c	33 32 37 36 b8				.byte	$33,$32,$37,$36,$b8
.2371					_end46:
>2371	05					.byte	_end47-*
>2372	00					.byte	$00
>2373	f2 14					.word	C4
>2375	b4					.byte	$b4
.2376					_end47:
>2376	06					.byte	_end48-*
>2377	00					.byte	$00
>2378	70 14					.word	Times4
>237a	34 aa					.byte	$34,$aa
.237c					_end48:
>237c	06					.byte	_end49-*
>237d	00					.byte	$00
>237e	83 14					.word	Divide4
>2380	34 af					.byte	$34,$af
.2382					_end49:
>2382	08					.byte	_end50-*
>2383	00					.byte	$00
>2384	62 15					.word	C4096
>2386	34 30 39 b6				.byte	$34,$30,$39,$b6
.238a					_end50:
>238a	05					.byte	_end51-*
>238b	00					.byte	$00
>238c	f6 14					.word	C5
>238e	b5					.byte	$b5
.238f					_end51:
>238f	07					.byte	_end52-*
>2390	00					.byte	$00
>2391	4a 15					.word	C512
>2393	35 31 b2				.byte	$35,$31,$b2
.2396					_end52:
>2396	06					.byte	_end53-*
>2397	00					.byte	$00
>2398	1f 15					.word	C63
>239a	36 b3					.byte	$36,$b3
.239c					_end53:
>239c	06					.byte	_end54-*
>239d	00					.byte	$00
>239e	23 15					.word	C64
>23a0	36 b4					.byte	$36,$b4
.23a2					_end54:
>23a2	05					.byte	_end55-*
>23a3	00					.byte	$00
>23a4	fa 14					.word	C8
>23a6	b8					.byte	$b8
.23a7					_end55:
>23a7	06					.byte	_end56-*
>23a8	00					.byte	$00
>23a9	6c 14					.word	Times8
>23ab	38 aa					.byte	$38,$aa
.23ad					_end56:
>23ad	06					.byte	_end57-*
>23ae	00					.byte	$00
>23af	7f 14					.word	Divide8
>23b1	38 af					.byte	$38,$af
.23b3					_end57:
>23b3	05					.byte	_end58-*
>23b4	40					.byte	$40
>23b5	c3 1a					.word	ReturnHandler
>23b7	bb					.byte	$bb
.23b8					_end58:
>23b8	05					.byte	_end59-*
>23b9	00					.byte	$00
>23ba	88 12					.word	CheckLess
>23bc	bc					.byte	$bc
.23bd					_end59:
>23bd	06					.byte	_end60-*
>23be	00					.byte	$00
>23bf	a1 12					.word	CheckLessEq
>23c1	3c bd					.byte	$3c,$bd
.23c3					_end60:
>23c3	06					.byte	_end61-*
>23c4	00					.byte	$00
>23c5	51 12					.word	CheckNotEqual
>23c7	3c be					.byte	$3c,$be
.23c9					_end61:
>23c9	05					.byte	_end62-*
>23ca	00					.byte	$00
>23cb	54 12					.word	CheckEqual
>23cd	bd					.byte	$bd
.23ce					_end62:
>23ce	05					.byte	_end63-*
>23cf	00					.byte	$00
>23d0	a4 12					.word	CheckGreater
>23d2	be					.byte	$be
.23d3					_end63:
>23d3	06					.byte	_end64-*
>23d4	00					.byte	$00
>23d5	85 12					.word	CheckGreaterEq
>23d7	3e bd					.byte	$3e,$bd
.23d9					_end64:
>23d9	08					.byte	_end65-*
>23da	00					.byte	$00
>23db	8f 15					.word	TestDup
>23dd	3f 44 55 d0				.byte	$3f,$44,$55,$d0
.23e1					_end65:
>23e1	05					.byte	_end66-*
>23e2	00					.byte	$00
>23e3	04 16					.word	WordRead
>23e5	c0					.byte	$c0
.23e6					_end66:
>23e6	07					.byte	_end67-*
>23e7	00					.byte	$00
>23e8	0a 14					.word	Absolute
>23ea	41 42 d3				.byte	$41,$42,$d3
.23ed					_end67:
>23ed	09					.byte	_end68-*
>23ee	00					.byte	$00
>23ef	47 16					.word	AllocateMemory
>23f1	41 4c 4c 4f c3				.byte	$41,$4c,$4c,$4f,$c3
.23f6					_end68:
>23f6	07					.byte	_end69-*
>23f7	00					.byte	$00
>23f8	2a 12					.word	And
>23fa	41 4e c4				.byte	$41,$4e,$c4
.23fd					_end69:
>23fd	0a					.byte	_end70-*
>23fe	00					.byte	$00
>23ff	5b 1e					.word	AssertCode
>2401	41 53 53 45 52 d4			.byte	$41,$53,$53,$45,$52,$d4
.2407					_end70:
>2407	09					.byte	_end71-*
>2408	00					.byte	$00
>2409	5d 14					.word	ByteSwap
>240b	42 53 57 41 d0				.byte	$42,$53,$57,$41,$d0
.2410					_end71:
>2410	06					.byte	_end72-*
>2411	00					.byte	$00
>2412	12 16					.word	ByteWrite
>2414	43 a1					.byte	$43,$a1
.2416					_end72:
>2416	06					.byte	_end73-*
>2417	00					.byte	$00
>2418	fb 15					.word	ByteRead
>241a	43 c0					.byte	$43,$c0
.241c					_end73:
>241c	07					.byte	_end74-*
>241d	00					.byte	$00
>241e	84 1b					.word	ClrHandler
>2420	43 4c d2				.byte	$43,$4c,$d2
.2423					_end74:
>2423	08					.byte	_end75-*
>2424	00					.byte	$00
>2425	86 15					.word	Drop
>2427	44 52 4f d0				.byte	$44,$52,$4f,$d0
.242b					_end75:
>242b	07					.byte	_end76-*
>242c	00					.byte	$00
>242d	98 15					.word	Dup
>242f	44 55 d0				.byte	$44,$55,$d0
.2432					_end76:
>2432	08					.byte	_end77-*
>2433	01					.byte	$01
>2434	10 1a					.word	ElseHandler
>2436	45 4c 53 c5				.byte	$45,$4c,$53,$c5
.243a					_end77:
>243a	07					.byte	_end78-*
>243b	00					.byte	$00
>243c	7c 1e					.word	EndProgram
>243e	45 4e c4				.byte	$45,$4e,$c4
.2441					_end78:
>2441	09					.byte	_end79-*
>2442	00					.byte	$00
>2443	13 1a					.word	EndIfHandler
>2445	45 4e 44 49 c6				.byte	$45,$4e,$44,$49,$c6
.244a					_end79:
>244a	07					.byte	_end80-*
>244b	00					.byte	$00
>244c	88 19					.word	ForHandler
>244e	46 4f d2				.byte	$46,$4f,$d2
.2451					_end80:
>2451	06					.byte	_end81-*
>2452	01					.byte	$01
>2453	0d 1a					.word	IfHandler
>2455	49 c6					.byte	$49,$c6
.2457					_end81:
>2457	09					.byte	_end82-*
>2458	00					.byte	$00
>2459	ec 19					.word	GetIndex
>245b	49 4e 44 45 d8				.byte	$49,$4e,$44,$45,$d8
.2460					_end82:
>2460	08					.byte	_end83-*
>2461	00					.byte	$00
>2462	b3 1d					.word	ListCode
>2464	4c 49 53 d4				.byte	$4c,$49,$53,$d4
.2468					_end83:
>2468	07					.byte	_end84-*
>2469	00					.byte	$00
>246a	c1 12					.word	Maximum
>246c	4d 41 d8				.byte	$4d,$41,$d8
.246f					_end84:
>246f	07					.byte	_end85-*
>2470	00					.byte	$00
>2471	bd 12					.word	Minimum
>2473	4d 49 ce				.byte	$4d,$49,$ce
.2476					_end85:
>2476	07					.byte	_end86-*
>2477	00					.byte	$00
>2478	fd 12					.word	Modulus16x16
>247a	4d 4f c4				.byte	$4d,$4f,$c4
.247d					_end86:
>247d	0a					.byte	_end87-*
>247e	00					.byte	$00
>247f	11 14					.word	Negate
>2481	4e 45 47 41 54 c5			.byte	$4e,$45,$47,$41,$54,$c5
.2487					_end87:
>2487	07					.byte	_end88-*
>2488	00					.byte	$00
>2489	7b 1b					.word	NewHandler
>248b	4e 45 d7				.byte	$4e,$45,$d7
.248e					_end88:
>248e	08					.byte	_end89-*
>248f	01					.byte	$01
>2490	b6 19					.word	NextHandler
>2492	4e 45 58 d4				.byte	$4e,$45,$58,$d4
.2496					_end89:
>2496	07					.byte	_end90-*
>2497	00					.byte	$00
>2498	cc 15					.word	Nip
>249a	4e 49 d0				.byte	$4e,$49,$d0
.249d					_end90:
>249d	07					.byte	_end91-*
>249e	00					.byte	$00
>249f	21 14					.word	OneComplement
>24a1	4e 4f d4				.byte	$4e,$4f,$d4
.24a4					_end91:
>24a4	06					.byte	_end92-*
>24a5	00					.byte	$00
>24a6	44 12					.word	LogOr
>24a8	4f d2					.byte	$4f,$d2
.24aa					_end92:
>24aa	08					.byte	_end93-*
>24ab	00					.byte	$00
>24ac	b4 15					.word	Over
>24ae	4f 56 45 d2				.byte	$4f,$56,$45,$d2
.24b2					_end93:
>24b2	0a					.byte	_end94-*
>24b3	00					.byte	$00
>24b4	16 1a					.word	RepeatHandler
>24b6	52 45 50 45 41 d4			.byte	$52,$45,$50,$45,$41,$d4
.24bc					_end94:
>24bc	07					.byte	_end95-*
>24bd	00					.byte	$00
>24be	a0 14					.word	RandomNumber
>24c0	52 4e c4				.byte	$52,$4e,$c4
.24c3					_end95:
>24c3	07					.byte	_end96-*
>24c4	00					.byte	$00
>24c5	d1 15					.word	Rot
>24c7	52 4f d4				.byte	$52,$4f,$d4
.24ca					_end96:
>24ca	07					.byte	_end97-*
>24cb	00					.byte	$00
>24cc	30 1e					.word	RunProgram
>24ce	52 55 ce				.byte	$52,$55,$ce
.24d1					_end97:
>24d1	07					.byte	_end98-*
>24d2	00					.byte	$00
>24d3	4c 14					.word	SignTOS
>24d5	53 47 ce				.byte	$53,$47,$ce
.24d8					_end98:
>24d8	08					.byte	_end99-*
>24d9	00					.byte	$00
>24da	74 1e					.word	StopCode
>24dc	53 54 4f d0				.byte	$53,$54,$4f,$d0
.24e0					_end99:
>24e0	08					.byte	_end100-*
>24e1	00					.byte	$00
>24e2	a1 15					.word	Swap
>24e4	53 57 41 d0				.byte	$53,$57,$41,$d0
.24e8					_end100:
>24e8	07					.byte	_end101-*
>24e9	00					.byte	$00
>24ea	44 1e					.word	Call6502
>24ec	53 59 d3				.byte	$53,$59,$d3
.24ef					_end101:
>24ef	0d					.byte	_end102-*
>24f0	00					.byte	$00
>24f1	07 20					.word	IntToString
>24f3	54 4f 2e 53 54 52 49 4e			.byte	$54,$4f,$2e,$53,$54,$52,$49,$4e,$c7
>24fb	c7
.24fc					_end102:
>24fc	09					.byte	_end103-*
>24fd	01					.byte	$01
>24fe	19 1a					.word	UntilHandler
>2500	55 4e 54 49 cc				.byte	$55,$4e,$54,$49,$cc
.2505					_end103:
>2505	09					.byte	_end104-*
>2506	00					.byte	$00
>2507	7f 1e					.word	VlistCode
>2509	56 4c 49 53 d4				.byte	$56,$4c,$49,$53,$d4
.250e					_end104:
>250e	0a					.byte	_end105-*
>250f	40					.byte	$40
>2510	cf 1b					.word	BreakCmd
>2512	58 42 52 45 41 cb			.byte	$58,$42,$52,$45,$41,$cb
.2518					_end105:
>2518	09					.byte	_end106-*
>2519	00					.byte	$00
>251a	c9 1b					.word	ExitDump
>251c	58 44 55 4d d0				.byte	$58,$44,$55,$4d,$d0
.2521					_end106:
>2521	07					.byte	_end107-*
>2522	00					.byte	$00
>2523	37 12					.word	Xor
>2525	58 4f d2				.byte	$58,$4f,$d2
.2528					_end107:
>2528	00					.byte	0

;******  Return to file: kernel.asm

>3fff	ff						.byte 	$FF
.4000					ProgramMemory:

;******  End of listing
