
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -q -D encode=0 -c -o kernel_nocode.prg -L kernel.lst -l kernel.lbl kernel.asm
; Sun Jan 19 09:06:55 2020

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=0					encode=0

;******  Processing input file: kernel.asm

=$1000					RplBuild = $1000 							; code starts here.
=$9eff					LastMemoryByte = $9EFF 						; program ends here

;******  Processing file: code/data.asm

.0000					NextCode:
>0000							.fill 	8
=5					AltCode = NextCode+5 						; Patch goes here.
=3					IP = NextCode+3 							; the IP which points to the current instruction
.0008					rsp:
>0008							.byte 	?
.0009					tos:
>0009							.word 	?
.000b					srcPtr:
>000b							.word 	?
.000d					bufPtr:
>000d							.word 	?
.000f					matchPtr:
>000f							.word 	?
.0011					nextFreeMem:
>0011							.word 	?
.0013					temp1:
>0013							.word 	?
.0015					temp2:
>0015							.word 	?
.0017					temp3:
>0017							.word 	?
.0019					temp4:
>0019							.word 	?
.001b					listPtr:
>001b							.word 	?
.001d					SignCount:
>001d							.byte 	?
.001e					RandomSeed:
>001e							.word 	?
.0020					ListCount:
>0020							.byte 	?
.0021					ListLowest:
>0021							.word 	?
.0023					BreakTestCount:
>0023							.byte 	?
.0024					FastMode:
>0024							.byte 	?
.0025					LineTable:
>0025							.word 	?
=$102					stack2Low = $102							; access other stack members following tsx
=$101					stack2High = $101							; (which requires saving X, not on the stack !)
=$104					stack3Low = $104
=$103					stack3High = $103
=$600					azVariables = $600 							; 26 x 2 variables occupying 52 bytes * PAGE BOUNDARY *
=16					hashTableSize = 16 							; hash tables for variables.
=$640					hashTable = $640 							; hash tables start here * ALL ON ONE PAGE *
=$810					textBuffer = $810 							; buffer for text.
=$700					returnStack = $700							; return stack (1 page)
=$700					returnStackLow = returnStack
=1856					returnStackHigh = returnStack+$40
=1920					returnStackX = returnStack+$80
=$80					NumberStackBase = $80 						; number stack down from here.
=$910					encodeBuffer = $910 						; buffer for encoded program
=0					COL_BLACK = 0
=1					COL_RED = 1
=2					COL_GREEN = 2
=3					COL_YELLOW = 3
=4					COL_BLUE = 4
=5					COL_MAGENTA = 5
=6					COL_CYAN = 6
=7					COL_WHITE = 7
=8					COL_RVS = 8
=2					CTH_LineNo = COL_Green
=6					CTH_Keyword = COL_Cyan
=11					CTH_Comment = COL_Yellow+COL_Rvs
=7					CTH_Definition = COL_White
=5					CTH_String = COL_Magenta
=3					CTH_Call = COL_Yellow
=7					CTH_Variable = COL_White

;******  Return to file: kernel.asm

.1000	4c e5 24	jmp $24e5			jmp 	ColdStart

;******  Processing file: files.asm


;******  Processing file: code/core.src

.1003					InitialiseCoreCode:
.1003	a9 7c		lda #$7c			lda 	#$7C 					; Copy JMP ($aaaa,x) 	6 cycles when run
.1005	85 02		sta $02				sta 	NextCode+2
.1007	86 03		stx $03				stx 	NextCode+3 				; set the indirect address (IP)
.1009	84 04		sty $04				sty 	NextCode+4
.100b	a9 4c		lda #$4c			lda 	#$4C 					; JMP AltHandler
.100d	85 05		sta $05				sta 	AltCode
.100f	a9 31		lda #$31			lda 	#AlternateHandler & $FF
.1011	85 06		sta $06				sta 	AltCode+1
.1013	a9 10		lda #$10			lda 	#AlternateHandler >> 8
.1015	85 07		sta $07				sta 	AltCode+2
.1017	20 1d 10	jsr $101d			jsr 	SetRunMode 				; set run mode to current
.101a	a2 01		ldx #$01			ldx 	#1 						; set up to run from provided word.
.101c	60		rts				rts								; (2 INX skip offset and line#)
.101d					SetRunMode:
.101d	a5 24		lda $24				lda 	FastMode
.101f	f0 07		beq $1028			beq 	_SRMSlow
.1021	a9 e8		lda #$e8			lda 	#$E8 					; Copy INX INX 			4 cycles when run
.1023	85 00		sta $00				sta 	NextCode
.1025	85 01		sta $01				sta 	NextCode+1
.1027	60		rts				rts
.1028					_SRMSlow:
.1028	a9 80		lda #$80			lda 	#$80	 				; BRA AltCode
.102a	85 00		sta $00				sta 	NextCode
.102c	a9 03		lda #$03			lda 	#AltCode-NextCode-2
.102e	85 01		sta $01				sta 	NextCode+1
.1030	60		rts				rts
.1031					AlternateHandler:
.1031	e8		inx				inx 							; patched in - does the INX that is overwritten
.1032	e8		inx				inx
.1033	86 13		stx $13				stx 	temp1 					; save it
.1035	ba		tsx				tsx 							; check underflow
.1036	e0 81		cpx #$81			cpx 	#$81
.1038	b0 11		bcs $104b			bcs 	_AHStackError
.103a	a6 13		ldx $13				ldx 	temp1
.103c	a5 23		lda $23				lda 	BreakTestCount 			; do a break test say 1 in 32
.103e	18		clc				clc
.103f	69 08		adc #$08			adc 	#8
.1041	85 23		sta $23				sta 	BreakTestCount
.1043	90 03		bcc $1048			bcc 	_AHNoTest
.1045	20 c6 25	jsr $25c6			jsr 	ExternCheckBreak
.1048					_AHNoTest:
.1048	4c 02 00	jmp $0002			jmp 	NextCode+2				; then the indirect jump.
.104b					_AHStackError:
.104b	20 7a 25	jsr $257a			jsr 	ErrorHandler
>104e	53 54 41 43 4b 20 55 4e				.text 	"STACK UNDERFLOW",0
>1056	44 45 52 46 4c 4f 57 00
.105e					SetSlowMode:
.105e	a9 00		lda #$00			lda 	#0
.1060	80 02		bra $1064			bra 	SetMode
.1062					SetFastMode:
.1062	a9 01		lda #$01			lda 	#1
.1064					SetMode:
.1064	85 24		sta $24				sta 	FastMode
.1066	20 1d 10	jsr $101d			jsr 	SetRunMode
.1069	4c 00 00	jmp $0000			jmp 	NextCode
.106c					HexLiteral2Byte:
.106c	ea		nop				nop 							; must have different address for decoding.
.106d					Literal2Byte:
.106d	a5 09		lda $09				lda 	TOS
.106f	48		pha				pha
.1070	a5 0a		lda $0a				lda 	TOS+1
.1072	48		pha				pha
.1073	e8		inx				inx  							; point X to the word
.1074	e8		inx				inx
.1075	8a		txa				txa 							; copy into Y
.1076	a8		tay				tay
.1077	b1 03		lda ($03),y			lda 	(IP),y 					; read it. the LSB
.1079	85 09		sta $09				sta 	TOS
.107b	c8		iny				iny 							; read and push the MSB
.107c	b1 03		lda ($03),y			lda 	(IP),y
.107e	85 0a		sta $0a				sta 	TOS+1
.1080	4c 00 00	jmp $0000			jmp 	NextCode
.1083					HexLiteral2ByteDecode:
.1083	a9 06		lda #$06			lda 	#CTH_Keyword
.1085	20 b6 19	jsr $19b6			jsr 	DecodeWriteBuffer
.1088	a9 24		lda #$24			lda 	#"$"
.108a	20 b6 19	jsr $19b6			jsr 	DecodeWriteBuffer
.108d	b1 0b		lda ($0b),y			lda 	(srcPtr),y
.108f	48		pha				pha
.1090	c8		iny				iny
.1091	b1 0b		lda ($0b),y			lda 	(srcPtr),y
.1093	c8		iny				iny
.1094	20 9c 10	jsr $109c			jsr 	HL2BDWrite
.1097	68		pla				pla
.1098	20 9c 10	jsr $109c			jsr 	HL2BDWrite
.109b	60		rts				rts
.109c					HL2BDWrite:
.109c	48		pha				pha
.109d	4a		lsr a				lsr 	a
.109e	4a		lsr a				lsr 	a
.109f	4a		lsr a				lsr 	a
.10a0	4a		lsr a				lsr 	a
.10a1	20 a5 10	jsr $10a5			jsr 	_HLNibble
.10a4	68		pla				pla
.10a5					_HLNibble:
.10a5	29 0f		and #$0f			and 	#$0F
.10a7	c9 0a		cmp #$0a			cmp 	#$0A
.10a9	90 03		bcc $10ae			bcc 	_HLNoAdjust
.10ab	18		clc				clc
.10ac	69 07		adc #$07			adc 	#7
.10ae					_HLNoAdjust:
.10ae	18		clc				clc
.10af	69 30		adc #$30			adc 	#48
.10b1	20 b6 19	jsr $19b6			jsr 	DecodeWriteBuffer
.10b4	60		rts				rts
.10b5					Literal2ByteDecode:
.10b5	a9 06		lda #$06			lda 	#CTH_Keyword
.10b7	20 b6 19	jsr $19b6			jsr 	DecodeWriteBuffer
.10ba	b1 0b		lda ($0b),y			lda 	(srcPtr),y
.10bc	aa		tax				tax
.10bd	c8		iny				iny
.10be	b1 0b		lda ($0b),y			lda 	(srcPtr),y
.10c0	a8		tay				tay
.10c1	8a		txa				txa
.10c2	38		sec				sec 							; output signed
.10c3	20 d8 19	jsr $19d8			jsr 	DecodeYAToBuffer
.10c6	60		rts				rts
.10c7					LiteralString:
.10c7	a5 09		lda $09				lda 	TOS
.10c9	48		pha				pha
.10ca	a5 0a		lda $0a				lda 	TOS+1
.10cc	48		pha				pha
.10cd	e8		inx				inx
.10ce	e8		inx				inx 							; skip over current word
.10cf	8a		txa				txa 							; add to IP + 1 to give string address
.10d0	a8		tay				tay 							; put in Y
.10d1	38		sec				sec 							; make that TOS
.10d2	65 03		adc $03				adc 	IP
.10d4	85 09		sta $09				sta 	TOS
.10d6	a5 04		lda $04				lda 	IP+1
.10d8	69 00		adc #$00			adc 	#0
.10da	85 0a		sta $0a				sta 	TOS+1
.10dc	8a		txa				txa 							; add data length to X
.10dd	18		clc				clc
.10de	71 03		adc ($03),y			adc 	(IP),y
.10e0	aa		tax				tax
.10e1	ca		dex				dex
.10e2	ca		dex				dex
.10e3	4c 00 00	jmp $0000			jmp 	NextCode
.10e6					LiteralStringDecoder:
.10e6	a9 05		lda #$05			lda 	#CTH_String
.10e8	20 b6 19	jsr $19b6			jsr 	DecodeWriteBuffer
.10eb	a9 22		lda #$22			lda 	#'"'
.10ed	20 b6 19	jsr $19b6			jsr 	DecodeWriteBuffer
.10f0	20 bf 19	jsr $19bf			jsr 	DecodeOutputData
.10f3	20 b6 19	jsr $19b6			jsr 	DecodeWriteBuffer
.10f6	60		rts				rts

;******  Return to file: files.asm


;******  Processing file: words/arithmetic/binary.src

.10f7					Add:
.10f7	7a		ply				ply
.10f8	68		pla				pla
.10f9	18		clc				clc
.10fa	65 09		adc $09				adc 	TOS
.10fc	85 09		sta $09				sta 	TOS
.10fe	98		tya				tya
.10ff	65 0a		adc $0a				adc 	TOS+1
.1101	85 0a		sta $0a				sta 	TOS+1
.1103	4c 00 00	jmp $0000			jmp 	NextCode
.1106					Subtract:
.1106	7a		ply				ply
.1107	68		pla				pla
.1108	38		sec				sec
.1109	e5 09		sbc $09				sbc 	TOS
.110b	85 09		sta $09				sta 	TOS
.110d	98		tya				tya
.110e	e5 0a		sbc $0a				sbc 	TOS+1
.1110	85 0a		sta $0a				sta 	TOS+1
.1112	4c 00 00	jmp $0000			jmp 	NextCode
.1115					And:
.1115	68		pla				pla
.1116	25 0a		and $0a				and 	TOS+1
.1118	85 0a		sta $0a				sta 	TOS+1
.111a	68		pla				pla
.111b	25 09		and $09				and 	TOS
.111d	85 09		sta $09				sta 	TOS
.111f	4c 00 00	jmp $0000			jmp 	NextCode
.1122					Xor:
.1122	68		pla				pla
.1123	45 0a		eor $0a				eor 	TOS+1
.1125	85 0a		sta $0a				sta 	TOS+1
.1127	68		pla				pla
.1128	45 09		eor $09				eor 	TOS
.112a	85 09		sta $09				sta 	TOS
.112c	4c 00 00	jmp $0000			jmp 	NextCode
.112f					LogOr:
.112f	68		pla				pla
.1130	05 0a		ora $0a				ora 	TOS+1
.1132	85 0a		sta $0a				sta 	TOS+1
.1134	68		pla				pla
.1135	05 09		ora $09				ora 	TOS
.1137	85 09		sta $09				sta 	TOS
.1139	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: files.asm


;******  Processing file: words/arithmetic/compare.src

.113c					CheckNotEqual:
.113c	38		sec				sec
.113d	80 01		bra $1140			bra 	CECode
.113f					CheckEqual:
.113f	18		clc				clc
.1140					CECode:
.1140	86 13		stx $13				stx 	temp1
.1142	ba		tsx				tsx
.1143	08		php				php
.1144	a5 09		lda $09				lda 	TOS
.1146	5d 02 01	eor $0102,x			eor 	Stack2Low,x
.1149	d0 17		bne $1162			bne	 	CompareFalse
.114b	a5 0a		lda $0a				lda 	TOS+1
.114d	5d 01 01	eor $0101,x			eor 	Stack2High,x
.1150	d0 10		bne $1162			bne 	CompareFalse
.1152					CompareTrue:
.1152	a6 13		ldx $13				ldx 	temp1
.1154	28		plp				plp
.1155	b0 10		bcs $1167			bcs		CompareFalse2
.1157					CompareTrue2:
.1157	68		pla				pla
.1158	68		pla				pla
.1159	a9 ff		lda #$ff			lda 	#$FF
.115b	85 09		sta $09				sta 	TOS
.115d	85 0a		sta $0a				sta 	TOS+1
.115f	4c 00 00	jmp $0000			jmp 	NextCode
.1162					CompareFalse:
.1162	a6 13		ldx $13				ldx 	temp1
.1164	28		plp				plp
.1165	b0 f0		bcs $1157			bcs		CompareTrue2
.1167					CompareFalse2:
.1167	68		pla				pla
.1168	68		pla				pla
.1169	64 09		stz $09				stz 	TOS
.116b	64 0a		stz $0a				stz 	TOS+1
.116d	4c 00 00	jmp $0000			jmp 	NextCode
.1170					CheckGreaterEq:
.1170	38		sec				sec
.1171	80 01		bra $1174			bra		CLCode
.1173					CheckLess:
.1173	18		clc				clc
.1174	86 13		stx $13		CLCode:	stx 	temp1
.1176	ba		tsx				tsx
.1177	08		php				php
.1178	18		clc				clc
.1179	a5 09		lda $09				lda 	TOS
.117b	fd 02 01	sbc $0102,x			sbc 	Stack2Low,x
.117e	a5 0a		lda $0a				lda 	TOS+1
.1180	fd 01 01	sbc $0101,x			sbc 	Stack2High,x
.1183	50 02		bvc $1187			bvc 	_CLNoFlip
.1185	49 80		eor #$80			eor 	#$80
.1187					_CLNoFlip:
.1187	0a		asl a				asl 	a
.1188	b0 d8		bcs $1162			bcs 	CompareFalse
.118a	80 c6		bra $1152			bra 	CompareTrue
.118c					CheckLessEq:
.118c	38		sec				sec
.118d	80 01		bra $1190			bra		CGCode
.118f					CheckGreater:
.118f	18		clc				clc
.1190					CGCode:
.1190	86 13		stx $13				stx 	temp1
.1192	ba		tsx				tsx
.1193	08		php				php
.1194	18		clc				clc
.1195	bd 02 01	lda $0102,x			lda 	Stack2Low,x
.1198	e5 09		sbc $09				sbc 	TOS
.119a	bd 01 01	lda $0101,x			lda 	Stack2High,x
.119d	e5 0a		sbc $0a				sbc 	TOS+1
.119f	50 02		bvc $11a3			bvc 	_CGNoFlip
.11a1	49 80		eor #$80			eor 	#$80
.11a3					_CGNoFlip:
.11a3	0a		asl a				asl 	a
.11a4	b0 bc		bcs $1162			bcs 	CompareFalse
.11a6	80 aa		bra $1152			bra 	CompareTrue
.11a8					Minimum:
.11a8	a9 00		lda #$00			lda 	#0
.11aa	80 02		bra $11ae			bra 	MinMaxCode
.11ac					Maximum:
.11ac	a9 80		lda #$80			lda 	#$80
.11ae					MinMaxCode:
.11ae	85 14		sta $14				sta 	temp1+1
.11b0	86 13		stx $13				stx 	temp1
.11b2	ba		tsx				tsx
.11b3	38		sec				sec
.11b4	a5 09		lda $09				lda 	TOS
.11b6	fd 02 01	sbc $0102,x			sbc 	Stack2Low,x
.11b9	a5 0a		lda $0a				lda 	TOS+1
.11bb	fd 01 01	sbc $0101,x			sbc 	Stack2High,x
.11be	50 02		bvc $11c2			bvc 	_MMNoFlip
.11c0	49 80		eor #$80			eor 	#$80
.11c2					_MMNoFlip:
.11c2	45 14		eor $14				eor 	temp1+1
.11c4	30 0a		bmi $11d0			bmi 	_MMNoCopy
.11c6	bd 02 01	lda $0102,x			lda 	Stack2Low,x
.11c9	85 09		sta $09				sta 	TOS
.11cb	bd 01 01	lda $0101,x			lda 	Stack2High,x
.11ce	85 0a		sta $0a				sta 	TOS+1
.11d0					_MMNoCopy:
.11d0	a6 13		ldx $13				ldx 	temp1
.11d2	68		pla				pla
.11d3	68		pla				pla
.11d4	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: files.asm


;******  Processing file: words/arithmetic/divide.src

.11d7					Divide16x16:
.11d7	86 15		stx $15				stx 	temp2
.11d9	ba		tsx				tsx
.11da	20 fd 11	jsr $11fd			jsr 	IntegerDivide
.11dd	68		pla				pla
.11de	85 0a		sta $0a				sta 	TOS+1
.11e0	68		pla				pla
.11e1	85 09		sta $09				sta 	TOS
.11e3	a6 15		ldx $15				ldx 	temp2
.11e5	4c 00 00	jmp $0000			jmp 	NextCode
.11e8					Modulus16x16:
.11e8	86 15		stx $15				stx 	temp2
.11ea	ba		tsx				tsx
.11eb	20 fd 11	jsr $11fd			jsr 	IntegerDivide
.11ee	a6 15		ldx $15				ldx 	temp2
.11f0	68		pla				pla
.11f1	68		pla				pla
.11f2	a5 13		lda $13				lda 	temp1
.11f4	85 09		sta $09				sta 	TOS
.11f6	a5 14		lda $14				lda 	temp1+1
.11f8	85 0a		sta $0a				sta 	TOS+1
.11fa	4c 00 00	jmp $0000			jmp 	NextCode
.11fd					IntegerDivide:
.11fd	a5 09		lda $09				lda 	TOS 				; check for division by zero.
.11ff	05 0a		ora $0a				ora 	TOS+1
.1201	d0 14		bne $1217			bne 	_BFDOkay
.1203	20 7a 25	jsr $257a			jsr 	ErrorHandler
>1206	44 49 56 49 53 49 4f 4e				.text 	"DIVISION BY ZERO",0
>120e	20 42 59 20 5a 45 52 4f 00
.1217					_BFDOkay:
.1217	64 13		stz $13				stz 	temp1 						; Q/Dividend/Left in +0
.1219	64 14		stz $14				stz 	temp1+1 					; M/Divisor/Right in +2
.121b	64 1d		stz $1d				stz 	SignCount 					; Count of signs.
.121d	20 58 12	jsr $1258			jsr 	CheckIntegerNegate 			; negate 2nd (and bump sign count)
.1220	20 72 12	jsr $1272			jsr 	CheckTOSNegate 				; negate TOS (and bump sign count)
.1223	5a		phy				phy 								; Y is the counter
.1224	a0 10		ldy #$10			ldy 	#16 						; 16 iterations of the loop.
.1226					_BFDLoop:
.1226	1e 02 01	asl $0102,x			asl 	Stack2Low,x 				; shift AQ left.
.1229	3e 01 01	rol $0101,x			rol 	Stack2High,x
.122c	26 13		rol $13				rol 	temp1
.122e	26 14		rol $14				rol 	temp1+1
.1230	38		sec				sec
.1231	a5 13		lda $13				lda 	temp1+0 					; Calculate A-M on stack.
.1233	e5 09		sbc $09				sbc 	TOS
.1235	48		pha				pha
.1236	a5 14		lda $14				lda 	temp1+1
.1238	e5 0a		sbc $0a				sbc 	TOS+1
.123a	90 0f		bcc $124b			bcc 	_BFDNoAdd
.123c	85 14		sta $14				sta 	temp1+1
.123e	68		pla				pla
.123f	85 13		sta $13				sta 	temp1+0
.1241	bd 02 01	lda $0102,x			lda 	Stack2Low,x 				; set Q bit 1.
.1244	09 01		ora #$01			ora 	#1
.1246	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.1249	80 01		bra $124c			bra 	_BFDNext
.124b					_BFDNoAdd:
.124b	68		pla				pla 								; Throw away the intermediate calculations
.124c					_BFDNext:
.124c	88		dey				dey
.124d	d0 d7		bne $1226			bne 	_BFDLoop
.124f	7a		ply				ply 								; restore Y
.1250	46 1d		lsr $1d				lsr 	SignCount 					; if sign count odd,
.1252	90 03		bcc $1257			bcc 	_BFDUnsigned 				; then the result is signed
.1254	20 5e 12	jsr $125e			jsr		IntegerNegateAlways 		; negate the result
.1257					_BFDUnsigned:
.1257	60		rts				rts
.1258					CheckIntegerNegate:
.1258	bd 01 01	lda $0101,x			lda 	Stack2High,x 				; is it -ve = MSB set ?
.125b	30 01		bmi $125e			bmi 	IntegerNegateAlways 		; if so negate it
.125d	60		rts				rts
.125e					IntegerNegateAlways:
.125e	e6 1d		inc $1d				inc 	SignCount 					; bump the count of signs
.1260	38		sec				sec 								; negate
.1261	a9 00		lda #$00			lda 	#0
.1263	fd 02 01	sbc $0102,x			sbc 	Stack2Low,x
.1266	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.1269	a9 00		lda #$00			lda 	#0
.126b	fd 01 01	sbc $0101,x			sbc 	Stack2High,x
.126e	9d 01 01	sta $0101,x			sta 	Stack2High,x
.1271	60		rts				rts
.1272					CheckTOSNegate:
.1272	a5 0a		lda $0a				lda 	TOS+1
.1274	10 0f		bpl $1285			bpl		CTNNoChange
.1276	e6 1d		inc $1d				inc 	SignCount
.1278					TOSNegateAlways:
.1278	38		sec				sec
.1279	a9 00		lda #$00			lda 	#0
.127b	e5 09		sbc $09				sbc 	TOS
.127d	85 09		sta $09				sta 	TOS
.127f	a9 00		lda #$00			lda 	#0
.1281	e5 0a		sbc $0a				sbc 	TOS+1
.1283	85 0a		sta $0a				sta 	TOS+1
.1285					CTNNoChange:
.1285	60		rts				rts

;******  Return to file: files.asm


;******  Processing file: words/arithmetic/multiply.src

.1286					Multiply16x16:
.1286	86 13		stx $13				stx 	temp1
.1288	ba		tsx				tsx
.1289	bd 02 01	lda $0102,x			lda 	Stack2Low,x 				; 2nd value on stack to temp1
.128c	85 15		sta $15				sta 	temp2
.128e	bd 01 01	lda $0101,x			lda		Stack2High,x
.1291	85 16		sta $16				sta 	temp2+1
.1293	9e 02 01	stz $0102,x			stz 	Stack2Low,x 				; zero 2nd value on stack
.1296	9e 01 01	stz $0101,x			stz 	Stack2High,x
.1299					_MultLoop:
.1299	46 16		lsr $16				lsr 	temp2+1 					; ror temp2 into C
.129b	66 15		ror $15				ror 	temp2
.129d	90 11		bcc $12b0			bcc 	_MultNoAdd
.129f	18		clc				clc 								; add 1st to 2nd
.12a0	a5 09		lda $09				lda 	TOS
.12a2	7d 02 01	adc $0102,x			adc 	Stack2Low,x
.12a5	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.12a8	a5 0a		lda $0a				lda 	TOS+1
.12aa	7d 01 01	adc $0101,x			adc 	Stack2High,x
.12ad	9d 01 01	sta $0101,x			sta 	Stack2High,x
.12b0					_MultNoAdd:
.12b0	06 09		asl $09				asl 	TOS 						; shift 1st left
.12b2	26 0a		rol $0a				rol 	TOS+1
.12b4	a5 15		lda $15				lda 	temp2	 					; until zero
.12b6	05 16		ora $16				ora 	temp2+1
.12b8	d0 df		bne $1299			bne 	_MultLoop
.12ba	a6 13		ldx $13				ldx 	temp1 						; restore X load result
.12bc	68		pla				pla
.12bd	85 0a		sta $0a				sta 	TOS+1
.12bf	68		pla				pla
.12c0	85 09		sta $09				sta 	TOS
.12c2	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: files.asm


;******  Processing file: words/arithmetic/unary.src

.12c5					Unary1Plus:
.12c5	e6 09		inc $09				inc 	TOS
.12c7	d0 02		bne $12cb			bne 	_U1PSkip
.12c9	e6 0a		inc $0a				inc 	TOS+1
.12cb					_U1PSkip:
.12cb	4c 00 00	jmp $0000			jmp 	NextCode
.12ce					Unary2Plus:
.12ce	18		clc				clc
.12cf	a5 09		lda $09				lda 	TOS
.12d1	69 02		adc #$02			adc 	#2
.12d3	85 09		sta $09				sta 	TOS
.12d5	90 02		bcc $12d9			bcc 	_U1PSkip
.12d7	e6 0a		inc $0a				inc 	TOS+1
.12d9					_U1PSkip:
.12d9	4c 00 00	jmp $0000			jmp 	NextCode
.12dc					Unary1Minus:
.12dc	a5 09		lda $09				lda 	TOS
.12de	d0 02		bne $12e2			bne 	_U1MSkip
.12e0	c6 0a		dec $0a				dec 	TOS+1
.12e2					_U1MSkip:
.12e2	c6 09		dec $09				dec 	TOS
.12e4	4c 00 00	jmp $0000			jmp 	NextCode
.12e7					Unary2Minus:
.12e7	38		sec				sec
.12e8	a5 09		lda $09				lda 	TOS
.12ea	e9 02		sbc #$02			sbc 	#2
.12ec	85 09		sta $09				sta 	TOS
.12ee	b0 02		bcs $12f2			bcs 	_U1PSkip
.12f0	c6 0a		dec $0a				dec 	TOS+1
.12f2					_U1PSkip:
.12f2	4c 00 00	jmp $0000			jmp 	NextCode
.12f5					Absolute:
.12f5	a5 0a		lda $0a				lda 	TOS+1
.12f7	30 03		bmi $12fc			bmi 	Negate
.12f9	4c 00 00	jmp $0000			jmp 	NextCode
.12fc					Negate:
.12fc	38		sec				sec
.12fd	a9 00		lda #$00			lda 	#0
.12ff	e5 09		sbc $09				sbc 	TOS
.1301	85 09		sta $09				sta 	TOS
.1303	a9 00		lda #$00			lda 	#0
.1305	e5 0a		sbc $0a				sbc 	TOS+1
.1307	85 0a		sta $0a				sta 	TOS+1
.1309	4c 00 00	jmp $0000			jmp 	NextCode
.130c					OneComplement:
.130c	a5 09		lda $09				lda 	TOS
.130e	49 ff		eor #$ff			eor 	#$FF
.1310	85 09		sta $09				sta 	TOS
.1312	a5 0a		lda $0a				lda 	TOS+1
.1314	49 ff		eor #$ff			eor 	#$FF
.1316	85 0a		sta $0a				sta 	TOS+1
.1318	4c 00 00	jmp $0000			jmp 	NextCode
.131b					CheckMinus:
.131b	a5 0a		lda $0a				lda 	TOS+1
.131d	30 07		bmi $1326			bmi 	UnaryTrue
.131f					UnaryFalse:
.131f	64 09		stz $09				stz 	TOS
.1321	64 0a		stz $0a				stz 	TOS+1
.1323	4c 00 00	jmp $0000			jmp 	NextCode
.1326					UnaryTrue:
.1326	a9 ff		lda #$ff			lda 	#$FF
.1328	85 09		sta $09				sta 	TOS
.132a	85 0a		sta $0a				sta 	TOS+1
.132c	4c 00 00	jmp $0000			jmp 	NextCode
.132f					CheckZero:
.132f	a5 09		lda $09				lda 	TOS
.1331	05 0a		ora $0a				ora 	TOS+1
.1333	d0 ea		bne $131f			bne 	UnaryFalse
.1335	80 ef		bra $1326			bra 	UnaryTrue
.1337					SignTOS:
.1337	a5 0a		lda $0a				lda 	TOS+1
.1339	30 eb		bmi $1326			bmi		UnaryTrue
.133b	05 09		ora $09				ora 	TOS
.133d	f0 e0		beq $131f			beq 	UnaryFalse
.133f	a9 01		lda #$01			lda 	#1
.1341	85 09		sta $09				sta 	TOS
.1343	64 0a		stz $0a				stz		TOS+1
.1345	4c 00 00	jmp $0000			jmp 	NextCode
.1348					ByteSwap:
.1348	a5 09		lda $09				lda 	TOS
.134a	a4 0a		ldy $0a				ldy 	TOS+1
.134c	85 0a		sta $0a				sta 	TOS+1
.134e	84 09		sty $09				sty 	TOS
.1350	4c 00 00	jmp $0000			jmp 	NextCode
.1353					Times16:
.1353	06 09		asl $09				asl 	TOS
.1355	26 0a		rol $0a				rol 	TOS+1
.1357					Times8:
.1357	06 09		asl $09				asl 	TOS
.1359	26 0a		rol $0a				rol 	TOS+1
.135b					Times4:
.135b	06 09		asl $09				asl 	TOS
.135d	26 0a		rol $0a				rol 	TOS+1
.135f					Times2:
.135f	06 09		asl $09				asl 	TOS
.1361	26 0a		rol $0a				rol 	TOS+1
.1363	4c 00 00	jmp $0000			jmp 	NextCode
.1366					Divide16:
.1366	46 0a		lsr $0a				lsr 	TOS+1
.1368	66 09		ror $09				ror 	TOS
.136a					Divide8:
.136a	46 0a		lsr $0a				lsr 	TOS+1
.136c	66 09		ror $09				ror 	TOS
.136e					Divide4:
.136e	46 0a		lsr $0a				lsr 	TOS+1
.1370	66 09		ror $09				ror 	TOS
.1372					Divide2:
.1372	46 0a		lsr $0a				lsr 	TOS+1
.1374	66 09		ror $09				ror 	TOS
.1376	4c 00 00	jmp $0000			jmp 	NextCode
.1379					Times256:
.1379	a5 09		lda $09				lda 	TOS
.137b	85 0a		sta $0a				sta 	TOS+1
.137d	64 09		stz $09				stz 	TOS
.137f	4c 00 00	jmp $0000			jmp 	NextCode
.1382					Divide256:
.1382	a5 0a		lda $0a				lda 	TOS+1
.1384	85 09		sta $09				sta 	TOS
.1386	64 0a		stz $0a				stz 	TOS+1
.1388	4c 00 00	jmp $0000			jmp 	NextCode
.138b					RandomNumber:
.138b	a5 09		lda $09				lda 	TOS
.138d	48		pha				pha
.138e	a5 0a		lda $0a				lda 	TOS+1
.1390	48		pha				pha
.1391	a5 1e		lda $1e				lda 	randomSeed
.1393	05 1f		ora $1f				ora 	randomSeed+1
.1395	d0 08		bne $139f			bne 	_RH_NoInit
.1397	a9 7c		lda #$7c			lda 	#$7C
.1399	85 1e		sta $1e				sta 	randomSeed
.139b	a9 a1		lda #$a1			lda 	#$A1
.139d	85 1f		sta $1f				sta 	randomSeed+1
.139f					_RH_NoInit:
.139f	a5 1e		lda $1e				lda 	randomSeed
.13a1	4a		lsr a		        lsr		a
.13a2	26 1f		rol $1f		        rol 	randomSeed+1
.13a4	90 02		bcc $13a8	        bcc 	_RH_NoEor
.13a6	49 b4		eor #$b4	        eor 	#$B4
.13a8					_RH_NoEor:
.13a8	85 1e		sta $1e		        sta 	randomSeed
.13aa	45 1f		eor $1f		        eor 	randomSeed+1
.13ac	85 0a		sta $0a		        sta 	TOS+1
.13ae	a5 1e		lda $1e		        lda 	randomSeed
.13b0	85 09		sta $09		        sta 	TOS
.13b2	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: files.asm


;******  Processing file: words/data/literals.src

.13b5					Constant0:
.13b5	a5 09		lda $09				lda 	TOS
.13b7	48		pha				pha
.13b8	a5 0a		lda $0a				lda 	TOS+1
.13ba	48		pha				pha
.13bb	64 09		stz $09				stz 	TOS
.13bd	64 0a		stz $0a				stz 	TOS+1
.13bf	4c 00 00	jmp $0000			jmp 	NextCode
.13c2					ConstantMinus1:
.13c2	a5 09		lda $09				lda 	TOS
.13c4	48		pha				pha
.13c5	a5 0a		lda $0a				lda 	TOS+1
.13c7	48		pha				pha
.13c8	a9 ff		lda #$ff			lda 	#$FF
.13ca	85 09		sta $09				sta 	TOS
.13cc	85 0a		sta $0a				sta 	TOS+1
.13ce	4c 00 00	jmp $0000			jmp 	NextCode
.13d1					C1:
.13d1	a0 01		ldy #$01			ldy 	#1
.13d3	80 24		bra $13f9			bra 	Const1Byte
.13d5					C2:
.13d5	a0 02		ldy #$02			ldy 	#2
.13d7	80 20		bra $13f9			bra 	Const1Byte
.13d9					C3:
.13d9	a0 03		ldy #$03			ldy 	#3
.13db	80 1c		bra $13f9			bra 	Const1Byte
.13dd					C4:
.13dd	a0 04		ldy #$04			ldy 	#4
.13df	80 18		bra $13f9			bra 	Const1Byte
.13e1					C5:
.13e1	a0 05		ldy #$05			ldy 	#5
.13e3	80 14		bra $13f9			bra 	Const1Byte
.13e5					C8:
.13e5	a0 08		ldy #$08			ldy 	#8
.13e7	80 10		bra $13f9			bra 	Const1Byte
.13e9					C10:
.13e9	a0 0a		ldy #$0a			ldy 	#10
.13eb	80 0c		bra $13f9			bra 	Const1Byte
.13ed					C15:
.13ed	a0 0f		ldy #$0f			ldy 	#15
.13ef	80 08		bra $13f9			bra 	Const1Byte
.13f1					C16:
.13f1	a0 10		ldy #$10			ldy 	#16
.13f3	80 04		bra $13f9			bra 	Const1Byte
.13f5					C24:
.13f5	a0 18		ldy #$18			ldy 	#24
.13f7	80 00		bra $13f9			bra 	Const1Byte
.13f9					Const1Byte:
.13f9	a5 09		lda $09				lda 	TOS
.13fb	48		pha				pha
.13fc	a5 0a		lda $0a				lda 	TOS+1
.13fe	48		pha				pha
.13ff	84 09		sty $09				sty 	TOS
.1401	64 0a		stz $0a				stz 	TOS+1
.1403	4c 00 00	jmp $0000			jmp 	NextCode
.1406					C32:
.1406	a0 20		ldy #$20			ldy 	#32
.1408	80 ef		bra $13f9			bra 	Const1Byte
.140a					C63:
.140a	a0 3f		ldy #$3f			ldy 	#63
.140c	80 eb		bra $13f9			bra 	Const1Byte
.140e					C64:
.140e	a0 40		ldy #$40			ldy 	#64
.1410	80 e7		bra $13f9			bra 	Const1Byte
.1412					C100:
.1412	a0 64		ldy #$64			ldy 	#100
.1414	80 e3		bra $13f9			bra 	Const1Byte
.1416					C127:
.1416	a0 7f		ldy #$7f			ldy 	#127
.1418	80 df		bra $13f9			bra 	Const1Byte
.141a					C128:
.141a	a0 80		ldy #$80			ldy 	#128
.141c	80 db		bra $13f9			bra 	Const1Byte
.141e					C255:
.141e	a0 ff		ldy #$ff			ldy 	#255
.1420	80 d7		bra $13f9			bra 	Const1Byte
.1422					Const2Byte:
.1422	85 09		sta $09				sta 	TOS
.1424	84 0a		sty $0a				sty 	TOS+1
.1426	4c 00 00	jmp $0000			jmp 	NextCode
.1429					C256:
.1429	a5 09		lda $09				lda 	TOS
.142b	48		pha				pha
.142c	a5 0a		lda $0a				lda 	TOS+1
.142e	48		pha				pha
.142f	a9 00		lda #$00			lda 	#(256) & $FF
.1431	a0 01		ldy #$01			ldy 	#(256) >> 8
.1433	80 ed		bra $1422			bra 	Const2Byte
.1435					C512:
.1435	a5 09		lda $09				lda 	TOS
.1437	48		pha				pha
.1438	a5 0a		lda $0a				lda 	TOS+1
.143a	48		pha				pha
.143b	a9 00		lda #$00			lda 	#(512) & $FF
.143d	a0 02		ldy #$02			ldy 	#(512) >> 8
.143f	80 e1		bra $1422			bra 	Const2Byte
.1441					C1024:
.1441	a5 09		lda $09				lda 	TOS
.1443	48		pha				pha
.1444	a5 0a		lda $0a				lda 	TOS+1
.1446	48		pha				pha
.1447	a9 00		lda #$00			lda 	#(1024) & $FF
.1449	a0 04		ldy #$04			ldy 	#(1024) >> 8
.144b	80 d5		bra $1422			bra 	Const2Byte
.144d					C4096:
.144d	a5 09		lda $09				lda 	TOS
.144f	48		pha				pha
.1450	a5 0a		lda $0a				lda 	TOS+1
.1452	48		pha				pha
.1453	a9 00		lda #$00			lda 	#(4096) & $FF
.1455	a0 10		ldy #$10			ldy 	#(4096) >> 8
.1457	80 c9		bra $1422			bra 	Const2Byte
.1459					C32767:
.1459	a5 09		lda $09				lda 	TOS
.145b	48		pha				pha
.145c	a5 0a		lda $0a				lda 	TOS+1
.145e	48		pha				pha
.145f	a9 ff		lda #$ff			lda 	#(32767) & $FF
.1461	a0 7f		ldy #$7f			ldy 	#(32767) >> 8
.1463	80 bd		bra $1422			bra 	Const2Byte
.1465					C32768:
.1465	a5 09		lda $09				lda 	TOS
.1467	48		pha				pha
.1468	a5 0a		lda $0a				lda 	TOS+1
.146a	48		pha				pha
.146b	a9 00		lda #$00			lda 	#(32768) & $FF
.146d	a0 80		ldy #$80			ldy 	#(32768) >> 8
.146f	80 b1		bra $1422			bra 	Const2Byte

;******  Return to file: files.asm


;******  Processing file: words/data/stack.src

.1471					Drop:
.1471	68		pla				pla
.1472	85 0a		sta $0a				sta 	TOS+1
.1474	68		pla				pla
.1475	85 09		sta $09				sta 	TOS
.1477	4c 00 00	jmp $0000			jmp 	NextCode
.147a					TestDup:
.147a	a5 09		lda $09				lda 	TOS
.147c	05 0a		ora $0a				ora 	TOS+1
.147e	d0 03		bne $1483			bne 	Dup
.1480	4c 00 00	jmp $0000			jmp 	NextCode
.1483					Dup:
.1483	a5 09		lda $09				lda 	TOS
.1485	48		pha				pha
.1486	a5 0a		lda $0a				lda 	TOS+1
.1488	48		pha				pha
.1489	4c 00 00	jmp $0000			jmp 	NextCode
.148c					Swap:
.148c	86 13		stx $13				stx 	temp1
.148e	7a		ply				ply
.148f	fa		plx				plx
.1490	a5 09		lda $09				lda 	TOS
.1492	48		pha				pha
.1493	a5 0a		lda $0a				lda 	TOS+1
.1495	48		pha				pha
.1496	86 09		stx $09				stx 	TOS
.1498	84 0a		sty $0a				sty 	TOS+1
.149a	a6 13		ldx $13				ldx 	temp1
.149c	4c 00 00	jmp $0000			jmp 	NextCode
.149f					Over:
.149f	a5 09		lda $09				lda 	TOS
.14a1	48		pha				pha
.14a2	a5 0a		lda $0a				lda 	TOS+1
.14a4	48		pha				pha
.14a5	86 13		stx $13				stx 	temp1
.14a7	ba		tsx				tsx
.14a8	bd 04 01	lda $0104,x			lda 	stack3low,x
.14ab	85 09		sta $09				sta 	TOS
.14ad	bd 03 01	lda $0103,x			lda 	stack3High,x
.14b0	85 0a		sta $0a				sta 	TOS+1
.14b2	a6 13		ldx $13				ldx 	temp1
.14b4	4c 00 00	jmp $0000			jmp 	NextCode
.14b7					Nip:
.14b7	68		pla				pla
.14b8	68		pla				pla
.14b9	4c 00 00	jmp $0000			jmp 	NextCode
.14bc					Rot:
.14bc	86 13		stx $13				stx 	temp1
.14be	ba		tsx				tsx
.14bf	bd 04 01	lda $0104,x			lda 	Stack3Low,x
.14c2	a8		tay				tay
.14c3	bd 02 01	lda $0102,x			lda 	Stack2Low,x
.14c6	9d 04 01	sta $0104,x			sta 	Stack3Low,x
.14c9	a5 09		lda $09				lda 	TOS
.14cb	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.14ce	84 09		sty $09				sty 	TOS
.14d0	bd 03 01	lda $0103,x			lda 	Stack3High,x
.14d3	a8		tay				tay
.14d4	bd 01 01	lda $0101,x			lda 	Stack2High,x
.14d7	9d 03 01	sta $0103,x			sta 	Stack3High,x
.14da	a5 0a		lda $0a				lda 	TOS+1
.14dc	9d 01 01	sta $0101,x			sta 	Stack2High,x
.14df	84 0a		sty $0a				sty 	TOS+1
.14e1	a6 13		ldx $13				ldx 	temp1
.14e3	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: files.asm


;******  Processing file: words/data/memory.src

.14e6					ByteRead:
.14e6	b2 09		lda ($09)			lda 	(TOS)
.14e8	85 09		sta $09				sta 	TOS
.14ea	64 0a		stz $0a				stz 	TOS+1
.14ec	4c 00 00	jmp $0000			jmp 	NextCode
.14ef					WordRead:
.14ef	a0 01		ldy #$01			ldy 	#1
.14f1	b1 09		lda ($09),y			lda 	(TOS),y
.14f3	a8		tay				tay
.14f4	b2 09		lda ($09)			lda 	(TOS)
.14f6	85 09		sta $09				sta 	TOS
.14f8	84 0a		sty $0a				sty 	TOS+1
.14fa	4c 00 00	jmp $0000			jmp 	NextCode
.14fd					ByteWrite:
.14fd	68		pla				pla
.14fe	68		pla				pla
.14ff	92 09		sta ($09)			sta 	(TOS)
.1501	68		pla				pla
.1502	85 0a		sta $0a				sta 	TOS+1
.1504	68		pla				pla
.1505	85 09		sta $09				sta 	TOS
.1507	4c 00 00	jmp $0000			jmp 	NextCode
.150a					WordWrite:
.150a	68		pla				pla
.150b	a0 01		ldy #$01			ldy 	#1
.150d	91 09		sta ($09),y			sta 	(TOS),y
.150f	68		pla				pla
.1510	92 09		sta ($09)			sta 	(TOS)
.1512	68		pla				pla
.1513	85 0a		sta $0a				sta 	TOS+1
.1515	68		pla				pla
.1516	85 09		sta $09				sta 	TOS
.1518	4c 00 00	jmp $0000			jmp 	NextCode
.151b					WordAdd:
.151b	7a		ply				ply
.151c	68		pla				pla
.151d	18		clc				clc
.151e	72 09		adc ($09)			adc 	(TOS)
.1520	92 09		sta ($09)			sta 	(TOS)
.1522	98		tya				tya
.1523	a0 01		ldy #$01			ldy 	#1
.1525	71 09		adc ($09),y			adc 	(TOS),y
.1527	91 09		sta ($09),y			sta 	(TOS),y
.1529	68		pla				pla
.152a	85 0a		sta $0a				sta 	TOS+1
.152c	68		pla				pla
.152d	85 09		sta $09				sta 	TOS
.152f	4c 00 00	jmp $0000			jmp 	NextCode
.1532					AllocateMemory:
.1532	a5 09		lda $09				lda 	TOS 						; save memory required on stack.
.1534	48		pha				pha
.1535	a5 0a		lda $0a				lda 	TOS+1
.1537	48		pha				pha
.1538	a5 11		lda $11				lda 	nextFreeMem 				; copy free mem address to TOS
.153a	85 09		sta $09				sta 	TOS
.153c	a5 12		lda $12				lda 	nextFreeMem+1
.153e	85 0a		sta $0a				sta 	TOS+1
.1540	7a		ply				ply 								; advance the free ram pointer
.1541	68		pla				pla
.1542	20 95 18	jsr $1895			jsr 	AdvanceFreeMem
.1545	20 a2 18	jsr $18a2			jsr 	CheckMemory 				; low on memory ?
.1548	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: files.asm


;******  Processing file: words/structures/fornext.src

.154b					ForHandler:
.154b	e6 08		inc $08				inc 	rsp 						; bump the RSP
.154d	a4 08		ldy $08				ldy 	rsp 						; get return stack and push TOS/$FF on it.
.154f	c0 40		cpy #$40			cpy 	#$40 						; overflow
.1551	f0 18		beq $156b			beq 	_FHOverflow
.1553	a5 0a		lda $0a				lda 	TOS+1
.1555	99 40 07	sta $0740,y			sta 	returnStackHigh,y
.1558	a5 09		lda $09				lda 	TOS
.155a	99 00 07	sta $0700,y			sta 	returnStackLow,y
.155d	a9 ff		lda #$ff			lda 	#$FF
.155f	99 80 07	sta $0780,y			sta 	returnStackX,y
.1562	68		pla				pla
.1563	85 0a		sta $0a				sta 	TOS+1
.1565	68		pla				pla
.1566	85 09		sta $09				sta 	TOS
.1568	4c 00 00	jmp $0000			jmp 	NextCode
.156b					_FHOverflow:
.156b	20 7a 25	jsr $257a			jsr 	ErrorHandler
>156e	53 54 52 55 43 54 55 52				.text 	"STRUCTURE OVERFLOW",0
>1576	45 20 4f 56 45 52 46 4c 4f 57 00
.1581					ForEncoder:
.1581	a9 4b		lda #$4b			lda 	#ForHandler & $FF 			; for handler
.1583	a0 15		ldy #$15			ldy 	#ForHandler >> 8
.1585	20 15 23	jsr $2315			jsr 	EncodeWriteWord
.1588	a9 46		lda #$46			lda 	#"F" 						; for marker
.158a	20 ab 23	jsr $23ab			jsr 	EncodePushPosMarkerOnStack
.158d	60		rts				rts
.158e					NextHandler:
.158e	da		phx				phx
.158f	a6 08		ldx $08				ldx 	rsp 						; get current stack ptr
.1591	bd 80 07	lda $0780,x			lda 	returnStackX,x 				; check it's a FOR Loop
.1594	c9 ff		cmp #$ff			cmp 	#$FF
.1596	d0 21		bne $15b9			bne 	NHNoFor
.1598	bd 00 07	lda $0700,x			lda 	returnStackLow,x 			; decrement the count
.159b	d0 03		bne $15a0			bne 	_NHNoBorrow
.159d	de 40 07	dec $0740,x			dec 	returnStackHigh,x
.15a0					_NHNoBorrow:
.15a0	de 00 07	dec $0700,x			dec 	returnStackLow,x
.15a3	bd 00 07	lda $0700,x			lda 	returnStackLow,x 			; have we reached the end ?
.15a6	1d 40 07	ora $0740,x			ora 	returnStackHigh,x
.15a9	fa		plx				plx 								; restore X and re-test
.15aa	09 00		ora #$00			ora 	#0
.15ac	f0 05		beq $15b3			beq 	_NHComplete 				; if so then complete, else loop.
.15ae	e8		inx				inx 								; advance to branch
.15af	e8		inx				inx
.15b0	4c d5 16	jmp $16d5			jmp 	BranchAlways
.15b3					_NHComplete:
.15b3	e8		inx				inx 								; skip over the branch quantity
.15b4	c6 08		dec $08				dec 	rsp 						; drop the indx
.15b6	4c 00 00	jmp $0000			jmp 	NextCode
.15b9					NHNoFor:
.15b9	20 7a 25	jsr $257a			jsr 	ErrorHandler
>15bc	4f 55 54 20 4f 46 20 46				.text 	"OUT OF FOR SCOPE",0
>15c4	4f 52 20 53 43 4f 50 45 00
.15cd					NextEncoder:
.15cd	a9 8e		lda #$8e			lda 	#NextHandler & $FF 			; next code
.15cf	a0 15		ldy #$15			ldy 	#NextHandler >> 8
.15d1	20 15 23	jsr $2315			jsr 	EncodeWriteWord
.15d4	a6 08		ldx $08				ldx 	rsp 						; get stack offset and pop
.15d6	c6 08		dec $08				dec 	rsp
.15d8	bd 40 07	lda $0740,x			lda 	returnStackHigh,x 			; check it is a for
.15db	c9 46		cmp #$46			cmp 	#"F"
.15dd	d0 07		bne $15e6			bne 	_NENoFor
.15df	bd 80 07	lda $0780,x			lda 	returnStackX,x 				; write the branch
.15e2	20 1f 23	jsr $231f			jsr 	EncodeWriteByte
.15e5	60		rts				rts
.15e6					_NENoFor:
.15e6	20 7a 25	jsr $257a			jsr 	ErrorHandler
>15e9	4d 49 53 53 49 4e 47 20				.text 	"MISSING FOR",0
>15f1	46 4f 52 00
.15f5					GetIndex:
.15f5	a4 08		ldy $08				ldy 	rsp 						; get current stack ptr
.15f7	b9 80 07	lda $0780,y			lda 	returnStackX,y 				; check it's a FOR Loop
.15fa	c9 ff		cmp #$ff			cmp 	#$FF
.15fc	d0 bb		bne $15b9			bne 	NHNoFor
.15fe	a5 09		lda $09				lda 	TOS
.1600	48		pha				pha
.1601	a5 0a		lda $0a				lda 	TOS+1
.1603	48		pha				pha
.1604	b9 00 07	lda $0700,y			lda 	returnStackLow,y 			; put counter-1 out
.1607	38		sec				sec
.1608	e9 01		sbc #$01			sbc 	#1
.160a	85 09		sta $09				sta 	TOS
.160c	b9 40 07	lda $0740,y			lda 	returnStackHigh,y
.160f	e9 00		sbc #$00			sbc 	#0
.1611	85 0a		sta $0a				sta 	TOS+1
.1613	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: files.asm


;******  Processing file: words/structures/ifelseendif.src

.1616					IfHandler:
.1616	4c bd 16	jmp $16bd			jmp 	BranchIfZero
.1619					IfEncoder:
.1619	a9 16		lda #$16			lda 	#IfHandler & $FF 			; if handler
.161b	a0 16		ldy #$16			ldy 	#IfHandler >> 8
.161d	20 15 23	jsr $2315			jsr 	EncodeWriteWord
.1620	a9 49		lda #$49			lda 	#"I" 						; if marker
.1622	20 ab 23	jsr $23ab			jsr 	EncodePushPosMarkerOnStack
.1625	a9 00		lda #$00			lda 	#0
.1627	20 1f 23	jsr $231f			jsr 	EncodeWriteByte 			; dummy write.
.162a	60		rts				rts
.162b					ElseHandler:
.162b	4c d3 16	jmp $16d3			jmp 	BranchTestSucceedsNoPop
.162e					ElseEncoder:
.162e	a9 2b		lda #$2b			lda 	#ElseHandler & $FF 			; else handler
.1630	a0 16		ldy #$16			ldy 	#ElseHandler >> 8
.1632	20 15 23	jsr $2315			jsr 	EncodeWriteWord
.1635	ad 10 09	lda $0910			lda 	encodeBuffer 				; push current position
.1638	48		pha				pha
.1639	a9 00		lda #$00			lda 	#0 							; zero branch
.163b	20 1f 23	jsr $231f			jsr 	EncodeWriteByte
.163e	20 5b 16	jsr $165b			jsr 	IfPatch 					; fix up the branch.
.1641	a9 49		lda #$49			lda 	#"I" 						; recreate if marker
.1643	20 ab 23	jsr $23ab			jsr 	EncodePushPosMarkerOnStack
.1646	68		pla				pla 								; address to patch
.1647	a6 08		ldx $08				ldx 	rsp
.1649	9d 80 07	sta $0780,x			sta 	returnStackX,x 				; and overwrite the target address
.164c	60		rts				rts
.164d					EndIfHandler:
.164d	4c 00 00	jmp $0000			jmp 	NextCode
.1650					EndIfEncoder:
.1650	a9 4d		lda #$4d			lda 	#EndIfHandler & $FF 		; endif handler
.1652	a0 16		ldy #$16			ldy 	#EndIfHandler >> 8
.1654	20 15 23	jsr $2315			jsr 	EncodeWriteWord
.1657	20 5b 16	jsr $165b			jsr 	IfPatch
.165a	60		rts				rts
.165b					IfPatch:
.165b	a6 08		ldx $08				ldx 	rsp 						; get stack offset and pop
.165d	c6 08		dec $08				dec 	rsp
.165f	bd 40 07	lda $0740,x			lda 	returnStackHigh,x 			; check it is an if.
.1662	c9 49		cmp #$49			cmp 	#"I"
.1664	d0 0b		bne $1671			bne 	_NENoIf
.1666	bd 80 07	lda $0780,x			lda 	returnStackX,x 				; this is what you patch.
.1669	aa		tax				tax
.166a	ad 10 09	lda $0910			lda 	encodeBuffer 				; with the current position.
.166d	9d 10 09	sta $0910,x			sta 	encodeBuffer,x
.1670	60		rts				rts
.1671					_NENoIf:
.1671	20 7a 25	jsr $257a			jsr 	ErrorHandler
>1674	4d 49 53 53 49 4e 47 20				.text 	"MISSING IF",0
>167c	49 46 00

;******  Return to file: files.asm


;******  Processing file: words/structures/repeatuntil.src

.167f					RepeatHandler:
.167f	4c 00 00	jmp $0000			jmp 	NextCode
.1682					RepeatEncoder:
.1682	a9 7f		lda #$7f			lda 	#RepeatHandler & $FF 		; repeat marker
.1684	a0 16		ldy #$16			ldy 	#RepeatHandler >> 8
.1686	20 15 23	jsr $2315			jsr 	EncodeWriteWord
.1689	a9 52		lda #$52			lda 	#"R" 						; repeat marker
.168b	20 ab 23	jsr $23ab			jsr 	EncodePushPosMarkerOnStack
.168e	60		rts				rts
.168f					UntilHandler:
.168f	4c bd 16	jmp $16bd			jmp 	BranchIfZero
.1692					UntilEncoder:
.1692	a9 8f		lda #$8f			lda 	#UntilHandler & $FF 		; until code
.1694	a0 16		ldy #$16			ldy 	#UntilHandler >> 8
.1696	20 15 23	jsr $2315			jsr 	EncodeWriteWord
.1699	a6 08		ldx $08				ldx 	rsp 						; get stack offset and pop
.169b	c6 08		dec $08				dec 	rsp
.169d	bd 40 07	lda $0740,x			lda 	returnStackHigh,x 			; check it is a repeat
.16a0	c9 52		cmp #$52			cmp 	#"R"
.16a2	d0 07		bne $16ab			bne 	_UENoRepeat
.16a4	bd 80 07	lda $0780,x			lda 	returnStackX,x 				; write the branch
.16a7	20 1f 23	jsr $231f			jsr 	EncodeWriteByte
.16aa	60		rts				rts
.16ab					_UENoRepeat:
.16ab	20 7a 25	jsr $257a			jsr 	ErrorHandler
>16ae	4d 49 53 53 49 4e 47 20				.text 	"MISSING REPEAT",0
>16b6	52 45 50 45 41 54 00

;******  Return to file: files.asm


;******  Processing file: words/system/branch.src

.16bd					BranchIfZero:
.16bd	a5 09		lda $09				lda 	TOS 						; check TOS = 0
.16bf	05 0a		ora $0a				ora 	TOS+1
.16c1	f0 0a		beq $16cd			beq 	BranchTestSucceeds
.16c3					BranchTestFails:
.16c3	68		pla				pla
.16c4	85 0a		sta $0a				sta 	TOS+1
.16c6	68		pla				pla
.16c7	85 09		sta $09				sta 	TOS
.16c9	e8		inx				inx 								; skip over the relative branch.
.16ca	4c 00 00	jmp $0000			jmp 	NextCode
.16cd					BranchTestSucceeds:
.16cd	68		pla				pla
.16ce	85 0a		sta $0a				sta 	TOS+1
.16d0	68		pla				pla
.16d1	85 09		sta $09				sta 	TOS
.16d3					BranchTestSucceedsNoPop:
.16d3	e8		inx				inx 								; advance by two, to the offset
.16d4	e8		inx				inx
.16d5					BranchAlways:
.16d5	8a		txa				txa 								; A = Y = position
.16d6	a8		tay				tay 								; (IP),Y now points to the branch target
.16d7	b1 03		lda ($03),y			lda 	(IP),y 						; adjust the position
.16d9	aa		tax				tax 								; position back in this line.
.16da	ca		dex				dex
.16db	ca		dex				dex
.16dc	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: files.asm


;******  Processing file: words/system/callhandler.src

.16df					CallHandler:
.16df	e8		inx				inx									; bump X to the call address.
.16e0	e8		inx				inx
.16e1	e6 08		inc $08				inc 	rsp 						; bump the RSP (first time to zero)
.16e3	a4 08		ldy $08				ldy 	rsp 						; get return stack and push IP/X on it.
.16e5	c0 40		cpy #$40			cpy 	#$40 						; overflow
.16e7	f0 35		beq $171e			beq 	_CHOverflow
.16e9	a5 04		lda $04				lda 	IP+1
.16eb	99 40 07	sta $0740,y			sta 	returnStackHigh,y
.16ee	a5 03		lda $03				lda 	IP
.16f0	99 00 07	sta $0700,y			sta 	returnStackLow,y
.16f3	8a		txa				txa
.16f4	99 80 07	sta $0780,y			sta 	returnStackX,y
.16f7	8a		txa				txa 								; get the line number into temp1.
.16f8	a8		tay				tay
.16f9	b1 03		lda ($03),y			lda 	(IP),y
.16fb	85 13		sta $13				sta 	temp1
.16fd	c8		iny				iny
.16fe	b1 03		lda ($03),y			lda 	(IP),y
.1700	85 14		sta $14				sta 	temp1+1
.1702	20 0f 1b	jsr $1b0f			jsr 	CallSearch
.1705	a0 03		ldy #$03			ldy 	#3	 						; check it begins with $$define
.1707	b1 03		lda ($03),y			lda 	(IP),y
.1709	c9 f5		cmp #$f5			cmp 	#DefineCode & $FF
.170b	d0 28		bne $1735			bne 	_CHNoDefine
.170d	c8		iny				iny
.170e	b1 03		lda ($03),y			lda 	(IP),y
.1710	c9 1d		cmp #$1d			cmp 	#DefineCode >> 8
.1712	d0 21		bne $1735			bne 	_CHNoDefine
.1714	c8		iny				iny
.1715	b1 03		lda ($03),y			lda 	(IP),y 						; this is the length of the define name
.1717	18		clc				clc
.1718	69 03		adc #$03			adc 	#5-2 						; $$define token, line number, offset - 2 for Next
.171a	aa		tax				tax
.171b	4c 00 00	jmp $0000			jmp 	NextCode
.171e					_CHOverflow:
.171e	20 7a 25	jsr $257a			jsr 	ErrorHandler
>1721	43 41 4c 4c 20 53 54 41				.text 	"CALL STACK OVERFLOW",0
>1729	43 4b 20 4f 56 45 52 46 4c 4f 57 00
.1735					_CHNoDefine:
.1735	20 7a 25	jsr $257a			jsr 	ErrorHandler
>1738	44 45 46 49 4e 45 20 4d				.text 	"DEFINE MISSING",0
>1740	49 53 53 49 4e 47 00
.1747					ReturnHandler:
.1747	a4 08		ldy $08				ldy 	rsp 						; get rsp
.1749	f0 15		beq $1760			beq 	_RHUnderflow 				; if -ve underflowed
.174b	c6 08		dec $08				dec 	rsp 						; decrement rsp
.174d	b9 40 07	lda $0740,y			lda 	returnStackHigh,y 			; restore IP/X
.1750	85 04		sta $04				sta 	IP+1
.1752	b9 00 07	lda $0700,y			lda 	returnStackLow,y
.1755	85 03		sta $03				sta 	IP
.1757	b9 80 07	lda $0780,y			lda 	returnStackX,y
.175a	aa		tax				tax
.175b	f0 15		beq $1772			beq 	_RHInLoop 					; this means you have done :something for ; next
.175d	4c 00 00	jmp $0000			jmp 	NextCode
.1760					_RHUnderflow:
.1760	20 7a 25	jsr $257a			jsr 	ErrorHandler
>1763	4d 49 53 53 49 4e 47 20				.text 	"MISSING RETURN",0
>176b	52 45 54 55 52 4e 00
.1772					_RHInLoop:
.1772	20 7a 25	jsr $257a			jsr 	ErrorHandler
>1775	52 45 54 55 52 4e 20 49				.text 	"RETURN IN LOOP ERROR",0
>177d	4e 20 4c 4f 4f 50 20 45 52 52 4f 52 00
.178a					CallHandlerDecode:
.178a	a9 03		lda #$03			lda 	#CTH_Call					; space
.178c	20 b6 19	jsr $19b6			jsr 	DecodeWriteBuffer
.178f	b1 0b		lda ($0b),y			lda 	(srcPtr),y 					; get line number into YA
.1791	aa		tax				tax
.1792	c8		iny				iny
.1793	b1 0b		lda ($0b),y			lda 	(srcPtr),y
.1795	a8		tay				tay
.1796	8a		txa				txa
.1797	20 d4 17	jsr $17d4			jsr 	FindLine 					; try to locate that line.
.179a	b0 11		bcs $17ad			bcs 	_CHDFound 					; if found .....
.179c					_CHDLineOnly:
.179c	48		pha				pha
.179d	a9 3c		lda #$3c			lda 	#"<"
.179f	20 b6 19	jsr $19b6			jsr 	DecodeWriteBuffer
.17a2	68		pla				pla
.17a3	18		clc				clc 								; output unsigned
.17a4	20 d8 19	jsr $19d8			jsr 	DecodeYAToBuffer
.17a7	a9 3e		lda #$3e			lda 	#">"
.17a9	20 b6 19	jsr $19b6			jsr 	DecodeWriteBuffer
.17ac	60		rts				rts
.17ad					_CHDFound:
.17ad	48		pha				pha 								; save YA
.17ae	5a		phy				phy
.17af	a0 03		ldy #$03			ldy 	#3 							; check first is $$define
.17b1	b1 13		lda ($13),y			lda 	(temp1),y
.17b3	c9 f5		cmp #$f5			cmp 	#DefineCode & 255
.17b5	d0 07		bne $17be			bne 	_CHDNoDefine
.17b7	c8		iny				iny
.17b8	b1 13		lda ($13),y			lda 	(temp1),y
.17ba	c9 1d		cmp #$1d			cmp 	#DefineCode >> 8
.17bc	f0 04		beq $17c2			beq 	_CHDFoundDefine
.17be					_CHDNoDefine:
.17be	7a		ply				ply									; restore the line number and print it in <>
.17bf	68		pla				pla
.17c0	80 da		bra $179c			bra 	_CHDLineOnly
.17c2					_CHDFoundDefine:
.17c2	68		pla				pla 								; throw saved line number.
.17c3	68		pla				pla
.17c4	a0 05		ldy #$05			ldy 	#5 							; 3,4 $$define 5 length, name has bit 7 set at end
.17c6					_CHDOutName:
.17c6	c8		iny				iny 								; next
.17c7	b1 13		lda ($13),y			lda 	(temp1),y 					; print char no bit 7
.17c9	48		pha				pha
.17ca	29 7f		and #$7f			and 	#$7F
.17cc	20 b6 19	jsr $19b6			jsr 	DecodeWriteBuffer
.17cf	68		pla				pla
.17d0	0a		asl a				asl 	a 							; bit 7 to carry
.17d1	90 f3		bcc $17c6			bcc 	_CHDOutName
.17d3	60		rts				rts
.17d4					FindLine:
.17d4	48		pha				pha 								; save registers
.17d5	da		phx				phx
.17d6	5a		phy				phy
.17d7	85 15		sta $15				sta 	temp2 						; temp2 = target line#
.17d9	84 16		sty $16				sty 	temp2+1
.17db	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.17dd	85 13		sta $13				sta 	0+(temp1)
.17df	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.17e1	85 14		sta $14				sta 	1+(temp1)
.17e3					_FLLoop:
.17e3	b2 13		lda ($13)			lda 	(temp1) 					; found end ?
.17e5	18		clc				clc									; if so exit with CC.
.17e6	f0 1d		beq $1805			beq 	_FLExit
.17e8	a0 01		ldy #$01			ldy 	#1 							; check line # match
.17ea	b1 13		lda ($13),y			lda 	(temp1),y
.17ec	c5 15		cmp $15				cmp 	temp2
.17ee	d0 08		bne $17f8			bne 	_FLNext
.17f0	c8		iny				iny
.17f1	b1 13		lda ($13),y			lda 	(temp1),y
.17f3	c5 16		cmp $16				cmp 	temp2+1
.17f5	38		sec				sec 								; if so exit with CS
.17f6	f0 0d		beq $1805			beq 	_FLExit
.17f8					_FLNext:
.17f8	18		clc				clc
.17f9	a5 13		lda $13				lda 	temp1
.17fb	72 13		adc ($13)			adc 	(temp1)
.17fd	85 13		sta $13				sta 	temp1
.17ff	90 02		bcc $1803			bcc 	_NoCarryAdv
.1801	e6 14		inc $14				inc 	temp1+1
.1803					_NoCarryAdv:
.1803	80 de		bra $17e3			bra 	_FLLoop 					; keep looking.
.1805					_FLExit:
.1805	7a		ply				ply
.1806	fa		plx				plx
.1807	68		pla				pla
.1808	60		rts				rts
.1809	18		clc				clc
.180a	60		rts				rts
.180b					DisabledCallSearch:
.180b	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.180d	85 03		sta $03				sta 	0+(IP)
.180f	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.1811	85 04		sta $04				sta 	1+(IP)
.1813	b2 03		lda ($03)			lda 	(IP)						; no program code ?
.1815	f0 22		beq $1839			beq 	SearchFail
.1817	a0 01		ldy #$01			ldy 	#1 							; Y = 1 throughout.
.1819					_CHSearch:
.1819	b1 03		lda ($03),y			lda 	(IP),y 						; check LSB of line number
.181b	c5 13		cmp $13				cmp 	temp1
.181d	f0 11		beq $1830			beq 	_CHFoundLSB
.181f					_CHSearchNext:
.181f	18		clc				clc
.1820	a5 03		lda $03				lda 	IP
.1822	72 03		adc ($03)			adc 	(IP)
.1824	85 03		sta $03				sta 	IP
.1826	90 02		bcc $182a			bcc 	_NoCarryAdv
.1828	e6 04		inc $04				inc 	IP+1
.182a					_NoCarryAdv:
.182a	b2 03		lda ($03)			lda 	(IP)						; check reached the end.
.182c	d0 eb		bne $1819			bne 	_CHSearch
.182e	80 09		bra $1839			bra 	SearchFail
.1830					_CHFoundLSB:
.1830	c8		iny				iny 								; get MSB
.1831	b1 03		lda ($03),y			lda 	(IP),y
.1833	88		dey				dey
.1834	c5 14		cmp $14				cmp 	temp1+1 					; matches, if not contineu
.1836	d0 e7		bne $181f			bne 	_CHSearchNext
.1838	60		rts				rts
.1839					SearchFail:
.1839	20 7a 25	jsr $257a			jsr 	ErrorHandler
>183c	43 41 4e 54 20 46 49 4e				.text 	"CANT FIND DEFINITION",0
>1844	44 20 44 45 46 49 4e 49 54 49 4f 4e 00

;******  Return to file: files.asm


;******  Processing file: words/system/clrnew.src

.1851					NewHandler:
.1851	9c 00 40	stz $4000			stz 	ProgramMemory 				; Make the first offset zero.
.1854	20 67 18	jsr $1867			jsr 	ClearVariableSpace 			; clear variables, reset pointers
.1857	4c f4 24	jmp $24f4			jmp 	WarmStartBlankStack
.185a					ClrHandler:
.185a	86 13		stx $13				stx 	temp1
.185c	a2 80		ldx #$80			ldx 	#NumberStackBase
.185e	9a		txs				txs
.185f	a6 13		ldx $13				ldx 	temp1
.1861	20 67 18	jsr $1867			jsr 	ClearVariableSpace 			; clear variables, reset pointers
.1864	4c 00 00	jmp $0000			jmp 	NextCode
.1867					ClearVariableSpace:
.1867	64 08		stz $08				stz 	rsp
.1869	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.186b	85 11		sta $11				sta 	0+(nextFreeMem)
.186d	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.186f	85 12		sta $12				sta 	1+(nextFreeMem)
.1871	a0 1f		ldy #$1f			ldy 	#hashTableSize*2-1 			; erase the hash table (used for variables)
.1873					_CVSHashClear:
.1873	a9 00		lda #$00			lda 	#0 							; all the first record pointers are $00
.1875	99 40 06	sta $0640,y			sta 	hashTable,y
.1878	88		dey				dey
.1879	10 f8		bpl $1873			bpl 	_CVSHashClear
.187b					_CVSFindEnd:
.187b	18		clc				clc
.187c	a5 11		lda $11				lda 	nextFreeMem
.187e	72 11		adc ($11)			adc 	(nextFreeMem)
.1880	85 11		sta $11				sta 	nextFreeMem
.1882	90 02		bcc $1886			bcc 	_NoCarryAdv
.1884	e6 12		inc $12				inc 	nextFreeMem+1
.1886					_NoCarryAdv:
.1886	b2 11		lda ($11)			lda 	(nextFreeMem)
.1888	d0 f1		bne $187b			bne 	_CVSFindEnd
.188a	a9 08		lda #$08			lda 	#8 							; this puts a gap in, more for clarity than anything.
.188c	a0 00		ldy #$00			ldy 	#0
.188e	20 95 18	jsr $1895			jsr 	AdvanceFreeMem				; we need +1 because the previous code leaves the
.1891	20 a9 1a	jsr $1aa9			jsr 	CreateSearchTable 			; create search lookup
.1894	60		rts				rts
.1895					AdvanceFreeMem:
.1895	18		clc				clc
.1896	65 11		adc $11				adc 	nextFreeMem
.1898	85 11		sta $11				sta 	nextFreeMem
.189a	98		tya				tya
.189b	65 12		adc $12				adc 	nextFreeMem+1
.189d	85 12		sta $12				sta 	nextFreeMem+1
.189f	b0 08		bcs $18a9			bcs 	MemoryOverflow
.18a1	60		rts				rts
.18a2					CheckMemory:
.18a2	a5 12		lda $12				lda 	nextFreeMem+1
.18a4	c9 9d		cmp #$9d			cmp 	#(lastMemoryByte >> 8)-1
.18a6	b0 01		bcs $18a9			bcs 	MemoryOverflow
.18a8	60		rts				rts
.18a9					MemoryOverflow:
.18a9	20 7a 25	jsr $257a			jsr 	ErrorHandler
>18ac	4f 55 54 20 4f 46 20 4d				.text 	"OUT OF MEMORY",0
>18b4	45 4d 4f 52 59 00

;******  Return to file: files.asm


;******  Processing file: words/system/debug.src

.18ba					ExitDump:
.18ba	ba		tsx				tsx 								; save Data Stack in temp1
.18bb	86 13		stx $13				stx 	temp1
.18bd	4c ff ff	jmp $ffff			jmp 	$FFFF 						; makes the X16-Emulator dump-exit.
.18c0					BreakCmd:
>18c0	ff						.byte 	$FF
.18c1	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: files.asm


;******  Processing file: words/system/decode.src

.18c4					DecodeLineIntoBufPtr:
.18c4	48		pha				pha
.18c5	da		phx				phx
.18c6	5a		phy				phy
.18c7	85 0b		sta $0b				sta 	srcPtr 						; save the source line.
.18c9	84 0c		sty $0c				sty 	srcPtr+1
.18cb	90 1b		bcc $18e8			bcc 	_DecodeNoLineNumber
.18cd	a0 01		ldy #$01			ldy 	#1 							; get line # to YA
.18cf	b1 0b		lda ($0b),y			lda 	(srcPtr),y
.18d1	aa		tax				tax
.18d2	c8		iny				iny
.18d3	b1 0b		lda ($0b),y			lda 	(srcPtr),y
.18d5	a8		tay				tay
.18d6	8a		txa				txa
.18d7	18		clc				clc
.18d8	20 d8 19	jsr $19d8			jsr 	DecodeYAToBuffer 			; convert to string in buffer
.18db	aa		tax				tax 								; count in X
.18dc					_DecodeLineSpace:
.18dc	e0 05		cpx #$05			cpx 	#5
.18de	f0 08		beq $18e8			beq 	_DecodeNoLineNumber
.18e0	a9 20		lda #$20			lda 	#" " 						; pad to 5 spaces
.18e2	20 b6 19	jsr $19b6			jsr 	DecodeWriteBuffer
.18e5	e8		inx				inx
.18e6	80 f4		bra $18dc			bra 	_DecodeLineSpace
.18e8					_DecodeNoLineNumber:
.18e8	a0 03		ldy #$03			ldy 	#3 							; initial position.
.18ea					_DecodeLoop:
.18ea	b1 0b		lda ($0b),y			lda 	(srcPtr),y 					; copy the current character to temp1
.18ec	85 13		sta $13				sta 	temp1 						; must be an execution address.
.18ee	c8		iny				iny
.18ef	b1 0b		lda ($0b),y			lda 	(srcPtr),y
.18f1	85 14		sta $14				sta 	temp1+1
.18f3	c8		iny				iny 								; y points to the byte after it.
.18f4	a5 13		lda $13				lda 	temp1
.18f6	c9 b3		cmp #$b3			cmp 	#NextLine & $FF
.18f8	d0 06		bne $1900			bne 	_DecodeNotEOL
.18fa	a5 14		lda $14				lda 	temp1+1
.18fc	c9 1d		cmp #$1d			cmp 	#NextLine >> 8
.18fe	f0 0b		beq $190b			beq 	_DecodeEOL
.1900					_DecodeNotEOL:
.1900	20 13 19	jsr $1913			jsr 	IdentifyCodeWord
.1903	20 61 19	jsr $1961			jsr 	DecodeFoundWord
.1906	20 4b 19	jsr $194b			jsr 	AdvanceToNext 				; advance to next entry in the line.
.1909	80 df		bra $18ea			bra 	_DecodeLoop 				; and go round again
.190b					_DecodeEOL:
.190b	a9 00		lda #$00			lda 	#0
.190d	92 0d		sta ($0d)			sta 	(bufPtr)
.190f	7a		ply				ply 								; restore registers and exit
.1910	fa		plx				plx
.1911	68		pla				pla
.1912	60		rts				rts
.1913					IdentifyCodeWord:
.1913	5a		phy				phy 								; save current position on the stack.
.1914	a9 b8		lda #$b8			lda 	#(Dictionary) & $FF
.1916	85 0f		sta $0f				sta 	0+(matchPtr)
.1918	a9 26		lda #$26			lda 	#(Dictionary) >> 8
.191a	85 10		sta $10				sta 	1+(matchPtr)
.191c					_DecodeIdentify:
.191c	a0 02		ldy #$02			ldy 	#2 							; have we found a match ?
.191e	b1 0f		lda ($0f),y			lda 	(matchPtr),y
.1920	c5 13		cmp $13				cmp 	temp1
.1922	d0 07		bne $192b			bne 	_DecodeIdNext
.1924	c8		iny				iny
.1925	b1 0f		lda ($0f),y			lda 	(matchPtr),y
.1927	c5 14		cmp $14				cmp 	temp1+1
.1929	f0 1e		beq $1949			beq 	_DecodeIdFound
.192b					_DecodeIdNext:
.192b	18		clc				clc
.192c	b2 0f		lda ($0f)			lda 	(matchPtr)
.192e	f0 0a		beq $193a			beq 	_DecodeIdIssue
.1930	65 0f		adc $0f				adc 	matchPtr
.1932	85 0f		sta $0f				sta 	matchPtr
.1934	90 e6		bcc $191c			bcc 	_DecodeIdentify
.1936	e6 10		inc $10				inc 	matchPtr+1
.1938	80 e2		bra $191c			bra 	_DecodeIdentify
.193a					_DecodeIdIssue:
.193a	20 7a 25	jsr $257a			jsr 	ErrorHandler
>193d	42 41 44 20 50 52 4f 47				.text 	"BAD PROGRAM",0
>1945	52 41 4d 00
.1949					_DecodeIdFound:
.1949	7a		ply				ply 								; restore position.
.194a	60		rts				rts
.194b					AdvanceToNext:
.194b	5a		phy				phy 								; get the parameter count from bits 0-1 of the type byte
.194c	a0 01		ldy #$01			ldy 	#1
.194e	b1 0f		lda ($0f),y			lda 	(matchPtr),y
.1950	29 03		and #$03			and 	#3 							; bits 0-1.
.1952	7a		ply				ply
.1953	c9 03		cmp #$03			cmp 	#3 							; is it n-bytes e.g. specified by the next byte
.1955	d0 02		bne $1959			bne 	_ATN012
.1957	b1 0b		lda ($0b),y			lda 	(srcPtr),y 					; if so, use that byte as the overall length.
.1959					_ATN012:
.1959	85 15		sta $15				sta 	temp2 						; now add that to Y
.195b	98		tya				tya
.195c	18		clc				clc
.195d	65 15		adc $15				adc 	temp2
.195f	a8		tay				tay
.1960	60		rts				rts
.1961					DecodeFoundWord:
.1961	5a		phy				phy 								; save current position
.1962	84 15		sty $15				sty		temp2 						; put it in temp2 as well.
.1964	a0 01		ldy #$01			ldy 	#1 							; get the type byte
.1966	b1 0f		lda ($0f),y			lda 	(matchPtr),y 				; is there a special decoder check (bit 4 set) ?
.1968	29 10		and #$10			and 	#$10
.196a	d0 0e		bne $197a			bne 	_DFWSpecialDecoder
.196c	b1 0f		lda ($0f),y			lda 	(matchPtr),y 				; reget it.
.196e	30 08		bmi $1978			bmi 	_DFWExit 					; if hidden word (bit 7 set)
.1970	a9 06		lda #$06			lda 	#CTH_Keyword				; output a space to the buffer
.1972	20 b6 19	jsr $19b6			jsr 	DecodeWriteBuffer
.1975	20 93 19	jsr $1993			jsr 	DecodeCurrentWord 			; expand that.
.1978					_DFWExit:
.1978	7a		ply				ply 								; restore current position
.1979	60		rts				rts
.197a					_DFWSpecialDecoder:
.197a	a0 04		ldy #$04			ldy 	#4 							; the decode word address is at offset 4,5
.197c	b1 0f		lda ($0f),y			lda 	(matchPtr),y 				; copy this into temp2
.197e	85 15		sta $15				sta 	temp2
.1980	c8		iny				iny
.1981	b1 0f		lda ($0f),y			lda 	(matchPtr),y
.1983	85 16		sta $16				sta 	temp2+1
.1985	7a		ply				ply 	 							; restore current position into Y
.1986	48		pha				pha 								; save registers
.1987	da		phx				phx
.1988	5a		phy				phy
.1989	20 90 19	jsr $1990			jsr 	_DFWCallDecoder				; call the decoder routine
.198c	7a		ply				ply 								; restore registers and exit
.198d	fa		plx				plx
.198e	68		pla				pla
.198f	60		rts				rts
.1990					_DFWCallDecoder:
.1990	6c 15 00	jmp ($0015)			jmp 	(temp2)
.1993					DecodeCurrentWord:
.1993	5a		phy				phy
.1994	a0 01		ldy #$01			ldy 	#1 							; read type byte
.1996	b1 0f		lda ($0f),y			lda 	(matchPtr),y
.1998	a0 04		ldy #$04			ldy 	#4 							; original offset
.199a	4a		lsr a				lsr 	a 							; encoder/decoder bits in 0-1
.199b	4a		lsr a				lsr 	a 							; add 2 to Y for each encoder/decoder
.199c	4a		lsr a				lsr 	a 							; bit set.
.199d	4a		lsr a				lsr 	a
.199e	4a		lsr a				lsr 	a 							; decoder bit
.199f	90 02		bcc $19a3			bcc 	_DWBNoDec
.19a1	c8		iny				iny
.19a2	c8		iny				iny
.19a3					_DWBNoDec:
.19a3	4a		lsr a				lsr 	a
.19a4	90 02		bcc $19a8			bcc 	_DWBNoEnc
.19a6	c8		iny				iny
.19a7	c8		iny				iny
.19a8					_DWBNoEnc:
.19a8					_DWBWordOut:
.19a8	b1 0f		lda ($0f),y			lda 	(matchPtr),y 				; output until bit 7 set.
.19aa	48		pha				pha
.19ab	29 7f		and #$7f			and 	#$7F
.19ad	20 b6 19	jsr $19b6			jsr		DecodeWriteBuffer
.19b0	c8		iny				iny
.19b1	68		pla				pla
.19b2	10 f4		bpl $19a8			bpl 	_DWBWordOut
.19b4	7a		ply				ply 								; restore Y and exit
.19b5	60		rts				rts
.19b6					DecodeWriteBuffer:
.19b6	92 0d		sta ($0d)			sta 	(bufPtr)
.19b8	e6 0d		inc $0d				inc 	bufPtr
.19ba	d0 02		bne $19be			bne 	_DWBNoCarry
.19bc	e6 0e		inc $0e				inc 	bufPtr+1
.19be					_DWBNoCarry:
.19be	60		rts				rts
.19bf					DecodeOutputData:
.19bf	48		pha				pha
.19c0	da		phx				phx
.19c1	5a		phy				phy
.19c2	b1 0b		lda ($0b),y			lda 	(srcPtr),y 					; length + 1
.19c4	aa		tax				tax
.19c5					_DODLoop:
.19c5	ca		dex				dex 								; done it all ?
.19c6	f0 0c		beq $19d4			beq		_DODExit
.19c8	c8		iny				iny 								; output next character
.19c9	b1 0b		lda ($0b),y			lda 	(srcPtr),y
.19cb	29 7f		and #$7f			and 	#$7F
.19cd	f0 f6		beq $19c5			beq 	_DODLoop 					; don't print NULL
.19cf	20 b6 19	jsr $19b6			jsr 	DecodeWriteBuffer
.19d2	80 f1		bra $19c5			bra 	_DODLoop
.19d4					_DODExit:
.19d4	7a		ply				ply
.19d5	fa		plx				plx
.19d6	68		pla				pla
.19d7	60		rts				rts
.19d8					DecodeYAToBuffer:
.19d8	da		phx				phx
.19d9	5a		phy				phy
.19da	48		pha				pha
.19db	a5 0d		lda $0d				lda 	bufPtr 						; copy bufPtr to temp2
.19dd	85 15		sta $15				sta 	temp2
.19df	a5 0e		lda $0e				lda 	bufPtr+1
.19e1	85 16		sta $16				sta 	temp2+1
.19e3	68		pla				pla
.19e4	20 ec 1e	jsr $1eec			jsr 	ConvertToStringMain 		; convert YA to string there
.19e7	aa		tax				tax 								; chars output to X
.19e8	18		clc				clc
.19e9	65 0d		adc $0d				adc 	bufPtr 						; add to buffer pointer
.19eb	85 0d		sta $0d				sta 	bufPtr
.19ed	90 02		bcc $19f1			bcc 	_DYABNoCarry
.19ef	e6 0e		inc $0e				inc 	bufPtr+1
.19f1					_DYABNoCarry:
.19f1	8a		txa				txa 								; count in A
.19f2	7a		ply				ply									; restore and exit.
.19f3	fa		plx				plx
.19f4	60		rts				rts

;******  Return to file: files.asm


;******  Processing file: words/system/edit.src

.19f5					EditProgram:
.19f5	20 75 1a	jsr $1a75			jsr 	EDFindLine					; find line address -> temp1
.19f8	90 0f		bcc $1a09			bcc 	_EPNotFound 				; if missing don't delete it.
.19fa	a5 13		lda $13				lda 	temp1 						; save line address
.19fc	48		pha				pha
.19fd	a5 14		lda $14				lda 	temp1+1
.19ff	48		pha				pha
.1a00	20 1a 1a	jsr $1a1a			jsr 	EDDeleteLine 				; delete the line
.1a03	68		pla				pla 								; restore line address
.1a04	85 14		sta $14				sta 	temp1+1
.1a06	68		pla				pla
.1a07	85 13		sta $13				sta 	temp1
.1a09					_EPNotFound:
.1a09	ad 10 09	lda $0910			lda 	encodeBuffer 				; is there anything in the line.
.1a0c	c9 05		cmp #$05			cmp 	#5 							; <offset> <line#> <next line>
.1a0e	f0 06		beq $1a16			beq 	_EPNoInsert
.1a10	20 3d 1a	jsr $1a3d			jsr 	EDInsertLine 				; insert line back in.
.1a13	20 a2 18	jsr $18a2			jsr 	CheckMemory 				; low on memory ?
.1a16					_EPNoInsert:
.1a16	20 67 18	jsr $1867			jsr 	ClearVariableSpace
.1a19	60		rts				rts
.1a1a					EDDeleteLine:
.1a1a	20 67 18	jsr $1867			jsr 	ClearVariableSpace
.1a1d	a0 00		ldy #$00			ldy 	#0 							; this is the offset to copy down.
.1a1f	a2 00		ldx #$00			ldx 	#0
.1a21	b1 13		lda ($13),y			lda 	(temp1),y
.1a23	a8		tay				tay 								; put in Y
.1a24					_EDDelLoop:
.1a24	b1 13		lda ($13),y			lda 	(temp1),y 					; get it
.1a26	81 13		sta ($13,x)			sta 	(temp1,x) 					; write it.
.1a28	a5 13		lda $13				lda 	temp1 						; check if pointer has reached the end of
.1a2a	c5 11		cmp $11				cmp		nextFreeMem 				; low memory. We will have copied down an
.1a2c	d0 06		bne $1a34			bne 	_EDDelNext 					; extra pile of stuff - technically should
.1a2e	a5 14		lda $14				lda 	temp1+1 					; check the upper value (e.g. temp1+y)
.1a30	c5 12		cmp $12				cmp 	nextFreeMem+1				; doesn't really matter.
.1a32	f0 08		beq $1a3c			beq		_EDDelExit
.1a34					_EDDelNext:
.1a34	e6 13		inc $13				inc 	temp1 						; go to next byte.
.1a36	d0 ec		bne $1a24			bne 	_EDDelLoop
.1a38	e6 14		inc $14				inc 	temp1+1
.1a3a	80 e8		bra $1a24			bra 	_EDDelLoop
.1a3c					_EDDelExit:
.1a3c	60		rts				rts
.1a3d					EDInsertLine:
.1a3d	20 67 18	jsr $1867			jsr 	ClearVariableSpace
.1a40	a5 11		lda $11				lda 	nextFreeMem 				; copy high memory to temp3
.1a42	85 17		sta $17				sta 	temp3
.1a44	a5 12		lda $12				lda 	nextFreeMem+1
.1a46	85 18		sta $18				sta 	temp3+1
.1a48	ac 10 09	ldy $0910			ldy 	encodeBuffer 				; space to move it to in Y
.1a4b	a2 00		ldx #$00			ldx 	#0
.1a4d					_EDInsLoop:
.1a4d	a1 17		lda ($17,x)			lda 	(temp3,x)					; copy it up
.1a4f	91 17		sta ($17),y			sta 	(temp3),y
.1a51	a5 17		lda $17				lda 	temp3 						; reached the insert point (temp1)
.1a53	c5 13		cmp $13				cmp 	temp1
.1a55	d0 06		bne $1a5d			bne 	_EDINextShift
.1a57	a5 18		lda $18				lda 	temp3+1
.1a59	c5 14		cmp $14				cmp 	temp1+1
.1a5b	f0 0a		beq $1a67			beq 	_EDIShiftOver
.1a5d					_EDINextShift:
.1a5d	a5 17		lda $17				lda 	temp3 						; decrement the copy pointer.
.1a5f	d0 02		bne $1a63			bne 	_EDINoBorrow
.1a61	c6 18		dec $18				dec 	temp3+1
.1a63					_EDINoBorrow:
.1a63	c6 17		dec $17				dec 	temp3
.1a65	80 e6		bra $1a4d			bra 	_EDInsLoop
.1a67					_EDIShiftOver:
.1a67	a0 00		ldy #$00			ldy 	#0
.1a69					_EDICopyCode:
.1a69	b9 10 09	lda $0910,y			lda 	encodeBuffer,y				; read from the current line
.1a6c	91 13		sta ($13),y			sta 	(temp1),y 					; write out
.1a6e	c8		iny				iny 								; bump pointers
.1a6f	cc 10 09	cpy $0910			cpy 	encodeBuffer 				; done the whole lot ?
.1a72	d0 f5		bne $1a69			bne 	_EDICopyCode
.1a74	60		rts				rts
.1a75					EDFindLine:
.1a75	a9 00		lda #$00			lda 	#(programMemory) & $FF
.1a77	85 13		sta $13				sta 	0+(temp1)
.1a79	a9 40		lda #$40			lda 	#(programMemory) >> 8
.1a7b	85 14		sta $14				sta 	1+(temp1)
.1a7d					_EDFLLoop:
.1a7d	b2 13		lda ($13)			lda 	(temp1) 					; check offset
.1a7f	f0 24		beq $1aa5			beq 	_EDFLFail 					; then obviously that's the end ;-) (great comment !)
.1a81	a0 01		ldy #$01			ldy 	#1							; look at line #
.1a83	38		sec				sec
.1a84	ad 11 09	lda $0911			lda 	encodeBuffer+1				; subtract the current from the target
.1a87	f1 13		sbc ($13),y			sbc 	(temp1),y 					; so if searching for 100 and this one is 90,
.1a89	aa		tax				tax	 								; this will return 10.
.1a8a	ad 12 09	lda $0912			lda 	encodeBuffer+2
.1a8d	c8		iny				iny
.1a8e	f1 13		sbc ($13),y			sbc 	(temp1),y
.1a90	90 13		bcc $1aa5			bcc 	_EDFLFail					; if target < current then failed.
.1a92	d0 04		bne $1a98			bne 	_EDFLNext 					; if non-zero then goto next
.1a94	e0 00		cpx #$00			cpx 	#0 							; same for the LSB - zero if match found.
.1a96	f0 0f		beq $1aa7			beq 	_EDFLFound
.1a98					_EDFLNext:
.1a98	18		clc				clc
.1a99	a5 13		lda $13				lda 	temp1
.1a9b	72 13		adc ($13)			adc 	(temp1)
.1a9d	85 13		sta $13				sta 	temp1
.1a9f	90 02		bcc $1aa3			bcc 	_NoCarryAdv
.1aa1	e6 14		inc $14				inc 	temp1+1
.1aa3					_NoCarryAdv:
.1aa3	80 d8		bra $1a7d			bra 	_EDFLLoop
.1aa5					_EDFLFail:
.1aa5	18		clc				clc
.1aa6	60		rts				rts
.1aa7					_EDFLFound:
.1aa7	38		sec				sec
.1aa8	60		rts				rts

;******  Return to file: files.asm


;******  Processing file: words/system/fastsearch.src

.1aa9					CreateSearchTable:
.1aa9	20 b1 1a	jsr $1ab1			jsr 	CreateLineNumberTable
.1aac	85 25		sta $25				sta 	LineTable
.1aae	84 26		sty $26				sty 	LineTable+1
.1ab0	60		rts				rts
.1ab1					CreateLineNumberTable:
.1ab1	a5 11		lda $11				lda 	nextFreeMem 				; push table position on stack.
.1ab3	a4 12		ldy $12				ldy 	nextFreeMem+1
.1ab5	48		pha				pha
.1ab6	5a		phy				phy
.1ab7	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.1ab9	85 13		sta $13				sta 	0+(temp1)
.1abb	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.1abd	85 14		sta $14				sta 	1+(temp1)
.1abf					_CLNTCheck:
.1abf	b2 13		lda ($13)			lda 	(temp1) 					; finished ?
.1ac1	f0 39		beq $1afc			beq 	_CLNTEnd
.1ac3	a0 03		ldy #$03			ldy 	#3 							; is it $$define
.1ac5	b1 13		lda ($13),y			lda 	(temp1),y
.1ac7	c9 f5		cmp #$f5			cmp 	#DefineCode & $FF
.1ac9	d0 24		bne $1aef			bne 	_CLNTNext
.1acb	c8		iny				iny
.1acc	b1 13		lda ($13),y			lda 	(temp1),y
.1ace	c9 1d		cmp #$1d			cmp 	#DefineCode >> 8
.1ad0	d0 1d		bne $1aef			bne 	_CLNTNext
.1ad2	a0 02		ldy #$02			ldy 	#2
.1ad4	b1 13		lda ($13),y			lda 	(temp1),y 					; line msb
.1ad6	88		dey				dey
.1ad7	91 11		sta ($11),y			sta 	(nextFreeMem),y 			; save out
.1ad9	b1 13		lda ($13),y			lda 	(temp1),y 					; line lsb
.1adb	92 11		sta ($11)			sta 	(nextFreeMem)
.1add	a0 02		ldy #$02			ldy 	#2 							; copy line position
.1adf	a5 13		lda $13				lda 	temp1
.1ae1	91 11		sta ($11),y			sta 	(nextFreeMem),y
.1ae3	a5 14		lda $14				lda 	temp1+1
.1ae5	c8		iny				iny
.1ae6	91 11		sta ($11),y			sta 	(nextFreeMem),y
.1ae8	a9 04		lda #$04			lda 	#4 							; advance memory pointer
.1aea	a0 00		ldy #$00			ldy 	#0
.1aec	20 95 18	jsr $1895			jsr 	AdvanceFreeMem 				; over new record.
.1aef					_CLNTNext:
.1aef	18		clc				clc
.1af0	a5 13		lda $13				lda 	temp1
.1af2	72 13		adc ($13)			adc 	(temp1)
.1af4	85 13		sta $13				sta 	temp1
.1af6	90 02		bcc $1afa			bcc 	_NoCarryAdv
.1af8	e6 14		inc $14				inc 	temp1+1
.1afa					_NoCarryAdv:
.1afa	80 c3		bra $1abf			bra 	_CLNTCheck
.1afc					_CLNTEnd:
.1afc	a0 00		ldy #$00			ldy 	#0 							; append 128 zeros, so only check end on minus check.
.1afe					_CLNTPadZero:
.1afe	a9 00		lda #$00			lda 	#$00
.1b00	91 11		sta ($11),y			sta 	(nextFreeMem),y
.1b02	c8		iny				iny
.1b03	10 f9		bpl $1afe			bpl 	_CLNTPadZero
.1b05	a9 80		lda #$80			lda 	#128 						; advance memory pointer
.1b07	a0 00		ldy #$00			ldy 	#0
.1b09	20 95 18	jsr $1895			jsr 	AdvanceFreeMem 				; over padding
.1b0c	7a		ply				ply 								; restore original position and exit.
.1b0d	68		pla				pla
.1b0e	60		rts				rts
.1b0f					CallSearch:
.1b0f	a5 25		lda $25				lda 	LineTable 					; copy line table pointer to temp3
.1b11	85 17		sta $17				sta 	temp3
.1b13	a5 26		lda $26				lda 	LineTable+1
.1b15	85 18		sta $18				sta 	temp3+1
.1b17					_DFLNewYSet:
.1b17	a0 00		ldy #$00			ldy 	#0 							; start of set.
.1b19	a5 13		lda $13				lda 	temp1 						; A = Line number, low.
.1b1b					_DFLCheck:
.1b1b	d1 17		cmp ($17),y			cmp 	(temp3),y 					; do the LSB match ?
.1b1d	f0 1b		beq $1b3a			beq 	_DFLLSBMatch
.1b1f					_DFLLSBAdvance:
.1b1f	c8		iny				iny 								; advance to the next record
.1b20	c8		iny				iny
.1b21	c8		iny				iny
.1b22	c8		iny				iny
.1b23	10 f6		bpl $1b1b			bpl 	_DFLCheck 					; we only check when Y goes -ve hence the zero padding.
.1b25	88		dey				dey 								; check if the last entry is zero
.1b26	b1 17		lda ($17),y			lda 	(temp3),y
.1b28	88		dey				dey
.1b29	11 17		ora ($17),y			ora 	(temp3),y
.1b2b	f0 24		beq $1b51			beq 	_DFLFailed 					; if so, give up.
.1b2d	a5 17		lda $17				lda 	temp3 						; advance temp3 by 128, the next block of 128 defines
.1b2f	18		clc				clc
.1b30	69 80		adc #$80			adc 	#128
.1b32	85 17		sta $17				sta 	temp3
.1b34	90 e1		bcc $1b17			bcc 	_DFLNewYSet 				; go back zeroing Y to check the next lot.
.1b36	e6 18		inc $18				inc 	temp3+1
.1b38	80 dd		bra $1b17			bra 	_DFLNewYSet
.1b3a					_DFLLSBMatch:
.1b3a	c8		iny				iny 								; get the MSB
.1b3b	b1 17		lda ($17),y			lda 	(temp3),y
.1b3d	c5 14		cmp $14				cmp 	temp1+1 					; if it matches the MSB
.1b3f	f0 05		beq $1b46			beq 	_DFLFound 					; then we are done.
.1b41	88		dey				dey 								; fix back up
.1b42	a5 13		lda $13				lda 	temp1 						; restore A = low byte
.1b44	80 d9		bra $1b1f			bra 	_DFLLSBAdvance 				; and continue
.1b46					_DFLFound:
.1b46	c8		iny				iny									; copy the address into IP
.1b47	b1 17		lda ($17),y			lda 	(temp3),y
.1b49	85 03		sta $03				sta 	IP
.1b4b	c8		iny				iny
.1b4c	b1 17		lda ($17),y			lda 	(temp3),y
.1b4e	85 04		sta $04				sta 	IP+1
.1b50	60		rts				rts
.1b51					_DFLFailed:
.1b51	4c 39 18	jmp $1839			jmp 	SearchFail

;******  Return to file: files.asm


;******  Processing file: words/system/list.src

.1b54					ListCode:
.1b54	64 21		stz $21				stz 	ListLowest 					; zero lowest line#
.1b56	64 22		stz $22				stz 	ListLowest+1
.1b58	a9 18		lda #$18			lda 	#24 						; show max 24 after lowest line
.1b5a	85 20		sta $20				sta 	ListCount
.1b5c	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.1b5e	85 1b		sta $1b				sta 	0+(listPtr)
.1b60	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.1b62	85 1c		sta $1c				sta 	1+(listPtr)
.1b64	86 13		stx $13				stx 	temp1						; S->A
.1b66	ba		tsx				tsx
.1b67	8a		txa				txa
.1b68	a6 13		ldx $13				ldx 	temp1
.1b6a	c9 80		cmp #$80			cmp 	#NumberStackBase
.1b6c	f0 0e		beq $1b7c			beq 	_LCLoop
.1b6e	a5 09		lda $09				lda 	TOS 						; copy TOS to lowest
.1b70	85 21		sta $21				sta 	ListLowest
.1b72	a5 0a		lda $0a				lda 	TOS+1
.1b74	85 22		sta $22				sta 	ListLowest+1
.1b76	68		pla				pla
.1b77	85 0a		sta $0a				sta 	TOS+1
.1b79	68		pla				pla
.1b7a	85 09		sta $09				sta 	TOS
.1b7c					_LCLoop:
.1b7c	b2 1b		lda ($1b)			lda 	(listPtr)					; reached end ?
.1b7e	f0 4c		beq $1bcc			beq 	_LCExit
.1b80	a0 01		ldy #$01			ldy 	#1							; >= list lowest
.1b82	b1 1b		lda ($1b),y			lda 	(listPtr),y
.1b84	c5 21		cmp $21				cmp 	ListLowest
.1b86	c8		iny				iny
.1b87	b1 1b		lda ($1b),y			lda 	(listPtr),y
.1b89	e5 22		sbc $22				sbc 	ListLowest+1
.1b8b	90 32		bcc $1bbf			bcc 	_LCNext
.1b8d	a9 10		lda #$10			lda 	#(textBuffer) & $FF
.1b8f	85 0d		sta $0d				sta 	0+(bufPtr)
.1b91	a9 08		lda #$08			lda 	#(textBuffer) >> 8
.1b93	85 0e		sta $0e				sta 	1+(bufPtr)
.1b95	a5 1b		lda $1b				lda 	listPtr 					; output the line.
.1b97	a4 1c		ldy $1c				ldy 	listPtr+1
.1b99	38		sec				sec
.1b9a	20 c4 18	jsr $18c4			jsr 	DecodeLineIntoBufPtr
.1b9d	a9 02		lda #$02			lda 	#CTH_LineNo
.1b9f	20 e6 25	jsr $25e6			jsr 	ExternColour
.1ba2	a0 ff		ldy #$ff			ldy 	#255
.1ba4					_LCLoop2:
.1ba4	c8		iny				iny
.1ba5	b9 10 08	lda $0810,y			lda 	textBuffer,y
.1ba8	f0 0e		beq $1bb8			beq 	_LCEnd
.1baa	c9 20		cmp #$20			cmp 	#32
.1bac	b0 05		bcs $1bb3			bcs 	_LCPrint
.1bae	20 e6 25	jsr $25e6			jsr 	ExternColour
.1bb1	a9 20		lda #$20			lda 	#32
.1bb3					_LCPrint:
.1bb3	20 da 25	jsr $25da			jsr 	ExternPrint
.1bb6	80 ec		bra $1ba4			bra 	_LCLoop2
.1bb8	a9 0d		lda #$0d	_LCEnd:	lda 	#13 						; new line
.1bba	20 da 25	jsr $25da			jsr 	ExternPrint
.1bbd	c6 20		dec $20				dec 	ListCount					; done all the lines allowed
.1bbf					_LCNext:
.1bbf	18		clc				clc
.1bc0	a5 1b		lda $1b				lda 	listPtr
.1bc2	72 1b		adc ($1b)			adc 	(listPtr)
.1bc4	85 1b		sta $1b				sta 	listPtr
.1bc6	90 02		bcc $1bca			bcc 	_NoCarryAdv
.1bc8	e6 1c		inc $1c				inc 	listPtr+1
.1bca					_NoCarryAdv:
.1bca	80 b0		bra $1b7c			bra 	_LCLoop 					; go round again.
.1bcc					_LCExit:
.1bcc	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: files.asm


;******  Processing file: words/system/miscellany.src

.1bcf					RunProgram:
.1bcf	86 13		stx $13				stx 	temp1
.1bd1	a2 80		ldx #$80			ldx 	#NumberStackBase
.1bd3	9a		txs				txs
.1bd4	a6 13		ldx $13				ldx 	temp1
.1bd6	20 67 18	jsr $1867			jsr 	ClearVariableSpace 			; clear variables etc.
.1bd9	a2 00		ldx #$00			ldx		#ProgramMemory & $FF		; boot address
.1bdb	a0 40		ldy #$40			ldy 	#ProgramMemory >>8
.1bdd	20 03 10	jsr $1003			jsr 	InitialiseCoreCode 			; initialise the NEXT routine at $00
.1be0	4c 00 00	jmp $0000			jmp 	NextCode
.1be3					Call6502:
.1be3	a5 09		lda $09				lda 	TOS 						; copy call address
.1be5	85 13		sta $13				sta 	temp1
.1be7	a5 0a		lda $0a				lda 	TOS+1
.1be9	85 14		sta $14				sta 	temp1+1
.1beb	68		pla				pla
.1bec	85 0a		sta $0a				sta 	TOS+1
.1bee	68		pla				pla
.1bef	85 09		sta $09				sta 	TOS
.1bf1	da		phx				phx
.1bf2	ad 02 06	lda $0602			lda		('A'-'@')*2+azVariables 	; load AXY
.1bf5	ae 30 06	ldx $0630			ldx		('X'-'@')*2+azVariables
.1bf8	ac 32 06	ldy $0632			ldy		('Y'-'@')*2+azVariables
.1bfb	20 02 1c	jsr $1c02			jsr 	_CallTemp1 					; call it
.1bfe	fa		plx				plx
.1bff	4c 00 00	jmp $0000			jmp 	NextCode
.1c02					_CallTemp1:
.1c02	6c 13 00	jmp ($0013)			jmp 	(temp1)
.1c05					AssertCode:
.1c05	a5 09		lda $09				lda 	TOS 						; TOS = 0
.1c07	05 0a		ora $0a				ora 	TOS+1
.1c09	f0 09		beq $1c14			beq 	_ASFail 					; if zero fail
.1c0b	68		pla				pla
.1c0c	85 0a		sta $0a				sta 	TOS+1
.1c0e	68		pla				pla
.1c0f	85 09		sta $09				sta 	TOS
.1c11	4c 00 00	jmp $0000			jmp 	NextCode
.1c14					_ASFail:
.1c14	20 7a 25	jsr $257a			jsr 	ErrorHandler
>1c17	41 53 53 45 52 54 00				.text 	"ASSERT",0
.1c1e					StopCode:
.1c1e	20 7a 25	jsr $257a			jsr 	ErrorHandler
>1c21	53 54 4f 50 00					.text 	"STOP",0
.1c26					EndProgram:
.1c26	4c fb 24	jmp $24fb			jmp 	WarmStart
.1c29					VlistCode:
.1c29	a9 b8		lda #$b8			lda 	#(Dictionary) & $FF
.1c2b	85 13		sta $13				sta 	0+(temp1)
.1c2d	a9 26		lda #$26			lda 	#(Dictionary) >> 8
.1c2f	85 14		sta $14				sta 	1+(temp1)
.1c31	a0 01		ldy #$01	_VLLoop:ldy 	#1							; type byte
.1c33	b1 13		lda ($13),y			lda 	(temp1),y
.1c35	a0 04		ldy #$04			ldy 	#4 							; Y = 4
.1c37	4a		lsr a				lsr 	a 							; shift bits 4 and 5 to 0,1
.1c38	4a		lsr a				lsr 	a
.1c39	4a		lsr a				lsr		a
.1c3a	4a		lsr a				lsr 	a
.1c3b	4a		lsr a				lsr 	a 							; add those bits in
.1c3c	90 02		bcc $1c40			bcc 	_VLNoDec
.1c3e	c8		iny				iny
.1c3f	c8		iny				iny
.1c40					_VLNoDec:
.1c40	4a		lsr a				lsr 	a
.1c41	90 02		bcc $1c45			bcc 	_VLNoEnc
.1c43	c8		iny				iny
.1c44	c8		iny				iny
.1c45					_VLNoEnc:
.1c45	b1 13		lda ($13),y			lda 	(temp1),y 					; remove $$ words
.1c47	c9 24		cmp #$24			cmp 	#"$"
.1c49	d0 06		bne $1c51			bne 	_VLPrint
.1c4b	c8		iny				iny
.1c4c	51 13		eor ($13),y			eor 	(temp1),y
.1c4e	f0 13		beq $1c63			beq 	_VLNext
.1c50	88		dey				dey
.1c51					_VLPrint:
.1c51	b1 13		lda ($13),y			lda 	(temp1),y
.1c53	48		pha				pha
.1c54	c8		iny				iny
.1c55	29 7f		and #$7f			and 	#$7F
.1c57	20 da 25	jsr $25da			jsr 	ExternPrint
.1c5a	68		pla				pla
.1c5b	0a		asl a				asl 	a
.1c5c	90 f3		bcc $1c51			bcc 	_VLPrint
.1c5e	a9 20		lda #$20			lda 	#32
.1c60	20 da 25	jsr $25da			jsr 	ExternPrint
.1c63					_VLNext:
.1c63	18		clc				clc 								; go to next
.1c64	b2 13		lda ($13)			lda 	(temp1)
.1c66	65 13		adc $13				adc 	temp1
.1c68	85 13		sta $13				sta 	temp1
.1c6a	90 02		bcc $1c6e			bcc 	_VLNoCarry
.1c6c	e6 14		inc $14				inc 	temp1+1
.1c6e					_VLNoCarry:
.1c6e	b2 13		lda ($13)			lda 	(temp1)
.1c70	d0 bf		bne $1c31			bne 	_VLLoop
.1c72	a9 0d		lda #$0d			lda 	#13
.1c74	20 da 25	jsr $25da			jsr 	ExternPrint
.1c77	4c 00 00	jmp $0000			jmp 	NextCode
.1c7a					DumpStack:
.1c7a	a9 5b		lda #$5b			lda		#"["
.1c7c	20 da 25	jsr $25da			jsr 	ExternPrint
.1c7f	86 13		stx $13				stx 	temp1 						; X -> A
.1c81	ba		tsx				tsx
.1c82	8a		txa				txa
.1c83	a6 13		ldx $13				ldx 	temp1
.1c85	c9 80		cmp #$80			cmp 	#NumberStackBase 			; out of range, exit
.1c87	f0 2f		beq $1cb8			beq 	_DSExit
.1c89	48		pha				pha 								; save it
.1c8a	a9 07		lda #$07			lda 	#COL_WHITE
.1c8c	20 e6 25	jsr $25e6			jsr 	ExternColour
.1c8f	a5 09		lda $09				lda 	TOS 						; print TOS then stack values backwards
.1c91	a4 0a		ldy $0a				ldy 	TOS+1
.1c93	38		sec				sec 								; print unsigned.
.1c94	20 c6 1e	jsr $1ec6			jsr 	PrintYA
.1c97	a9 06		lda #$06			lda 	#COL_CYAN
.1c99	20 e6 25	jsr $25e6			jsr 	ExternColour
.1c9c	7a		ply				ply 								; restore offset
.1c9d					_DSLoop:
.1c9d	c0 7e		cpy #$7e			cpy 	#NumberStackBase-2 			; till done whole stack.
.1c9f	f0 17		beq $1cb8			beq 	_DSExit
.1ca1	a9 20		lda #$20			lda 	#" " 						; space
.1ca3	20 da 25	jsr $25da			jsr 	ExternPrint
.1ca6	5a		phy				phy 								; save pos
.1ca7	b9 01 01	lda $0101,y			lda 	$0101,y 					; read stack item
.1caa	48		pha				pha
.1cab	b9 02 01	lda $0102,y			lda 	$0102,y
.1cae	7a		ply				ply
.1caf	38		sec				sec
.1cb0	20 c6 1e	jsr $1ec6			jsr 	PrintYA 					; print it
.1cb3	7a		ply				ply 								; restore and advance pos
.1cb4	c8		iny				iny
.1cb5	c8		iny				iny
.1cb6	80 e5		bra $1c9d			bra 	_DSLoop
.1cb8					_DSExit:
.1cb8	a9 5d		lda #$5d			lda		#"]"
.1cba	20 da 25	jsr $25da			jsr 	ExternPrint
.1cbd	a9 0d		lda #$0d			lda 	#13
.1cbf	20 da 25	jsr $25da			jsr 	ExternPrint
.1cc2	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: files.asm


;******  Processing file: words/system/old.src

.1cc5					OldCode:
.1cc5	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.1cc7	85 0b		sta $0b				sta 	0+(srcPtr)
.1cc9	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.1ccb	85 0c		sta $0c				sta 	1+(srcPtr)
.1ccd	a0 03		ldy #$03			ldy 	#3 							; start after line# / offset
.1ccf					_OldLoop:
.1ccf	b1 0b		lda ($0b),y			lda 	(srcPtr),y 					; copy the current character to temp1
.1cd1	85 13		sta $13				sta 	temp1 						; must be an execution address.
.1cd3	c8		iny				iny
.1cd4	b1 0b		lda ($0b),y			lda 	(srcPtr),y
.1cd6	85 14		sta $14				sta 	temp1+1
.1cd8	c8		iny				iny
.1cd9	a5 13		lda $13				lda 	temp1 						; have we reached the end ?
.1cdb	c9 b3		cmp #$b3			cmp 	#NextLine & $FF
.1cdd	d0 06		bne $1ce5			bne 	_OldNotEOL
.1cdf	a5 14		lda $14				lda 	temp1+1
.1ce1	c9 1d		cmp #$1d			cmp 	#NextLine >> 8
.1ce3	f0 08		beq $1ced			beq 	_OldEOL
.1ce5					_OldNotEOL:
.1ce5	20 13 19	jsr $1913			jsr 	IdentifyCodeWord			; what is it ?
.1ce8	20 4b 19	jsr $194b			jsr 	AdvanceToNext 				; advance to next entry in the line.
.1ceb	80 e2		bra $1ccf			bra	 	_OldLoop
.1ced					_OldEOL:
.1ced	8c 00 40	sty $4000			sty 	ProgramMemory 				; Y is the offset.
.1cf0	20 67 18	jsr $1867			jsr 	ClearVariableSpace 			; clear variables, reset pointers
.1cf3	4c f4 24	jmp $24f4			jmp 	WarmStartBlankStack

;******  Return to file: files.asm


;******  Processing file: words/system/saveload.src

.1cf6					System_Save:
.1cf6	20 67 18	jsr $1867			jsr 	ClearVariableSpace  		; make sure start/end are right
.1cf9	20 78 1d	jsr $1d78			jsr 	ExtendWithDictionary 		; attach the dictionary addresses.
.1cfc	20 24 1d	jsr $1d24			jsr 	SLGetFileName 				; get filename -> temp3
.1cff	a5 11		lda $11				lda 	nextFreeMem 				; end address
.1d01	85 13		sta $13				sta 	temp1
.1d03	a5 12		lda $12				lda 	nextFreeMem+1
.1d05	85 14		sta $14				sta 	temp1+1
.1d07	a9 00		lda #$00			lda 	#ProgramMemory & $FF 		; program start to YA
.1d09	a0 40		ldy #$40			ldy 	#ProgramMemory >> 8
.1d0b	20 2e 26	jsr $262e			jsr 	ExternSave
.1d0e	20 67 18	jsr $1867			jsr 	ClearVariableSpace  		; make sure start/end are right
.1d11	4c f4 24	jmp $24f4			jmp 	WarmStartBlankStack
.1d14					System_Load:
.1d14	20 24 1d	jsr $1d24			jsr 	SLGetFileName 				; get filename -> temp3
.1d17	a9 00		lda #$00			lda 	#ProgramMemory & $FF 		; program start to YA
.1d19	a0 40		ldy #$40			ldy 	#ProgramMemory >> 8
.1d1b	20 64 26	jsr $2664			jsr 	ExternLoad
.1d1e	20 67 18	jsr $1867			jsr 	ClearVariableSpace 			; reset everything.
.1d21	4c f4 24	jmp $24f4			jmp 	WarmStartBlankStack
.1d24					SLGetFileName:
.1d24	ba		tsx				tsx
.1d25	e0 80		cpx #$80			cpx 	#NumberStackBase
.1d27	f0 3a		beq $1d63			beq 	_SLFNFail
.1d29	a9 10		lda #$10			lda 	#textBuffer & $FF 			; f/n in input buffer.
.1d2b	85 17		sta $17				sta 	temp3
.1d2d	a9 08		lda #$08			lda 	#textBuffer >> 8
.1d2f	85 18		sta $18				sta 	temp3+1
.1d31	a0 00		ldy #$00			ldy 	#0
.1d33	b1 09		lda ($09),y	_SLCopy:lda 	(TOS),y
.1d35	91 17		sta ($17),y			sta 	(temp3),y
.1d37	c8		iny				iny
.1d38	c9 00		cmp #$00			cmp		#0
.1d3a	d0 f7		bne $1d33			bne 	_SLCopy
.1d3c	88		dey				dey
.1d3d	a2 03		ldx #$03			ldx 	#3 							; check if it ends in .RPL
.1d3f					_SLCheckEnd:
.1d3f	88		dey				dey
.1d40	bd 73 1d	lda $1d73,x			lda 	_SLFNExtension,x
.1d43	d1 17		cmp ($17),y			cmp 	(temp3),y
.1d45	d0 05		bne $1d4c			bne 	_SLNoExtension
.1d47	ca		dex				dex
.1d48	10 f5		bpl $1d3f			bpl 	_SLCheckEnd
.1d4a	80 16		bra $1d62			bra 	_SLExit
.1d4c					_SLNoExtension:
.1d4c	a0 ff		ldy #$ff			ldy 	#255						; add the extension.
.1d4e					_SLFindend:
.1d4e	c8		iny				iny
.1d4f	b9 10 08	lda $0810,y			lda 	textBuffer,y
.1d52	d0 fa		bne $1d4e			bne 	_SLFindend
.1d54	a2 00		ldx #$00			ldx 	#0
.1d56					_SLAppend:
.1d56	bd 73 1d	lda $1d73,x			lda 	_SLFNExtension,x
.1d59	99 10 08	sta $0810,y			sta 	textBuffer,y
.1d5c	e8		inx				inx
.1d5d	c8		iny				iny
.1d5e	c9 00		cmp #$00			cmp 	#0
.1d60	d0 f4		bne $1d56			bne 	_SLAppend
.1d62					_SLExit:
.1d62	60		rts				rts
.1d63					_SLFNFail:
.1d63	20 7a 25	jsr $257a			jsr 	ErrorHandler
>1d66	42 41 44 20 46 49 4c 45				.text 	"BAD FILENAME",0
>1d6e	4e 41 4d 45 00
.1d73					_SLFNExtension:
>1d73	2e 52 50 4c 00					.text 	".RPL",0
.1d78					ExtendWithDictionary:
.1d78	20 a1 1d	jsr $1da1			jsr 	_EWDMarker 					; 8 bytes after the final offset write a marker
.1d7b	a9 b8		lda #$b8			lda 	#(Dictionary) & $FF
.1d7d	85 13		sta $13				sta 	0+(temp1)
.1d7f	a9 26		lda #$26			lda 	#(Dictionary) >> 8
.1d81	85 14		sta $14				sta 	1+(temp1)
.1d83					_EWDLoop:
.1d83	b2 13		lda ($13)			lda 	(temp1)						; end
.1d85	f0 1a		beq $1da1			beq 	_EWDMarker
.1d87	a0 02		ldy #$02			ldy 	#2 							; output the address
.1d89	b1 13		lda ($13),y			lda 	(temp1),y
.1d8b	20 aa 1d	jsr $1daa			jsr 	_EWDWrite
.1d8e	c8		iny				iny
.1d8f	b1 13		lda ($13),y			lda 	(temp1),y
.1d91	20 aa 1d	jsr $1daa			jsr 	_EWDWrite
.1d94	18		clc				clc 								; next entry.
.1d95	a5 13		lda $13				lda 	temp1
.1d97	72 13		adc ($13)			adc 	(temp1)
.1d99	85 13		sta $13				sta 	temp1
.1d9b	90 e6		bcc $1d83			bcc 	_EWDLoop
.1d9d	e6 14		inc $14				inc 	temp1+1
.1d9f	80 e2		bra $1d83			bra 	_EWDLoop
.1da1					_EWDMarker:
.1da1	a9 ff		lda #$ff			lda 	#$FF
.1da3	20 aa 1d	jsr $1daa			jsr 	_EWDWrite
.1da6	20 aa 1d	jsr $1daa			jsr 	_EWDWrite
.1da9	60		rts				rts
.1daa					_EWDWrite:
.1daa	92 11		sta ($11)			sta 	(nextFreeMem)
.1dac	e6 11		inc $11				inc 	nextFreeMem
.1dae	d0 02		bne $1db2			bne 	_EWDExit
.1db0	e6 12		inc $12				inc 	nextFreeMem+1
.1db2					_EWDExit:
.1db2	60		rts				rts

;******  Return to file: files.asm


;******  Processing file: words/system/skipper.src

.1db3					NextLine:
.1db3	18		clc				clc
.1db4	a5 03		lda $03				lda 	IP
.1db6	72 03		adc ($03)			adc 	(IP)
.1db8	85 03		sta $03				sta 	IP
.1dba	90 02		bcc $1dbe			bcc 	_NoCarryAdv
.1dbc	e6 04		inc $04				inc 	IP+1
.1dbe					_NoCarryAdv:
.1dbe	b2 03		lda ($03)			lda 	(IP)						; is there any following program ?
.1dc0	f0 05		beq $1dc7			beq 	_NLGoEnd
.1dc2	a2 01		ldx #$01			ldx 	#1 							; start 3 in (-2 for Next)
.1dc4	4c 00 00	jmp $0000			jmp 	NextCode
.1dc7					_NLGoEnd:
.1dc7	4c fb 24	jmp $24fb			jmp 	WarmStart
.1dca					SkipComment:
.1dca	e8		inx				inx									; (IP),X points to the length.
.1dcb	e8		inx				inx
.1dcc	8a		txa				txa
.1dcd	a8		tay				tay 								; put into Y
.1dce	18		clc				clc
.1dcf	71 03		adc ($03),y			adc 	(IP),y 						; add the length to X
.1dd1	aa		tax				tax 								; put back in X
.1dd2	ca		dex				dex
.1dd3	ca		dex				dex
.1dd4	4c 00 00	jmp $0000			jmp 	NextCode
.1dd7					CommentDecoder:
.1dd7	a9 06		lda #$06			lda 	#CTH_Keyword
.1dd9	20 b6 19	jsr $19b6			jsr 	DecodeWriteBuffer
.1ddc	a9 27		lda #$27			lda 	#"'"
.1dde	20 b6 19	jsr $19b6			jsr 	DecodeWriteBuffer
.1de1	b1 0b		lda ($0b),y			lda 	(srcPtr),y 					; check if there is no data
.1de3	c9 01		cmp #$01			cmp 	#1
.1de5	f0 0d		beq $1df4			beq 	_CDEmpty 					; if so print nothing.
.1de7	a9 0b		lda #$0b			lda 	#CTH_Comment
.1de9	20 b6 19	jsr $19b6			jsr 	DecodeWriteBuffer
.1dec	20 bf 19	jsr $19bf			jsr 	DecodeOutputData
.1def	a9 20		lda #$20			lda 	#32
.1df1	20 b6 19	jsr $19b6			jsr 	DecodeWriteBuffer
.1df4					_CDEmpty
.1df4	60		rts				rts
.1df5					DefineCode:
.1df5	20 7a 25	jsr $257a			jsr 	ErrorHandler
>1df8	52 45 41 43 48 45 44 20				.text 	"REACHED DEFINITION",0
>1e00	44 45 46 49 4e 49 54 49 4f 4e 00
.1e0b					DefineDecoder:
.1e0b	a9 07		lda #$07			lda 	#CTH_Definition
.1e0d	20 b6 19	jsr $19b6			jsr 	DecodeWriteBuffer
.1e10	a9 3a		lda #$3a			lda 	#":"
.1e12	20 b6 19	jsr $19b6			jsr 	DecodeWriteBuffer
.1e15	20 bf 19	jsr $19bf			jsr 	DecodeOutputData
.1e18	a9 20		lda #$20			lda 	#32
.1e1a	20 b6 19	jsr $19b6			jsr 	DecodeWriteBuffer
.1e1d	60		rts				rts

;******  Return to file: files.asm


;******  Processing file: words/system/toint.src

.1e1e					ConvertToInteger:
.1e1e	84 1a		sty $1a				sty 	temp4+1
.1e20	85 19		sta $19				sta 	temp4
.1e22	64 17		stz $17				stz 	temp3 						; reset value
.1e24	64 18		stz $18				stz 	temp3+1
.1e26	64 13		stz $13				stz 	temp1 						; temp1 = 0 (decimal) 255 (hex)
.1e28	a0 00		ldy #$00			ldy 	#0 							; look at first character
.1e2a	b1 19		lda ($19),y			lda 	(temp4),y
.1e2c	49 2d		eor #$2d			eor 	#"-"						; zero if '-'
.1e2e	85 14		sta $14				sta 	temp1+1 					; save this in temp1+1
.1e30	d0 01		bne $1e33			bne 	_CTINotMinus
.1e32	c8		iny				iny									; skip -
.1e33					_CTINotMinus:
.1e33	b1 19		lda ($19),y			lda 	(temp4),y
.1e35	c9 24		cmp #$24			cmp		#'$'						; if $ then skip it and set hex flag
.1e37	d0 03		bne $1e3c			bne 	_CTILoop
.1e39	c6 13		dec $13				dec 	temp1
.1e3b	c8		iny				iny
.1e3c					_CTILoop:
.1e3c	b1 19		lda ($19),y			lda 	(temp4),y 					; next digit
.1e3e	29 7f		and #$7f			and 	#$7F 						; drop end of word flag
.1e40	38		sec				sec
.1e41	e9 30		sbc #$30			sbc 	#'0' 						; put in range '0'+
.1e43	90 65		bcc $1eaa			bcc 	_CTIFail 					; out of range.
.1e45	c9 0a		cmp #$0a			cmp 	#10 						; in 0-9 ?
.1e47	90 0b		bcc $1e54			bcc 	_CTILegal
.1e49	c9 11		cmp #$11			cmp 	#'A'-'0'					; between 9 and A ?
.1e4b	90 5d		bcc $1eaa			bcc 	_CTIFail
.1e4d	38		sec				sec
.1e4e	e9 07		sbc #$07			sbc 	#7 							; hex adjust
.1e50	c9 10		cmp #$10			cmp 	#16 						; out of range ?
.1e52	b0 56		bcs $1eaa			bcs 	_CTIFail
.1e54					_CTILegal:
.1e54	48		pha				pha 								; save digit value.
.1e55	06 17		asl $17				asl 	temp3
.1e57	26 18		rol $18				rol 	temp3+1
.1e59	a5 17		lda $17				lda 	temp3 						; copy x2 into temp2
.1e5b	85 15		sta $15				sta 	temp2
.1e5d	a5 18		lda $18				lda 	temp3+1
.1e5f	85 16		sta $16				sta 	temp2+1
.1e61	06 17		asl $17				asl 	temp3
.1e63	26 18		rol $18				rol 	temp3+1
.1e65	06 17		asl $17				asl 	temp3
.1e67	26 18		rol $18				rol 	temp3+1
.1e69	24 13		bit $13				bit 	temp1 						; hexadecimal
.1e6b	10 07		bpl $1e74			bpl 	_CTIDecimal
.1e6d	06 17		asl $17				asl 	temp3
.1e6f	26 18		rol $18				rol 	temp3+1
.1e71	68		pla				pla 								; get digit back
.1e72	80 12		bra $1e86			bra 	_CTIAddLoop
.1e74					_CTIDecimal:
.1e74	18		clc				clc 								; x 8 + x 2 = x 10
.1e75	a5 17		lda $17				lda 	temp3
.1e77	65 15		adc $15				adc 	temp2
.1e79	85 17		sta $17				sta 	temp3
.1e7b	a5 18		lda $18				lda 	temp3+1
.1e7d	65 16		adc $16				adc 	temp2+1
.1e7f	85 18		sta $18				sta 	temp3+1
.1e81	68		pla				pla 								; check digit 0-9
.1e82	c9 0a		cmp #$0a			cmp 	#10
.1e84	b0 24		bcs $1eaa			bcs 	_CTIFail
.1e86					_CTIAddLoop:
.1e86	18		clc				clc
.1e87	65 17		adc $17				adc 	temp3
.1e89	85 17		sta $17				sta 	temp3
.1e8b	90 02		bcc $1e8f			bcc 	_CTINoCarry
.1e8d	e6 18		inc $18				inc 	temp3+1
.1e8f					_CTINoCarry:
.1e8f	c8		iny				iny
.1e90	b1 19		lda ($19),y			lda 	(temp4),y 					; was this the last character
.1e92	c9 21		cmp #$21			cmp 	#32+1
.1e94	b0 a6		bcs $1e3c			bcs 	_CTILoop 					; no, go back.
.1e96	a5 14		lda $14				lda 	temp1+1 					; was it - ?
.1e98	d0 0d		bne $1ea7			bne 	_CTIOkay
.1e9a	38		sec				sec
.1e9b	a9 00		lda #$00			lda 	#0 							; negate temp3.
.1e9d	e5 17		sbc $17				sbc 	temp3
.1e9f	85 17		sta $17				sta 	temp3
.1ea1	a9 00		lda #$00			lda 	#0
.1ea3	e5 18		sbc $18				sbc 	temp3+1
.1ea5	85 18		sta $18				sta 	temp3+1
.1ea7					_CTIOkay:
.1ea7	98		tya				tya
.1ea8	38		sec				sec
.1ea9	60		rts				rts
.1eaa					_CTIFail:
.1eaa	18		clc				clc
.1eab	60		rts				rts

;******  Return to file: files.asm


;******  Processing file: words/system/tostr.src

.1eac					IntToString:
.1eac	a9 10		lda #$10			lda 	#(textBuffer) & $FF
.1eae	85 15		sta $15				sta 	0+(temp2)
.1eb0	a9 08		lda #$08			lda 	#(textBuffer) >> 8
.1eb2	85 16		sta $16				sta 	1+(temp2)
.1eb4	a5 09		lda $09				lda 	TOS 						; value in YA
.1eb6	a4 0a		ldy $0a				ldy 	TOS+1
.1eb8	20 e8 1e	jsr $1ee8			jsr 	ConvertToString
.1ebb	a9 10		lda #$10			lda 	#(textBuffer) & $FF
.1ebd	85 09		sta $09				sta 	0+(TOS)
.1ebf	a9 08		lda #$08			lda 	#(textBuffer) >> 8
.1ec1	85 0a		sta $0a				sta 	1+(TOS)
.1ec3	4c 00 00	jmp $0000			jmp 	NextCode
.1ec6					PrintYA:
.1ec6	48		pha				pha
.1ec7	da		phx				phx
.1ec8	5a		phy				phy
.1ec9	48		pha				pha
.1eca	a9 10		lda #$10			lda 	#(textBuffer) & $FF
.1ecc	85 15		sta $15				sta 	0+(temp2)
.1ece	a9 08		lda #$08			lda 	#(textBuffer) >> 8
.1ed0	85 16		sta $16				sta 	1+(temp2)
.1ed2	68		pla				pla
.1ed3	20 ec 1e	jsr $1eec			jsr 	ConvertToStringMain
.1ed6	a2 00		ldx #$00			ldx 	#0
.1ed8					_PrintYALoop:
.1ed8	bd 10 08	lda $0810,x			lda 	textBuffer,x
.1edb	20 da 25	jsr $25da			jsr 	ExternPrint
.1ede	e8		inx				inx
.1edf	bd 10 08	lda $0810,x			lda 	textBuffer,x
.1ee2	d0 f4		bne $1ed8			bne 	_PrintYALoop
.1ee4	7a		ply				ply
.1ee5	fa		plx				plx
.1ee6	68		pla				pla
.1ee7	60		rts				rts
.1ee8					ConvertToString:
.1ee8	38		sec				sec
.1ee9	80 01		bra $1eec			bra 	ConvertToStringMain
.1eeb					ConvertToStringUnsigned:
.1eeb	18		clc				clc
.1eec					ConvertToStringMain:
.1eec	da		phx				phx									; save XY
.1eed	5a		phy				phy
.1eee	64 1d		stz $1d				stz 	SignCount 					; this is zero suppression
.1ef0	85 13		sta $13				sta 	temp1 						; save YA in temp1
.1ef2	84 14		sty $14				sty 	temp1+1
.1ef4	a0 00		ldy #$00			ldy 	#0 							; index to result.
.1ef6	90 16		bcc $1f0e			bcc 	_CTSUnsigned 				; if carry clear do not adjust for -
.1ef8	a5 14		lda $14				lda 	temp1+1 					; is it negative
.1efa	10 12		bpl $1f0e			bpl 	_CTSUnsigned
.1efc	a9 2d		lda #$2d			lda 	#"-"						; output - sign
.1efe	91 15		sta ($15),y			sta 	(temp2),y
.1f00	c8		iny				iny
.1f01	38		sec				sec 								; negate temp1
.1f02	a9 00		lda #$00			lda 	#0
.1f04	e5 13		sbc $13				sbc 	temp1
.1f06	85 13		sta $13				sta 	temp1
.1f08	a9 00		lda #$00			lda 	#0
.1f0a	e5 14		sbc $14				sbc 	temp1+1
.1f0c	85 14		sta $14				sta 	temp1+1
.1f0e					_CTSUnsigned:
.1f0e	a2 00		ldx #$00			ldx 	#0 							; index into subtraction table
.1f10					_CTSLoop:
.1f10	a9 2f		lda #$2f			lda 	#"0"-1						; set the digit to '0' code.
.1f12	91 15		sta ($15),y			sta 	(temp2),y
.1f14					_CTSSubLoop:
.1f14	b1 15		lda ($15),y			lda 	(temp2),y 					; bump the count
.1f16	1a		inc a				inc 	a
.1f17	91 15		sta ($15),y			sta 	(temp2),y
.1f19	38		sec				sec 								; do subtraction saving interim result
.1f1a	a5 13		lda $13				lda 	temp1
.1f1c	fd 4f 1f	sbc $1f4f,x			sbc 	_CTSTable,x
.1f1f	48		pha				pha
.1f20	a5 14		lda $14				lda 	temp1+1
.1f22	fd 50 1f	sbc $1f50,x			sbc 	_CTSTable+1,x
.1f25	90 07		bcc $1f2e			bcc 	_CTSCantSubtract 			; end of subtraction.
.1f27	85 14		sta $14				sta 	temp1+1 					; save result back
.1f29	68		pla				pla
.1f2a	85 13		sta $13				sta 	temp1
.1f2c	80 e6		bra $1f14			bra 	_CTSSubLoop
.1f2e					_CTSCantSubtract:
.1f2e	68		pla				pla 								; throw away interim
.1f2f	e8		inx				inx 								; next subtractor
.1f30	e8		inx				inx
.1f31	b1 15		lda ($15),y			lda 	(temp2),y 					; update leading zero
.1f33	49 30		eor #$30			eor 	#"0"
.1f35	05 1d		ora $1d				ora 	SignCount
.1f37	85 1d		sta $1d				sta 	SignCount
.1f39	f0 01		beq $1f3c			beq		_CTSLZ 						; if all zeros so far suppress.
.1f3b	c8		iny				iny 								; next character
.1f3c					_CTSLZ:
.1f3c	e0 08		cpx #$08			cpx 	#_CTSTableEnd-_CTSTable 	; done them all ?
.1f3e	d0 d0		bne $1f10			bne 	_CTSLoop
.1f40					_CTSComplete:
.1f40	a5 13		lda $13				lda		temp1 						; get remainder 0-9
.1f42	09 30		ora #$30			ora 	#48 						; ASCII
.1f44	91 15		sta ($15),y			sta 	(temp2),y					; write out
.1f46	c8		iny				iny
.1f47	a9 00		lda #$00			lda 	#0							; make ASCIIZ
.1f49	91 15		sta ($15),y			sta 	(temp2),y
.1f4b	98		tya				tya 								; size in A
.1f4c	7a		ply				ply									; pull and exit.
.1f4d	fa		plx				plx
.1f4e	60		rts				rts
.1f4f					_CTSTable:
>1f4f	10 27 e8 03 64 00 0a 00				.word 	10000,1000,100,10 			; subtractors, this is a simple version.
.1f57					_CTSTableEnd:

;******  Return to file: files.asm


;******  Processing file: words/system/varhandlers.src

.1f57					VarAddressHandler:
.1f57	18		clc				clc 								; find variable, error if it doesn't exist.
.1f58	20 fa 1f	jsr $1ffa			jsr 	VariableFind
.1f5b	20 d4 1f	jsr $1fd4			jsr 	VariableCheckIndex
.1f5e	a5 09		lda $09				lda 	TOS
.1f60	48		pha				pha
.1f61	a5 0a		lda $0a				lda 	TOS+1
.1f63	48		pha				pha
.1f64	a5 13		lda $13				lda 	temp1 						; the address is the new value
.1f66	85 09		sta $09				sta 	TOS
.1f68	a5 14		lda $14				lda		temp1+1
.1f6a	85 0a		sta $0a				sta 	TOS+1
.1f6c	4c 00 00	jmp $0000			jmp 	NextCode
.1f6f					VarAddrHandlerDecode:
.1f6f	a9 26		lda #$26			lda 	#"&"
.1f71	4c b2 20	jmp $20b2			jmp 	VarHandlerDecode
.1f74					VarReadHandler:
.1f74	18		clc				clc 								; find variable, error if it doesn't exist.
.1f75	20 fa 1f	jsr $1ffa			jsr 	VariableFind
.1f78	20 d4 1f	jsr $1fd4			jsr 	VariableCheckIndex
.1f7b	a5 09		lda $09				lda 	TOS
.1f7d	48		pha				pha
.1f7e	a5 0a		lda $0a				lda 	TOS+1
.1f80	48		pha				pha
.1f81	b2 13		lda ($13)			lda 	(temp1)						; read variable address to TOS
.1f83	85 09		sta $09				sta 	TOS
.1f85	a0 01		ldy #$01			ldy 	#1
.1f87	b1 13		lda ($13),y			lda 	(temp1),y
.1f89	85 0a		sta $0a				sta 	TOS+1
.1f8b	4c 00 00	jmp $0000			jmp 	NextCode
.1f8e					VarReadHandlerDecode:
.1f8e	a9 40		lda #$40			lda 	#"@"
.1f90	4c b2 20	jmp $20b2			jmp 	VarHandlerDecode
.1f93					VarWriteHandler:
.1f93	38		sec				sec 								; find variable, create it if it doesn't exist.
.1f94	20 fa 1f	jsr $1ffa			jsr 	VariableFind
.1f97	20 d4 1f	jsr $1fd4			jsr 	VariableCheckIndex
.1f9a	a5 09		lda $09				lda 	TOS 						; write TOS to that address.
.1f9c	92 13		sta ($13)			sta 	(temp1)
.1f9e	a5 0a		lda $0a				lda 	TOS+1
.1fa0	a0 01		ldy #$01			ldy 	#1
.1fa2	91 13		sta ($13),y			sta 	(temp1),y
.1fa4	68		pla				pla
.1fa5	85 0a		sta $0a				sta 	TOS+1
.1fa7	68		pla				pla
.1fa8	85 09		sta $09				sta 	TOS
.1faa	4c 00 00	jmp $0000			jmp 	NextCode
.1fad					VarWriteHandlerDecode:
.1fad	a9 21		lda #$21			lda 	#"!"
.1faf	4c b2 20	jmp $20b2			jmp 	VarHandlerDecode
.1fb2					IndexHandler:
.1fb2	20 7a 25	jsr $257a			jsr 	ErrorHandler
>1fb5	24 24 49 4e 44 45 58 3a				.text 	"$$INDEX:BUG",0
>1fbd	42 55 47 00
.1fc1					IndexHandlerDecode:
.1fc1	a9 5b		lda #$5b			lda 	#"["
.1fc3	20 b6 19	jsr $19b6			jsr 	DecodeWriteBuffer
.1fc6	b1 0b		lda ($0b),y			lda 	(srcPtr),y
.1fc8	a0 00		ldy #$00			ldy 	#0
.1fca	38		sec				sec
.1fcb	20 d8 19	jsr $19d8			jsr 	DecodeYAToBuffer
.1fce	a9 5d		lda #$5d			lda 	#"]"
.1fd0	20 b6 19	jsr $19b6			jsr 	DecodeWriteBuffer
.1fd3	60		rts				rts
.1fd4					VariableCheckIndex:
.1fd4	8a		txa				txa 								; next is $$index ?
.1fd5	a8		tay				tay
.1fd6	c8		iny				iny
.1fd7	c8		iny				iny
.1fd8	b1 03		lda ($03),y			lda 	(IP),y
.1fda	c9 b2		cmp #$b2			cmp 	#IndexHandler & $FF
.1fdc	d0 1b		bne $1ff9			bne 	_VCIExit
.1fde	c8		iny				iny
.1fdf	b1 03		lda ($03),y			lda 	(IP),y
.1fe1	c9 1f		cmp #$1f			cmp 	#IndexHandler >> 8
.1fe3	d0 14		bne $1ff9			bne 	_VCIExit
.1fe5	98		tya				tya 								; fix X backup 3 on from where we started
.1fe6	aa		tax				tax
.1fe7	c8		iny				iny 								; get the index
.1fe8	b1 03		lda ($03),y			lda 	(IP),y
.1fea	0a		asl a				asl 	a 							; double it, add to (temp1) -> temp1
.1feb	a0 01		ldy #$01			ldy 	#1
.1fed	72 13		adc ($13)			adc 	(temp1) 					; do the indirection e.g. the look up.
.1fef	48		pha				pha
.1ff0	b1 13		lda ($13),y			lda 	(temp1),y
.1ff2	69 00		adc #$00			adc 	#0
.1ff4	85 14		sta $14				sta 	temp1+1
.1ff6	68		pla				pla
.1ff7	85 13		sta $13				sta 	temp1
.1ff9					_VCIExit:
.1ff9	60		rts				rts
.1ffa					VariableFind:
.1ffa	08		php				php 								; save autocreate flag.
.1ffb	e8		inx				inx 								; advance to/over the variable name.
.1ffc	e8		inx				inx
.1ffd	8a		txa				txa 								; put in Y
.1ffe	a8		tay				tay
.1fff	b1 03		lda ($03),y			lda 	(IP),y 						; copy name word into temp2
.2001	85 15		sta $15				sta 	temp2
.2003	c8		iny				iny
.2004	b1 03		lda ($03),y			lda 	(IP),y
.2006	85 16		sta $16				sta 	temp2+1
.2008	c9 1b		cmp #$1b			cmp 	#27 						; check for A-Z
.200a	b0 0f		bcs $201b			bcs 	_VFLong
.200c	a5 16		lda $16				lda 	temp2+1
.200e	d0 0b		bne $201b			bne 	_VFLong
.2010	a5 15		lda $15				lda 	temp2						; this is the index
.2012	0a		asl a				asl 	a 							; double it
.2013	85 13		sta $13				sta 	temp1
.2015	a9 06		lda #$06			lda 	#azVariables >> 8			; set the MSB
.2017	85 14		sta $14				sta 	temp1+1
.2019	28		plp				plp 								; throw creation flag, it always exists.
.201a	60		rts				rts
.201b					_VFLong:
.201b	a5 15		lda $15				lda 	temp2 						; built a hash table index into temp3/temp4
.201d	6a		ror a				ror 	a
.201e	6a		ror a				ror 	a
.201f	6a		ror a				ror 	a
.2020	6a		ror a				ror 	a
.2021	45 15		eor $15				eor 	temp2
.2023	45 16		eor $16				eor 	temp2+1
.2025	29 0f		and #$0f			and 	#(hashTableSize-1)			; force into range
.2027	0a		asl a				asl 	a
.2028	69 40		adc #$40			adc 	#hashTable & $FF 			; make an address of the head => temp1/3
.202a	85 13		sta $13				sta 	temp1
.202c	85 17		sta $17				sta 	temp3
.202e	a9 06		lda #$06			lda 	#hashTable >> 8
.2030	85 14		sta $14				sta 	temp1+1
.2032	85 18		sta $18				sta 	temp3+1
.2034					_VFSearch:
.2034	a0 01		ldy #$01			ldy 	#1							; read MSB of first record
.2036	b1 13		lda ($13),y			lda 	(temp1),y
.2038	f0 23		beq $205d			beq 	_VFNotFound 				; is MSB is zero, can't be a variable record
.203a	a8		tay				tay 								; follow the link through.
.203b	b2 13		lda ($13)			lda 	(temp1)
.203d	85 13		sta $13				sta 	temp1
.203f	84 14		sty $14				sty 	temp1+1
.2041	a0 04		ldy #$04			ldy 	#4							; check if the name matches
.2043	b1 13		lda ($13),y			lda 	(temp1),y
.2045	c5 15		cmp $15				cmp 	temp2
.2047	d0 eb		bne $2034			bne 	_VFSearch 					; if it doesn't, follow the next link.
.2049	c8		iny				iny 								; same for 2nd byte of name
.204a	b1 13		lda ($13),y			lda 	(temp1),y
.204c	c5 16		cmp $16				cmp 	temp2+1
.204e	d0 e4		bne $2034			bne 	_VFSearch
.2050	18		clc				clc
.2051	a5 13		lda $13				lda 	temp1 						; make temp1 point to the data at offset 2
.2053	69 02		adc #$02			adc 	#2
.2055	85 13		sta $13				sta 	temp1
.2057	90 02		bcc $205b			bcc 	_VFNoPage1
.2059	e6 14		inc $14				inc 	temp1+1
.205b					_VFNoPage1:
.205b	28		plp				plp 								; don't need to worry about creation flag
.205c	60		rts				rts
.205d					_VFNotFound:
.205d	28		plp				plp 								; was carry set, e.g. create a new record if not found ?
.205e	b0 14		bcs $2074			bcs 	_VFCreate
.2060	20 7a 25	jsr $257a			jsr 	ErrorHandler
>2063	4e 4f 20 53 55 43 48 20				.text 	"NO SUCH VARIABLE",0
>206b	56 41 52 49 41 42 4c 45 00
.2074					_VFCreate:
.2074	a0 01		ldy #$01			ldy 	#1
.2076	b2 17		lda ($17)			lda 	(temp3) 					; copy the head link to the first 2 bytes
.2078	92 11		sta ($11)			sta 	(nextFreeMem)
.207a	b1 17		lda ($17),y			lda 	(temp3),y
.207c	91 11		sta ($11),y			sta 	(nextFreeMem),y
.207e	c8		iny				iny
.207f	a9 00		lda #$00			lda 	#0	 						; write zero initialised data out.
.2081	91 11		sta ($11),y			sta 	(nextFreeMem),y
.2083	c8		iny				iny
.2084	91 11		sta ($11),y			sta 	(nextFreeMem),y
.2086	c8		iny				iny
.2087	a5 15		lda $15				lda 	temp2 						; copy the name out
.2089	91 11		sta ($11),y			sta 	(nextFreeMem),y
.208b	c8		iny				iny
.208c	a5 16		lda $16				lda 	temp2+1
.208e	91 11		sta ($11),y			sta 	(nextFreeMem),y
.2090	a0 01		ldy #$01			ldy 	#1
.2092	a5 11		lda $11				lda 	nextFreeMem 				; update the head link
.2094	92 17		sta ($17)			sta 	(temp3)
.2096	a5 12		lda $12				lda 	nextFreeMem+1
.2098	91 17		sta ($17),y			sta 	(temp3),y
.209a	18		clc				clc
.209b	a5 11		lda $11				lda 	nextFreeMem 				; put nextFreeMem+2 in temp1 (data pointer)
.209d	69 02		adc #$02			adc 	#2
.209f	85 13		sta $13				sta 	temp1
.20a1	a5 12		lda $12				lda 	nextFreeMem+1
.20a3	69 00		adc #$00			adc 	#0
.20a5	85 14		sta $14				sta 	temp1+1
.20a7	a9 06		lda #$06			lda 	#6							; shift freemem pointer up 6
.20a9	a0 00		ldy #$00			ldy 	#0
.20ab	20 95 18	jsr $1895			jsr 	AdvanceFreeMem
.20ae	20 a2 18	jsr $18a2			jsr 	CheckMemory 				; low on memory ?
.20b1	60		rts				rts
.20b2					VarHandlerDecode:
.20b2	48		pha				pha 								; save, leading space
.20b3	a9 07		lda #$07			lda 	#CTH_Variable
.20b5	20 b6 19	jsr $19b6			jsr 	DecodeWriteBuffer
.20b8	68		pla				pla 								; restore and write type
.20b9	20 b6 19	jsr $19b6			jsr 	DecodeWriteBuffer
.20bc	b1 0b		lda ($0b),y			lda 	(srcPtr),y 					; copy to temp1
.20be	85 13		sta $13				sta 	temp1
.20c0	c8		iny				iny
.20c1	b1 0b		lda ($0b),y			lda 	(srcPtr),y
.20c3	85 14		sta $14				sta 	temp1+1
.20c5	a5 13		lda $13				lda 	temp1 						; output the first character
.20c7	29 1f		and #$1f			and 	#31
.20c9	20 f4 20	jsr $20f4			jsr 	VHOutVarChar
.20cc	a2 05		ldx #$05			ldx 	#5 							; divide temp1 by 32
.20ce					_VHDShift:
.20ce	46 14		lsr $14				lsr 	temp1+1
.20d0	66 13		ror $13				ror 	temp1
.20d2	ca		dex				dex
.20d3	d0 f9		bne $20ce			bne 	_VHDShift
.20d5	a2 ff		ldx #$ff			ldx 	#255 						; now divide that by 40 by repeated subtraction.
.20d7					_VHDDiv40:
.20d7	e8		inx				inx
.20d8	38		sec				sec
.20d9	a5 13		lda $13				lda 	temp1
.20db	e9 28		sbc #$28			sbc 	#40
.20dd	a8		tay				tay
.20de	a5 14		lda $14				lda 	temp1+1
.20e0	e9 00		sbc #$00			sbc 	#0
.20e2	90 06		bcc $20ea			bcc 	_VHDivDone
.20e4	85 14		sta $14				sta 	temp1+1
.20e6	84 13		sty $13				sty 	temp1
.20e8	80 ed		bra $20d7			bra 	_VHDDiv40
.20ea					_VHDivDone:
.20ea	a5 13		lda $13				lda 	temp1 						; remainder
.20ec	20 f4 20	jsr $20f4			jsr 	VHOutVarChar
.20ef	8a		txa				txa
.20f0	20 f4 20	jsr $20f4			jsr 	VHOutVarChar 				; and result.
.20f3	60		rts				rts
.20f4					VHOutVarChar:
.20f4	c9 00		cmp #$00			cmp 	#0
.20f6	f0 0c		beq $2104			beq 	_VHOExit
.20f8	18		clc				clc
.20f9	69 40		adc #$40			adc 	#64 						; 65-90 A-Z 91-100 0-9
.20fb	c9 5b		cmp #$5b			cmp 	#91 						; convert back ?
.20fd	90 02		bcc $2101			bcc 	_VHOOut
.20ff	e9 2b		sbc #$2b			sbc 	#91-48 						; adjust to digit
.2101					_VHOOut:
.2101	20 b6 19	jsr $19b6			jsr 	DecodeWriteBuffer
.2104					_VHOExit:
.2104	60		rts				rts

;******  Return to file: files.asm


;******  Processing file: words/encode/encode.src

.2105					EncodeProgram:
.2105	48		pha				pha 								; save registers.
.2106	da		phx				phx
.2107	5a		phy				phy
.2108	84 0c		sty $0c				sty 	srcPtr+1					; save source pointer.
.210a	85 0b		sta $0b				sta		srcPtr
.210c	64 08		stz $08				stz 	rsp
.210e	a6 08		ldx $08				ldx 	rsp 						; this is the current stack entry type, so $00 means
.2110	9e 40 07	stz $0740,x			stz 	returnStackHigh,x 			; an initial "until" will fail as it's looking for "R" here (repeat)
.2113	20 92 23	jsr $2392			jsr 	EncodeTrimTrailingSpaces 	; remove trailing spaces.
.2116	a9 03		lda #$03			lda 	#3 							; reset the encode Buffer
.2118	8d 10 09	sta $0910			sta 	encodeBuffer 				; this is also the write ptr/offset
.211b	9c 11 09	stz $0911			stz 	encodeBuffer+1 				; the line number
.211e	9c 12 09	stz $0912			stz 	encodeBuffer+2 				; which is initially zero.
.2121	b2 0b		lda ($0b)			lda 	(srcPtr) 					; check if first character is digit
.2123	20 3d 23	jsr $233d			jsr 	CheckIsDigit
.2126	90 09		bcc $2131			bcc 	_EPNoLineNumber 			; if so there is a line number
.2128	20 5f 23	jsr $235f			jsr 	EncodeGetConstant 			; extract that constant from the source
.212b	8d 11 09	sta $0911			sta 	encodeBuffer+1 				; that is the line number
.212e	8c 12 09	sty $0912			sty 	encodeBuffer+2
.2131					_EPNoLineNumber:
.2131					EncodeLoop:
.2131	20 84 23	jsr $2384			jsr 	EncSkipSpaces 				; skip over spaces
.2134	b2 0b		lda ($0b)			lda 	(srcPtr) 					; reached end ?
.2136	d0 21		bne $2159			bne 	_EPNotEnd
.2138					_EPEndEncode:
.2138	a9 b3		lda #$b3			lda 	#NextLine & $FF 			; compile $$nextline to mark eol
.213a	a0 1d		ldy #$1d			ldy 	#NextLine >> 8
.213c	20 15 23	jsr $2315			jsr 	EncodeWriteWord
.213f	a5 08		lda $08				lda 	rsp 						; is the return stack empty ?
.2141	d0 04		bne $2147			bne 	_EPIncomplete
.2143	7a		ply				ply									; restore and exit.
.2144	fa		plx				plx
.2145	68		pla				pla
.2146	60		rts				rts
.2147					_EPIncomplete:
.2147	20 7a 25	jsr $257a			jsr 	ErrorHandler
>214a	53 54 52 55 43 54 55 52				.text 	"STRUCTURE OPEN",0
>2152	45 20 4f 50 45 4e 00
.2159					_EPNotEnd:
.2159	b2 0b		lda ($0b)			lda 	(srcPtr)
.215b	c9 22		cmp #$22			cmp 	#'"'						; is it a quoted string or comment ?
.215d	f0 04		beq $2163			beq 	_EPIsComStr
.215f	c9 27		cmp #$27			cmp 	#"'"
.2161	d0 05		bne $2168			bne 	_EPNotComStr
.2163					_EPIsComStr:
.2163	20 62 22	jsr $2262			jsr 	EncodeCommentString
.2166	80 c9		bra $2131			bra 	EncodeLoop
.2168					_EPNotComStr:
.2168	38		sec				sec
.2169	20 71 23	jsr $2371			jsr 	EncSetBit7Word
.216c	20 b9 23	jsr $23b9			jsr 	EncodeSearchDictionary		; look it up
.216f	90 45		bcc $21b6			bcc 	_EPNotInDictionary
.2171	85 13		sta $13				sta 	temp1 						; save dictionary record address
.2173	84 14		sty $14				sty 	temp1+1
.2175	a0 01		ldy #$01			ldy 	#1
.2177	b1 13		lda ($13),y			lda 	(temp1),y 					; check if has an encode bit
.2179	29 20		and #$20			and 	#$20
.217b	d0 12		bne $218f			bne 	_EPEncodeRoutine 			; if so, do special routine.
.217d	a0 02		ldy #$02			ldy 	#2 							; write out the routine address
.217f	b1 13		lda ($13),y			lda 	(temp1),y
.2181	20 1f 23	jsr $231f			jsr 	EncodeWriteByte
.2184	c8		iny				iny
.2185	b1 13		lda ($13),y			lda 	(temp1),y
.2187	20 1f 23	jsr $231f			jsr 	EncodeWriteByte
.218a	20 49 23	jsr $2349			jsr 	EncodeMoveNextWord 			; advance to the next and loop
.218d	80 a2		bra $2131			bra 	EncodeLoop
.218f					_EPEncodeRoutine:
.218f	a0 01		ldy #$01			ldy 	#1							; get type bit
.2191	b1 13		lda ($13),y			lda 	(temp1),y
.2193	a0 04		ldy #$04			ldy 	#4							; encoder here if no decoder
.2195	29 10		and #$10			and 	#$10 						; but decoder comes first
.2197	f0 02		beq $219b			beq 	_EPENoDecoder
.2199	c8		iny				iny 								; so if it exists, adjust for it.
.219a	c8		iny				iny
.219b					_EPENoDecoder:
.219b	b1 13		lda ($13),y			lda 	(temp1),y 					; copy exec addr to temp2
.219d	85 15		sta $15				sta 	temp2
.219f	c8		iny				iny
.21a0	b1 13		lda ($13),y			lda 	(temp1),y
.21a2	85 16		sta $16				sta 	temp2+1
.21a4	48		pha				pha 								; call routine preserving state
.21a5	da		phx				phx
.21a6	5a		phy				phy
.21a7	20 b3 21	jsr $21b3			jsr 	_EPECallTemp2
.21aa	7a		ply				ply
.21ab	fa		plx				plx
.21ac	68		pla				pla
.21ad	20 49 23	jsr $2349			jsr 	EncodeMoveNextWord 			; advance to the next and loop
.21b0	4c 31 21	jmp $2131			jmp 	EncodeLoop
.21b3					_EPECallTemp2:
.21b3	6c 15 00	jmp ($0015)			jmp 	(temp2)
.21b6					_EPNotInDictionary:
.21b6	20 c7 22	jsr $22c7			jsr 	EncodeSearchUserDefined 	; are there any user defined routines
.21b9	90 19		bcc $21d4			bcc 	_EPNotDefined
.21bb	48		pha				pha
.21bc	a9 df		lda #$df			lda	 	#CallHandler & $FF 			; write code call handler
.21be	20 1f 23	jsr $231f			jsr 	EncodeWriteByte
.21c1	a9 16		lda #$16			lda	 	#CallHandler >> 8
.21c3	20 1f 23	jsr $231f			jsr 	EncodeWriteByte
.21c6	68		pla				pla 								; write line number
.21c7	20 1f 23	jsr $231f			jsr 	EncodeWriteByte
.21ca	98		tya				tya
.21cb	20 1f 23	jsr $231f			jsr 	EncodeWriteByte
.21ce	20 49 23	jsr $2349			jsr 	EncodeMoveNextWord 			; advance to the next and loop
.21d1	4c 31 21	jmp $2131			jmp 	EncodeLoop
.21d4					_EPNotDefined:
.21d4	b2 0b		lda ($0b)			lda 	(srcPtr) 					; first character
.21d6	c9 3a		cmp #$3a			cmp 	#":"						; is it :<routine> ?
.21d8	f0 65		beq $223f			beq 	_EPDefinition
.21da	c9 3c		cmp #$3c			cmp 	#"<"						; is it <line> which is call syntax
.21dc	f0 3b		beq $2219			beq 	_EPCallDirect
.21de	c9 21		cmp #$21			cmp 	#"!"						; check for variable operators
.21e0	f0 54		beq $2236			beq 	_EPVariable
.21e2	c9 40		cmp #$40			cmp 	#"@"
.21e4	f0 50		beq $2236			beq 	_EPVariable
.21e6	c9 26		cmp #$26			cmp 	#"&"
.21e8	f0 4c		beq $2236			beq 	_EPVariable
.21ea	c9 24		cmp #$24			cmp 	#"$" 						; is it a hex constant
.21ec	d0 09		bne $21f7			bne 	_EPDecLiteral
.21ee	a9 6c		lda #$6c			lda 	#HexLiteral2Byte & $FF 		; write out 2 byte literal (hex)
.21f0	a0 10		ldy #$10			ldy 	#HexLiteral2Byte >> 8
.21f2	20 15 23	jsr $2315			jsr 	EncodeWriteWord
.21f5	80 07		bra $21fe			bra 	_EPOutputConstant
.21f7					_EPDecLiteral:
.21f7	a9 6d		lda #$6d			lda 	#Literal2Byte & $FF 		; write out 2 byte literal
.21f9	a0 10		ldy #$10			ldy 	#Literal2Byte >> 8
.21fb	20 15 23	jsr $2315			jsr 	EncodeWriteWord
.21fe					_EPOutputConstant:
.21fe	20 5f 23	jsr $235f			jsr 	EncodeGetConstant 			; extract that constant from the source
.2201	90 06		bcc $2209			bcc 	_EPFail 					; if can't find one, that's us done.
.2203	20 15 23	jsr $2315			jsr 	EncodeWriteWord 			; write out the encoded value.
.2206	4c 31 21	jmp $2131			jmp 	EncodeLoop 					; and go round again.
.2209					_EPFail:
.2209	20 7a 25	jsr $257a			jsr 	ErrorHandler
>220c	53 59 4e 54 41 58 20 45				.text 	"SYNTAX ERROR",0
>2214	52 52 4f 52 00
.2219					_EPCallDirect:
.2219	a9 df		lda #$df			lda	 	#CallHandler & $FF 			; write code call handler
.221b	a0 16		ldy #$16			ldy	 	#CallHandler >> 8
.221d	20 15 23	jsr $2315			jsr 	EncodeWriteWord
.2220	a9 01		lda #$01			lda 	#1
.2222	20 55 23	jsr $2355			jsr 	EncodeAddSrcPtr 			; skip over the <
.2225	a0 ff		ldy #$ff			ldy 	#255 						; scan forward for last character.
.2227					_EPToLast:
.2227	c8		iny				iny
.2228	b1 0b		lda ($0b),y			lda 	(srcPtr),y
.222a	10 fb		bpl $2227			bpl	 	_EPToLast
.222c	c9 be		cmp #$be			cmp 	#">"+$80 					; must be >
.222e	d0 d9		bne $2209			bne 	_EPFail
.2230	a9 20		lda #$20			lda 	#" " 						; strip back to a number, erases last char
.2232	91 0b		sta ($0b),y			sta 	(srcPtr),y
.2234	80 c8		bra $21fe			bra 	_EPOutputConstant 			; borrow the number routines extract/compile constant
.2236					_EPVariable:
.2236	20 0d 24	jsr $240d			jsr 	EncodeVariableReference
.2239	20 49 23	jsr $2349			jsr 	EncodeMoveNextWord 			; advance to the next and loop
.223c	4c 31 21	jmp $2131			jmp 	EncodeLoop
.223f					_EPDefinition:
.223f	a9 f5		lda #$f5			lda	 	#DefineCode & $FF 			; write code call handler
.2241	a0 1d		ldy #$1d			ldy	 	#DefineCode >> 8
.2243	20 15 23	jsr $2315			jsr 	EncodeWriteWord
.2246	ae 10 09	ldx $0910			ldx 	encodeBuffer 				; position
.2249	a9 01		lda #$01			lda 	#1 							; write default size
.224b	20 1f 23	jsr $231f			jsr 	EncodeWriteByte
.224e	a0 00		ldy #$00			ldy 	#0 							; copy definition over.
.2250	c8		iny		_EPCopy:iny
.2251	b1 0b		lda ($0b),y			lda 	(srcPtr),y
.2253	20 1f 23	jsr $231f			jsr 	EncodeWriteByte
.2256	fe 10 09	inc $0910,x			inc 	encodeBuffer,x 				; update length.
.2259	0a		asl a				asl 	a
.225a	90 f4		bcc $2250			bcc 	_EPCopy
.225c	20 49 23	jsr $2349			jsr 	EncodeMoveNextWord 			; advance to the next and loop
.225f	4c 31 21	jmp $2131			jmp 	EncodeLoop

;******  Return to file: files.asm


;******  Processing file: words/encode/comstr.src

.2262					EncodeCommentString:
.2262	b2 0b		lda ($0b)			lda 	(srcPtr) 					; get first character
.2264	64 13		stz $13				stz 	temp1 						; other terminator = EOL
.2266	aa		tax				tax 								; save in X
.2267	a9 ca		lda #$ca			lda 	#(SkipComment & $FF)		; get the routine to use
.2269	a0 1d		ldy #$1d			ldy 	#(SkipComment >> 8)
.226b	e0 27		cpx #$27			cpx 	#"'"
.226d	f0 06		beq $2275			beq 	_ECSGotCmd
.226f	86 13		stx $13				stx		temp1 						; other terminator = "
.2271	a9 c7		lda #$c7			lda 	#(LiteralString & $FF)
.2273	a0 10		ldy #$10			ldy 	#(LiteralString >> 8)
.2275					_ECSGotCmd:
.2275	20 15 23	jsr $2315			jsr 	EncodeWriteWord 			; write word out.
.2278	a9 01		lda #$01			lda 	#1 							; skip over ' or "
.227a	20 55 23	jsr $2355			jsr 	EncodeAddSrcPtr
.227d	e0 27		cpx #$27			cpx 	#"'"						; if ' then skip spaces
.227f	d0 03		bne $2284			bne 	_ECNoSkipSpaces
.2281	20 84 23	jsr $2384			jsr 	EncSkipSpaces
.2284					_ECNoSkipSpaces:
.2284	ae 10 09	ldx $0910			ldx 	encodeBuffer 				; keep offset to buffer in X.
.2287	a9 01		lda #$01			lda 	#1
.2289	20 1f 23	jsr $231f			jsr 	EncodeWriteByte 			; write total length, so far 1.
.228c	a0 00		ldy #$00			ldy 	#0 							; for reading the actual text
.228e					_ECSCopyText:
.228e	b1 0b		lda ($0b),y			lda 	(srcPtr),y 					; get next
.2290	f0 18		beq $22aa			beq 	_ECSEndOfLine 				; end of line ?
.2292	c5 13		cmp $13				cmp 	temp1						; is it the other terminator
.2294	f0 09		beq $229f			beq 	_ECSEndOfString 			; if so must be closing quote.
.2296	20 1f 23	jsr $231f			jsr 	EncodeWriteByte 			; write the byte out
.2299	fe 10 09	inc $0910,x			inc 	encodeBuffer,x				; increase length
.229c	c8		iny				iny 								; next character
.229d	80 ef		bra $228e			bra 	_ECSCopyText
.229f					_ECSEndOfString:
.229f	c8		iny				iny 								; skip closing quote.
.22a0	a9 00		lda #$00			lda 	#0 							; write out ASCIIZ
.22a2	20 1f 23	jsr $231f			jsr 	EncodeWriteByte
.22a5	fe 10 09	inc $0910,x			inc 	encodeBuffer,x 				; fix the length up.
.22a8	80 18		bra $22c2			bra 	_ECSComplete 				; and just patching up srcPtr to do.
.22aa					_ECSEndOfLine:
.22aa	a5 13		lda $13				lda 	temp1 						; missing closing quote
.22ac	f0 14		beq $22c2			beq 	_ECSComplete 				; if we were doing a string.
.22ae	20 7a 25	jsr $257a			jsr 	ErrorHandler
>22b1	4e 4f 20 43 4c 4f 53 49				.text 	"NO CLOSING QUOTE",0
>22b9	4e 47 20 51 55 4f 54 45 00
.22c2					_ECSComplete:
.22c2	98		tya				tya									; skip over.
.22c3	20 55 23	jsr $2355			jsr 	EncodeAddSrcPtr
.22c6	60		rts				rts

;******  Return to file: files.asm


;******  Processing file: words/encode/encdef.src

.22c7					EncodeSearchUserDefined:
.22c7	38		sec				sec 								; temp1 = srcPtr-6 because the
.22c8	a5 0b		lda $0b				lda 	srcPtr				 		; name is 6 in (offset line# $$call len)
.22ca	e9 06		sbc #$06			sbc		#6
.22cc	85 13		sta $13				sta 	temp1
.22ce	a5 0c		lda $0c				lda 	srcPtr+1
.22d0	e9 00		sbc #$00			sbc 	#0
.22d2	85 14		sta $14				sta 	temp1+1
.22d4	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.22d6	85 15		sta $15				sta 	0+(temp2)
.22d8	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.22da	85 16		sta $16				sta 	1+(temp2)
.22dc					_ESULoop:
.22dc	b2 15		lda ($15)			lda 	(temp2) 					; reached the end (offset 0)
.22de	f0 33		beq $2313			beq 	_ESUFail
.22e0	a0 03		ldy #$03			ldy 	#3 							; check it is $$define
.22e2	b1 15		lda ($15),y			lda 	(temp2),y
.22e4	c9 f5		cmp #$f5			cmp 	#DefineCode & $FF
.22e6	d0 1e		bne $2306			bne 	_ESUNext
.22e8	c8		iny				iny
.22e9	b1 15		lda ($15),y			lda 	(temp2),y
.22eb	c9 1d		cmp #$1d			cmp 	#DefineCode >> 8
.22ed	d0 17		bne $2306			bne 	_ESUNext
.22ef	c8		iny				iny 								; skip length byte.
.22f0					_ESUCompare:
.22f0	c8		iny				iny
.22f1	b1 15		lda ($15),y			lda 	(temp2),y
.22f3	d1 13		cmp ($13),y			cmp 	(temp1),y
.22f5	d0 0f		bne $2306			bne 	_ESUNext
.22f7	0a		asl a				asl 	a 							; bit 7 set => found it.
.22f8	90 f6		bcc $22f0			bcc 	_ESUCompare
.22fa	a0 01		ldy #$01			ldy 	#1
.22fc	b1 15		lda ($15),y			lda 	(temp2),y 					; read in the line number to YA
.22fe	aa		tax				tax
.22ff	c8		iny				iny
.2300	b1 15		lda ($15),y			lda 	(temp2),y
.2302	a8		tay				tay
.2303	8a		txa				txa
.2304	38		sec				sec 								; return with carry set as found
.2305	60		rts				rts
.2306					_ESUNext:
.2306	18		clc				clc
.2307	a5 15		lda $15				lda 	temp2
.2309	72 15		adc ($15)			adc 	(temp2)
.230b	85 15		sta $15				sta 	temp2
.230d	90 02		bcc $2311			bcc 	_NoCarryAdv
.230f	e6 16		inc $16				inc 	temp2+1
.2311					_NoCarryAdv:
.2311	80 c9		bra $22dc			bra 	_ESULoop 					; and loop round
.2313					_ESUFail:
.2313	18		clc				clc
.2314	60		rts				rts

;******  Return to file: files.asm


;******  Processing file: words/encode/encutils.src

.2315					EncodeWriteWord:
.2315	48		pha				pha
.2316	20 1f 23	jsr $231f			jsr 	EncodeWriteByte
.2319	98		tya				tya
.231a	20 1f 23	jsr $231f			jsr 	EncodeWriteByte
.231d	68		pla				pla
.231e	60		rts				rts
.231f					EncodeWriteByte:
.231f	da		phx				phx
.2320	ae 10 09	ldx $0910			ldx 	encodeBuffer
.2323	9d 10 09	sta $0910,x			sta 	encodeBuffer,x
.2326	9e 11 09	stz $0911,x			stz 	encodeBuffer+1,x
.2329	9e 12 09	stz $0912,x			stz 	encodeBuffer+2,x
.232c	ee 10 09	inc $0910			inc 	encodeBuffer
.232f	fa		plx				plx
.2330	60		rts				rts
.2331					CheckIsLetter:
.2331	c9 41		cmp #$41			cmp 	#"A"						; return CS if A..Z
.2333	90 06		bcc $233b			bcc 	_CILFail
.2335	c9 5b		cmp #$5b			cmp 	#"Z"+1
.2337	b0 02		bcs $233b			bcs 	_CILFail
.2339	38		sec				sec
.233a	60		rts				rts
.233b					_CILFail:
.233b	18		clc				clc
.233c	60		rts				rts
.233d					CheckIsDigit:
.233d	c9 30		cmp #$30			cmp 	#"0"						; return CS if 0..9
.233f	90 06		bcc $2347			bcc 	_CIDFail
.2341	c9 3a		cmp #$3a			cmp 	#"9"+1
.2343	b0 02		bcs $2347			bcs 	_CIDFail
.2345	38		sec				sec
.2346	60		rts				rts
.2347					_CIDFail:
.2347	18		clc				clc
.2348	60		rts				rts
.2349					EncodeMoveNextWord:
.2349	a0 ff		ldy #$ff			ldy 	#255 						; search forward
.234b					_EPNWLoop:
.234b	c8		iny				iny
.234c	b1 0b		lda ($0b),y			lda 	(srcPtr),y
.234e	c9 21		cmp #$21			cmp 	#" "+1						; looking for <= space
.2350	b0 f9		bcs $234b			bcs 	_EPNWLoop
.2352	98		tya				tya
.2353	80 00		bra $2355			bra 	EncodeAddSrcPtr
.2355					EncodeAddSrcPtr:
.2355	18		clc				clc 								; add offset
.2356	65 0b		adc $0b				adc 	srcPtr
.2358	85 0b		sta $0b				sta 	srcPtr
.235a	90 02		bcc $235e			bcc 	_EASPNoCarry
.235c	e6 0c		inc $0c				inc 	srcPtr+1					; carry through
.235e					_EASPNoCarry:
.235e	60		rts				rts
.235f					EncodeGetConstant:
.235f	a5 0b		lda $0b				lda 	srcPtr 						; get source
.2361	a4 0c		ldy $0c				ldy 	srcPtr+1
.2363	20 1e 1e	jsr $1e1e			jsr 	ConvertToInteger 			; call converter
.2366	90 08		bcc $2370			bcc 	_EGCExit
.2368	20 55 23	jsr $2355			jsr 	EncodeAddSrcPtr 			; if passed add chars to src ptr
.236b	a5 17		lda $17				lda 	temp3 						; get result into YA
.236d	a4 18		ldy $18				ldy 	temp3+1
.236f	38		sec				sec 								; return CS
.2370					_EGCExit:
.2370	60		rts				rts
.2371					EncSetBit7Word:
.2371	08		php				php 								; save carry
.2372	a0 ff		ldy #$ff			ldy 	#255 						; scan forward for space/NULL
.2374					_ESB7Loop:
.2374	c8		iny				iny
.2375	b1 0b		lda ($0b),y			lda 	(srcPtr),y
.2377	c9 21		cmp #$21			cmp 	#" "+1 						; while > ' '
.2379	b0 f9		bcs $2374			bcs 	_ESB7Loop
.237b	88		dey				dey									; previous character
.237c	b1 0b		lda ($0b),y			lda 	(srcPtr),y 					; read it
.237e	0a		asl a				asl 	a 							; shift bit 7 out
.237f	28		plp				plp 								; restore carry
.2380	6a		ror a				ror 	a 							; shift it in
.2381	91 0b		sta ($0b),y			sta 	(srcPtr),y 					; write back and exit
.2383	60		rts				rts
.2384					EncSkipSpaces:
.2384	b2 0b		lda ($0b)			lda 	(srcPtr) 					; skip over spaces/ reached end
.2386	c9 20		cmp #$20			cmp 	#32
.2388	d0 07		bne $2391			bne 	_ESNotSpace
.238a	a9 01		lda #$01			lda 	#1
.238c	20 55 23	jsr $2355			jsr 	EncodeAddSrcPtr
.238f	80 f3		bra $2384			bra	 	EncSkipSpaces
.2391					_ESNotSpace:
.2391	60		rts				rts
.2392					EncodeTrimTrailingSpaces:
.2392	a0 ff		ldy #$ff			ldy 	#255 						; find EOS
.2394					_ETTFindEnd:
.2394	c8		iny				iny
.2395	b1 0b		lda ($0b),y			lda 	(srcPtr),y
.2397	d0 fb		bne $2394			bne 	_ETTFindEnd
.2399					_ETTRemoveSpace:
.2399	c0 00		cpy #$00			cpy 	#0 							; start of string
.239b	f0 0d		beq $23aa			beq 	_ETTExit
.239d	88		dey				dey 								; previous character 1..32
.239e	b1 0b		lda ($0b),y			lda 	(srcPtr),y
.23a0	c9 21		cmp #$21			cmp 	#32+1
.23a2	b0 06		bcs $23aa			bcs 	_ETTExit
.23a4	a9 00		lda #$00			lda 	#0 							; erase it and go round again
.23a6	91 0b		sta ($0b),y			sta 	(srcPtr),y
.23a8	80 ef		bra $2399			bra 	_ETTRemoveSpace
.23aa					_ETTExit:
.23aa	60		rts				rts
.23ab					EncodePushPosMarkerOnStack:
.23ab	e6 08		inc $08				inc 	rsp 						; make space on rstack
.23ad	a6 08		ldx $08				ldx 	rsp							; access it
.23af	9d 40 07	sta $0740,x			sta 	returnStackHigh,x			; save marker
.23b2	ad 10 09	lda $0910			lda 	encodeBuffer 				; save position in encode buffer
.23b5	9d 80 07	sta $0780,x			sta 	returnStackX,x
.23b8	60		rts				rts

;******  Return to file: files.asm


;******  Processing file: words/encode/encsearch.src

.23b9					EncodeSearchDictionary:
.23b9	a9 b8		lda #$b8			lda 	#(Dictionary) & $FF
.23bb	85 13		sta $13				sta 	0+(temp1)
.23bd	a9 26		lda #$26			lda 	#(Dictionary) >> 8
.23bf	85 14		sta $14				sta 	1+(temp1)
.23c1					_ESDLoop:
.23c1	b2 13		lda ($13)			lda 	(temp1) 					; end of dictionary return with CC.
.23c3	18		clc				clc
.23c4	f0 46		beq $240c			beq 	_ESDExit
.23c6	a0 01		ldy #$01			ldy 	#1 							; get control bits, get offset to name.
.23c8	b1 13		lda ($13),y			lda 	(temp1),y
.23ca	4a		lsr a				lsr 	a 							; encode/decode bits move to 0,1
.23cb	4a		lsr a				lsr 	a
.23cc	4a		lsr a				lsr 	a
.23cd	4a		lsr a				lsr 	a
.23ce	c8		iny				iny 								; Y = 2
.23cf	4a		lsr a				lsr 	a
.23d0	90 01		bcc $23d3			bcc 	_ESDNotDec
.23d2	c8		iny				iny
.23d3					_ESDNotDec:
.23d3	4a		lsr a				lsr 	a
.23d4	90 01		bcc $23d7			bcc 	_ESDNotInc
.23d6	c8		iny				iny
.23d7					_ESDNotInc:
.23d7	98		tya				tya
.23d8	0a		asl a				asl 	a 							; A is now 4,6,8 offset to name.
.23d9	a8		tay				tay
.23da	b1 13		lda ($13),y			lda 	(temp1),y 					; quick check of first character
.23dc	d2 0b		cmp ($0b)			cmp 	(srcPtr)
.23de	d0 1f		bne $23ff			bne 	_ESDNext 					; do not match, go to next
.23e0	98		tya				tya 								; make temp2 point to the name in
.23e1	18		clc				clc 								; the dictionary.
.23e2	65 13		adc $13				adc 	temp1
.23e4	85 15		sta $15				sta 	temp2
.23e6	a5 14		lda $14				lda 	temp1+1
.23e8	69 00		adc #$00			adc 	#0
.23ea	85 16		sta $16				sta 	temp2+1
.23ec	a0 ff		ldy #$ff			ldy 	#255 						; now start matching up.
.23ee					_ESDCompare:
.23ee	c8		iny				iny
.23ef	b1 0b		lda ($0b),y			lda 	(srcPtr),y
.23f1	d1 15		cmp ($15),y			cmp 	(temp2),y
.23f3	d0 0a		bne $23ff			bne 	_ESDNext
.23f5	0a		asl a				asl 	a
.23f6	90 f6		bcc $23ee			bcc 	_ESDCompare
.23f8	a5 13		lda $13				lda 	temp1 						; return address in YA and carry set.
.23fa	a4 14		ldy $14				ldy 	temp1+1
.23fc	38		sec				sec
.23fd	80 0d		bra $240c			bra 	_ESDExit
.23ff					_ESDNext:
.23ff	18		clc				clc
.2400	a5 13		lda $13				lda 	temp1
.2402	72 13		adc ($13)			adc 	(temp1)
.2404	85 13		sta $13				sta 	temp1
.2406	90 b9		bcc $23c1			bcc 	_ESDLoop
.2408	e6 14		inc $14				inc 	temp1+1
.240a	80 b5		bra $23c1			bra 	_ESDLoop
.240c					_ESDExit:
.240c	60		rts				rts

;******  Return to file: files.asm


;******  Processing file: words/encode/encvar.src

.240d					EncodeVariableReference:
.240d	b2 0b		lda ($0b)			lda 	(srcPtr)					; get the type, use it to identify the routine
.240f	a2 57		ldx #$57			ldx 	#VarAddressHandler & $FF
.2411	a0 1f		ldy #$1f			ldy 	#VarAddressHandler >> 8
.2413	c9 26		cmp #$26			cmp 	#"&"
.2415	f0 0c		beq $2423			beq 	_EVFHaveAddress
.2417	a2 74		ldx #$74			ldx 	#VarReadHandler & $FF
.2419	a0 1f		ldy #$1f			ldy 	#VarReadHandler >> 8
.241b	c9 40		cmp #$40			cmp 	#"@"
.241d	f0 04		beq $2423			beq 	_EVFHaveAddress
.241f	a2 93		ldx #$93			ldx 	#VarWriteHandler & $FF
.2421	a0 1f		ldy #$1f			ldy 	#VarWriteHandler >> 8
.2423					_EVFHaveAddress:
.2423	8a		txa				txa
.2424	20 15 23	jsr $2315			jsr 	EncodeWriteWord 			; write it out.
.2427	a0 01		ldy #$01			ldy 	#1 							; get the first charactere
.2429	b1 0b		lda ($0b),y			lda 	(srcPtr),y
.242b	29 7f		and #$7f			and 	#$7F 						; might be the last.
.242d	20 31 23	jsr $2331			jsr 	CheckIsLetter 				; is it A-Z
.2430	90 54		bcc $2486			bcc 	EVFFail
.2432	29 1f		and #$1f			and 	#31 						; make 1-26
.2434	85 13		sta $13				sta 	temp1 						; start building the name in temp1
.2436	64 14		stz $14				stz 	temp1+1
.2438	38		sec				sec 								; possible char 2
.2439	20 9b 24	jsr $249b			jsr 	EncVarAlNum
.243c	18		clc				clc 								; possible char 3
.243d	20 9b 24	jsr $249b			jsr 	EncVarAlNum
.2440	5a		phy				phy
.2441	a5 13		lda $13				lda 	temp1 						; write out variable identifier.
.2443	a4 14		ldy $14				ldy 	temp1+1
.2445	20 15 23	jsr $2315			jsr 	EncodeWriteWord
.2448	7a		ply				ply
.2449	b1 0b		lda ($0b),y			lda 	(srcPtr),y 					; more text after ?
.244b	10 01		bpl $244e			bpl 	_EVFCheckArray
.244d	60		rts				rts
.244e					_EVFCheckArray:
.244e	c8		iny				iny 								; get the next character
.244f	b1 0b		lda ($0b),y			lda 	(srcPtr),y
.2451	c9 5b		cmp #$5b			cmp 	#"["						; array index ?
.2453	d0 31		bne $2486			bne 	EVFFail
.2455	64 13		stz $13				stz 	temp1 						; zero temp1.
.2457	c8		iny				iny  								; point to index
.2458					_EVFGetIndex:
.2458	06 13		asl $13				asl 	temp1 						; temp1 x 10
.245a	a5 13		lda $13				lda 	temp1
.245c	0a		asl a				asl 	a
.245d	0a		asl a				asl		a
.245e	65 13		adc $13				adc 	temp1
.2460	85 13		sta $13				sta 	temp1
.2462	b1 0b		lda ($0b),y			lda 	(srcPtr),y 					; get the digit
.2464	20 3d 23	jsr $233d			jsr 	CheckIsDigit
.2467	90 1d		bcc $2486			bcc 	EVFFail 					; failed, not digit
.2469	29 0f		and #$0f			and 	#15
.246b	18		clc				clc
.246c	65 13		adc $13				adc 	temp1
.246e	30 16		bmi $2486			bmi 	EVFFail 					; failed, bad index.
.2470	85 13		sta $13				sta 	temp1
.2472	c8		iny				iny
.2473	b1 0b		lda ($0b),y			lda 	(srcPtr),y
.2475	c9 dd		cmp #$dd			cmp 	#"]"+$80
.2477	d0 df		bne $2458			bne 	_EVFGetIndex 				; index now in temp1.
.2479	a9 b2		lda #$b2			lda 	#IndexHandler & $FF 		; output code
.247b	a0 1f		ldy #$1f			ldy 	#IndexHandler >> 8
.247d	20 15 23	jsr $2315			jsr 	EncodeWriteWord
.2480	a5 13		lda $13				lda 	temp1	 					; write index
.2482	20 1f 23	jsr $231f			jsr 	EncodeWriteByte
.2485	60		rts				rts
.2486					EVFFail:
.2486	20 7a 25	jsr $257a			jsr 	ErrorHandler
>2489	42 41 44 20 56 41 52 49				.text 	"BAD VARIABLE NAME",0
>2491	41 42 4c 45 20 4e 41 4d 45 00
.249b					EncVarAlNum:
.249b	b1 0b		lda ($0b),y			lda 	(srcPtr),y 					; points to the  last char processed.
.249d	10 01		bpl $24a0			bpl 	_EVAContinue
.249f	60		rts				rts
.24a0					_EVAContinue:
.24a0	08		php				php 								; CS x 32 ; CC x 32 x 40
.24a1	c8		iny				iny 								; get the next character, strip bit 7
.24a2	b1 0b		lda ($0b),y			lda 	(srcPtr),y
.24a4	88		dey				dey
.24a5	29 7f		and #$7f			and 	#$7F
.24a7	20 31 23	jsr $2331			jsr 	CheckIsLetter 				; letter ?
.24aa	b0 08		bcs $24b4			bcs 	_EVACharOkay
.24ac	20 3d 23	jsr $233d			jsr 	CheckIsDigit				; fail if not digit.
.24af	90 32		bcc $24e3			bcc 	_EVAExit
.24b1	18		clc				clc
.24b2	69 2b		adc #$2b			adc 	#"Z"+1-"0"					; shift 0 so after Z
.24b4					_EVACharOkay:
.24b4	c8		iny				iny 								; char okay advance to it.
.24b5	38		sec				sec 								; range 1-36
.24b6	e9 40		sbc #$40			sbc 	#64
.24b8	28		plp				plp 								; which multiplier ?
.24b9	90 0f		bcc $24ca			bcc 	_EVATimes32x40
.24bb	85 15		sta $15				sta 	temp2 						; save in temp2 - A x 32
.24bd	64 16		stz $16				stz 	temp2+1
.24bf	a2 05		ldx #$05			ldx 	#5
.24c1	06 15		asl $15		_EVA32:	asl 	temp2
.24c3	26 16		rol $16				rol 	temp2+1
.24c5	ca		dex				dex
.24c6	d0 f9		bne $24c1			bne 	_EVA32
.24c8	80 0b		bra $24d5			bra 	_EVAAddVar
.24ca					_EVATimes32x40:
.24ca	85 16		sta $16				sta 	temp2+1						; 32 x 40 = 1280 or $500, so temp2 = A x 256 x 5
.24cc	64 15		stz $15				stz 	temp2
.24ce	0a		asl a				asl 	a
.24cf	0a		asl a				asl 	a
.24d0	18		clc				clc
.24d1	65 16		adc $16				adc 	temp2+1
.24d3	85 16		sta $16				sta 	temp2+1
.24d5					_EVAAddVar:
.24d5	18		clc				clc
.24d6	a5 13		lda $13				lda 	temp1
.24d8	65 15		adc $15				adc 	temp2
.24da	85 13		sta $13				sta 	temp1
.24dc	a5 14		lda $14				lda 	temp1+1
.24de	65 16		adc $16				adc 	temp2+1
.24e0	85 14		sta $14				sta 	temp1+1
.24e2	08		php				php
.24e3					_EVAExit:
.24e3	28		plp				plp
.24e4	60		rts				rts

;******  Return to file: files.asm


;******  Return to file: kernel.asm

.24e5					ColdStart:
.24e5	a2 ff		ldx #$ff			ldx 	#$FF 						; reset the stack
.24e7	9a		txs				txs
.24e8	64 24		stz $24				stz 	FastMode 					; start in slow mode.
.24ea	20 ad 25	jsr $25ad			jsr 	ExternInitialise
.24ed	a9 28		lda #$28			lda 	#BootMsg & $FF
.24ef	a0 25		ldy #$25			ldy 	#BootMsg >> 8
.24f1	20 a1 26	jsr $26a1			jsr 	EXPrintString
.24f4					WarmStartBlankStack:
.24f4	86 13		stx $13				stx 	temp1
.24f6	a2 80		ldx #$80			ldx 	#NumberStackBase
.24f8	9a		txs				txs
.24f9	a6 13		ldx $13				ldx 	temp1
.24fb					WarmStart:
.24fb	a9 03		lda #$03			lda 	#COL_Yellow
.24fd	20 e6 25	jsr $25e6			jsr 	ExternColour
.2500	20 09 26	jsr $2609			jsr 	ExternInput
.2503	a9 06		lda #$06			lda 	#COL_Cyan
.2505	20 e6 25	jsr $25e6			jsr 	ExternColour
.2508	a2 10		ldx #$10			ldx 	#encodeBuffer & $FF 		; run what is in the encode buffer.
.250a	a0 09		ldy #$09			ldy 	#encodeBuffer >> 8
.250c	20 03 10	jsr $1003			jsr 	InitialiseCoreCode 			; initialise the NEXT routine at $00 so error line# works
.250f	a9 10		lda #$10			lda 	#textBuffer & $FF
.2511	a0 08		ldy #$08			ldy 	#textBuffer >> 8
.2513	20 05 21	jsr $2105			jsr 	EncodeProgram
.2516	ad 11 09	lda $0911			lda 	encodeBuffer+1 				; has a line number been entered ?
.2519	0d 12 09	ora $0912			ora 	encodeBuffer+2
.251c	d0 05		bne $2523			bne 	LineEditor 					; if so, do the line editing code.
.251e	64 08		stz $08				stz 	rsp
.2520	4c 00 00	jmp $0000			jmp 	NextCode
.2523					LineEditor:
.2523	20 f5 19	jsr $19f5			jsr 	EditProgram
.2526	80 cc		bra $24f4			bra 	WarmStartBlankStack
.2528					BootMsg:
>2528	2a 2a 2a 20 52 50 4c 2f				.text 	"*** RPL/C INTERPRETER ***",13,13
>2530	43 20 49 4e 54 45 52 50 52 45 54 45 52 20 2a 2a
>2540	2a 0d 0d
>2543	57 52 49 54 54 45 4e 20				.text	"WRITTEN BY PAUL ROBSON 2020",13,13
>254b	42 59 20 50 41 55 4c 20 52 4f 42 53 4f 4e 20 32
>255b	30 32 30 0d 0d
>2560	42 55 49 4c 44 3a 20				.text 	"BUILD: "

;******  Processing file: generated/timestamp.inc

>2567	5b 32 30 2d 30 31 2d 31			.text	"[20-01-19 09:06]"
>256f	39 20 30 39 3a 30 36 5d

;******  Return to file: kernel.asm

>2577	0d 0d 00					.byte 	13,13,0

;******  Processing file: code/error.asm

.257a					ErrorHandler:
.257a	68		pla				pla 								; get message address
.257b	7a		ply				ply
.257c	1a		inc a				inc 	a
.257d	d0 01		bne $2580			bne 	_EHNoCarry
.257f	c8		iny				iny
.2580					_EHNoCarry:
.2580	20 a1 26	jsr $26a1			jsr 	EXPrintString
.2583	a0 01		ldy #$01			ldy 	#1 							; check if there is a line #
.2585	b1 03		lda ($03),y			lda 	(IP),y
.2587	c8		iny				iny
.2588	11 03		ora ($03),y			ora 	(IP),y
.258a	f0 14		beq $25a0			beq 	_EHNoLine
.258c	a9 a8		lda #$a8			lda 	#_EHMsg2 & $FF 				; print " at "
.258e	a0 25		ldy #$25			ldy 	#_EHMsg2 >> 8
.2590	20 a1 26	jsr $26a1			jsr 	EXPrintString
.2593	a0 02		ldy #$02			ldy 	#2 							; print line number
.2595	b1 03		lda ($03),y			lda 	(IP),y
.2597	48		pha				pha
.2598	88		dey				dey
.2599	b1 03		lda ($03),y			lda 	(IP),y
.259b	7a		ply				ply
.259c	18		clc				clc
.259d	20 c6 1e	jsr $1ec6			jsr 	PrintYA
.25a0					_EHNoLine:
.25a0	a9 0d		lda #$0d			lda 	#13
.25a2	20 da 25	jsr $25da			jsr 	ExternPrint
.25a5	4c f4 24	jmp $24f4			jmp 	WarmStartBlankStack			; S is indeterminate
>25a8	20 41 54 20 00			_EHMsg2:.text 	" AT ",0

;******  Return to file: kernel.asm


;******  Processing file: code/extern.asm

.25ad					ExternInitialise:
.25ad	a9 90		lda #$90			lda 	#144 						; set colour
.25af	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.25b2	a9 01		lda #$01			lda 	#$01
.25b4	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.25b7	a9 0e		lda #$0e			lda 	#14							; lower case
.25b9	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.25bc	a9 93		lda #$93			lda 	#147 						; clear screen
.25be	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.25c1	a9 07		lda #$07			lda 	#COL_WHITE 					; white text.
.25c3	4c e6 25	jmp $25e6			jmp 	ExternColour
.25c6					ExternCheckBreak:
.25c6	da		phx				phx 								; make sure we keep XY
.25c7	5a		phy				phy
.25c8	20 e1 ff	jsr $ffe1			jsr 	$FFE1						; STOP check on CBM KERNAL
.25cb	f0 03		beq $25d0			beq		_ECBExit 					; stopped
.25cd	7a		ply				ply 								; restore and exit.
.25ce	fa		plx				plx
.25cf	60		rts				rts
.25d0					_ECBExit:
.25d0	20 7a 25	jsr $257a			jsr 	ErrorHandler
>25d3	45 53 43 41 50 45 00				.text 	"ESCAPE",0
.25da					ExternPrint:
.25da	48		pha				pha
.25db	da		phx				phx
.25dc	5a		phy				phy
.25dd	29 7f		and #$7f			and 	#$7F
.25df	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.25e2	7a		ply				ply
.25e3	fa		plx				plx
.25e4	68		pla				pla
.25e5	60		rts				rts
.25e6					ExternColour:
.25e6	48		pha				pha
.25e7	da		phx				phx
.25e8	48		pha				pha
.25e9	29 08		and #$08			and 	#8
.25eb	0a		asl a				asl 	a
.25ec	0a		asl a				asl 	a
.25ed	0a		asl a				asl 	a
.25ee	0a		asl a				asl 	a
.25ef	49 92		eor #$92			eor 	#$92
.25f1	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.25f4	68		pla				pla
.25f5	29 07		and #$07			and 	#7
.25f7	aa		tax				tax
.25f8	bd 01 26	lda $2601,x			lda 	_ECTable,x
.25fb	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.25fe	fa		plx				plx
.25ff	68		pla				pla
.2600	60		rts				rts
.2601					_ECTable:
>2601	90						.byte 	144
>2602	1c						.byte 	28
>2603	1e						.byte 	30
>2604	9e						.byte 	158
>2605	1f						.byte 	31
>2606	9c						.byte 	156
>2607	9f						.byte 	159
>2608	05						.byte 	5
.2609					ExternInput:
.2609	a9 10		lda #$10			lda 	#(textBuffer & $FF)
.260b	85 17		sta $17				sta 	temp3
.260d	a9 08		lda #$08			lda 	#(textBuffer >> 8)
.260f	85 18		sta $18				sta 	temp3+1
.2611	20 cf ff	jsr $ffcf	_EIRead:jsr 	$FFCF
.2614	c9 0d		cmp #$0d			cmp 	#13
.2616	f0 0c		beq $2624			beq 	_EIExit
.2618	29 7f		and #$7f			and 	#$7F
.261a	92 17		sta ($17)			sta 	(temp3)
.261c	e6 17		inc $17				inc 	temp3
.261e	d0 f1		bne $2611			bne 	_EIRead
.2620	e6 18		inc $18				inc 	temp3+1
.2622	80 ed		bra $2611			bra 	_EIRead
.2624	a9 00		lda #$00	_EIExit:lda 	#0
.2626	92 17		sta ($17)			sta 	(temp3)
.2628	a9 0d		lda #$0d			lda 	#13
.262a	20 da 25	jsr $25da			jsr 	ExternPrint
.262d	60		rts				rts
.262e					ExternSave:
.262e	da		phx				phx
.262f	5a		phy				phy
.2630	85 15		sta $15				sta 	temp2 						; save start
.2632	84 16		sty $16				sty 	temp2+1
.2634	20 96 26	jsr $2696			jsr 	EXGetLength 				; get length of file into A
.2637	a6 17		ldx $17				ldx 	temp3
.2639	a4 18		ldy $18				ldy 	temp3+1
.263b	20 bd ff	jsr $ffbd			jsr 	$FFBD 						; set name
.263e	a9 01		lda #$01			lda 	#1
.2640	a2 08		ldx #$08			ldx 	#8	 						; device #8
.2642	a0 00		ldy #$00			ldy 	#0
.2644	20 ba ff	jsr $ffba			jsr 	$FFBA 						; set LFS
.2647	a6 13		ldx $13				ldx 	temp1 						; end address
.2649	a4 14		ldy $14				ldy 	temp1+1
.264b	a9 15		lda #$15			lda 	#temp2
.264d	20 d8 ff	jsr $ffd8			jsr 	$FFD8 						; save
.2650	b0 03		bcs $2655			bcs 	_ESSave
.2652	7a		ply				ply
.2653	fa		plx				plx
.2654	60		rts				rts
.2655					_ESSave:
.2655	20 7a 25	jsr $257a			jsr 	ErrorHandler
>2658	53 41 56 45 20 46 41 49				.text 	"SAVE FAILED",0
>2660	4c 45 44 00
.2664					ExternLoad:
.2664	da		phx				phx 								; save XY
.2665	5a		phy				phy
.2666	48		pha				pha 								; save target
.2667	5a		phy				phy
.2668	20 96 26	jsr $2696			jsr 	EXGetLength 				; get length of file into A
.266b	a6 17		ldx $17				ldx 	temp3
.266d	a4 18		ldy $18				ldy 	temp3+1
.266f	20 bd ff	jsr $ffbd			jsr 	$FFBD 						; set name
.2672	a9 01		lda #$01			lda 	#1
.2674	a2 08		ldx #$08			ldx 	#8	 						; device #8
.2676	a0 00		ldy #$00			ldy 	#0
.2678	20 ba ff	jsr $ffba			jsr 	$FFBA 						; set LFS
.267b	7a		ply				ply 								; restore target to YX and call load
.267c	fa		plx				plx
.267d	a9 00		lda #$00			lda 	#0 							; load command
.267f	20 d5 ff	jsr $ffd5			jsr 	$FFD5
.2682	b0 03		bcs $2687			bcs 	_ESLoad
.2684	7a		ply				ply
.2685	fa		plx				plx
.2686	60		rts				rts
.2687					_ESLoad:
.2687	20 7a 25	jsr $257a			jsr 	ErrorHandler
>268a	4c 4f 41 44 20 46 41 49				.text 	"LOAD FAILED",0
>2692	4c 45 44 00
.2696					EXGetLength:
.2696	5a		phy				phy
.2697	a0 ff		ldy #$ff			ldy 	#255
.2699	c8		iny		_EXGL0:	iny
.269a	b1 17		lda ($17),y			lda 	(temp3),y
.269c	d0 fb		bne $2699			bne 	_EXGL0
.269e	98		tya				tya
.269f	7a		ply				ply
.26a0	60		rts				rts
.26a1					EXPrintString:
.26a1	48		pha				pha
.26a2	5a		phy				phy
.26a3	84 14		sty $14				sty 	temp1+1
.26a5	85 13		sta $13				sta 	temp1
.26a7	a0 00		ldy #$00			ldy 	#0
.26a9					_EXPSLoop:
.26a9	b1 13		lda ($13),y			lda 	(temp1),y
.26ab	f0 08		beq $26b5			beq 	_EXPSExit
.26ad	29 7f		and #$7f			and 	#$7F
.26af	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.26b2	c8		iny				iny
.26b3	80 f4		bra $26a9			bra 	_EXPSLoop
.26b5					_EXPSExit:
.26b5	7a		ply				ply
.26b6	68		pla				pla
.26b7	60		rts				rts

;******  Return to file: kernel.asm

.26b8					Dictionary:

;******  Processing file: generated/dictionary.inc

>26b8	05					.byte	_end0-*
>26b9	00					.byte	$00
>26ba	0a 15					.word	WordWrite
>26bc	a1					.byte	$a1
.26bd					_end0:
>26bd	10					.byte	_end1-*
>26be	52					.byte	$52
>26bf	93 1f					.word	VarWriteHandler
>26c1	ad 1f					.word	VarWriteHandlerDecode
>26c3	24 24 21 48 41 4e 44 4c			.byte	$24,$24,$21,$48,$41,$4e,$44,$4c,$45,$d2
>26cb	45 d2
.26cd					_end1:
>26cd	10					.byte	_end2-*
>26ce	52					.byte	$52
>26cf	57 1f					.word	VarAddressHandler
>26d1	6f 1f					.word	VarAddrHandlerDecode
>26d3	24 24 26 48 41 4e 44 4c			.byte	$24,$24,$26,$48,$41,$4e,$44,$4c,$45,$d2
>26db	45 d2
.26dd					_end2:
>26dd	10					.byte	_end3-*
>26de	52					.byte	$52
>26df	74 1f					.word	VarReadHandler
>26e1	8e 1f					.word	VarReadHandlerDecode
>26e3	24 24 40 48 41 4e 44 4c			.byte	$24,$24,$40,$48,$41,$4e,$44,$4c,$45,$d2
>26eb	45 d2
.26ed					_end3:
>26ed	0c					.byte	_end4-*
>26ee	52					.byte	$52
>26ef	df 16					.word	CallHandler
>26f1	8a 17					.word	CallHandlerDecode
>26f3	24 24 43 41 4c cc			.byte	$24,$24,$43,$41,$4c,$cc
.26f9					_end4:
>26f9	0f					.byte	_end5-*
>26fa	53					.byte	$53
>26fb	ca 1d					.word	SkipComment
>26fd	d7 1d					.word	CommentDecoder
>26ff	24 24 43 4f 4d 4d 45 4e			.byte	$24,$24,$43,$4f,$4d,$4d,$45,$4e,$d4
>2707	d4
.2708					_end5:
>2708	0e					.byte	_end6-*
>2709	53					.byte	$53
>270a	f5 1d					.word	DefineCode
>270c	0b 1e					.word	DefineDecoder
>270e	24 24 44 45 46 49 4e c5			.byte	$24,$24,$44,$45,$46,$49,$4e,$c5
.2716					_end6:
>2716	0f					.byte	_end7-*
>2717	52					.byte	$52
>2718	6d 10					.word	Literal2Byte
>271a	b5 10					.word	Literal2ByteDecode
>271c	24 24 4c 49 54 45 52 41			.byte	$24,$24,$4c,$49,$54,$45,$52,$41,$cc
>2724	cc
.2725					_end7:
>2725	0e					.byte	_end8-*
>2726	80					.byte	$80
>2727	b3 1d					.word	NextLine
>2729	24 24 4e 45 58 54 4c 49			.byte	$24,$24,$4e,$45,$58,$54,$4c,$49,$4e,$c5
>2731	4e c5
.2733					_end8:
>2733	0e					.byte	_end9-*
>2734	53					.byte	$53
>2735	c7 10					.word	LiteralString
>2737	e6 10					.word	LiteralStringDecoder
>2739	24 24 53 54 52 49 4e c7			.byte	$24,$24,$53,$54,$52,$49,$4e,$c7
.2741					_end9:
>2741	05					.byte	_end10-*
>2742	00					.byte	$00
>2743	86 12					.word	Multiply16x16
>2745	aa					.byte	$aa
.2746					_end10:
>2746	05					.byte	_end11-*
>2747	00					.byte	$00
>2748	f7 10					.word	Add
>274a	ab					.byte	$ab
.274b					_end11:
>274b	06					.byte	_end12-*
>274c	00					.byte	$00
>274d	1b 15					.word	WordAdd
>274f	2b a1					.byte	$2b,$a1
.2751					_end12:
>2751	05					.byte	_end13-*
>2752	00					.byte	$00
>2753	06 11					.word	Subtract
>2755	ad					.byte	$ad
.2756					_end13:
>2756	06					.byte	_end14-*
>2757	00					.byte	$00
>2758	c2 13					.word	ConstantMinus1
>275a	2d b1					.byte	$2d,$b1
.275c					_end14:
>275c	06					.byte	_end15-*
>275d	00					.byte	$00
>275e	7a 1c					.word	DumpStack
>2760	2e ae					.byte	$2e,$ae
.2762					_end15:
>2762	05					.byte	_end16-*
>2763	00					.byte	$00
>2764	d7 11					.word	Divide16x16
>2766	af					.byte	$af
.2767					_end16:
>2767	05					.byte	_end17-*
>2768	00					.byte	$00
>2769	b5 13					.word	Constant0
>276b	b0					.byte	$b0
.276c					_end17:
>276c	06					.byte	_end18-*
>276d	00					.byte	$00
>276e	1b 13					.word	CheckMinus
>2770	30 bc					.byte	$30,$bc
.2772					_end18:
>2772	06					.byte	_end19-*
>2773	00					.byte	$00
>2774	2f 13					.word	CheckZero
>2776	30 bd					.byte	$30,$bd
.2778					_end19:
>2778	05					.byte	_end20-*
>2779	00					.byte	$00
>277a	d1 13					.word	C1
>277c	b1					.byte	$b1
.277d					_end20:
>277d	06					.byte	_end21-*
>277e	00					.byte	$00
>277f	c5 12					.word	Unary1Plus
>2781	31 ab					.byte	$31,$ab
.2783					_end21:
>2783	06					.byte	_end22-*
>2784	00					.byte	$00
>2785	dc 12					.word	Unary1Minus
>2787	31 ad					.byte	$31,$ad
.2789					_end22:
>2789	06					.byte	_end23-*
>278a	00					.byte	$00
>278b	e9 13					.word	C10
>278d	31 b0					.byte	$31,$b0
.278f					_end23:
>278f	07					.byte	_end24-*
>2790	00					.byte	$00
>2791	12 14					.word	C100
>2793	31 30 b0				.byte	$31,$30,$b0
.2796					_end24:
>2796	08					.byte	_end25-*
>2797	00					.byte	$00
>2798	41 14					.word	C1024
>279a	31 30 32 b4				.byte	$31,$30,$32,$b4
.279e					_end25:
>279e	07					.byte	_end26-*
>279f	00					.byte	$00
>27a0	16 14					.word	C127
>27a2	31 32 b7				.byte	$31,$32,$b7
.27a5					_end26:
>27a5	07					.byte	_end27-*
>27a6	00					.byte	$00
>27a7	1a 14					.word	C128
>27a9	31 32 b8				.byte	$31,$32,$b8
.27ac					_end27:
>27ac	06					.byte	_end28-*
>27ad	00					.byte	$00
>27ae	ed 13					.word	C15
>27b0	31 b5					.byte	$31,$b5
.27b2					_end28:
>27b2	06					.byte	_end29-*
>27b3	00					.byte	$00
>27b4	f1 13					.word	C16
>27b6	31 b6					.byte	$31,$b6
.27b8					_end29:
>27b8	07					.byte	_end30-*
>27b9	00					.byte	$00
>27ba	53 13					.word	Times16
>27bc	31 36 aa				.byte	$31,$36,$aa
.27bf					_end30:
>27bf	07					.byte	_end31-*
>27c0	00					.byte	$00
>27c1	66 13					.word	Divide16
>27c3	31 36 af				.byte	$31,$36,$af
.27c6					_end31:
>27c6	05					.byte	_end32-*
>27c7	00					.byte	$00
>27c8	d5 13					.word	C2
>27ca	b2					.byte	$b2
.27cb					_end32:
>27cb	06					.byte	_end33-*
>27cc	00					.byte	$00
>27cd	5f 13					.word	Times2
>27cf	32 aa					.byte	$32,$aa
.27d1					_end33:
>27d1	06					.byte	_end34-*
>27d2	00					.byte	$00
>27d3	ce 12					.word	Unary2Plus
>27d5	32 ab					.byte	$32,$ab
.27d7					_end34:
>27d7	06					.byte	_end35-*
>27d8	00					.byte	$00
>27d9	e7 12					.word	Unary2Minus
>27db	32 ad					.byte	$32,$ad
.27dd					_end35:
>27dd	06					.byte	_end36-*
>27de	00					.byte	$00
>27df	72 13					.word	Divide2
>27e1	32 af					.byte	$32,$af
.27e3					_end36:
>27e3	06					.byte	_end37-*
>27e4	00					.byte	$00
>27e5	f5 13					.word	C24
>27e7	32 b4					.byte	$32,$b4
.27e9					_end37:
>27e9	07					.byte	_end38-*
>27ea	00					.byte	$00
>27eb	1e 14					.word	C255
>27ed	32 35 b5				.byte	$32,$35,$b5
.27f0					_end38:
>27f0	07					.byte	_end39-*
>27f1	00					.byte	$00
>27f2	29 14					.word	C256
>27f4	32 35 b6				.byte	$32,$35,$b6
.27f7					_end39:
>27f7	08					.byte	_end40-*
>27f8	00					.byte	$00
>27f9	79 13					.word	Times256
>27fb	32 35 36 aa				.byte	$32,$35,$36,$aa
.27ff					_end40:
>27ff	08					.byte	_end41-*
>2800	00					.byte	$00
>2801	82 13					.word	Divide256
>2803	32 35 36 af				.byte	$32,$35,$36,$af
.2807					_end41:
>2807	05					.byte	_end42-*
>2808	00					.byte	$00
>2809	d9 13					.word	C3
>280b	b3					.byte	$b3
.280c					_end42:
>280c	06					.byte	_end43-*
>280d	00					.byte	$00
>280e	06 14					.word	C32
>2810	33 b2					.byte	$33,$b2
.2812					_end43:
>2812	09					.byte	_end44-*
>2813	00					.byte	$00
>2814	59 14					.word	C32767
>2816	33 32 37 36 b7				.byte	$33,$32,$37,$36,$b7
.281b					_end44:
>281b	09					.byte	_end45-*
>281c	00					.byte	$00
>281d	65 14					.word	C32768
>281f	33 32 37 36 b8				.byte	$33,$32,$37,$36,$b8
.2824					_end45:
>2824	05					.byte	_end46-*
>2825	00					.byte	$00
>2826	dd 13					.word	C4
>2828	b4					.byte	$b4
.2829					_end46:
>2829	06					.byte	_end47-*
>282a	00					.byte	$00
>282b	5b 13					.word	Times4
>282d	34 aa					.byte	$34,$aa
.282f					_end47:
>282f	06					.byte	_end48-*
>2830	00					.byte	$00
>2831	6e 13					.word	Divide4
>2833	34 af					.byte	$34,$af
.2835					_end48:
>2835	08					.byte	_end49-*
>2836	00					.byte	$00
>2837	4d 14					.word	C4096
>2839	34 30 39 b6				.byte	$34,$30,$39,$b6
.283d					_end49:
>283d	05					.byte	_end50-*
>283e	00					.byte	$00
>283f	e1 13					.word	C5
>2841	b5					.byte	$b5
.2842					_end50:
>2842	07					.byte	_end51-*
>2843	00					.byte	$00
>2844	35 14					.word	C512
>2846	35 31 b2				.byte	$35,$31,$b2
.2849					_end51:
>2849	06					.byte	_end52-*
>284a	00					.byte	$00
>284b	0a 14					.word	C63
>284d	36 b3					.byte	$36,$b3
.284f					_end52:
>284f	06					.byte	_end53-*
>2850	00					.byte	$00
>2851	0e 14					.word	C64
>2853	36 b4					.byte	$36,$b4
.2855					_end53:
>2855	05					.byte	_end54-*
>2856	00					.byte	$00
>2857	e5 13					.word	C8
>2859	b8					.byte	$b8
.285a					_end54:
>285a	06					.byte	_end55-*
>285b	00					.byte	$00
>285c	57 13					.word	Times8
>285e	38 aa					.byte	$38,$aa
.2860					_end55:
>2860	06					.byte	_end56-*
>2861	00					.byte	$00
>2862	6a 13					.word	Divide8
>2864	38 af					.byte	$38,$af
.2866					_end56:
>2866	05					.byte	_end57-*
>2867	40					.byte	$40
>2868	47 17					.word	ReturnHandler
>286a	bb					.byte	$bb
.286b					_end57:
>286b	05					.byte	_end58-*
>286c	00					.byte	$00
>286d	73 11					.word	CheckLess
>286f	bc					.byte	$bc
.2870					_end58:
>2870	06					.byte	_end59-*
>2871	00					.byte	$00
>2872	8c 11					.word	CheckLessEq
>2874	3c bd					.byte	$3c,$bd
.2876					_end59:
>2876	06					.byte	_end60-*
>2877	00					.byte	$00
>2878	3c 11					.word	CheckNotEqual
>287a	3c be					.byte	$3c,$be
.287c					_end60:
>287c	05					.byte	_end61-*
>287d	00					.byte	$00
>287e	3f 11					.word	CheckEqual
>2880	bd					.byte	$bd
.2881					_end61:
>2881	05					.byte	_end62-*
>2882	00					.byte	$00
>2883	8f 11					.word	CheckGreater
>2885	be					.byte	$be
.2886					_end62:
>2886	06					.byte	_end63-*
>2887	00					.byte	$00
>2888	70 11					.word	CheckGreaterEq
>288a	3e bd					.byte	$3e,$bd
.288c					_end63:
>288c	08					.byte	_end64-*
>288d	00					.byte	$00
>288e	7a 14					.word	TestDup
>2890	3f 44 55 d0				.byte	$3f,$44,$55,$d0
.2894					_end64:
>2894	05					.byte	_end65-*
>2895	00					.byte	$00
>2896	ef 14					.word	WordRead
>2898	c0					.byte	$c0
.2899					_end65:
>2899	07					.byte	_end66-*
>289a	00					.byte	$00
>289b	f5 12					.word	Absolute
>289d	41 42 d3				.byte	$41,$42,$d3
.28a0					_end66:
>28a0	09					.byte	_end67-*
>28a1	00					.byte	$00
>28a2	32 15					.word	AllocateMemory
>28a4	41 4c 4c 4f c3				.byte	$41,$4c,$4c,$4f,$c3
.28a9					_end67:
>28a9	07					.byte	_end68-*
>28aa	00					.byte	$00
>28ab	15 11					.word	And
>28ad	41 4e c4				.byte	$41,$4e,$c4
.28b0					_end68:
>28b0	0a					.byte	_end69-*
>28b1	00					.byte	$00
>28b2	05 1c					.word	AssertCode
>28b4	41 53 53 45 52 d4			.byte	$41,$53,$53,$45,$52,$d4
.28ba					_end69:
>28ba	09					.byte	_end70-*
>28bb	00					.byte	$00
>28bc	48 13					.word	ByteSwap
>28be	42 53 57 41 d0				.byte	$42,$53,$57,$41,$d0
.28c3					_end70:
>28c3	06					.byte	_end71-*
>28c4	00					.byte	$00
>28c5	fd 14					.word	ByteWrite
>28c7	43 a1					.byte	$43,$a1
.28c9					_end71:
>28c9	06					.byte	_end72-*
>28ca	00					.byte	$00
>28cb	e6 14					.word	ByteRead
>28cd	43 c0					.byte	$43,$c0
.28cf					_end72:
>28cf	07					.byte	_end73-*
>28d0	00					.byte	$00
>28d1	5a 18					.word	ClrHandler
>28d3	43 4c d2				.byte	$43,$4c,$d2
.28d6					_end73:
>28d6	08					.byte	_end74-*
>28d7	00					.byte	$00
>28d8	71 14					.word	Drop
>28da	44 52 4f d0				.byte	$44,$52,$4f,$d0
.28de					_end74:
>28de	07					.byte	_end75-*
>28df	00					.byte	$00
>28e0	83 14					.word	Dup
>28e2	44 55 d0				.byte	$44,$55,$d0
.28e5					_end75:
>28e5	0a					.byte	_end76-*
>28e6	21					.byte	$21
>28e7	2b 16					.word	ElseHandler
>28e9	2e 16					.word	ElseEncoder
>28eb	45 4c 53 c5				.byte	$45,$4c,$53,$c5
.28ef					_end76:
>28ef	07					.byte	_end77-*
>28f0	00					.byte	$00
>28f1	26 1c					.word	EndProgram
>28f3	45 4e c4				.byte	$45,$4e,$c4
.28f6					_end77:
>28f6	0b					.byte	_end78-*
>28f7	20					.byte	$20
>28f8	4d 16					.word	EndIfHandler
>28fa	50 16					.word	EndIfEncoder
>28fc	45 4e 44 49 c6				.byte	$45,$4e,$44,$49,$c6
.2901					_end78:
>2901	09					.byte	_end79-*
>2902	20					.byte	$20
>2903	4b 15					.word	ForHandler
>2905	81 15					.word	ForEncoder
>2907	46 4f d2				.byte	$46,$4f,$d2
.290a					_end79:
>290a	08					.byte	_end80-*
>290b	21					.byte	$21
>290c	16 16					.word	IfHandler
>290e	19 16					.word	IfEncoder
>2910	49 c6					.byte	$49,$c6
.2912					_end80:
>2912	09					.byte	_end81-*
>2913	00					.byte	$00
>2914	f5 15					.word	GetIndex
>2916	49 4e 44 45 d8				.byte	$49,$4e,$44,$45,$d8
.291b					_end81:
>291b	08					.byte	_end82-*
>291c	00					.byte	$00
>291d	54 1b					.word	ListCode
>291f	4c 49 53 d4				.byte	$4c,$49,$53,$d4
.2923					_end82:
>2923	07					.byte	_end83-*
>2924	00					.byte	$00
>2925	ac 11					.word	Maximum
>2927	4d 41 d8				.byte	$4d,$41,$d8
.292a					_end83:
>292a	07					.byte	_end84-*
>292b	00					.byte	$00
>292c	a8 11					.word	Minimum
>292e	4d 49 ce				.byte	$4d,$49,$ce
.2931					_end84:
>2931	07					.byte	_end85-*
>2932	00					.byte	$00
>2933	e8 11					.word	Modulus16x16
>2935	4d 4f c4				.byte	$4d,$4f,$c4
.2938					_end85:
>2938	0a					.byte	_end86-*
>2939	00					.byte	$00
>293a	fc 12					.word	Negate
>293c	4e 45 47 41 54 c5			.byte	$4e,$45,$47,$41,$54,$c5
.2942					_end86:
>2942	07					.byte	_end87-*
>2943	00					.byte	$00
>2944	51 18					.word	NewHandler
>2946	4e 45 d7				.byte	$4e,$45,$d7
.2949					_end87:
>2949	0a					.byte	_end88-*
>294a	21					.byte	$21
>294b	8e 15					.word	NextHandler
>294d	cd 15					.word	NextEncoder
>294f	4e 45 58 d4				.byte	$4e,$45,$58,$d4
.2953					_end88:
>2953	07					.byte	_end89-*
>2954	00					.byte	$00
>2955	b7 14					.word	Nip
>2957	4e 49 d0				.byte	$4e,$49,$d0
.295a					_end89:
>295a	07					.byte	_end90-*
>295b	00					.byte	$00
>295c	0c 13					.word	OneComplement
>295e	4e 4f d4				.byte	$4e,$4f,$d4
.2961					_end90:
>2961	06					.byte	_end91-*
>2962	00					.byte	$00
>2963	2f 11					.word	LogOr
>2965	4f d2					.byte	$4f,$d2
.2967					_end91:
>2967	08					.byte	_end92-*
>2968	00					.byte	$00
>2969	9f 14					.word	Over
>296b	4f 56 45 d2				.byte	$4f,$56,$45,$d2
.296f					_end92:
>296f	0c					.byte	_end93-*
>2970	20					.byte	$20
>2971	7f 16					.word	RepeatHandler
>2973	82 16					.word	RepeatEncoder
>2975	52 45 50 45 41 d4			.byte	$52,$45,$50,$45,$41,$d4
.297b					_end93:
>297b	07					.byte	_end94-*
>297c	00					.byte	$00
>297d	8b 13					.word	RandomNumber
>297f	52 4e c4				.byte	$52,$4e,$c4
.2982					_end94:
>2982	07					.byte	_end95-*
>2983	00					.byte	$00
>2984	bc 14					.word	Rot
>2986	52 4f d4				.byte	$52,$4f,$d4
.2989					_end95:
>2989	07					.byte	_end96-*
>298a	00					.byte	$00
>298b	cf 1b					.word	RunProgram
>298d	52 55 ce				.byte	$52,$55,$ce
.2990					_end96:
>2990	07					.byte	_end97-*
>2991	00					.byte	$00
>2992	37 13					.word	SignTOS
>2994	53 47 ce				.byte	$53,$47,$ce
.2997					_end97:
>2997	08					.byte	_end98-*
>2998	00					.byte	$00
>2999	1e 1c					.word	StopCode
>299b	53 54 4f d0				.byte	$53,$54,$4f,$d0
.299f					_end98:
>299f	08					.byte	_end99-*
>29a0	00					.byte	$00
>29a1	8c 14					.word	Swap
>29a3	53 57 41 d0				.byte	$53,$57,$41,$d0
.29a7					_end99:
>29a7	07					.byte	_end100-*
>29a8	00					.byte	$00
>29a9	e3 1b					.word	Call6502
>29ab	53 59 d3				.byte	$53,$59,$d3
.29ae					_end100:
>29ae	0d					.byte	_end101-*
>29af	00					.byte	$00
>29b0	ac 1e					.word	IntToString
>29b2	54 4f 2e 53 54 52 49 4e			.byte	$54,$4f,$2e,$53,$54,$52,$49,$4e,$c7
>29ba	c7
.29bb					_end101:
>29bb	0b					.byte	_end102-*
>29bc	21					.byte	$21
>29bd	8f 16					.word	UntilHandler
>29bf	92 16					.word	UntilEncoder
>29c1	55 4e 54 49 cc				.byte	$55,$4e,$54,$49,$cc
.29c6					_end102:
>29c6	09					.byte	_end103-*
>29c7	00					.byte	$00
>29c8	29 1c					.word	VlistCode
>29ca	56 4c 49 53 d4				.byte	$56,$4c,$49,$53,$d4
.29cf					_end103:
>29cf	0a					.byte	_end104-*
>29d0	40					.byte	$40
>29d1	c0 18					.word	BreakCmd
>29d3	58 42 52 45 41 cb			.byte	$58,$42,$52,$45,$41,$cb
.29d9					_end104:
>29d9	09					.byte	_end105-*
>29da	00					.byte	$00
>29db	ba 18					.word	ExitDump
>29dd	58 44 55 4d d0				.byte	$58,$44,$55,$4d,$d0
.29e2					_end105:
>29e2	07					.byte	_end106-*
>29e3	00					.byte	$00
>29e4	22 11					.word	Xor
>29e6	58 4f d2				.byte	$58,$4f,$d2
.29e9					_end106:
>29e9	08					.byte	_end107-*
>29ea	00					.byte	$00
>29eb	f6 1c					.word	System_Save
>29ed	53 41 56 c5				.byte	$53,$41,$56,$c5
.29f1					_end107:
>29f1	08					.byte	_end108-*
>29f2	00					.byte	$00
>29f3	14 1d					.word	System_Load
>29f5	4c 4f 41 c4				.byte	$4c,$4f,$41,$c4
.29f9					_end108:
>29f9	0d					.byte	_end109-*
>29fa	11					.byte	$11
>29fb	b2 1f					.word	IndexHandler
>29fd	c1 1f					.word	IndexHandlerDecode
>29ff	24 24 49 4e 44 45 d8			.byte	$24,$24,$49,$4e,$44,$45,$d8
.2a06					_end109:
>2a06	07					.byte	_end110-*
>2a07	00					.byte	$00
>2a08	c5 1c					.word	OldCode
>2a0a	4f 4c c4				.byte	$4f,$4c,$c4
.2a0d					_end110:
>2a0d	12					.byte	_end111-*
>2a0e	52					.byte	$52
>2a0f	6c 10					.word	HexLiteral2Byte
>2a11	83 10					.word	HexLiteral2ByteDecode
>2a13	24 24 48 45 58 4c 49 54			.byte	$24,$24,$48,$45,$58,$4c,$49,$54,$45,$52,$41,$cc
>2a1b	45 52 41 cc
.2a1f					_end111:
>2a1f	08					.byte	_end112-*
>2a20	00					.byte	$00
>2a21	62 10					.word	SetFastMode
>2a23	46 41 53 d4				.byte	$46,$41,$53,$d4
.2a27					_end112:
>2a27	08					.byte	_end113-*
>2a28	00					.byte	$00
>2a29	5e 10					.word	SetSlowMode
>2a2b	53 4c 4f d7				.byte	$53,$4c,$4f,$d7
.2a2f					_end113:
>2a2f	00					.byte	0

;******  Return to file: kernel.asm


;******  Processing file: code/enctest.asm


;******  Return to file: kernel.asm

>3fff	ff						.byte 	$FF
.4000					ProgramMemory:

;******  End of listing
