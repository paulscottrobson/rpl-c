
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -q -c -o kernel_nocode.prg -L kernel.lst -l kernel.lbl kernel.asm
; Fri Jan 10 13:08:19 2020

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: kernel.asm

=$1000					RplBuild = $1000 							; code starts here.

;******  Processing file: data.asm

.0000					Next:
>0000							.fill 	5
=3					IP = Next+3 								; the IP which points to the current instruction
.0005					rsp:
>0005							.byte 	?
.0006					tos:
>0006							.word 	?
.0008					srcPtr:
>0008							.word 	?
.000a					bufPtr:
>000a							.word 	?
.000c					matchPtr:
>000c							.word 	?
.000e					nextFreeMem:
>000e							.word 	?
.0010					freeMemory:
>0010							.word 	?
.0012					temp1:
>0012							.word 	?
.0014					temp2:
>0014							.word 	?
.0016					temp3:
>0016							.word 	?
.0018					temp4:
>0018							.word 	?
.001a					SignCount:
>001a							.byte 	?
.001b					RandomSeed:
>001b							.byte 	?
=$102					stack2Low = $102							; access other stack members following tsx
=$101					stack2High = $101							; (which requires saving X, not on the stack !)
=$104					stack3Low = $104
=$103					stack3High = $103
=$600					azVariables = $600 							; 26 x 2 variables occupying 52 bytes * PAGE BOUNDARY *
=16					hashTableSize = 16 							; hash tables for variables.
=$640					hashTable = $640 							; hash tables start here * ALL ON ONE PAGE *
=$810					textBuffer = $810 							; buffer for text.
=$700					returnStack = $700							; return stack (1 page)
=$700					returnStackLow = returnStack
=1856					returnStackHigh = returnStack+$40
=1920					returnStackX = returnStack+$80
=$80					NumberStackBase = $80 						; number stack down from here.

;******  Return to file: kernel.asm

.1000	a2 ff		ldx #$ff			ldx 		#$FF 					; reset the stack
.1002	9a		txs				txs
.1003	a2 80		ldx #$80			ldx 	#NumberStackBase
.1005	9a		txs				txs
.1006	20 0f 18	jsr $180f			jsr 		ClearVariableSpace 		; clear variables etc.
.1009	a2 00		ldx #$00			ldx			#ProgramMemory & $FF	; boot address
.100b	a0 40		ldy #$40			ldy 		#ProgramMemory >>8
.100d	20 13 10	jsr $1013			jsr 		InitialiseCoreCode 		; initialise the NEXT routine at $00
.1010	4c 00 00	jmp $0000			jmp 		Next

;******  Processing file: core.src

.1013					InitialiseCoreCode:
.1013	a9 e8		lda #$e8			lda 	#$E8 					; Copy INX INX 			4 cycles when run
.1015	85 00		sta $00				sta 	Next
.1017	85 01		sta $01				sta 	Next+1
.1019	a9 7c		lda #$7c			lda 	#$7C 					; Copy JMP ($aaaa,x) 	6 cycles when run
.101b	85 02		sta $02				sta 	Next+2
.101d	86 03		stx $03				stx 	Next+3 					; set the indirect address (IP)
.101f	84 04		sty $04				sty 	Next+4
.1021	a2 01		ldx #$01			ldx 	#1 						; set up to run from provided word.
.1023	60		rts				rts								; (2 INX skip offset and line#)
.1024					Literal2Byte:
.1024	a5 06		lda $06				lda 	TOS
.1026	48		pha				pha
.1027	a5 07		lda $07				lda 	TOS+1
.1029	48		pha				pha
.102a	e8		inx				inx  							; point X to the word
.102b	e8		inx				inx
.102c	8a		txa				txa 							; copy into Y
.102d	a8		tay				tay
.102e	b1 03		lda ($03),y			lda 	(IP),y 					; read it. the LSB
.1030	85 06		sta $06				sta 	TOS
.1032	c8		iny				iny 							; read and push the MSB
.1033	b1 03		lda ($03),y			lda 	(IP),y
.1035	85 07		sta $07				sta 	TOS+1
.1037	4c 00 00	jmp $0000			jmp 	Next
.103a					Literal2ByteDecode:
.103a	a9 20		lda #$20			lda 	#32
.103c	20 7b 11	jsr $117b			jsr 	DecodeWriteBuffer
.103f	b1 08		lda ($08),y			lda 	(srcPtr),y
.1041	aa		tax				tax
.1042	c8		iny				iny
.1043	b1 08		lda ($08),y			lda 	(srcPtr),y
.1045	a8		tay				tay
.1046	8a		txa				txa
.1047	38		sec				sec 							; output signed
.1048	20 9d 11	jsr $119d			jsr 	DecodeYAToBuffer
.104b	60		rts				rts
.104c					LiteralString:
.104c	a5 06		lda $06				lda 	TOS
.104e	48		pha				pha
.104f	a5 07		lda $07				lda 	TOS+1
.1051	48		pha				pha
.1052	e8		inx				inx
.1053	e8		inx				inx 							; skip over current word
.1054	8a		txa				txa 							; add to IP + 1 to give string address
.1055	a8		tay				tay 							; put in Y
.1056	38		sec				sec 							; make that TOS
.1057	65 03		adc $03				adc 	IP
.1059	85 06		sta $06				sta 	TOS
.105b	a5 04		lda $04				lda 	IP+1
.105d	69 00		adc #$00			adc 	#0
.105f	85 07		sta $07				sta 	TOS+1
.1061	8a		txa				txa 							; add data length to X
.1062	18		clc				clc
.1063	71 03		adc ($03),y			adc 	(IP),y
.1065	aa		tax				tax
.1066	4c 02 00	jmp $0002			jmp 	Next+2 					; jump without pre-increment
.1069					LiteralStringDecoder:
.1069	a9 20		lda #$20			lda 	#32
.106b	20 7b 11	jsr $117b			jsr 	DecodeWriteBuffer
.106e	a9 22		lda #$22			lda 	#'"'
.1070	20 7b 11	jsr $117b			jsr 	DecodeWriteBuffer
.1073	20 84 11	jsr $1184			jsr 	DecodeOutputData
.1076	20 7b 11	jsr $117b			jsr 	DecodeWriteBuffer
.1079	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: decode/list.src

.107a					listcode:
.107a	a9 10		lda #$10			lda 	#(textBuffer) & $FF
.107c	85 0a		sta $0a				sta 	0+(bufPtr)
.107e	a9 08		lda #$08			lda 	#(textBuffer) >> 8
.1080	85 0b		sta $0b				sta 	1+(bufPtr)
.1082	a9 00		lda #$00			lda 	#$00
.1084	a0 40		ldy #$40			ldy 	#$40
.1086	38		sec				sec
.1087	20 8d 10	jsr $108d			jsr 	DecodeLineIntoBufPtr
.108a	4c 00 00	jmp $0000			jmp 	Next
.108d					DecodeLineIntoBufPtr:
.108d	48		pha				pha
.108e	da		phx				phx
.108f	5a		phy				phy
.1090	85 08		sta $08				sta 	srcPtr 						; save the source line.
.1092	84 09		sty $09				sty 	srcPtr+1
.1094	90 1b		bcc $10b1			bcc 	_DecodeNoLineNumber
.1096	a0 01		ldy #$01			ldy 	#1 							; get line # to YA
.1098	b1 08		lda ($08),y			lda 	(srcPtr),y
.109a	aa		tax				tax
.109b	c8		iny				iny
.109c	b1 08		lda ($08),y			lda 	(srcPtr),y
.109e	a8		tay				tay
.109f	8a		txa				txa
.10a0	18		clc				clc
.10a1	20 9d 11	jsr $119d			jsr 	DecodeYAToBuffer 			; convert to string in buffer
.10a4	aa		tax				tax 								; count in X
.10a5					_DecodeLineSpace:
.10a5	e0 05		cpx #$05			cpx 	#5
.10a7	f0 08		beq $10b1			beq 	_DecodeNoLineNumber
.10a9	a9 20		lda #$20			lda 	#" " 						; pad to 5 spaces
.10ab	20 7b 11	jsr $117b			jsr 	DecodeWriteBuffer
.10ae	e8		inx				inx
.10af	80 f4		bra $10a5			bra 	_DecodeLineSpace
.10b1					_DecodeNoLineNumber:
.10b1	a0 03		ldy #$03			ldy 	#3 							; initial position.
.10b3					_DecodeLoop:
.10b3	b1 08		lda ($08),y			lda 	(srcPtr),y 					; copy the current character to temp1
.10b5	85 12		sta $12				sta 	temp1 						; must be an execution address.
.10b7	c8		iny				iny
.10b8	b1 08		lda ($08),y			lda 	(srcPtr),y
.10ba	85 13		sta $13				sta 	temp1+1
.10bc	c8		iny				iny 								; y points to the byte after it.
.10bd	a5 12		lda $12				lda 	temp1
.10bf	c9 3c		cmp #$3c			cmp 	#NextLine & $FF
.10c1	d0 06		bne $10c9			bne 	_DecodeNotEOL
.10c3	a5 13		lda $13				lda 	temp1+1
.10c5	c9 19		cmp #$19			cmp 	#NextLine >> 8
.10c7	f0 0b		beq $10d4			beq 	_DecodeEOL
.10c9					_DecodeNotEOL:
.10c9	20 dc 10	jsr $10dc			jsr 	IdentifyCodeWord
.10cc	20 26 11	jsr $1126			jsr 	DecodeFoundWord
.10cf	20 10 11	jsr $1110			jsr 	AdvanceToNext 				; advance to next entry in the line.
.10d2	80 df		bra $10b3			bra 	_DecodeLoop 				; and go round again
.10d4					_DecodeEOL:
.10d4	a9 00		lda #$00			lda 	#0
.10d6	92 0a		sta ($0a)			sta 	(bufPtr)
.10d8	7a		ply				ply 								; restore registers and exit
.10d9	fa		plx				plx
.10da	68		pla				pla
.10db	60		rts				rts
.10dc					IdentifyCodeWord:
.10dc	5a		phy				phy 								; save current position on the stack.
.10dd	a9 7a		lda #$7a			lda 	#(Dictionary) & $FF
.10df	85 0c		sta $0c				sta 	0+(matchPtr)
.10e1	a9 1b		lda #$1b			lda 	#(Dictionary) >> 8
.10e3	85 0d		sta $0d				sta 	1+(matchPtr)
.10e5					_DecodeIdentify:
.10e5	a0 02		ldy #$02			ldy 	#2 							; have we found a match ?
.10e7	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.10e9	c5 12		cmp $12				cmp 	temp1
.10eb	d0 07		bne $10f4			bne 	_DecodeIdNext
.10ed	c8		iny				iny
.10ee	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.10f0	c5 13		cmp $13				cmp 	temp1+1
.10f2	f0 1a		beq $110e			beq 	_DecodeIdFound
.10f4					_DecodeIdNext:
.10f4	18		clc				clc
.10f5	b2 0c		lda ($0c)			lda 	(matchPtr)
.10f7	f0 0a		beq $1103			beq 	_DecodeIdIssue
.10f9	65 0c		adc $0c				adc 	matchPtr
.10fb	85 0c		sta $0c				sta 	matchPtr
.10fd	90 e6		bcc $10e5			bcc 	_DecodeIdentify
.10ff	e6 0d		inc $0d				inc 	matchPtr+1
.1101	80 e2		bra $10e5			bra 	_DecodeIdentify
.1103					_DecodeIdIssue:
.1103	20 77 1b	jsr $1b77			jsr 	ErrorHandler
>1106	44 45 43 4f 44 45 3f 00				.text 	"DECODE?",0
.110e					_DecodeIdFound:
.110e	7a		ply				ply 								; restore position.
.110f	60		rts				rts
.1110					AdvanceToNext:
.1110	5a		phy				phy 								; get the parameter count from bits 0-1 of the type byte
.1111	a0 01		ldy #$01			ldy 	#1
.1113	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.1115	29 03		and #$03			and 	#3 							; bits 0-1.
.1117	7a		ply				ply
.1118	c9 03		cmp #$03			cmp 	#3 							; is it n-bytes e.g. specified by the next byte
.111a	d0 02		bne $111e			bne 	_ATN012
.111c	b1 08		lda ($08),y			lda 	(srcPtr),y 					; if so, use that byte as the overall length.
.111e					_ATN012:
.111e	85 14		sta $14				sta 	temp2 						; now add that to Y
.1120	98		tya				tya
.1121	18		clc				clc
.1122	65 14		adc $14				adc 	temp2
.1124	a8		tay				tay
.1125	60		rts				rts
.1126					DecodeFoundWord:
.1126	5a		phy				phy 								; save current position
.1127	84 14		sty $14				sty		temp2 						; put it in temp2 as well.
.1129	a0 01		ldy #$01			ldy 	#1 							; get the type byte
.112b	b1 0c		lda ($0c),y			lda 	(matchPtr),y 				; is there a special decoder check (bit 4 set) ?
.112d	29 10		and #$10			and 	#$10
.112f	d0 0e		bne $113f			bne 	_DFWSpecialDecoder
.1131	b1 0c		lda ($0c),y			lda 	(matchPtr),y 				; reget it.
.1133	30 08		bmi $113d			bmi 	_DFWExit 					; if hidden word (bit 7 set)
.1135	a9 20		lda #$20			lda 	#" "						; output a space to the buffer
.1137	20 7b 11	jsr $117b			jsr 	DecodeWriteBuffer
.113a	20 58 11	jsr $1158			jsr 	DecodeCurrentWord 			; expand that.
.113d					_DFWExit:
.113d	7a		ply				ply 								; restore current position
.113e	60		rts				rts
.113f					_DFWSpecialDecoder:
.113f	a0 04		ldy #$04			ldy 	#4 							; the decode word address is at offset 4,5
.1141	b1 0c		lda ($0c),y			lda 	(matchPtr),y 				; copy this into temp2
.1143	85 14		sta $14				sta 	temp2
.1145	c8		iny				iny
.1146	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.1148	85 15		sta $15				sta 	temp2+1
.114a	7a		ply				ply 	 							; restore current position into Y
.114b	48		pha				pha 								; save registers
.114c	da		phx				phx
.114d	5a		phy				phy
.114e	20 55 11	jsr $1155			jsr 	_DFWCallDecoder				; call the decoder routine
.1151	7a		ply				ply 								; restore registers and exit
.1152	fa		plx				plx
.1153	68		pla				pla
.1154	60		rts				rts
.1155					_DFWCallDecoder:
.1155	6c 14 00	jmp ($0014)			jmp 	(temp2)
.1158					DecodeCurrentWord:
.1158	5a		phy				phy
.1159	a0 01		ldy #$01			ldy 	#1 							; read type byte
.115b	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.115d	a0 04		ldy #$04			ldy 	#4 							; original offset
.115f	4a		lsr a				lsr 	a 							; encoder/decoder bits in 0-1
.1160	4a		lsr a				lsr 	a 							; add 2 to Y for each encoder/decoder
.1161	4a		lsr a				lsr 	a 							; bit set.
.1162	4a		lsr a				lsr 	a
.1163	4a		lsr a				lsr 	a 							; decoder bit
.1164	90 02		bcc $1168			bcc 	_DWBNoDec
.1166	c8		iny				iny
.1167	c8		iny				iny
.1168					_DWBNoDec:
.1168	4a		lsr a				lsr 	a
.1169	90 02		bcc $116d			bcc 	_DWBNoEnc
.116b	c8		iny				iny
.116c	c8		iny				iny
.116d					_DWBNoEnc:
.116d					_DWBWordOut:
.116d	b1 0c		lda ($0c),y			lda 	(matchPtr),y 				; output until bit 7 set.
.116f	48		pha				pha
.1170	29 7f		and #$7f			and 	#$7F
.1172	20 7b 11	jsr $117b			jsr		DecodeWriteBuffer
.1175	c8		iny				iny
.1176	68		pla				pla
.1177	10 f4		bpl $116d			bpl 	_DWBWordOut
.1179	7a		ply				ply 								; restore Y and exit
.117a	60		rts				rts
.117b					DecodeWriteBuffer:
.117b	92 0a		sta ($0a)			sta 	(bufPtr)
.117d	e6 0a		inc $0a				inc 	bufPtr
.117f	d0 02		bne $1183			bne 	_DWBNoCarry
.1181	e6 0b		inc $0b				inc 	bufPtr+1
.1183					_DWBNoCarry:
.1183	60		rts				rts
.1184					DecodeOutputData:
.1184	48		pha				pha
.1185	da		phx				phx
.1186	5a		phy				phy
.1187	b1 08		lda ($08),y			lda 	(srcPtr),y 					; length + 1
.1189	aa		tax				tax
.118a					_DODLoop:
.118a	ca		dex				dex 								; done it all ?
.118b	f0 0c		beq $1199			beq		_DODExit
.118d	c8		iny				iny 								; output next character
.118e	b1 08		lda ($08),y			lda 	(srcPtr),y
.1190	29 7f		and #$7f			and 	#$7F
.1192	f0 f6		beq $118a			beq 	_DODLoop 					; don't print NULL
.1194	20 7b 11	jsr $117b			jsr 	DecodeWriteBuffer
.1197	80 f1		bra $118a			bra 	_DODLoop
.1199					_DODExit:
.1199	7a		ply				ply
.119a	fa		plx				plx
.119b	68		pla				pla
.119c	60		rts				rts
.119d					DecodeYAToBuffer:
.119d	da		phx				phx
.119e	5a		phy				phy
.119f	48		pha				pha
.11a0	a5 0a		lda $0a				lda 	bufPtr 						; copy bufPtr to temp2
.11a2	85 14		sta $14				sta 	temp2
.11a4	a5 0b		lda $0b				lda 	bufPtr+1
.11a6	85 15		sta $15				sta 	temp2+1
.11a8	68		pla				pla
.11a9	20 b6 19	jsr $19b6			jsr 	ConvertToStringMain 		; convert YA to string there
.11ac	aa		tax				tax 								; chars output to X
.11ad	18		clc				clc
.11ae	65 0a		adc $0a				adc 	bufPtr 						; add to buffer pointer
.11b0	85 0a		sta $0a				sta 	bufPtr
.11b2	90 02		bcc $11b6			bcc 	_DYABNoCarry
.11b4	e6 0b		inc $0b				inc 	bufPtr+1
.11b6					_DYABNoCarry:
.11b6	8a		txa				txa 								; count in A
.11b7	7a		ply				ply									; restore and exit.
.11b8	fa		plx				plx
.11b9	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/binary.src

.11ba					Add:
.11ba	7a		ply				ply
.11bb	68		pla				pla
.11bc	18		clc				clc
.11bd	65 06		adc $06				adc 	TOS
.11bf	85 06		sta $06				sta 	TOS
.11c1	98		tya				tya
.11c2	65 07		adc $07				adc 	TOS+1
.11c4	85 07		sta $07				sta 	TOS+1
.11c6	4c 00 00	jmp $0000			jmp 	Next
.11c9					Subtract:
.11c9	7a		ply				ply
.11ca	68		pla				pla
.11cb	38		sec				sec
.11cc	49 ff		eor #$ff			eor 	#$FF
.11ce	65 06		adc $06				adc 	TOS
.11d0	85 06		sta $06				sta 	TOS
.11d2	98		tya				tya
.11d3	49 ff		eor #$ff			eor 	#$FF
.11d5	65 07		adc $07				adc 	TOS+1
.11d7	85 07		sta $07				sta 	TOS+1
.11d9	4c 00 00	jmp $0000			jmp 	Next
.11dc					And:
.11dc	68		pla				pla
.11dd	25 07		and $07				and 	TOS+1
.11df	85 07		sta $07				sta 	TOS+1
.11e1	68		pla				pla
.11e2	25 06		and $06				and 	TOS
.11e4	85 06		sta $06				sta 	TOS
.11e6	4c 00 00	jmp $0000			jmp 	Next
.11e9					Xor:
.11e9	68		pla				pla
.11ea	45 07		eor $07				eor 	TOS+1
.11ec	85 07		sta $07				sta 	TOS+1
.11ee	68		pla				pla
.11ef	45 06		eor $06				eor 	TOS
.11f1	85 06		sta $06				sta 	TOS
.11f3	4c 00 00	jmp $0000			jmp 	Next
.11f6					LogOr:
.11f6	68		pla				pla
.11f7	05 07		ora $07				ora 	TOS+1
.11f9	85 07		sta $07				sta 	TOS+1
.11fb	68		pla				pla
.11fc	05 06		ora $06				ora 	TOS
.11fe	85 06		sta $06				sta 	TOS
.1200	4c 00 00	jmp $0000			jmp 	Next

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/compare.src

.1203					CheckNotEqual:
.1203	38		sec				sec
.1204	80 01		bra $1207			bra 	CECode
.1206					CheckEqual:
.1206	18		clc				clc
.1207					CECode:
.1207	86 12		stx $12				stx 	temp1
.1209	ba		tsx				tsx
.120a	08		php				php
.120b	a5 06		lda $06				lda 	TOS
.120d	5d 02 01	eor $0102,x			eor 	Stack2Low,x
.1210	d0 17		bne $1229			bne	 	CompareFalse
.1212	a5 07		lda $07				lda 	TOS+1
.1214	5d 01 01	eor $0101,x			eor 	Stack2High,x
.1217	d0 10		bne $1229			bne 	CompareFalse
.1219					CompareTrue:
.1219	a6 12		ldx $12				ldx 	temp1
.121b	28		plp				plp
.121c	b0 10		bcs $122e			bcs		CompareFalse2
.121e					CompareTrue2:
.121e	68		pla				pla
.121f	68		pla				pla
.1220	a9 ff		lda #$ff			lda 	#$FF
.1222	85 06		sta $06				sta 	TOS
.1224	85 07		sta $07				sta 	TOS+1
.1226	4c 00 00	jmp $0000			jmp 	Next
.1229					CompareFalse:
.1229	a6 12		ldx $12				ldx 	temp1
.122b	28		plp				plp
.122c	b0 f0		bcs $121e			bcs		CompareTrue2
.122e					CompareFalse2:
.122e	68		pla				pla
.122f	68		pla				pla
.1230	64 06		stz $06				stz 	TOS
.1232	64 07		stz $07				stz 	TOS+1
.1234	4c 00 00	jmp $0000			jmp 	Next
.1237					CheckGreaterEq:
.1237	38		sec				sec
.1238	80 01		bra $123b			bra		CLCode
.123a					CheckLess:
.123a	18		clc				clc
.123b	86 12		stx $12		CLCode:	stx 	temp1
.123d	ba		tsx				tsx
.123e	08		php				php
.123f	18		clc				clc
.1240	a5 06		lda $06				lda 	TOS
.1242	fd 02 01	sbc $0102,x			sbc 	Stack2Low,x
.1245	a5 07		lda $07				lda 	TOS+1
.1247	fd 01 01	sbc $0101,x			sbc 	Stack2High,x
.124a	50 02		bvc $124e			bvc 	_CLNoFlip
.124c	49 80		eor #$80			eor 	#$80
.124e					_CLNoFlip:
.124e	0a		asl a				asl 	a
.124f	b0 d8		bcs $1229			bcs 	CompareFalse
.1251	80 c6		bra $1219			bra 	CompareTrue
.1253					CheckLessEq:
.1253	38		sec				sec
.1254	80 01		bra $1257			bra		CGCode
.1256					CheckGreater:
.1256	18		clc				clc
.1257					CGCode:
.1257	86 12		stx $12				stx 	temp1
.1259	ba		tsx				tsx
.125a	08		php				php
.125b	18		clc				clc
.125c	bd 02 01	lda $0102,x			lda 	Stack2Low,x
.125f	e5 06		sbc $06				sbc 	TOS
.1261	bd 01 01	lda $0101,x			lda 	Stack2High,x
.1264	e5 07		sbc $07				sbc 	TOS+1
.1266	50 02		bvc $126a			bvc 	_CGNoFlip
.1268	49 80		eor #$80			eor 	#$80
.126a					_CGNoFlip:
.126a	0a		asl a				asl 	a
.126b	b0 bc		bcs $1229			bcs 	CompareFalse
.126d	80 aa		bra $1219			bra 	CompareTrue
.126f					Minimum:
.126f	a9 00		lda #$00			lda 	#0
.1271	80 02		bra $1275			bra 	MinMaxCode
.1273					Maximum:
.1273	a9 80		lda #$80			lda 	#$80
.1275					MinMaxCode:
.1275	85 13		sta $13				sta 	temp1+1
.1277	86 12		stx $12				stx 	temp1
.1279	ba		tsx				tsx
.127a	38		sec				sec
.127b	a5 06		lda $06				lda 	TOS
.127d	fd 02 01	sbc $0102,x			sbc 	Stack2Low,x
.1280	a5 07		lda $07				lda 	TOS+1
.1282	fd 01 01	sbc $0101,x			sbc 	Stack2High,x
.1285	50 02		bvc $1289			bvc 	_MMNoFlip
.1287	49 80		eor #$80			eor 	#$80
.1289					_MMNoFlip:
.1289	45 13		eor $13				eor 	temp1+1
.128b	30 0a		bmi $1297			bmi 	_MMNoCopy
.128d	bd 02 01	lda $0102,x			lda 	Stack2Low,x
.1290	85 06		sta $06				sta 	TOS
.1292	bd 01 01	lda $0101,x			lda 	Stack2High,x
.1295	85 07		sta $07				sta 	TOS+1
.1297					_MMNoCopy:
.1297	a6 12		ldx $12				ldx 	temp1
.1299	68		pla				pla
.129a	68		pla				pla
.129b	4c 00 00	jmp $0000			jmp 	Next

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/divide.src

.129e					Divide16x16:
.129e	86 14		stx $14				stx 	temp2
.12a0	ba		tsx				tsx
.12a1	20 c4 12	jsr $12c4			jsr 	IntegerDivide
.12a4	68		pla				pla
.12a5	85 07		sta $07				sta 	TOS+1
.12a7	68		pla				pla
.12a8	85 06		sta $06				sta 	TOS
.12aa	a6 14		ldx $14				ldx 	temp2
.12ac	4c 00 00	jmp $0000			jmp 	Next
.12af					Modulus16x16:
.12af	86 14		stx $14				stx 	temp2
.12b1	ba		tsx				tsx
.12b2	20 c4 12	jsr $12c4			jsr 	IntegerDivide
.12b5	a6 14		ldx $14				ldx 	temp2
.12b7	68		pla				pla
.12b8	68		pla				pla
.12b9	a5 12		lda $12				lda 	temp1
.12bb	85 06		sta $06				sta 	TOS
.12bd	a5 13		lda $13				lda 	temp1+1
.12bf	85 07		sta $07				sta 	TOS+1
.12c1	4c 00 00	jmp $0000			jmp 	Next
.12c4					IntegerDivide:
.12c4	a5 06		lda $06				lda 	TOS 				; check for division by zero.
.12c6	05 07		ora $07				ora 	TOS+1
.12c8	d0 14		bne $12de			bne 	_BFDOkay
.12ca	20 77 1b	jsr $1b77			jsr 	ErrorHandler
>12cd	44 49 56 49 53 49 4f 4e				.text 	"DIVISION BY ZERO",0
>12d5	20 42 59 20 5a 45 52 4f 00
.12de					_BFDOkay:
.12de	64 12		stz $12				stz 	temp1 						; Q/Dividend/Left in +0
.12e0	64 13		stz $13				stz 	temp1+1 					; M/Divisor/Right in +2
.12e2	64 1a		stz $1a				stz 	SignCount 					; Count of signs.
.12e4	20 1f 13	jsr $131f			jsr 	CheckIntegerNegate 			; negate 2nd (and bump sign count)
.12e7	20 39 13	jsr $1339			jsr 	CheckTOSNegate 				; negate TOS (and bump sign count)
.12ea	5a		phy				phy 								; Y is the counter
.12eb	a0 10		ldy #$10			ldy 	#16 						; 16 iterations of the loop.
.12ed					_BFDLoop:
.12ed	1e 02 01	asl $0102,x			asl 	Stack2Low,x 				; shift AQ left.
.12f0	3e 01 01	rol $0101,x			rol 	Stack2High,x
.12f3	26 12		rol $12				rol 	temp1
.12f5	26 13		rol $13				rol 	temp1+1
.12f7	38		sec				sec
.12f8	a5 12		lda $12				lda 	temp1+0 					; Calculate A-M on stack.
.12fa	e5 06		sbc $06				sbc 	TOS
.12fc	48		pha				pha
.12fd	a5 13		lda $13				lda 	temp1+1
.12ff	e5 07		sbc $07				sbc 	TOS+1
.1301	90 0f		bcc $1312			bcc 	_BFDNoAdd
.1303	85 13		sta $13				sta 	temp1+1
.1305	68		pla				pla
.1306	85 12		sta $12				sta 	temp1+0
.1308	bd 02 01	lda $0102,x			lda 	Stack2Low,x 				; set Q bit 1.
.130b	09 01		ora #$01			ora 	#1
.130d	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.1310	80 01		bra $1313			bra 	_BFDNext
.1312					_BFDNoAdd:
.1312	68		pla				pla 								; Throw away the intermediate calculations
.1313					_BFDNext:
.1313	88		dey				dey
.1314	d0 d7		bne $12ed			bne 	_BFDLoop
.1316	7a		ply				ply 								; restore Y
.1317	46 1a		lsr $1a				lsr 	SignCount 					; if sign count odd,
.1319	90 03		bcc $131e			bcc 	_BFDUnsigned 				; then the result is signed
.131b	20 25 13	jsr $1325			jsr		IntegerNegateAlways 		; negate the result
.131e					_BFDUnsigned:
.131e	60		rts				rts
.131f					CheckIntegerNegate:
.131f	bd 01 01	lda $0101,x			lda 	Stack2High,x 				; is it -ve = MSB set ?
.1322	30 01		bmi $1325			bmi 	IntegerNegateAlways 		; if so negate it
.1324	60		rts				rts
.1325					IntegerNegateAlways:
.1325	e6 1a		inc $1a				inc 	SignCount 					; bump the count of signs
.1327	38		sec				sec 								; negate
.1328	a9 00		lda #$00			lda 	#0
.132a	fd 02 01	sbc $0102,x			sbc 	Stack2Low,x
.132d	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.1330	a9 00		lda #$00			lda 	#0
.1332	fd 01 01	sbc $0101,x			sbc 	Stack2High,x
.1335	9d 01 01	sta $0101,x			sta 	Stack2High,x
.1338	60		rts				rts
.1339					CheckTOSNegate:
.1339	a5 07		lda $07				lda 	TOS+1
.133b	10 0f		bpl $134c			bpl		CTNNoChange
.133d	e6 1a		inc $1a				inc 	SignCount
.133f					TOSNegateAlways:
.133f	38		sec				sec
.1340	a9 00		lda #$00			lda 	#0
.1342	e5 06		sbc $06				sbc 	TOS
.1344	85 06		sta $06				sta 	TOS
.1346	a9 00		lda #$00			lda 	#0
.1348	e5 07		sbc $07				sbc 	TOS+1
.134a	85 07		sta $07				sta 	TOS+1
.134c					CTNNoChange:
.134c	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/multiply.src

.134d					Multiply16x16:
.134d	86 12		stx $12				stx 	temp1
.134f	ba		tsx				tsx
.1350	bd 02 01	lda $0102,x			lda 	Stack2Low,x 				; 2nd value on stack to temp1
.1353	85 14		sta $14				sta 	temp2
.1355	bd 01 01	lda $0101,x			lda		Stack2High,x
.1358	85 15		sta $15				sta 	temp2+1
.135a	9e 02 01	stz $0102,x			stz 	Stack2Low,x 				; zero 2nd value on stack
.135d	9e 01 01	stz $0101,x			stz 	Stack2High,x
.1360					_MultLoop:
.1360	46 15		lsr $15				lsr 	temp2+1 					; ror temp2 into C
.1362	66 14		ror $14				ror 	temp2
.1364	90 11		bcc $1377			bcc 	_MultNoAdd
.1366	18		clc				clc 								; add 1st to 2nd
.1367	a5 06		lda $06				lda 	TOS
.1369	7d 02 01	adc $0102,x			adc 	Stack2Low,x
.136c	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.136f	a5 07		lda $07				lda 	TOS+1
.1371	7d 01 01	adc $0101,x			adc 	Stack2High,x
.1374	9d 01 01	sta $0101,x			sta 	Stack2High,x
.1377					_MultNoAdd:
.1377	06 06		asl $06				asl 	TOS 						; shift 1st left
.1379	26 07		rol $07				rol 	TOS+1
.137b	a5 14		lda $14				lda 	temp2	 					; until zero
.137d	05 15		ora $15				ora 	temp2+1
.137f	d0 df		bne $1360			bne 	_MultLoop
.1381	a6 12		ldx $12				ldx 	temp1 						; restore X load result
.1383	68		pla				pla
.1384	85 07		sta $07				sta 	TOS+1
.1386	68		pla				pla
.1387	85 06		sta $06				sta 	TOS
.1389	4c 00 00	jmp $0000			jmp 	Next

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/unary.src

.138c					Unary1Plus:
.138c	e6 06		inc $06				inc 	TOS
.138e	d0 02		bne $1392			bne 	_U1PSkip
.1390	e6 07		inc $07				inc 	TOS+1
.1392					_U1PSkip:
.1392	4c 00 00	jmp $0000			jmp 	Next
.1395					Unary2Plus:
.1395	18		clc				clc
.1396	a5 06		lda $06				lda 	TOS
.1398	69 02		adc #$02			adc 	#2
.139a	85 06		sta $06				sta 	TOS
.139c	90 02		bcc $13a0			bcc 	_U1PSkip
.139e	e6 07		inc $07				inc 	TOS+1
.13a0					_U1PSkip:
.13a0	4c 00 00	jmp $0000			jmp 	Next
.13a3					Unary1Minus:
.13a3	a5 06		lda $06				lda 	TOS
.13a5	d0 02		bne $13a9			bne 	_U1MSkip
.13a7	c6 07		dec $07				dec 	TOS+1
.13a9					_U1MSkip:
.13a9	c6 06		dec $06				dec 	TOS
.13ab	4c 00 00	jmp $0000			jmp 	Next
.13ae					Unary2Minus:
.13ae	38		sec				sec
.13af	a5 06		lda $06				lda 	TOS
.13b1	e9 02		sbc #$02			sbc 	#2
.13b3	85 06		sta $06				sta 	TOS
.13b5	b0 02		bcs $13b9			bcs 	_U1PSkip
.13b7	c6 07		dec $07				dec 	TOS+1
.13b9					_U1PSkip:
.13b9	4c 00 00	jmp $0000			jmp 	Next
.13bc					Absolute:
.13bc	a5 07		lda $07				lda 	TOS+1
.13be	30 03		bmi $13c3			bmi 	Negate
.13c0	4c 00 00	jmp $0000			jmp 	Next
.13c3					Negate:
.13c3	38		sec				sec
.13c4	a9 00		lda #$00			lda 	#0
.13c6	e5 06		sbc $06				sbc 	TOS
.13c8	85 06		sta $06				sta 	TOS
.13ca	a9 00		lda #$00			lda 	#0
.13cc	e5 07		sbc $07				sbc 	TOS+1
.13ce	85 07		sta $07				sta 	TOS+1
.13d0	4c 00 00	jmp $0000			jmp 	Next
.13d3					OneComplement:
.13d3	a5 06		lda $06				lda 	TOS
.13d5	49 ff		eor #$ff			eor 	#$FF
.13d7	85 06		sta $06				sta 	TOS
.13d9	a5 07		lda $07				lda 	TOS+1
.13db	49 ff		eor #$ff			eor 	#$FF
.13dd	85 07		sta $07				sta 	TOS+1
.13df	4c 00 00	jmp $0000			jmp 	Next
.13e2					CheckMinus:
.13e2	a5 07		lda $07				lda 	TOS+1
.13e4	30 07		bmi $13ed			bmi 	UnaryTrue
.13e6					UnaryFalse:
.13e6	64 06		stz $06				stz 	TOS
.13e8	64 07		stz $07				stz 	TOS+1
.13ea	4c 00 00	jmp $0000			jmp 	Next
.13ed					UnaryTrue:
.13ed	a9 ff		lda #$ff			lda 	#$FF
.13ef	85 06		sta $06				sta 	TOS
.13f1	85 07		sta $07				sta 	TOS+1
.13f3	4c 00 00	jmp $0000			jmp 	Next
.13f6					CheckZero:
.13f6	a5 06		lda $06				lda 	TOS
.13f8	05 07		ora $07				ora 	TOS+1
.13fa	d0 ea		bne $13e6			bne 	UnaryFalse
.13fc	80 ef		bra $13ed			bra 	UnaryTrue
.13fe					SignTOS:
.13fe	a5 07		lda $07				lda 	TOS+1
.1400	30 eb		bmi $13ed			bmi		UnaryTrue
.1402	05 06		ora $06				ora 	TOS
.1404	f0 e0		beq $13e6			beq 	UnaryFalse
.1406	a9 01		lda #$01			lda 	#1
.1408	85 06		sta $06				sta 	TOS
.140a	64 07		stz $07				stz		TOS+1
.140c	4c 00 00	jmp $0000			jmp 	Next
.140f					ByteSwap:
.140f	a5 06		lda $06				lda 	TOS
.1411	a4 07		ldy $07				ldy 	TOS+1
.1413	85 07		sta $07				sta 	TOS+1
.1415	84 06		sty $06				sty 	TOS
.1417	4c 00 00	jmp $0000			jmp 	Next
.141a					Times16:
.141a	06 06		asl $06				asl 	TOS
.141c	26 07		rol $07				rol 	TOS+1
.141e					Times8:
.141e	06 06		asl $06				asl 	TOS
.1420	26 07		rol $07				rol 	TOS+1
.1422					Times4:
.1422	06 06		asl $06				asl 	TOS
.1424	26 07		rol $07				rol 	TOS+1
.1426					Times2:
.1426	06 06		asl $06				asl 	TOS
.1428	26 07		rol $07				rol 	TOS+1
.142a	4c 00 00	jmp $0000			jmp 	Next
.142d					Divide16:
.142d	46 07		lsr $07				lsr 	TOS+1
.142f	66 06		ror $06				ror 	TOS
.1431					Divide8:
.1431	46 07		lsr $07				lsr 	TOS+1
.1433	66 06		ror $06				ror 	TOS
.1435					Divide4:
.1435	46 07		lsr $07				lsr 	TOS+1
.1437	66 06		ror $06				ror 	TOS
.1439					Divide2:
.1439	46 07		lsr $07				lsr 	TOS+1
.143b	66 06		ror $06				ror 	TOS
.143d	4c 00 00	jmp $0000			jmp 	Next
.1440					Times256:
.1440	a5 06		lda $06				lda 	TOS
.1442	85 07		sta $07				sta 	TOS+1
.1444	64 06		stz $06				stz 	TOS
.1446	4c 00 00	jmp $0000			jmp 	Next
.1449					Divide256:
.1449	a5 07		lda $07				lda 	TOS+1
.144b	85 06		sta $06				sta 	TOS
.144d	64 07		stz $07				stz 	TOS+1
.144f	4c 00 00	jmp $0000			jmp 	Next
.1452					RandomNumber:
.1452	a5 06		lda $06				lda 	TOS
.1454	48		pha				pha
.1455	a5 07		lda $07				lda 	TOS+1
.1457	48		pha				pha
.1458	a5 1b		lda $1b				lda 	randomSeed
.145a	05 1c		ora $1c				ora 	randomSeed+1
.145c	d0 08		bne $1466			bne 	_RH_NoInit
.145e	a9 7c		lda #$7c			lda 	#$7C
.1460	85 1b		sta $1b				sta 	randomSeed
.1462	a9 a1		lda #$a1			lda 	#$A1
.1464	85 1c		sta $1c				sta 	randomSeed+1
.1466					_RH_NoInit:
.1466	a5 1b		lda $1b				lda 	randomSeed
.1468	4a		lsr a		        lsr		a
.1469	26 1c		rol $1c		        rol 	randomSeed+1
.146b	90 02		bcc $146f	        bcc 	_RH_NoEor
.146d	49 b4		eor #$b4	        eor 	#$B4
.146f					_RH_NoEor:
.146f	85 1b		sta $1b		        sta 	randomSeed
.1471	45 1c		eor $1c		        eor 	randomSeed+1
.1473	85 07		sta $07		        sta 	TOS+1
.1475	a5 1b		lda $1b		        lda 	randomSeed
.1477	85 06		sta $06		        sta 	TOS
.1479	4c 00 00	jmp $0000			jmp 	Next

;******  Return to file: kernel.asm


;******  Processing file: words/data/literals.src

.147c					Constant0:
.147c	a5 06		lda $06				lda 	TOS
.147e	48		pha				pha
.147f	a5 07		lda $07				lda 	TOS+1
.1481	48		pha				pha
.1482	64 06		stz $06				stz 	TOS
.1484	64 07		stz $07				stz 	TOS+1
.1486	4c 00 00	jmp $0000			jmp 	Next
.1489					ConstantMinus1:
.1489	a5 06		lda $06				lda 	TOS
.148b	48		pha				pha
.148c	a5 07		lda $07				lda 	TOS+1
.148e	48		pha				pha
.148f	a9 ff		lda #$ff			lda 	#$FF
.1491	85 06		sta $06				sta 	TOS
.1493	85 07		sta $07				sta 	TOS+1
.1495	4c 00 00	jmp $0000			jmp 	Next
.1498					C1:
.1498	a0 01		ldy #$01			ldy 	#1
.149a	80 24		bra $14c0			bra 	Const1Byte
.149c					C2:
.149c	a0 02		ldy #$02			ldy 	#2
.149e	80 20		bra $14c0			bra 	Const1Byte
.14a0					C3:
.14a0	a0 03		ldy #$03			ldy 	#3
.14a2	80 1c		bra $14c0			bra 	Const1Byte
.14a4					C4:
.14a4	a0 04		ldy #$04			ldy 	#4
.14a6	80 18		bra $14c0			bra 	Const1Byte
.14a8					C5:
.14a8	a0 05		ldy #$05			ldy 	#5
.14aa	80 14		bra $14c0			bra 	Const1Byte
.14ac					C8:
.14ac	a0 08		ldy #$08			ldy 	#8
.14ae	80 10		bra $14c0			bra 	Const1Byte
.14b0					C10:
.14b0	a0 0a		ldy #$0a			ldy 	#10
.14b2	80 0c		bra $14c0			bra 	Const1Byte
.14b4					C15:
.14b4	a0 0f		ldy #$0f			ldy 	#15
.14b6	80 08		bra $14c0			bra 	Const1Byte
.14b8					C16:
.14b8	a0 10		ldy #$10			ldy 	#16
.14ba	80 04		bra $14c0			bra 	Const1Byte
.14bc					C24:
.14bc	a0 18		ldy #$18			ldy 	#24
.14be	80 00		bra $14c0			bra 	Const1Byte
.14c0					Const1Byte:
.14c0	a5 06		lda $06				lda 	TOS
.14c2	48		pha				pha
.14c3	a5 07		lda $07				lda 	TOS+1
.14c5	48		pha				pha
.14c6	84 06		sty $06				sty 	TOS
.14c8	64 07		stz $07				stz 	TOS+1
.14ca	4c 00 00	jmp $0000			jmp 	Next
.14cd					C32:
.14cd	a0 20		ldy #$20			ldy 	#32
.14cf	80 ef		bra $14c0			bra 	Const1Byte
.14d1					C63:
.14d1	a0 3f		ldy #$3f			ldy 	#63
.14d3	80 eb		bra $14c0			bra 	Const1Byte
.14d5					C64:
.14d5	a0 40		ldy #$40			ldy 	#64
.14d7	80 e7		bra $14c0			bra 	Const1Byte
.14d9					C100:
.14d9	a0 64		ldy #$64			ldy 	#100
.14db	80 e3		bra $14c0			bra 	Const1Byte
.14dd					C127:
.14dd	a0 7f		ldy #$7f			ldy 	#127
.14df	80 df		bra $14c0			bra 	Const1Byte
.14e1					C128:
.14e1	a0 80		ldy #$80			ldy 	#128
.14e3	80 db		bra $14c0			bra 	Const1Byte
.14e5					C255:
.14e5	a0 ff		ldy #$ff			ldy 	#255
.14e7	80 d7		bra $14c0			bra 	Const1Byte
.14e9					Const2Byte:
.14e9	85 06		sta $06				sta 	TOS
.14eb	84 07		sty $07				sty 	TOS+1
.14ed	4c 00 00	jmp $0000			jmp 	Next
.14f0					C256:
.14f0	a5 06		lda $06				lda 	TOS
.14f2	48		pha				pha
.14f3	a5 07		lda $07				lda 	TOS+1
.14f5	48		pha				pha
.14f6	a9 00		lda #$00			lda 	#(256) & $FF
.14f8	a0 01		ldy #$01			ldy 	#(256) >> 8
.14fa	80 ed		bra $14e9			bra 	Const2Byte
.14fc					C512:
.14fc	a5 06		lda $06				lda 	TOS
.14fe	48		pha				pha
.14ff	a5 07		lda $07				lda 	TOS+1
.1501	48		pha				pha
.1502	a9 00		lda #$00			lda 	#(512) & $FF
.1504	a0 02		ldy #$02			ldy 	#(512) >> 8
.1506	80 e1		bra $14e9			bra 	Const2Byte
.1508					C1024:
.1508	a5 06		lda $06				lda 	TOS
.150a	48		pha				pha
.150b	a5 07		lda $07				lda 	TOS+1
.150d	48		pha				pha
.150e	a9 00		lda #$00			lda 	#(1024) & $FF
.1510	a0 04		ldy #$04			ldy 	#(1024) >> 8
.1512	80 d5		bra $14e9			bra 	Const2Byte
.1514					C4096:
.1514	a5 06		lda $06				lda 	TOS
.1516	48		pha				pha
.1517	a5 07		lda $07				lda 	TOS+1
.1519	48		pha				pha
.151a	a9 00		lda #$00			lda 	#(4096) & $FF
.151c	a0 10		ldy #$10			ldy 	#(4096) >> 8
.151e	80 c9		bra $14e9			bra 	Const2Byte
.1520					C32767:
.1520	a5 06		lda $06				lda 	TOS
.1522	48		pha				pha
.1523	a5 07		lda $07				lda 	TOS+1
.1525	48		pha				pha
.1526	a9 ff		lda #$ff			lda 	#(32767) & $FF
.1528	a0 7f		ldy #$7f			ldy 	#(32767) >> 8
.152a	80 bd		bra $14e9			bra 	Const2Byte
.152c					C32768:
.152c	a5 06		lda $06				lda 	TOS
.152e	48		pha				pha
.152f	a5 07		lda $07				lda 	TOS+1
.1531	48		pha				pha
.1532	a9 00		lda #$00			lda 	#(32768) & $FF
.1534	a0 80		ldy #$80			ldy 	#(32768) >> 8
.1536	80 b1		bra $14e9			bra 	Const2Byte

;******  Return to file: kernel.asm


;******  Processing file: words/data/stack.src

.1538					Drop:
.1538	68		pla				pla
.1539	85 07		sta $07				sta 	TOS+1
.153b	68		pla				pla
.153c	85 06		sta $06				sta 	TOS
.153e	4c 00 00	jmp $0000			jmp 	Next
.1541					TestDup:
.1541	a5 06		lda $06				lda 	TOS
.1543	05 07		ora $07				ora 	TOS+1
.1545	d0 03		bne $154a			bne 	Dup
.1547	4c 00 00	jmp $0000			jmp 	Next
.154a					Dup:
.154a	a5 06		lda $06				lda 	TOS
.154c	48		pha				pha
.154d	a5 07		lda $07				lda 	TOS+1
.154f	48		pha				pha
.1550	4c 00 00	jmp $0000			jmp 	Next
.1553					Swap:
.1553	86 12		stx $12				stx 	temp1
.1555	7a		ply				ply
.1556	fa		plx				plx
.1557	a5 06		lda $06				lda 	TOS
.1559	48		pha				pha
.155a	a5 07		lda $07				lda 	TOS+1
.155c	48		pha				pha
.155d	86 06		stx $06				stx 	TOS
.155f	84 07		sty $07				sty 	TOS+1
.1561	a6 12		ldx $12				ldx 	temp1
.1563	4c 00 00	jmp $0000			jmp 	Next
.1566					Over:
.1566	a5 06		lda $06				lda 	TOS
.1568	48		pha				pha
.1569	a5 07		lda $07				lda 	TOS+1
.156b	48		pha				pha
.156c	86 12		stx $12				stx 	temp1
.156e	ba		tsx				tsx
.156f	bd 04 01	lda $0104,x			lda 	stack3low,x
.1572	85 06		sta $06				sta 	TOS
.1574	bd 03 01	lda $0103,x			lda 	stack3High,x
.1577	85 07		sta $07				sta 	TOS+1
.1579	a6 12		ldx $12				ldx 	temp1
.157b	4c 00 00	jmp $0000			jmp 	Next
.157e					Nip:
.157e	68		pla				pla
.157f	68		pla				pla
.1580	4c 00 00	jmp $0000			jmp 	Next
.1583					Rot:
.1583	86 12		stx $12				stx 	temp1
.1585	ba		tsx				tsx
.1586	bd 04 01	lda $0104,x			lda 	Stack3Low,x
.1589	a8		tay				tay
.158a	bd 02 01	lda $0102,x			lda 	Stack2Low,x
.158d	9d 04 01	sta $0104,x			sta 	Stack3Low,x
.1590	a5 06		lda $06				lda 	TOS
.1592	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.1595	84 06		sty $06				sty 	TOS
.1597	bd 03 01	lda $0103,x			lda 	Stack3High,x
.159a	a8		tay				tay
.159b	bd 01 01	lda $0101,x			lda 	Stack2High,x
.159e	9d 03 01	sta $0103,x			sta 	Stack3High,x
.15a1	a5 07		lda $07				lda 	TOS+1
.15a3	9d 01 01	sta $0101,x			sta 	Stack2High,x
.15a6	84 07		sty $07				sty 	TOS+1
.15a8	a6 12		ldx $12				ldx 	temp1
.15aa	4c 00 00	jmp $0000			jmp 	Next

;******  Return to file: kernel.asm


;******  Processing file: words/data/memory.src

.15ad					ByteRead:
.15ad	b2 06		lda ($06)			lda 	(TOS)
.15af	85 06		sta $06				sta 	TOS
.15b1	64 07		stz $07				stz 	TOS+1
.15b3	4c 00 00	jmp $0000			jmp 	Next
.15b6					WordRead:
.15b6	a0 01		ldy #$01			ldy 	#1
.15b8	b1 06		lda ($06),y			lda 	(TOS),y
.15ba	a8		tay				tay
.15bb	b2 06		lda ($06)			lda 	(TOS)
.15bd	85 06		sta $06				sta 	TOS
.15bf	84 07		sty $07				sty 	TOS+1
.15c1	4c 00 00	jmp $0000			jmp 	Next
.15c4					ByteWrite:
.15c4	68		pla				pla
.15c5	68		pla				pla
.15c6	92 06		sta ($06)			sta 	(TOS)
.15c8	68		pla				pla
.15c9	85 07		sta $07				sta 	TOS+1
.15cb	68		pla				pla
.15cc	85 06		sta $06				sta 	TOS
.15ce	4c 00 00	jmp $0000			jmp 	Next
.15d1					WordWrite:
.15d1	68		pla				pla
.15d2	a0 01		ldy #$01			ldy 	#1
.15d4	91 06		sta ($06),y			sta 	(TOS),y
.15d6	68		pla				pla
.15d7	92 06		sta ($06)			sta 	(TOS)
.15d9	68		pla				pla
.15da	85 07		sta $07				sta 	TOS+1
.15dc	68		pla				pla
.15dd	85 06		sta $06				sta 	TOS
.15df	4c 00 00	jmp $0000			jmp 	Next
.15e2					WordAdd:
.15e2	7a		ply				ply
.15e3	68		pla				pla
.15e4	18		clc				clc
.15e5	72 06		adc ($06)			adc 	(TOS)
.15e7	92 06		sta ($06)			sta 	(TOS)
.15e9	98		tya				tya
.15ea	a0 01		ldy #$01			ldy 	#1
.15ec	71 06		adc ($06),y			adc 	(TOS),y
.15ee	91 06		sta ($06),y			sta 	(TOS),y
.15f0	68		pla				pla
.15f1	85 07		sta $07				sta 	TOS+1
.15f3	68		pla				pla
.15f4	85 06		sta $06				sta 	TOS
.15f6	4c 00 00	jmp $0000			jmp 	Next
.15f9					AllocateMemory:
.15f9	a5 06		lda $06				lda 	TOS 						; save memory required on stack.
.15fb	48		pha				pha
.15fc	a5 07		lda $07				lda 	TOS+1
.15fe	48		pha				pha
.15ff	a5 0e		lda $0e				lda 	nextFreeMem 				; copy free mem address to TOS
.1601	85 06		sta $06				sta 	TOS
.1603	a5 0f		lda $0f				lda 	nextFreeMem+1
.1605	85 07		sta $07				sta 	TOS+1
.1607	7a		ply				ply 								; advance the free ram pointer
.1608	68		pla				pla
.1609	20 3c 18	jsr $183c			jsr 	AdvanceFreeMem
.160c	4c 00 00	jmp $0000			jmp 	Next 						; and continue

;******  Return to file: kernel.asm


;******  Processing file: words/structures/fornext.src

.160f					ForHandler:
.160f	e6 05		inc $05				inc 	rsp 						; bump the RSP
.1611	a4 05		ldy $05				ldy 	rsp 						; get return stack and push TOS/$FF on it.
.1613	c0 40		cpy #$40			cpy 	#$40 						; overflow
.1615	f0 18		beq $162f			beq 	_FHOverflow
.1617	a5 07		lda $07				lda 	TOS+1
.1619	99 40 07	sta $0740,y			sta 	returnStackHigh,y
.161c	a5 06		lda $06				lda 	TOS
.161e	99 00 07	sta $0700,y			sta 	returnStackLow,y
.1621	a9 ff		lda #$ff			lda 	#$FF
.1623	99 80 07	sta $0780,y			sta 	returnStackX,y
.1626	68		pla				pla
.1627	85 07		sta $07				sta 	TOS+1
.1629	68		pla				pla
.162a	85 06		sta $06				sta 	TOS
.162c	4c 00 00	jmp $0000			jmp 	Next
.162f					_FHOverflow:
.162f	20 77 1b	jsr $1b77			jsr 	ErrorHandler
>1632	46 4f 52 20 53 54 41 43				.text 	"FOR STACK?",0
>163a	4b 3f 00
.163d					NextHandler:
.163d	da		phx				phx
.163e	a6 05		ldx $05				ldx 	rsp 						; get current stack ptr
.1640	bd 80 07	lda $0780,x			lda 	returnStackX,x 				; check it's a FOR Loop
.1643	c9 ff		cmp #$ff			cmp 	#$FF
.1645	d0 21		bne $1668			bne 	NHNoFor
.1647	bd 00 07	lda $0700,x			lda 	returnStackLow,x 			; decrement the count
.164a	d0 03		bne $164f			bne 	_NHNoBorrow
.164c	de 40 07	dec $0740,x			dec 	returnStackHigh,x
.164f					_NHNoBorrow:
.164f	de 00 07	dec $0700,x			dec 	returnStackLow,x
.1652	bd 00 07	lda $0700,x			lda 	returnStackLow,x 			; have we reached the end ?
.1655	1d 40 07	ora $0740,x			ora 	returnStackHigh,x
.1658	fa		plx				plx 								; restore X and re-test
.1659	09 00		ora #$00			ora 	#0
.165b	f0 05		beq $1662			beq 	_NHComplete 				; if so then complete, else loop.
.165d	e8		inx				inx 								; advance to branch
.165e	e8		inx				inx
.165f	4c bb 16	jmp $16bb			jmp 	BranchAlways
.1662					_NHComplete:
.1662	e8		inx				inx 								; skip over the branch quantity
.1663	c6 05		dec $05				dec 	rsp 						; drop the indx
.1665	4c 00 00	jmp $0000			jmp 	Next
.1668					NHNoFor:
.1668	20 77 1b	jsr $1b77			jsr 	ErrorHandler
>166b	4e 4f 20 46 4f 52 3f 00				.text 	"NO FOR?",0
.1673					GetIndex:
.1673	a4 05		ldy $05				ldy 	rsp 						; get current stack ptr
.1675	b9 80 07	lda $0780,y			lda 	returnStackX,y 				; check it's a FOR Loop
.1678	c9 ff		cmp #$ff			cmp 	#$FF
.167a	d0 ec		bne $1668			bne 	NHNoFor
.167c	a5 06		lda $06				lda 	TOS
.167e	48		pha				pha
.167f	a5 07		lda $07				lda 	TOS+1
.1681	48		pha				pha
.1682	b9 00 07	lda $0700,y			lda 	returnStackLow,y 			; put counter-1 out
.1685	38		sec				sec
.1686	e9 01		sbc #$01			sbc 	#1
.1688	85 06		sta $06				sta 	TOS
.168a	b9 40 07	lda $0740,y			lda 	returnStackHigh,y
.168d	e9 00		sbc #$00			sbc 	#0
.168f	85 07		sta $07				sta 	TOS+1
.1691	4c 00 00	jmp $0000			jmp 	Next

;******  Return to file: kernel.asm


;******  Processing file: words/structures/ifelseendif.src

.1694					IfHandler:
.1694	4c a3 16	jmp $16a3			jmp 	BranchIfZero
.1697					ElseHandler:
.1697	4c b9 16	jmp $16b9			jmp 	BranchTestSucceedsNoPop
.169a					EndIfHandler:
.169a	4c 00 00	jmp $0000			jmp 	Next

;******  Return to file: kernel.asm


;******  Processing file: words/structures/repeatuntil.src

.169d					RepeatHandler:
.169d	4c 00 00	jmp $0000			jmp 	Next
.16a0					UntilHandler:
.16a0	4c a3 16	jmp $16a3			jmp 	BranchIfZero

;******  Return to file: kernel.asm


;******  Processing file: words/system/branch.src

.16a3					BranchIfZero:
.16a3	a5 06		lda $06				lda 	TOS 						; check TOS = 0
.16a5	05 07		ora $07				ora 	TOS+1
.16a7	f0 0a		beq $16b3			beq 	BranchTestSucceeds
.16a9					BranchTestFails:
.16a9	68		pla				pla
.16aa	85 07		sta $07				sta 	TOS+1
.16ac	68		pla				pla
.16ad	85 06		sta $06				sta 	TOS
.16af	e8		inx				inx 								; skip over the relative branch.
.16b0	4c 00 00	jmp $0000			jmp 	Next
.16b3					BranchTestSucceeds:
.16b3	68		pla				pla
.16b4	85 07		sta $07				sta 	TOS+1
.16b6	68		pla				pla
.16b7	85 06		sta $06				sta 	TOS
.16b9					BranchTestSucceedsNoPop:
.16b9	e8		inx				inx 								; advance by two, to the offset
.16ba	e8		inx				inx
.16bb					BranchAlways:
.16bb	8a		txa				txa 								; A = Y = position
.16bc	a8		tay				tay 								; (IP),Y now points to the branch target
.16bd	b1 03		lda ($03),y			lda 	(IP),y 						; adjust the position
.16bf	aa		tax				tax 								; position back in this line.
.16c0	4c 02 00	jmp $0002			jmp 	Next+2 						; and continue

;******  Return to file: kernel.asm


;******  Processing file: words/system/callhandler.src

.16c3					CallHandler:
.16c3	e8		inx				inx									; bump X to the call address.
.16c4	e8		inx				inx
.16c5	e6 05		inc $05				inc 	rsp 						; bump the RSP (first time to zero)
.16c7	a4 05		ldy $05				ldy 	rsp 						; get return stack and push IP/X on it.
.16c9	c0 40		cpy #$40			cpy 	#$40 						; overflow
.16cb	f0 4b		beq $1718			beq 	_CHOverflow
.16cd	a5 04		lda $04				lda 	IP+1
.16cf	99 40 07	sta $0740,y			sta 	returnStackHigh,y
.16d2	a5 03		lda $03				lda 	IP
.16d4	99 00 07	sta $0700,y			sta 	returnStackLow,y
.16d7	8a		txa				txa
.16d8	99 80 07	sta $0780,y			sta 	returnStackX,y
.16db	8a		txa				txa 								; get the line number into temp1.
.16dc	a8		tay				tay
.16dd	b1 03		lda ($03),y			lda 	(IP),y
.16df	85 12		sta $12				sta 	temp1
.16e1	c8		iny				iny
.16e2	b1 03		lda ($03),y			lda 	(IP),y
.16e4	85 13		sta $13				sta 	temp1+1
.16e6	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.16e8	85 03		sta $03				sta 	0+(IP)
.16ea	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.16ec	85 04		sta $04				sta 	1+(IP)
.16ee	b2 03		lda ($03)			lda 	(IP)						; no program code ?
.16f0	f0 17		beq $1709			beq 	_CHFail
.16f2	a0 01		ldy #$01			ldy 	#1 							; Y = 1 throughout.
.16f4					_CHSearch:
.16f4	b1 03		lda ($03),y			lda 	(IP),y 						; check LSB of line number
.16f6	c5 12		cmp $12				cmp 	temp1
.16f8	f0 2d		beq $1727			beq 	_CHFoundLSB
.16fa					_CHSearchNext:
.16fa	18		clc				clc
.16fb	a5 03		lda $03				lda 	IP
.16fd	72 03		adc ($03)			adc 	(IP)
.16ff	85 03		sta $03				sta 	IP
.1701	90 02		bcc $1705			bcc 	_NoCarryAdv
.1703	e6 04		inc $04				inc 	IP+1
.1705					_NoCarryAdv:
.1705	b2 03		lda ($03)			lda 	(IP)						; check reached the end.
.1707	d0 eb		bne $16f4			bne 	_CHSearch
.1709					_CHFail:
.1709	20 77 1b	jsr $1b77			jsr 	ErrorHandler
>170c	44 45 46 49 4e 49 54 49				.text 	"DEFINITION?",0
>1714	4f 4e 3f 00
.1718					_CHOverflow:
.1718	20 77 1b	jsr $1b77			jsr 	ErrorHandler
>171b	53 54 41 43 4b 44 45 50				.text 	"STACKDEPTH?",0
>1723	54 48 3f 00
.1727					_CHFoundLSB:
.1727	c8		iny				iny 								; get MSB
.1728	b1 03		lda ($03),y			lda 	(IP),y
.172a	88		dey				dey
.172b	c5 13		cmp $13				cmp 	temp1+1 					; matches, if not contineu
.172d	d0 cb		bne $16fa			bne 	_CHSearchNext
.172f	a0 03		ldy #$03			ldy 	#3	 						; check it begins with $$define
.1731	b1 03		lda ($03),y			lda 	(IP),y
.1733	c9 76		cmp #$76			cmp 	#DefineCode & $FF
.1735	d0 d2		bne $1709			bne 	_CHFail
.1737	c8		iny				iny
.1738	b1 03		lda ($03),y			lda 	(IP),y
.173a	c9 19		cmp #$19			cmp 	#DefineCode >> 8
.173c	d0 cb		bne $1709			bne 	_CHFail
.173e	c8		iny				iny
.173f	b1 03		lda ($03),y			lda 	(IP),y 						; this is the length of the define name
.1741	18		clc				clc
.1742	69 05		adc #$05			adc 	#5 							; $$define token, line number, offset
.1744	aa		tax				tax
.1745	4c 02 00	jmp $0002			jmp 	Next+2 						; and execute
.1748					ReturnHandler:
.1748	a4 05		ldy $05				ldy 	rsp 						; get rsp
.174a	30 15		bmi $1761			bmi 	_RHUnderflow 				; if -ve underflowed
.174c	c6 05		dec $05				dec 	rsp 						; decrement rsp
.174e	b9 40 07	lda $0740,y			lda 	returnStackHigh,y 			; restore IP/X
.1751	85 04		sta $04				sta 	IP+1
.1753	b9 00 07	lda $0700,y			lda 	returnStackLow,y
.1756	85 03		sta $03				sta 	IP
.1758	b9 80 07	lda $0780,y			lda 	returnStackX,y
.175b	aa		tax				tax
.175c	f0 0e		beq $176c			beq 	_RHInLoop 					; this means you have done :something for ; next
.175e	4c 00 00	jmp $0000			jmp 	Next
.1761					_RHUnderflow:
.1761	20 77 1b	jsr $1b77			jsr 	ErrorHandler
>1764	52 45 54 55 52 4e 3f 00				.text 	"RETURN?",0
.176c					_RHInLoop:
.176c	20 77 1b	jsr $1b77			jsr 	ErrorHandler
>176f	52 45 54 55 52 4e 20 49				.text 	"RETURN IN LOOP?",0
>1777	4e 20 4c 4f 4f 50 3f 00
.177f					CallHandlerDecode:
.177f	a9 20		lda #$20			lda 	#" "						; space
.1781	20 7b 11	jsr $117b			jsr 	DecodeWriteBuffer
.1784	b1 08		lda ($08),y			lda 	(srcPtr),y 					; get line number into YA
.1786	aa		tax				tax
.1787	c8		iny				iny
.1788	b1 08		lda ($08),y			lda 	(srcPtr),y
.178a	a8		tay				tay
.178b	8a		txa				txa
.178c	20 c9 17	jsr $17c9			jsr 	FindLine 					; try to locate that line.
.178f	b0 11		bcs $17a2			bcs 	_CHDFound 					; if found .....
.1791					_CHDLineOnly:
.1791	48		pha				pha
.1792	a9 3c		lda #$3c			lda 	#"<"
.1794	20 7b 11	jsr $117b			jsr 	DecodeWriteBuffer
.1797	68		pla				pla
.1798	18		clc				clc 								; output unsigned
.1799	20 9d 11	jsr $119d			jsr 	DecodeYAToBuffer
.179c	a9 3e		lda #$3e			lda 	#">"
.179e	20 7b 11	jsr $117b			jsr 	DecodeWriteBuffer
.17a1	60		rts				rts
.17a2					_CHDFound:
.17a2	48		pha				pha 								; save YA
.17a3	5a		phy				phy
.17a4	a0 03		ldy #$03			ldy 	#3 							; check first is $$define
.17a6	b1 12		lda ($12),y			lda 	(temp1),y
.17a8	c9 76		cmp #$76			cmp 	#DefineCode & 255
.17aa	d0 07		bne $17b3			bne 	_CHDNoDefine
.17ac	c8		iny				iny
.17ad	b1 12		lda ($12),y			lda 	(temp1),y
.17af	c9 19		cmp #$19			cmp 	#DefineCode >> 8
.17b1	f0 04		beq $17b7			beq 	_CHDFoundDefine
.17b3					_CHDNoDefine:
.17b3	7a		ply				ply									; restore the line number and print it in <>
.17b4	68		pla				pla
.17b5	80 da		bra $1791			bra 	_CHDLineOnly
.17b7					_CHDFoundDefine:
.17b7	68		pla				pla 								; throw saved line number.
.17b8	68		pla				pla
.17b9	a0 05		ldy #$05			ldy 	#5 							; 3,4 $$define 5 length, name has bit 7 set at end
.17bb					_CHDOutName:
.17bb	c8		iny				iny 								; next
.17bc	b1 12		lda ($12),y			lda 	(temp1),y 					; print char no bit 7
.17be	48		pha				pha
.17bf	29 7f		and #$7f			and 	#$7F
.17c1	20 7b 11	jsr $117b			jsr 	DecodeWriteBuffer
.17c4	68		pla				pla
.17c5	0a		asl a				asl 	a 							; bit 7 to carry
.17c6	90 f3		bcc $17bb			bcc 	_CHDOutName
.17c8	60		rts				rts
.17c9					FindLine:
.17c9	48		pha				pha 								; save registers
.17ca	da		phx				phx
.17cb	5a		phy				phy
.17cc	85 14		sta $14				sta 	temp2 						; temp2 = target line#
.17ce	84 15		sty $15				sty 	temp2+1
.17d0	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.17d2	85 12		sta $12				sta 	0+(temp1)
.17d4	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.17d6	85 13		sta $13				sta 	1+(temp1)
.17d8					_FLLoop:
.17d8	b2 12		lda ($12)			lda 	(temp1) 					; found end ?
.17da	18		clc				clc									; if so exit with CC.
.17db	f0 1d		beq $17fa			beq 	_FLExit
.17dd	a0 01		ldy #$01			ldy 	#1 							; check line # match
.17df	b1 12		lda ($12),y			lda 	(temp1),y
.17e1	c5 14		cmp $14				cmp 	temp2
.17e3	d0 08		bne $17ed			bne 	_FLNext
.17e5	c8		iny				iny
.17e6	b1 12		lda ($12),y			lda 	(temp1),y
.17e8	c5 15		cmp $15				cmp 	temp2+1
.17ea	38		sec				sec 								; if so exit with CS
.17eb	f0 0d		beq $17fa			beq 	_FLExit
.17ed					_FLNext:
.17ed	18		clc				clc
.17ee	a5 12		lda $12				lda 	temp1
.17f0	72 12		adc ($12)			adc 	(temp1)
.17f2	85 12		sta $12				sta 	temp1
.17f4	90 02		bcc $17f8			bcc 	_NoCarryAdv
.17f6	e6 13		inc $13				inc 	temp1+1
.17f8					_NoCarryAdv:
.17f8	80 de		bra $17d8			bra 	_FLLoop 					; keep looking.
.17fa					_FLExit:
.17fa	7a		ply				ply
.17fb	fa		plx				plx
.17fc	68		pla				pla
.17fd	60		rts				rts
.17fe	18		clc				clc
.17ff	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/clrnew.src

.1800					NewHandler:
.1800	9c 00 40	stz $4000			stz 	ProgramMemory 				; Make the first offset zero.
.1803	20 0f 18	jsr $180f			jsr 	ClearVariableSpace 			; clear variables, reset pointers
.1806	4c 00 00	jmp $0000			jmp 	Next
.1809					ClrHandler:
.1809	20 0f 18	jsr $180f			jsr 	ClearVariableSpace 			; clear variables, reset pointers
.180c	4c 00 00	jmp $0000			jmp 	Next
.180f					ClearVariableSpace:
.180f	a9 ff		lda #$ff			lda 	#$FF 						; empty return stack
.1811	85 05		sta $05				sta 	rsp
.1813	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.1815	85 0e		sta $0e				sta 	0+(nextFreeMem)
.1817	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.1819	85 0f		sta $0f				sta 	1+(nextFreeMem)
.181b	a0 1f		ldy #$1f			ldy 	#hashTableSize*2-1 			; erase the hash table (used for variables)
.181d					_CVSHashClear:
.181d	a9 00		lda #$00			lda 	#0 							; all the first record pointers are $00
.181f	99 40 06	sta $0640,y			sta 	hashTable,y
.1822	88		dey				dey
.1823	10 f8		bpl $181d			bpl 	_CVSHashClear
.1825					_CVSFindEnd:
.1825	18		clc				clc
.1826	a5 0e		lda $0e				lda 	nextFreeMem
.1828	72 0e		adc ($0e)			adc 	(nextFreeMem)
.182a	85 0e		sta $0e				sta 	nextFreeMem
.182c	90 02		bcc $1830			bcc 	_NoCarryAdv
.182e	e6 0f		inc $0f				inc 	nextFreeMem+1
.1830					_NoCarryAdv:
.1830	b2 0e		lda ($0e)			lda 	(nextFreeMem)
.1832	d0 f1		bne $1825			bne 	_CVSFindEnd
.1834	a9 08		lda #$08			lda 	#8 							; this puts a gap in, more for clarity than anything.
.1836	a0 00		ldy #$00			ldy 	#0
.1838	20 3c 18	jsr $183c			jsr 	AdvanceFreeMem				; we need +1 because the previous code leaves the
.183b	60		rts				rts 								; free mem pointer pointing to the last zero offset
.183c					AdvanceFreeMem:
.183c	18		clc				clc
.183d	65 0e		adc $0e				adc 	nextFreeMem
.183f	85 0e		sta $0e				sta 	nextFreeMem
.1841	98		tya				tya
.1842	65 0f		adc $0f				adc 	nextFreeMem+1
.1844	85 0f		sta $0f				sta 	nextFreeMem+1
.1846	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/debug.src

.1847					ExitDump:
.1847	ba		tsx				tsx 								; save Data Stack in temp1
.1848	86 12		stx $12				stx 	temp1
.184a	4c ff ff	jmp $ffff			jmp 	$FFFF 						; makes the X16-Emulator dump-exit.
.184d					BreakCmd:
>184d	ff						.byte 	$FF
.184e	4c 00 00	jmp $0000			jmp 	Next

;******  Return to file: kernel.asm


;******  Processing file: words/system/miscellany.src

.1851					Call6502:
.1851	a5 06		lda $06				lda 	TOS 						; copy call address
.1853	85 12		sta $12				sta 	temp1
.1855	a5 07		lda $07				lda 	TOS+1
.1857	85 13		sta $13				sta 	temp1+1
.1859	68		pla				pla
.185a	85 07		sta $07				sta 	TOS+1
.185c	68		pla				pla
.185d	85 06		sta $06				sta 	TOS
.185f	20 65 18	jsr $1865			jsr 	_CallTemp1 					; call it
.1862	4c 00 00	jmp $0000			jmp 	Next
.1865					_CallTemp1:
.1865	6c 12 00	jmp ($0012)			jmp 	(temp1)
.1868					AssertCode:
.1868	a5 06		lda $06				lda 	TOS 						; TOS = 0
.186a	05 07		ora $07				ora 	TOS+1
.186c	f0 09		beq $1877			beq 	_ASFail 					; if zero fail
.186e	68		pla				pla
.186f	85 07		sta $07				sta 	TOS+1
.1871	68		pla				pla
.1872	85 06		sta $06				sta 	TOS
.1874	4c 00 00	jmp $0000			jmp 	Next
.1877					_ASFail:
.1877	20 77 1b	jsr $1b77			jsr 	ErrorHandler
>187a	41 53 53 45 52 54 00				.text 	"ASSERT",0
.1881					StopCode:
.1881	20 77 1b	jsr $1b77			jsr 	ErrorHandler
>1884	53 54 4f 50 00					.text 	"STOP",0
.1889					EndProgram:
.1889	4c 74 1b	jmp $1b74			jmp 	WarmStart

;******  Return to file: kernel.asm


;******  Processing file: words/system/toint.src

.188c					NumToInt:
.188c	a5 06		lda $06				lda 	TOS 						; TOS to temp4
.188e	85 18		sta $18				sta 	temp4
.1890	a5 07		lda $07				lda		TOS+1
.1892	85 19		sta $19				sta 	temp4+1
.1894	20 b5 18	jsr $18b5			jsr 	ConvertToInteger
.1897	90 0f		bcc $18a8			bcc 	_NTIFail
.1899	a5 16		lda $16				lda 	temp3
.189b	48		pha				pha
.189c	a5 17		lda $17				lda 	temp3+1
.189e	48		pha				pha
.189f	a9 ff		lda #$ff			lda 	#$FF 						; TOS = -1
.18a1	85 06		sta $06				sta 	TOS
.18a3	85 07		sta $07				sta 	TOS+1
.18a5	4c 00 00	jmp $0000			jmp 	Next
.18a8					_NTIFail:
.18a8	64 06		stz $06				stz 	TOS 						; zero TOS and push on stack as null answer
.18aa	64 07		stz $07				stz 	TOS+1
.18ac	a5 06		lda $06				lda 	TOS
.18ae	48		pha				pha
.18af	a5 07		lda $07				lda 	TOS+1
.18b1	48		pha				pha
.18b2	4c 00 00	jmp $0000			jmp 	Next
.18b5					ConvertToInteger:
.18b5	64 16		stz $16				stz 	temp3 						; reset value
.18b7	64 17		stz $17				stz 	temp3+1
.18b9	64 12		stz $12				stz 	temp1 						; temp1 = 0 (decimal) 255 (hex)
.18bb	a0 00		ldy #$00			ldy 	#0 							; look at first character
.18bd	b1 18		lda ($18),y			lda 	(temp4),y
.18bf	49 2d		eor #$2d			eor 	#"-"						; zero if '-'
.18c1	85 13		sta $13				sta 	temp1+1 					; save this in temp1+1
.18c3	d0 01		bne $18c6			bne 	_CTINotMinus
.18c5	c8		iny				iny									; skip -
.18c6					_CTINotMinus:
.18c6	b1 18		lda ($18),y			lda 	(temp4),y
.18c8	c9 24		cmp #$24			cmp		#'$'						; if $ then skip it and set hex flag
.18ca	d0 03		bne $18cf			bne 	_CTILoop
.18cc	c6 12		dec $12				dec 	temp1
.18ce	c8		iny				iny
.18cf					_CTILoop:
.18cf	b1 18		lda ($18),y			lda 	(temp4),y 					; next digit
.18d1	29 7f		and #$7f			and 	#$7F 						; drop end of word flag
.18d3	38		sec				sec
.18d4	e9 30		sbc #$30			sbc 	#'0' 						; put in range '0'+
.18d6	90 62		bcc $193a			bcc 	_CTIFail 					; out of range.
.18d8	c9 0a		cmp #$0a			cmp 	#10 						; in 0-9 ?
.18da	90 0b		bcc $18e7			bcc 	_CTILegal
.18dc	c9 11		cmp #$11			cmp 	#'A'-'0'					; between 9 and A ?
.18de	90 5a		bcc $193a			bcc 	_CTIFail
.18e0	38		sec				sec
.18e1	e9 07		sbc #$07			sbc 	#7 							; hex adjust
.18e3	c9 10		cmp #$10			cmp 	#16 						; out of range ?
.18e5	b0 53		bcs $193a			bcs 	_CTIFail
.18e7					_CTILegal:
.18e7	48		pha				pha 								; save digit value.
.18e8	06 16		asl $16				asl 	temp3
.18ea	26 17		rol $17				rol 	temp3+1
.18ec	a5 16		lda $16				lda 	temp3 						; copy x2 into temp2
.18ee	85 14		sta $14				sta 	temp2
.18f0	a5 17		lda $17				lda 	temp3+1
.18f2	85 15		sta $15				sta 	temp2+1
.18f4	06 16		asl $16				asl 	temp3
.18f6	26 17		rol $17				rol 	temp3+1
.18f8	06 16		asl $16				asl 	temp3
.18fa	26 17		rol $17				rol 	temp3+1
.18fc	24 12		bit $12				bit 	temp1 						; hexadecimal
.18fe	10 07		bpl $1907			bpl 	_CTIDecimal
.1900	06 16		asl $16				asl 	temp3
.1902	26 17		rol $17				rol 	temp3+1
.1904	68		pla				pla 								; get digit back
.1905	80 12		bra $1919			bra 	_CTIAddLoop
.1907					_CTIDecimal:
.1907	18		clc				clc 								; x 8 + x 2 = x 10
.1908	a5 16		lda $16				lda 	temp3
.190a	65 14		adc $14				adc 	temp2
.190c	85 16		sta $16				sta 	temp3
.190e	a5 17		lda $17				lda 	temp3+1
.1910	65 15		adc $15				adc 	temp2+1
.1912	85 17		sta $17				sta 	temp3+1
.1914	68		pla				pla 					; check digit 0-9
.1915	c9 0a		cmp #$0a			cmp 	#10
.1917	b0 21		bcs $193a			bcs 	_CTIFail
.1919					_CTIAddLoop:
.1919	18		clc				clc
.191a	65 16		adc $16				adc 	temp3
.191c	85 16		sta $16				sta 	temp3
.191e	90 02		bcc $1922			bcc 	_CTINoCarry
.1920	e6 17		inc $17				inc 	temp3+1
.1922					_CTINoCarry:
.1922	c8		iny				iny
.1923	b1 18		lda ($18),y			lda 	(temp4),y 					; was this the last character
.1925	d0 a8		bne $18cf			bne 	_CTILoop 					; no, go back.
.1927	a5 13		lda $13				lda 	temp1+1 					; was it - ?
.1929	d0 0d		bne $1938			bne 	_CTIOkay
.192b	38		sec				sec
.192c	a9 00		lda #$00			lda 	#0 							; negate temp3.
.192e	e5 16		sbc $16				sbc 	temp3
.1930	85 16		sta $16				sta 	temp3
.1932	a9 00		lda #$00			lda 	#0
.1934	e5 17		sbc $17				sbc 	temp3+1
.1936	85 17		sta $17				sta 	temp3+1
.1938					_CTIOkay:
.1938	38		sec				sec
.1939	60		rts				rts
.193a					_CTIFail:
.193a	18		clc				clc
.193b	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/skipper.src

.193c					NextLine:
.193c	18		clc				clc
.193d	a5 03		lda $03				lda 	IP
.193f	72 03		adc ($03)			adc 	(IP)
.1941	85 03		sta $03				sta 	IP
.1943	90 02		bcc $1947			bcc 	_NoCarryAdv
.1945	e6 04		inc $04				inc 	IP+1
.1947					_NoCarryAdv:
.1947	b2 03		lda ($03)			lda 	(IP)						; is there any following program ?
.1949	f0 05		beq $1950			beq 	_NLGoEnd
.194b	a2 03		ldx #$03			ldx 	#3 							; start 3 in
.194d	4c 02 00	jmp $0002			jmp 	Next+2 						; avoid the first two INXs
.1950					_NLGoEnd:
.1950	4c 74 1b	jmp $1b74			jmp 	WarmStart
.1953					SkipComment:
.1953	e8		inx				inx									; (IP),X points to the length.
.1954	e8		inx				inx
.1955	8a		txa				txa
.1956	a8		tay				tay 								; put into Y
.1957	18		clc				clc
.1958	71 03		adc ($03),y			adc 	(IP),y 						; add the length to X
.195a	aa		tax				tax 								; put back in X
.195b	4c 02 00	jmp $0002			jmp 	Next+2 						; continue skipping the pre-increment.
.195e					CommentDecoder:
.195e	a9 20		lda #$20			lda 	#32
.1960	20 7b 11	jsr $117b			jsr 	DecodeWriteBuffer
.1963	a9 27		lda #$27			lda 	#"'"
.1965	20 7b 11	jsr $117b			jsr 	DecodeWriteBuffer
.1968	a9 20		lda #$20			lda 	#32
.196a	20 7b 11	jsr $117b			jsr 	DecodeWriteBuffer
.196d	20 84 11	jsr $1184			jsr 	DecodeOutputData
.1970	a9 20		lda #$20			lda 	#32
.1972	20 7b 11	jsr $117b			jsr 	DecodeWriteBuffer
.1975	60		rts				rts
.1976					DefineCode:
.1976	20 77 1b	jsr $1b77			jsr 	ErrorHandler
>1979	44 45 46 49 4e 49 54 49				.text 	"DEFINITION?",0
>1981	4f 4e 3f 00
.1985					DefineDecoder:
.1985	a9 20		lda #$20			lda 	#32
.1987	20 7b 11	jsr $117b			jsr 	DecodeWriteBuffer
.198a	a9 3a		lda #$3a			lda 	#":"
.198c	20 7b 11	jsr $117b			jsr 	DecodeWriteBuffer
.198f	20 84 11	jsr $1184			jsr 	DecodeOutputData
.1992	a9 20		lda #$20			lda 	#32
.1994	20 7b 11	jsr $117b			jsr 	DecodeWriteBuffer
.1997	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/tostr.src

.1998					IntToString:
.1998	a9 10		lda #$10			lda 	#(textBuffer) & $FF
.199a	85 14		sta $14				sta 	0+(temp2)
.199c	a9 08		lda #$08			lda 	#(textBuffer) >> 8
.199e	85 15		sta $15				sta 	1+(temp2)
.19a0	a5 06		lda $06				lda 	TOS 						; value in YA
.19a2	a4 07		ldy $07				ldy 	TOS+1
.19a4	20 b2 19	jsr $19b2			jsr 	ConvertToString
.19a7	a9 10		lda #$10			lda 	#(textBuffer) & $FF
.19a9	85 06		sta $06				sta 	0+(TOS)
.19ab	a9 08		lda #$08			lda 	#(textBuffer) >> 8
.19ad	85 07		sta $07				sta 	1+(TOS)
.19af	4c 00 00	jmp $0000			jmp 	Next
.19b2					ConvertToString:
.19b2	38		sec				sec
.19b3	80 01		bra $19b6			bra 	ConvertToStringMain
.19b5					ConvertToStringUnsigned:
.19b5	18		clc				clc
.19b6					ConvertToStringMain:
.19b6	da		phx				phx									; save XY
.19b7	5a		phy				phy
.19b8	64 1a		stz $1a				stz 	SignCount 					; this is zero suppression
.19ba	85 12		sta $12				sta 	temp1 						; save YA in temp1
.19bc	84 13		sty $13				sty 	temp1+1
.19be	a0 00		ldy #$00			ldy 	#0 							; index to result.
.19c0	90 16		bcc $19d8			bcc 	_CTSUnsigned 				; if carry clear do not adjust for -
.19c2	a5 13		lda $13				lda 	temp1+1 					; is it negative
.19c4	10 12		bpl $19d8			bpl 	_CTSUnsigned
.19c6	a9 2d		lda #$2d			lda 	#"-"						; output - sign
.19c8	91 14		sta ($14),y			sta 	(temp2),y
.19ca	c8		iny				iny
.19cb	38		sec				sec 								; negate temp1
.19cc	a9 00		lda #$00			lda 	#0
.19ce	e5 12		sbc $12				sbc 	temp1
.19d0	85 12		sta $12				sta 	temp1
.19d2	a9 00		lda #$00			lda 	#0
.19d4	e5 13		sbc $13				sbc 	temp1+1
.19d6	85 13		sta $13				sta 	temp1+1
.19d8					_CTSUnsigned:
.19d8	a2 00		ldx #$00			ldx 	#0 							; index into subtraction table
.19da					_CTSLoop:
.19da	a9 2f		lda #$2f			lda 	#"0"-1						; set the digit to '0' code.
.19dc	91 14		sta ($14),y			sta 	(temp2),y
.19de					_CTSSubLoop:
.19de	b1 14		lda ($14),y			lda 	(temp2),y 					; bump the count
.19e0	1a		inc a				inc 	a
.19e1	91 14		sta ($14),y			sta 	(temp2),y
.19e3	38		sec				sec 								; do subtraction saving interim result
.19e4	a5 12		lda $12				lda 	temp1
.19e6	fd 19 1a	sbc $1a19,x			sbc 	_CTSTable,x
.19e9	48		pha				pha
.19ea	a5 13		lda $13				lda 	temp1+1
.19ec	fd 1a 1a	sbc $1a1a,x			sbc 	_CTSTable+1,x
.19ef	90 07		bcc $19f8			bcc 	_CTSCantSubtract 			; end of subtraction.
.19f1	85 13		sta $13				sta 	temp1+1 					; save result back
.19f3	68		pla				pla
.19f4	85 12		sta $12				sta 	temp1
.19f6	80 e6		bra $19de			bra 	_CTSSubLoop
.19f8					_CTSCantSubtract:
.19f8	68		pla				pla 								; throw away interim
.19f9	e8		inx				inx 								; next subtractor
.19fa	e8		inx				inx
.19fb	b1 14		lda ($14),y			lda 	(temp2),y 					; update leading zero
.19fd	49 30		eor #$30			eor 	#"0"
.19ff	05 1a		ora $1a				ora 	SignCount
.1a01	85 1a		sta $1a				sta 	SignCount
.1a03	f0 01		beq $1a06			beq		_CTSLZ 						; if all zeros so far suppress.
.1a05	c8		iny				iny 								; next character
.1a06					_CTSLZ:
.1a06	e0 08		cpx #$08			cpx 	#_CTSTableEnd-_CTSTable 	; done them all ?
.1a08	d0 d0		bne $19da			bne 	_CTSLoop
.1a0a					_CTSComplete:
.1a0a	a5 12		lda $12				lda		temp1 						; get remainder 0-9
.1a0c	09 30		ora #$30			ora 	#48 						; ASCII
.1a0e	91 14		sta ($14),y			sta 	(temp2),y					; write out
.1a10	c8		iny				iny
.1a11	a9 00		lda #$00			lda 	#0							; make ASCIIZ
.1a13	91 14		sta ($14),y			sta 	(temp2),y
.1a15	98		tya				tya 								; size in A
.1a16	7a		ply				ply									; pull and exit.
.1a17	fa		plx				plx
.1a18	60		rts				rts
.1a19					_CTSTable:
>1a19	10 27 e8 03 64 00 0a 00				.word 	10000,1000,100,10 			; subtractors, this is a simple version.
.1a21					_CTSTableEnd:

;******  Return to file: kernel.asm


;******  Processing file: words/system/varhandlers.src

.1a21					VarAddressHandler:
.1a21	18		clc				clc 								; find variable, error if it doesn't exist.
.1a22	20 73 1a	jsr $1a73			jsr 	VariableFind
.1a25	a5 06		lda $06				lda 	TOS
.1a27	48		pha				pha
.1a28	a5 07		lda $07				lda 	TOS+1
.1a2a	48		pha				pha
.1a2b	a5 12		lda $12				lda 	temp1 						; the address is the new value
.1a2d	85 06		sta $06				sta 	TOS
.1a2f	a5 13		lda $13				lda		temp1+1
.1a31	85 07		sta $07				sta 	TOS+1
.1a33	4c 00 00	jmp $0000			jmp 	Next
.1a36					VarAddrHandlerDecode:
.1a36	a9 26		lda #$26			lda 	#"&"
.1a38	4c 21 1b	jmp $1b21			jmp 	VarHandlerDecode
.1a3b					VarReadHandler:
.1a3b	18		clc				clc 								; find variable, error if it doesn't exist.
.1a3c	20 73 1a	jsr $1a73			jsr 	VariableFind
.1a3f	a5 06		lda $06				lda 	TOS
.1a41	48		pha				pha
.1a42	a5 07		lda $07				lda 	TOS+1
.1a44	48		pha				pha
.1a45	b2 12		lda ($12)			lda 	(temp1)						; read variable address to TOS
.1a47	85 06		sta $06				sta 	TOS
.1a49	a0 01		ldy #$01			ldy 	#1
.1a4b	b1 12		lda ($12),y			lda 	(temp1),y
.1a4d	85 07		sta $07				sta 	TOS+1
.1a4f	4c 00 00	jmp $0000			jmp 	Next
.1a52					VarReadHandlerDecode:
.1a52	a9 40		lda #$40			lda 	#"@"
.1a54	4c 21 1b	jmp $1b21			jmp 	VarHandlerDecode
.1a57					VarWriteHandler:
.1a57	38		sec				sec 								; find variable, create it if it doesn't exist.
.1a58	20 73 1a	jsr $1a73			jsr 	VariableFind
.1a5b	a5 06		lda $06				lda 	TOS 						; write TOS to that address.
.1a5d	92 12		sta ($12)			sta 	(temp1)
.1a5f	a5 07		lda $07				lda 	TOS+1
.1a61	a0 01		ldy #$01			ldy 	#1
.1a63	91 12		sta ($12),y			sta 	(temp1),y
.1a65	68		pla				pla
.1a66	85 07		sta $07				sta 	TOS+1
.1a68	68		pla				pla
.1a69	85 06		sta $06				sta 	TOS
.1a6b	4c 00 00	jmp $0000			jmp 	Next
.1a6e					VarWriteHandlerDecode:
.1a6e	a9 21		lda #$21			lda 	#"!"
.1a70	4c 21 1b	jmp $1b21			jmp 	VarHandlerDecode
.1a73					VariableFind:
.1a73	08		php				php 								; save autocreate flag.
.1a74	e8		inx				inx 								; advance to/over the variable name.
.1a75	e8		inx				inx
.1a76	8a		txa				txa 								; put in Y
.1a77	a8		tay				tay
.1a78	b1 03		lda ($03),y			lda 	(IP),y 						; copy name word into temp2
.1a7a	85 14		sta $14				sta 	temp2
.1a7c	c8		iny				iny
.1a7d	b1 03		lda ($03),y			lda 	(IP),y
.1a7f	85 15		sta $15				sta 	temp2+1
.1a81	c9 1b		cmp #$1b			cmp 	#27 						; check for A-Z
.1a83	b0 0f		bcs $1a94			bcs 	_VFLong
.1a85	a5 15		lda $15				lda 	temp2+1
.1a87	d0 0b		bne $1a94			bne 	_VFLong
.1a89	a5 14		lda $14				lda 	temp2						; this is the index
.1a8b	0a		asl a				asl 	a 							; double it
.1a8c	85 12		sta $12				sta 	temp1
.1a8e	a9 06		lda #$06			lda 	#azVariables >> 8			; set the MSB
.1a90	85 13		sta $13				sta 	temp1+1
.1a92	28		plp				plp 								; throw creation flag, it always exists.
.1a93	60		rts				rts
.1a94					_VFLong:
.1a94	a5 14		lda $14				lda 	temp2 						; built a hash table index into temp3/temp4
.1a96	6a		ror a				ror 	a
.1a97	6a		ror a				ror 	a
.1a98	6a		ror a				ror 	a
.1a99	6a		ror a				ror 	a
.1a9a	45 14		eor $14				eor 	temp2
.1a9c	45 15		eor $15				eor 	temp2+1
.1a9e	29 0f		and #$0f			and 	#(hashTableSize-1)			; force into range
.1aa0	0a		asl a				asl 	a
.1aa1	69 40		adc #$40			adc 	#hashTable & $FF 			; make an address of the head => temp1/3
.1aa3	85 12		sta $12				sta 	temp1
.1aa5	85 16		sta $16				sta 	temp3
.1aa7	a9 06		lda #$06			lda 	#hashTable >> 8
.1aa9	85 13		sta $13				sta 	temp1+1
.1aab	85 17		sta $17				sta 	temp3+1
.1aad					_VFSearch:
.1aad	a0 01		ldy #$01			ldy 	#1							; read MSB of first record
.1aaf	b1 12		lda ($12),y			lda 	(temp1),y
.1ab1	f0 23		beq $1ad6			beq 	_VFNotFound 				; is MSB is zero, can't be a variable record
.1ab3	a8		tay				tay 								; follow the link through.
.1ab4	b2 12		lda ($12)			lda 	(temp1)
.1ab6	85 12		sta $12				sta 	temp1
.1ab8	84 13		sty $13				sty 	temp1+1
.1aba	a0 04		ldy #$04			ldy 	#4							; check if the name matches
.1abc	b1 12		lda ($12),y			lda 	(temp1),y
.1abe	c5 14		cmp $14				cmp 	temp2
.1ac0	d0 eb		bne $1aad			bne 	_VFSearch 					; if it doesn't, follow the next link.
.1ac2	c8		iny				iny 								; same for 2nd byte of name
.1ac3	b1 12		lda ($12),y			lda 	(temp1),y
.1ac5	c5 15		cmp $15				cmp 	temp2+1
.1ac7	d0 e4		bne $1aad			bne 	_VFSearch
.1ac9	18		clc				clc
.1aca	a5 12		lda $12				lda 	temp1 						; make temp1 point to the data at offset 2
.1acc	69 02		adc #$02			adc 	#2
.1ace	85 12		sta $12				sta 	temp1
.1ad0	90 02		bcc $1ad4			bcc 	_VFNoPage1
.1ad2	e6 13		inc $13				inc 	temp1+1
.1ad4					_VFNoPage1:
.1ad4	28		plp				plp 								; don't need to worry about creation flag
.1ad5	60		rts				rts
.1ad6					_VFNotFound:
.1ad6	28		plp				plp 								; was carry set, e.g. create a new record if not found ?
.1ad7	b0 0d		bcs $1ae6			bcs 	_VFCreate
.1ad9	20 77 1b	jsr $1b77			jsr 	ErrorHandler
>1adc	56 41 52 49 41 42 4c 45				.text 	"VARIABLE?",0
>1ae4	3f 00
.1ae6					_VFCreate:
.1ae6	a0 01		ldy #$01			ldy 	#1
.1ae8	b2 16		lda ($16)			lda 	(temp3) 					; copy the head link to the first 2 bytes
.1aea	92 0e		sta ($0e)			sta 	(nextFreeMem)
.1aec	b1 16		lda ($16),y			lda 	(temp3),y
.1aee	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.1af0	c8		iny				iny
.1af1	a9 00		lda #$00			lda 	#0	 						; write zero initialised data out.
.1af3	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.1af5	c8		iny				iny
.1af6	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.1af8	c8		iny				iny
.1af9	a5 14		lda $14				lda 	temp2 						; copy the name out
.1afb	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.1afd	c8		iny				iny
.1afe	a5 15		lda $15				lda 	temp2+1
.1b00	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.1b02	a0 01		ldy #$01			ldy 	#1
.1b04	a5 0e		lda $0e				lda 	nextFreeMem 				; update the head link
.1b06	92 16		sta ($16)			sta 	(temp3)
.1b08	a5 0f		lda $0f				lda 	nextFreeMem+1
.1b0a	91 16		sta ($16),y			sta 	(temp3),y
.1b0c	18		clc				clc
.1b0d	a5 0e		lda $0e				lda 	nextFreeMem 				; put nextFreeMem+2 in temp1 (data pointer)
.1b0f	69 02		adc #$02			adc 	#2
.1b11	85 12		sta $12				sta 	temp1
.1b13	a5 0f		lda $0f				lda 	nextFreeMem+1
.1b15	69 00		adc #$00			adc 	#0
.1b17	85 13		sta $13				sta 	temp1+1
.1b19	a9 06		lda #$06			lda 	#6							; shift freemem pointer up 6
.1b1b	a0 00		ldy #$00			ldy 	#0
.1b1d	20 3c 18	jsr $183c			jsr 	AdvanceFreeMem
.1b20	60		rts				rts
.1b21					VarHandlerDecode:
.1b21	48		pha				pha 								; save, leading space
.1b22	a9 20		lda #$20			lda 	#" "
.1b24	20 7b 11	jsr $117b			jsr 	DecodeWriteBuffer
.1b27	68		pla				pla 								; restore and write type
.1b28	20 7b 11	jsr $117b			jsr 	DecodeWriteBuffer
.1b2b	b1 08		lda ($08),y			lda 	(srcPtr),y 					; copy to temp1
.1b2d	85 12		sta $12				sta 	temp1
.1b2f	c8		iny				iny
.1b30	b1 08		lda ($08),y			lda 	(srcPtr),y
.1b32	85 13		sta $13				sta 	temp1+1
.1b34	a5 12		lda $12				lda 	temp1 						; output the first character
.1b36	29 1f		and #$1f			and 	#31
.1b38	20 63 1b	jsr $1b63			jsr 	VHOutVarChar
.1b3b	a2 05		ldx #$05			ldx 	#5 							; divide temp1 by 32
.1b3d					_VHDShift:
.1b3d	46 13		lsr $13				lsr 	temp1+1
.1b3f	66 12		ror $12				ror 	temp1
.1b41	ca		dex				dex
.1b42	d0 f9		bne $1b3d			bne 	_VHDShift
.1b44	a2 ff		ldx #$ff			ldx 	#255 						; now divide that by 40 by repeated subtraction.
.1b46					_VHDDiv40:
.1b46	e8		inx				inx
.1b47	38		sec				sec
.1b48	a5 12		lda $12				lda 	temp1
.1b4a	e9 28		sbc #$28			sbc 	#40
.1b4c	a8		tay				tay
.1b4d	a5 13		lda $13				lda 	temp1+1
.1b4f	e9 00		sbc #$00			sbc 	#0
.1b51	90 06		bcc $1b59			bcc 	_VHDivDone
.1b53	85 13		sta $13				sta 	temp1+1
.1b55	84 12		sty $12				sty 	temp1
.1b57	80 ed		bra $1b46			bra 	_VHDDiv40
.1b59					_VHDivDone:
.1b59	a5 12		lda $12				lda 	temp1 						; remainder
.1b5b	20 63 1b	jsr $1b63			jsr 	VHOutVarChar
.1b5e	8a		txa				txa
.1b5f	20 63 1b	jsr $1b63			jsr 	VHOutVarChar 				; and result.
.1b62	60		rts				rts
.1b63					VHOutVarChar:
.1b63	c9 00		cmp #$00			cmp 	#0
.1b65	f0 0c		beq $1b73			beq 	_VHOExit
.1b67	18		clc				clc
.1b68	69 40		adc #$40			adc 	#64 						; 65-90 A-Z 91-100 0-9
.1b6a	c9 5b		cmp #$5b			cmp 	#91 						; convert back ?
.1b6c	90 02		bcc $1b70			bcc 	_VHOOut
.1b6e	e9 2b		sbc #$2b			sbc 	#91-48 						; adjust to digit
.1b70					_VHOOut:
.1b70	20 7b 11	jsr $117b			jsr 	DecodeWriteBuffer
.1b73					_VHOExit:
.1b73	60		rts				rts

;******  Return to file: kernel.asm

.1b74					WarmStart:
>1b74	ff						.byte 	$FF
.1b75	a2 00		ldx #$00			ldx 	#$00
.1b77					ErrorHandler:
>1b77	ff						.byte 	$FF
.1b78	a2 5e		ldx #$5e			ldx 	#$5E
.1b7a					Dictionary:

;******  Processing file: generated/dictionary.inc

>1b7a	05					.byte	_end1-*
>1b7b	00					.byte	$00
>1b7c	d1 15					.word	WordWrite
>1b7e	a1					.byte	$a1
.1b7f					_end1:
>1b7f	10					.byte	_end2-*
>1b80	52					.byte	$52
>1b81	57 1a					.word	VarWriteHandler
>1b83	6e 1a					.word	VarWriteHandlerDecode
>1b85	24 24 21 48 41 4e 44 4c			.byte	$24,$24,$21,$48,$41,$4e,$44,$4c,$45,$d2
>1b8d	45 d2
.1b8f					_end2:
>1b8f	10					.byte	_end3-*
>1b90	52					.byte	$52
>1b91	21 1a					.word	VarAddressHandler
>1b93	36 1a					.word	VarAddrHandlerDecode
>1b95	24 24 26 48 41 4e 44 4c			.byte	$24,$24,$26,$48,$41,$4e,$44,$4c,$45,$d2
>1b9d	45 d2
.1b9f					_end3:
>1b9f	10					.byte	_end4-*
>1ba0	52					.byte	$52
>1ba1	3b 1a					.word	VarReadHandler
>1ba3	52 1a					.word	VarReadHandlerDecode
>1ba5	24 24 40 48 41 4e 44 4c			.byte	$24,$24,$40,$48,$41,$4e,$44,$4c,$45,$d2
>1bad	45 d2
.1baf					_end4:
>1baf	0c					.byte	_end5-*
>1bb0	52					.byte	$52
>1bb1	c3 16					.word	CallHandler
>1bb3	7f 17					.word	CallHandlerDecode
>1bb5	24 24 43 41 4c cc			.byte	$24,$24,$43,$41,$4c,$cc
.1bbb					_end5:
>1bbb	0f					.byte	_end6-*
>1bbc	53					.byte	$53
>1bbd	53 19					.word	SkipComment
>1bbf	5e 19					.word	CommentDecoder
>1bc1	24 24 43 4f 4d 4d 45 4e			.byte	$24,$24,$43,$4f,$4d,$4d,$45,$4e,$d4
>1bc9	d4
.1bca					_end6:
>1bca	0e					.byte	_end7-*
>1bcb	53					.byte	$53
>1bcc	76 19					.word	DefineCode
>1bce	85 19					.word	DefineDecoder
>1bd0	24 24 44 45 46 49 4e c5			.byte	$24,$24,$44,$45,$46,$49,$4e,$c5
.1bd8					_end7:
>1bd8	0f					.byte	_end8-*
>1bd9	52					.byte	$52
>1bda	24 10					.word	Literal2Byte
>1bdc	3a 10					.word	Literal2ByteDecode
>1bde	24 24 4c 49 54 45 52 41			.byte	$24,$24,$4c,$49,$54,$45,$52,$41,$cc
>1be6	cc
.1be7					_end8:
>1be7	0e					.byte	_end9-*
>1be8	80					.byte	$80
>1be9	3c 19					.word	NextLine
>1beb	24 24 4e 45 58 54 4c 49			.byte	$24,$24,$4e,$45,$58,$54,$4c,$49,$4e,$c5
>1bf3	4e c5
.1bf5					_end9:
>1bf5	0e					.byte	_end10-*
>1bf6	53					.byte	$53
>1bf7	4c 10					.word	LiteralString
>1bf9	69 10					.word	LiteralStringDecoder
>1bfb	24 24 53 54 52 49 4e c7			.byte	$24,$24,$53,$54,$52,$49,$4e,$c7
.1c03					_end10:
>1c03	05					.byte	_end11-*
>1c04	00					.byte	$00
>1c05	4d 13					.word	Multiply16x16
>1c07	aa					.byte	$aa
.1c08					_end11:
>1c08	05					.byte	_end12-*
>1c09	00					.byte	$00
>1c0a	ba 11					.word	Add
>1c0c	ab					.byte	$ab
.1c0d					_end12:
>1c0d	06					.byte	_end13-*
>1c0e	00					.byte	$00
>1c0f	e2 15					.word	WordAdd
>1c11	2b a1					.byte	$2b,$a1
.1c13					_end13:
>1c13	05					.byte	_end14-*
>1c14	00					.byte	$00
>1c15	c9 11					.word	Subtract
>1c17	ad					.byte	$ad
.1c18					_end14:
>1c18	06					.byte	_end15-*
>1c19	00					.byte	$00
>1c1a	89 14					.word	ConstantMinus1
>1c1c	2d b1					.byte	$2d,$b1
.1c1e					_end15:
>1c1e	05					.byte	_end16-*
>1c1f	00					.byte	$00
>1c20	9e 12					.word	Divide16x16
>1c22	af					.byte	$af
.1c23					_end16:
>1c23	05					.byte	_end17-*
>1c24	00					.byte	$00
>1c25	7c 14					.word	Constant0
>1c27	b0					.byte	$b0
.1c28					_end17:
>1c28	06					.byte	_end18-*
>1c29	00					.byte	$00
>1c2a	e2 13					.word	CheckMinus
>1c2c	30 bc					.byte	$30,$bc
.1c2e					_end18:
>1c2e	06					.byte	_end19-*
>1c2f	00					.byte	$00
>1c30	f6 13					.word	CheckZero
>1c32	30 bd					.byte	$30,$bd
.1c34					_end19:
>1c34	05					.byte	_end20-*
>1c35	00					.byte	$00
>1c36	98 14					.word	C1
>1c38	b1					.byte	$b1
.1c39					_end20:
>1c39	06					.byte	_end21-*
>1c3a	00					.byte	$00
>1c3b	8c 13					.word	Unary1Plus
>1c3d	31 ab					.byte	$31,$ab
.1c3f					_end21:
>1c3f	06					.byte	_end22-*
>1c40	00					.byte	$00
>1c41	a3 13					.word	Unary1Minus
>1c43	31 ad					.byte	$31,$ad
.1c45					_end22:
>1c45	06					.byte	_end23-*
>1c46	00					.byte	$00
>1c47	b0 14					.word	C10
>1c49	31 b0					.byte	$31,$b0
.1c4b					_end23:
>1c4b	07					.byte	_end24-*
>1c4c	00					.byte	$00
>1c4d	d9 14					.word	C100
>1c4f	31 30 b0				.byte	$31,$30,$b0
.1c52					_end24:
>1c52	08					.byte	_end25-*
>1c53	00					.byte	$00
>1c54	08 15					.word	C1024
>1c56	31 30 32 b4				.byte	$31,$30,$32,$b4
.1c5a					_end25:
>1c5a	07					.byte	_end26-*
>1c5b	00					.byte	$00
>1c5c	dd 14					.word	C127
>1c5e	31 32 b7				.byte	$31,$32,$b7
.1c61					_end26:
>1c61	07					.byte	_end27-*
>1c62	00					.byte	$00
>1c63	e1 14					.word	C128
>1c65	31 32 b8				.byte	$31,$32,$b8
.1c68					_end27:
>1c68	06					.byte	_end28-*
>1c69	00					.byte	$00
>1c6a	b4 14					.word	C15
>1c6c	31 b5					.byte	$31,$b5
.1c6e					_end28:
>1c6e	06					.byte	_end29-*
>1c6f	00					.byte	$00
>1c70	b8 14					.word	C16
>1c72	31 b6					.byte	$31,$b6
.1c74					_end29:
>1c74	07					.byte	_end30-*
>1c75	00					.byte	$00
>1c76	1a 14					.word	Times16
>1c78	31 36 aa				.byte	$31,$36,$aa
.1c7b					_end30:
>1c7b	07					.byte	_end31-*
>1c7c	00					.byte	$00
>1c7d	2d 14					.word	Divide16
>1c7f	31 36 af				.byte	$31,$36,$af
.1c82					_end31:
>1c82	05					.byte	_end32-*
>1c83	00					.byte	$00
>1c84	9c 14					.word	C2
>1c86	b2					.byte	$b2
.1c87					_end32:
>1c87	06					.byte	_end33-*
>1c88	00					.byte	$00
>1c89	26 14					.word	Times2
>1c8b	32 aa					.byte	$32,$aa
.1c8d					_end33:
>1c8d	06					.byte	_end34-*
>1c8e	00					.byte	$00
>1c8f	95 13					.word	Unary2Plus
>1c91	32 ab					.byte	$32,$ab
.1c93					_end34:
>1c93	06					.byte	_end35-*
>1c94	00					.byte	$00
>1c95	ae 13					.word	Unary2Minus
>1c97	32 ad					.byte	$32,$ad
.1c99					_end35:
>1c99	06					.byte	_end36-*
>1c9a	00					.byte	$00
>1c9b	39 14					.word	Divide2
>1c9d	32 af					.byte	$32,$af
.1c9f					_end36:
>1c9f	06					.byte	_end37-*
>1ca0	00					.byte	$00
>1ca1	bc 14					.word	C24
>1ca3	32 b4					.byte	$32,$b4
.1ca5					_end37:
>1ca5	07					.byte	_end38-*
>1ca6	00					.byte	$00
>1ca7	e5 14					.word	C255
>1ca9	32 35 b5				.byte	$32,$35,$b5
.1cac					_end38:
>1cac	07					.byte	_end39-*
>1cad	00					.byte	$00
>1cae	f0 14					.word	C256
>1cb0	32 35 b6				.byte	$32,$35,$b6
.1cb3					_end39:
>1cb3	08					.byte	_end40-*
>1cb4	00					.byte	$00
>1cb5	40 14					.word	Times256
>1cb7	32 35 36 aa				.byte	$32,$35,$36,$aa
.1cbb					_end40:
>1cbb	08					.byte	_end41-*
>1cbc	00					.byte	$00
>1cbd	49 14					.word	Divide256
>1cbf	32 35 36 af				.byte	$32,$35,$36,$af
.1cc3					_end41:
>1cc3	05					.byte	_end42-*
>1cc4	00					.byte	$00
>1cc5	a0 14					.word	C3
>1cc7	b3					.byte	$b3
.1cc8					_end42:
>1cc8	06					.byte	_end43-*
>1cc9	00					.byte	$00
>1cca	cd 14					.word	C32
>1ccc	33 b2					.byte	$33,$b2
.1cce					_end43:
>1cce	09					.byte	_end44-*
>1ccf	00					.byte	$00
>1cd0	20 15					.word	C32767
>1cd2	33 32 37 36 b7				.byte	$33,$32,$37,$36,$b7
.1cd7					_end44:
>1cd7	09					.byte	_end45-*
>1cd8	00					.byte	$00
>1cd9	2c 15					.word	C32768
>1cdb	33 32 37 36 b8				.byte	$33,$32,$37,$36,$b8
.1ce0					_end45:
>1ce0	05					.byte	_end46-*
>1ce1	00					.byte	$00
>1ce2	a4 14					.word	C4
>1ce4	b4					.byte	$b4
.1ce5					_end46:
>1ce5	06					.byte	_end47-*
>1ce6	00					.byte	$00
>1ce7	22 14					.word	Times4
>1ce9	34 aa					.byte	$34,$aa
.1ceb					_end47:
>1ceb	06					.byte	_end48-*
>1cec	00					.byte	$00
>1ced	35 14					.word	Divide4
>1cef	34 af					.byte	$34,$af
.1cf1					_end48:
>1cf1	08					.byte	_end49-*
>1cf2	00					.byte	$00
>1cf3	14 15					.word	C4096
>1cf5	34 30 39 b6				.byte	$34,$30,$39,$b6
.1cf9					_end49:
>1cf9	05					.byte	_end50-*
>1cfa	00					.byte	$00
>1cfb	a8 14					.word	C5
>1cfd	b5					.byte	$b5
.1cfe					_end50:
>1cfe	07					.byte	_end51-*
>1cff	00					.byte	$00
>1d00	fc 14					.word	C512
>1d02	35 31 b2				.byte	$35,$31,$b2
.1d05					_end51:
>1d05	06					.byte	_end52-*
>1d06	00					.byte	$00
>1d07	d1 14					.word	C63
>1d09	36 b3					.byte	$36,$b3
.1d0b					_end52:
>1d0b	06					.byte	_end53-*
>1d0c	00					.byte	$00
>1d0d	d5 14					.word	C64
>1d0f	36 b4					.byte	$36,$b4
.1d11					_end53:
>1d11	05					.byte	_end54-*
>1d12	00					.byte	$00
>1d13	ac 14					.word	C8
>1d15	b8					.byte	$b8
.1d16					_end54:
>1d16	06					.byte	_end55-*
>1d17	00					.byte	$00
>1d18	1e 14					.word	Times8
>1d1a	38 aa					.byte	$38,$aa
.1d1c					_end55:
>1d1c	06					.byte	_end56-*
>1d1d	00					.byte	$00
>1d1e	31 14					.word	Divide8
>1d20	38 af					.byte	$38,$af
.1d22					_end56:
>1d22	05					.byte	_end57-*
>1d23	40					.byte	$40
>1d24	48 17					.word	ReturnHandler
>1d26	bb					.byte	$bb
.1d27					_end57:
>1d27	05					.byte	_end58-*
>1d28	00					.byte	$00
>1d29	3a 12					.word	CheckLess
>1d2b	bc					.byte	$bc
.1d2c					_end58:
>1d2c	06					.byte	_end59-*
>1d2d	00					.byte	$00
>1d2e	53 12					.word	CheckLessEq
>1d30	3c bd					.byte	$3c,$bd
.1d32					_end59:
>1d32	06					.byte	_end60-*
>1d33	00					.byte	$00
>1d34	03 12					.word	CheckNotEqual
>1d36	3c be					.byte	$3c,$be
.1d38					_end60:
>1d38	05					.byte	_end61-*
>1d39	00					.byte	$00
>1d3a	06 12					.word	CheckEqual
>1d3c	bd					.byte	$bd
.1d3d					_end61:
>1d3d	05					.byte	_end62-*
>1d3e	00					.byte	$00
>1d3f	56 12					.word	CheckGreater
>1d41	be					.byte	$be
.1d42					_end62:
>1d42	06					.byte	_end63-*
>1d43	00					.byte	$00
>1d44	37 12					.word	CheckGreaterEq
>1d46	3e bd					.byte	$3e,$bd
.1d48					_end63:
>1d48	08					.byte	_end64-*
>1d49	00					.byte	$00
>1d4a	41 15					.word	TestDup
>1d4c	3f 44 55 d0				.byte	$3f,$44,$55,$d0
.1d50					_end64:
>1d50	05					.byte	_end65-*
>1d51	00					.byte	$00
>1d52	b6 15					.word	WordRead
>1d54	c0					.byte	$c0
.1d55					_end65:
>1d55	07					.byte	_end66-*
>1d56	00					.byte	$00
>1d57	bc 13					.word	Absolute
>1d59	41 42 d3				.byte	$41,$42,$d3
.1d5c					_end66:
>1d5c	09					.byte	_end67-*
>1d5d	00					.byte	$00
>1d5e	f9 15					.word	AllocateMemory
>1d60	41 4c 4c 4f c3				.byte	$41,$4c,$4c,$4f,$c3
.1d65					_end67:
>1d65	07					.byte	_end68-*
>1d66	00					.byte	$00
>1d67	dc 11					.word	And
>1d69	41 4e c4				.byte	$41,$4e,$c4
.1d6c					_end68:
>1d6c	0a					.byte	_end69-*
>1d6d	00					.byte	$00
>1d6e	68 18					.word	AssertCode
>1d70	41 53 53 45 52 d4			.byte	$41,$53,$53,$45,$52,$d4
.1d76					_end69:
>1d76	09					.byte	_end70-*
>1d77	00					.byte	$00
>1d78	0f 14					.word	ByteSwap
>1d7a	42 53 57 41 d0				.byte	$42,$53,$57,$41,$d0
.1d7f					_end70:
>1d7f	06					.byte	_end71-*
>1d80	00					.byte	$00
>1d81	c4 15					.word	ByteWrite
>1d83	43 a1					.byte	$43,$a1
.1d85					_end71:
>1d85	06					.byte	_end72-*
>1d86	00					.byte	$00
>1d87	ad 15					.word	ByteRead
>1d89	43 c0					.byte	$43,$c0
.1d8b					_end72:
>1d8b	07					.byte	_end73-*
>1d8c	00					.byte	$00
>1d8d	09 18					.word	ClrHandler
>1d8f	43 4c d2				.byte	$43,$4c,$d2
.1d92					_end73:
>1d92	08					.byte	_end74-*
>1d93	00					.byte	$00
>1d94	38 15					.word	Drop
>1d96	44 52 4f d0				.byte	$44,$52,$4f,$d0
.1d9a					_end74:
>1d9a	07					.byte	_end75-*
>1d9b	00					.byte	$00
>1d9c	4a 15					.word	Dup
>1d9e	44 55 d0				.byte	$44,$55,$d0
.1da1					_end75:
>1da1	08					.byte	_end76-*
>1da2	01					.byte	$01
>1da3	97 16					.word	ElseHandler
>1da5	45 4c 53 c5				.byte	$45,$4c,$53,$c5
.1da9					_end76:
>1da9	07					.byte	_end77-*
>1daa	00					.byte	$00
>1dab	89 18					.word	EndProgram
>1dad	45 4e c4				.byte	$45,$4e,$c4
.1db0					_end77:
>1db0	09					.byte	_end78-*
>1db1	00					.byte	$00
>1db2	9a 16					.word	EndIfHandler
>1db4	45 4e 44 49 c6				.byte	$45,$4e,$44,$49,$c6
.1db9					_end78:
>1db9	07					.byte	_end79-*
>1dba	00					.byte	$00
>1dbb	0f 16					.word	ForHandler
>1dbd	46 4f d2				.byte	$46,$4f,$d2
.1dc0					_end79:
>1dc0	06					.byte	_end80-*
>1dc1	01					.byte	$01
>1dc2	94 16					.word	IfHandler
>1dc4	49 c6					.byte	$49,$c6
.1dc6					_end80:
>1dc6	09					.byte	_end81-*
>1dc7	00					.byte	$00
>1dc8	73 16					.word	GetIndex
>1dca	49 4e 44 45 d8				.byte	$49,$4e,$44,$45,$d8
.1dcf					_end81:
>1dcf	08					.byte	_end82-*
>1dd0	00					.byte	$00
>1dd1	7a 10					.word	listcode
>1dd3	4c 49 53 d4				.byte	$4c,$49,$53,$d4
.1dd7					_end82:
>1dd7	07					.byte	_end83-*
>1dd8	00					.byte	$00
>1dd9	73 12					.word	Maximum
>1ddb	4d 41 d8				.byte	$4d,$41,$d8
.1dde					_end83:
>1dde	07					.byte	_end84-*
>1ddf	00					.byte	$00
>1de0	6f 12					.word	Minimum
>1de2	4d 49 ce				.byte	$4d,$49,$ce
.1de5					_end84:
>1de5	07					.byte	_end85-*
>1de6	00					.byte	$00
>1de7	af 12					.word	Modulus16x16
>1de9	4d 4f c4				.byte	$4d,$4f,$c4
.1dec					_end85:
>1dec	0a					.byte	_end86-*
>1ded	00					.byte	$00
>1dee	c3 13					.word	Negate
>1df0	4e 45 47 41 54 c5			.byte	$4e,$45,$47,$41,$54,$c5
.1df6					_end86:
>1df6	07					.byte	_end87-*
>1df7	00					.byte	$00
>1df8	00 18					.word	NewHandler
>1dfa	4e 45 d7				.byte	$4e,$45,$d7
.1dfd					_end87:
>1dfd	08					.byte	_end88-*
>1dfe	01					.byte	$01
>1dff	3d 16					.word	NextHandler
>1e01	4e 45 58 d4				.byte	$4e,$45,$58,$d4
.1e05					_end88:
>1e05	07					.byte	_end89-*
>1e06	00					.byte	$00
>1e07	7e 15					.word	Nip
>1e09	4e 49 d0				.byte	$4e,$49,$d0
.1e0c					_end89:
>1e0c	07					.byte	_end90-*
>1e0d	00					.byte	$00
>1e0e	d3 13					.word	OneComplement
>1e10	4e 4f d4				.byte	$4e,$4f,$d4
.1e13					_end90:
>1e13	06					.byte	_end91-*
>1e14	00					.byte	$00
>1e15	f6 11					.word	LogOr
>1e17	4f d2					.byte	$4f,$d2
.1e19					_end91:
>1e19	08					.byte	_end92-*
>1e1a	00					.byte	$00
>1e1b	66 15					.word	Over
>1e1d	4f 56 45 d2				.byte	$4f,$56,$45,$d2
.1e21					_end92:
>1e21	0a					.byte	_end93-*
>1e22	00					.byte	$00
>1e23	9d 16					.word	RepeatHandler
>1e25	52 45 50 45 41 d4			.byte	$52,$45,$50,$45,$41,$d4
.1e2b					_end93:
>1e2b	07					.byte	_end94-*
>1e2c	00					.byte	$00
>1e2d	52 14					.word	RandomNumber
>1e2f	52 4e c4				.byte	$52,$4e,$c4
.1e32					_end94:
>1e32	07					.byte	_end95-*
>1e33	00					.byte	$00
>1e34	83 15					.word	Rot
>1e36	52 4f d4				.byte	$52,$4f,$d4
.1e39					_end95:
>1e39	07					.byte	_end96-*
>1e3a	00					.byte	$00
>1e3b	fe 13					.word	SignTOS
>1e3d	53 47 ce				.byte	$53,$47,$ce
.1e40					_end96:
>1e40	08					.byte	_end97-*
>1e41	00					.byte	$00
>1e42	81 18					.word	StopCode
>1e44	53 54 4f d0				.byte	$53,$54,$4f,$d0
.1e48					_end97:
>1e48	08					.byte	_end98-*
>1e49	00					.byte	$00
>1e4a	53 15					.word	Swap
>1e4c	53 57 41 d0				.byte	$53,$57,$41,$d0
.1e50					_end98:
>1e50	07					.byte	_end99-*
>1e51	00					.byte	$00
>1e52	51 18					.word	Call6502
>1e54	53 59 d3				.byte	$53,$59,$d3
.1e57					_end99:
>1e57	0e					.byte	_end100-*
>1e58	00					.byte	$00
>1e59	8c 18					.word	NumToInt
>1e5b	54 4f 2e 49 4e 54 45 47			.byte	$54,$4f,$2e,$49,$4e,$54,$45,$47,$45,$d2
>1e63	45 d2
.1e65					_end100:
>1e65	0d					.byte	_end101-*
>1e66	00					.byte	$00
>1e67	98 19					.word	IntToString
>1e69	54 4f 2e 53 54 52 49 4e			.byte	$54,$4f,$2e,$53,$54,$52,$49,$4e,$c7
>1e71	c7
.1e72					_end101:
>1e72	09					.byte	_end102-*
>1e73	01					.byte	$01
>1e74	a0 16					.word	UntilHandler
>1e76	55 4e 54 49 cc				.byte	$55,$4e,$54,$49,$cc
.1e7b					_end102:
>1e7b	0a					.byte	_end103-*
>1e7c	40					.byte	$40
>1e7d	4d 18					.word	BreakCmd
>1e7f	58 42 52 45 41 cb			.byte	$58,$42,$52,$45,$41,$cb
.1e85					_end103:
>1e85	09					.byte	_end104-*
>1e86	00					.byte	$00
>1e87	47 18					.word	ExitDump
>1e89	58 44 55 4d d0				.byte	$58,$44,$55,$4d,$d0
.1e8e					_end104:
>1e8e	07					.byte	_end105-*
>1e8f	00					.byte	$00
>1e90	e9 11					.word	Xor
>1e92	58 4f d2				.byte	$58,$4f,$d2
.1e95					_end105:
>1e95	00					.byte	0

;******  Return to file: kernel.asm

>3fff	ff						.byte 	$FF
.4000					ProgramMemory:

;******  End of listing
