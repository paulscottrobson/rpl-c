
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -q -c -o kernel_nocode.prg -L kernel.lst -l kernel.lbl kernel.asm
; Fri Jan 10 08:14:51 2020

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: kernel.asm

=$1000					RplBuild = $1000 							; code starts here.

;******  Processing file: data.asm

.0000					Next:
>0000							.fill 	5
=3					IP = Next+3 								; the IP which points to the current instruction
.0005					rsp:
>0005							.byte 	?
.0006					tos:
>0006							.word 	?
.0008					srcPtr:
>0008							.word 	?
.000a					bufPtr:
>000a							.word 	?
.000c					matchPtr:
>000c							.word 	?
.000e					nextFreeMem:
>000e							.word 	?
.0010					freeMemory:
>0010							.word 	?
.0012					temp1:
>0012							.word 	?
.0014					temp2:
>0014							.word 	?
.0016					temp3:
>0016							.word 	?
.0018					temp4:
>0018							.word 	?
.001a					SignCount:
>001a							.byte 	?
.001b					RandomSeed:
>001b							.byte 	?
=$102					stack2Low = $102							; access other stack members following tsx
=$101					stack2High = $101							; (which requires saving X, not on the stack !)
=$104					stack3Low = $104
=$103					stack3High = $103
=$600					azVariables = $600 							; 26 x 2 variables occupying 52 bytes * PAGE BOUNDARY *
=16					hashTableSize = 16 							; hash tables for variables.
=$640					hashTable = $640 							; hash tables start here * ALL ON ONE PAGE *
=$810					textBuffer = $810 							; buffer for text.
=$700					returnStack = $700							; return stack (1 page)
=$700					returnStackLow = returnStack
=1856					returnStackHigh = returnStack+$40
=1920					returnStackX = returnStack+$80

;******  Return to file: kernel.asm

.1000	a2 ff		ldx #$ff			ldx 		#$FF 					; reset the stack
.1002	9a		txs				txs
.1003	a2 00		ldx #$00			ldx			#ProgramMemory & $FF	; boot address
.1005	a0 40		ldy #$40			ldy 		#ProgramMemory >>8
.1007	20 10 10	jsr $1010			jsr 		InitialiseCoreCode 		; initialise the NEXT routine at $00
.100a	20 8b 17	jsr $178b			jsr 		ClearVariableSpace 		; clear variables etc.
.100d	4c 00 00	jmp $0000			jmp 		Next

;******  Processing file: core.src

.1010					InitialiseCoreCode:
.1010	a9 e8		lda #$e8			lda 	#$E8 					; Copy INX INX 			4 cycles when run
.1012	85 00		sta $00				sta 	Next
.1014	85 01		sta $01				sta 	Next+1
.1016	a9 7c		lda #$7c			lda 	#$7C 					; Copy JMP ($aaaa,x) 	6 cycles when run
.1018	85 02		sta $02				sta 	Next+2
.101a	86 03		stx $03				stx 	Next+3 					; set the indirect address (IP)
.101c	84 04		sty $04				sty 	Next+4
.101e	a2 01		ldx #$01			ldx 	#1 						; set up to run from provided word.
.1020	60		rts				rts								; (2 INX skip offset and line#)
.1021					Literal2Byte:
.1021	a5 06		lda $06				lda 	TOS
.1023	48		pha				pha
.1024	a5 07		lda $07				lda 	TOS+1
.1026	48		pha				pha
.1027	e8		inx				inx  							; point X to the word
.1028	e8		inx				inx
.1029	8a		txa				txa 							; copy into Y
.102a	a8		tay				tay
.102b	b1 03		lda ($03),y			lda 	(IP),y 					; read it. the LSB
.102d	85 06		sta $06				sta 	TOS
.102f	c8		iny				iny 							; read and push the MSB
.1030	b1 03		lda ($03),y			lda 	(IP),y
.1032	85 07		sta $07				sta 	TOS+1
.1034	4c 00 00	jmp $0000			jmp 	Next
.1037					Literal2ByteDecode:
.1037	a9 20		lda #$20			lda 	#32
.1039	20 78 11	jsr $1178			jsr 	DecodeWriteBuffer
.103c	b1 08		lda ($08),y			lda 	(srcPtr),y
.103e	aa		tax				tax
.103f	c8		iny				iny
.1040	b1 08		lda ($08),y			lda 	(srcPtr),y
.1042	a8		tay				tay
.1043	8a		txa				txa
.1044	38		sec				sec 							; output signed
.1045	20 9a 11	jsr $119a			jsr 	DecodeYAToBuffer
.1048	60		rts				rts
.1049					LiteralString:
.1049	a5 06		lda $06				lda 	TOS
.104b	48		pha				pha
.104c	a5 07		lda $07				lda 	TOS+1
.104e	48		pha				pha
.104f	e8		inx				inx
.1050	e8		inx				inx 							; skip over current word
.1051	8a		txa				txa 							; add to IP + 1 to give string address
.1052	a8		tay				tay 							; put in Y
.1053	38		sec				sec 							; make that TOS
.1054	65 03		adc $03				adc 	IP
.1056	85 06		sta $06				sta 	TOS
.1058	a5 04		lda $04				lda 	IP+1
.105a	69 00		adc #$00			adc 	#0
.105c	85 07		sta $07				sta 	TOS+1
.105e	8a		txa				txa 							; add data length to X
.105f	18		clc				clc
.1060	71 03		adc ($03),y			adc 	(IP),y
.1062	aa		tax				tax
.1063	4c 02 00	jmp $0002			jmp 	Next+2 					; jump without pre-increment
.1066					LiteralStringDecoder:
.1066	a9 20		lda #$20			lda 	#32
.1068	20 78 11	jsr $1178			jsr 	DecodeWriteBuffer
.106b	a9 22		lda #$22			lda 	#'"'
.106d	20 78 11	jsr $1178			jsr 	DecodeWriteBuffer
.1070	20 81 11	jsr $1181			jsr 	DecodeOutputData
.1073	20 78 11	jsr $1178			jsr 	DecodeWriteBuffer
.1076	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: decode/list.src

.1077					listcode:
.1077	a9 10		lda #$10			lda 	#(textBuffer) & $FF
.1079	85 0a		sta $0a				sta 	0+(bufPtr)
.107b	a9 08		lda #$08			lda 	#(textBuffer) >> 8
.107d	85 0b		sta $0b				sta 	1+(bufPtr)
.107f	a9 00		lda #$00			lda 	#$00
.1081	a0 40		ldy #$40			ldy 	#$40
.1083	38		sec				sec
.1084	20 8a 10	jsr $108a			jsr 	DecodeLineIntoBufPtr
>1087	ff				h1:		.byte 	$FF
.1088	80 fd		bra $1087			bra 	h1
.108a					DecodeLineIntoBufPtr:
.108a	48		pha				pha
.108b	da		phx				phx
.108c	5a		phy				phy
.108d	85 08		sta $08				sta 	srcPtr 						; save the source line.
.108f	84 09		sty $09				sty 	srcPtr+1
.1091	90 1b		bcc $10ae			bcc 	_DecodeNoLineNumber
.1093	a0 01		ldy #$01			ldy 	#1 							; get line # to YA
.1095	b1 08		lda ($08),y			lda 	(srcPtr),y
.1097	aa		tax				tax
.1098	c8		iny				iny
.1099	b1 08		lda ($08),y			lda 	(srcPtr),y
.109b	a8		tay				tay
.109c	8a		txa				txa
.109d	18		clc				clc
.109e	20 9a 11	jsr $119a			jsr 	DecodeYAToBuffer 			; convert to string in buffer
.10a1	aa		tax				tax 								; count in X
.10a2					_DecodeLineSpace:
.10a2	e0 05		cpx #$05			cpx 	#5
.10a4	f0 08		beq $10ae			beq 	_DecodeNoLineNumber
.10a6	a9 20		lda #$20			lda 	#" " 						; pad to 5 spaces
.10a8	20 78 11	jsr $1178			jsr 	DecodeWriteBuffer
.10ab	e8		inx				inx
.10ac	80 f4		bra $10a2			bra 	_DecodeLineSpace
.10ae					_DecodeNoLineNumber:
.10ae	a0 03		ldy #$03			ldy 	#3 							; initial position.
.10b0					_DecodeLoop:
.10b0	b1 08		lda ($08),y			lda 	(srcPtr),y 					; copy the current character to temp1
.10b2	85 12		sta $12				sta 	temp1 						; must be an execution address.
.10b4	c8		iny				iny
.10b5	b1 08		lda ($08),y			lda 	(srcPtr),y
.10b7	85 13		sta $13				sta 	temp1+1
.10b9	c8		iny				iny 								; y points to the byte after it.
.10ba	a5 12		lda $12				lda 	temp1
.10bc	c9 b8		cmp #$b8			cmp 	#NextLine & $FF
.10be	d0 06		bne $10c6			bne 	_DecodeNotEOL
.10c0	a5 13		lda $13				lda 	temp1+1
.10c2	c9 18		cmp #$18			cmp 	#NextLine >> 8
.10c4	f0 0b		beq $10d1			beq 	_DecodeEOL
.10c6					_DecodeNotEOL:
.10c6	20 d9 10	jsr $10d9			jsr 	IdentifyCodeWord
.10c9	20 23 11	jsr $1123			jsr 	DecodeFoundWord
.10cc	20 0d 11	jsr $110d			jsr 	AdvanceToNext 				; advance to next entry in the line.
.10cf	80 df		bra $10b0			bra 	_DecodeLoop 				; and go round again
.10d1					_DecodeEOL:
.10d1	a9 00		lda #$00			lda 	#0
.10d3	92 0a		sta ($0a)			sta 	(bufPtr)
.10d5	7a		ply				ply 								; restore registers and exit
.10d6	fa		plx				plx
.10d7	68		pla				pla
.10d8	60		rts				rts
.10d9					IdentifyCodeWord:
.10d9	5a		phy				phy 								; save current position on the stack.
.10da	a9 f7		lda #$f7			lda 	#(Dictionary) & $FF
.10dc	85 0c		sta $0c				sta 	0+(matchPtr)
.10de	a9 1a		lda #$1a			lda 	#(Dictionary) >> 8
.10e0	85 0d		sta $0d				sta 	1+(matchPtr)
.10e2					_DecodeIdentify:
.10e2	a0 02		ldy #$02			ldy 	#2 							; have we found a match ?
.10e4	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.10e6	c5 12		cmp $12				cmp 	temp1
.10e8	d0 07		bne $10f1			bne 	_DecodeIdNext
.10ea	c8		iny				iny
.10eb	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.10ed	c5 13		cmp $13				cmp 	temp1+1
.10ef	f0 1a		beq $110b			beq 	_DecodeIdFound
.10f1					_DecodeIdNext:
.10f1	18		clc				clc
.10f2	b2 0c		lda ($0c)			lda 	(matchPtr)
.10f4	f0 0a		beq $1100			beq 	_DecodeIdIssue
.10f6	65 0c		adc $0c				adc 	matchPtr
.10f8	85 0c		sta $0c				sta 	matchPtr
.10fa	90 e6		bcc $10e2			bcc 	_DecodeIdentify
.10fc	e6 0d		inc $0d				inc 	matchPtr+1
.10fe	80 e2		bra $10e2			bra 	_DecodeIdentify
.1100					_DecodeIdIssue:
.1100	20 f4 1a	jsr $1af4			jsr 	ErrorHandler
>1103	44 45 43 4f 44 45 3f 00				.text 	"DECODE?",0
.110b					_DecodeIdFound:
.110b	7a		ply				ply 								; restore position.
.110c	60		rts				rts
.110d					AdvanceToNext:
.110d	5a		phy				phy 								; get the parameter count from bits 0-1 of the type byte
.110e	a0 01		ldy #$01			ldy 	#1
.1110	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.1112	29 03		and #$03			and 	#3 							; bits 0-1.
.1114	7a		ply				ply
.1115	c9 03		cmp #$03			cmp 	#3 							; is it n-bytes e.g. specified by the next byte
.1117	d0 02		bne $111b			bne 	_ATN012
.1119	b1 08		lda ($08),y			lda 	(srcPtr),y 					; if so, use that byte as the overall length.
.111b					_ATN012:
.111b	85 14		sta $14				sta 	temp2 						; now add that to Y
.111d	98		tya				tya
.111e	18		clc				clc
.111f	65 14		adc $14				adc 	temp2
.1121	a8		tay				tay
.1122	60		rts				rts
.1123					DecodeFoundWord:
.1123	5a		phy				phy 								; save current position
.1124	84 14		sty $14				sty		temp2 						; put it in temp2 as well.
.1126	a0 01		ldy #$01			ldy 	#1 							; get the type byte
.1128	b1 0c		lda ($0c),y			lda 	(matchPtr),y 				; is there a special decoder check (bit 4 set) ?
.112a	29 10		and #$10			and 	#$10
.112c	d0 0e		bne $113c			bne 	_DFWSpecialDecoder
.112e	b1 0c		lda ($0c),y			lda 	(matchPtr),y 				; reget it.
.1130	30 08		bmi $113a			bmi 	_DFWExit 					; if hidden word (bit 7 set)
.1132	a9 20		lda #$20			lda 	#" "						; output a space to the buffer
.1134	20 78 11	jsr $1178			jsr 	DecodeWriteBuffer
.1137	20 55 11	jsr $1155			jsr 	DecodeCurrentWord 			; expand that.
.113a					_DFWExit:
.113a	7a		ply				ply 								; restore current position
.113b	60		rts				rts
.113c					_DFWSpecialDecoder:
.113c	a0 04		ldy #$04			ldy 	#4 							; the decode word address is at offset 4,5
.113e	b1 0c		lda ($0c),y			lda 	(matchPtr),y 				; copy this into temp2
.1140	85 14		sta $14				sta 	temp2
.1142	c8		iny				iny
.1143	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.1145	85 15		sta $15				sta 	temp2+1
.1147	7a		ply				ply 	 							; restore current position into Y
.1148	48		pha				pha 								; save registers
.1149	da		phx				phx
.114a	5a		phy				phy
.114b	20 52 11	jsr $1152			jsr 	_DFWCallDecoder				; call the decoder routine
.114e	7a		ply				ply 								; restore registers and exit
.114f	fa		plx				plx
.1150	68		pla				pla
.1151	60		rts				rts
.1152					_DFWCallDecoder:
.1152	6c 14 00	jmp ($0014)			jmp 	(temp2)
.1155					DecodeCurrentWord:
.1155	5a		phy				phy
.1156	a0 01		ldy #$01			ldy 	#1 							; read type byte
.1158	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.115a	a0 04		ldy #$04			ldy 	#4 							; original offset
.115c	4a		lsr a				lsr 	a 							; encoder/decoder bits in 0-1
.115d	4a		lsr a				lsr 	a 							; add 2 to Y for each encoder/decoder
.115e	4a		lsr a				lsr 	a 							; bit set.
.115f	4a		lsr a				lsr 	a
.1160	4a		lsr a				lsr 	a 							; decoder bit
.1161	90 02		bcc $1165			bcc 	_DWBNoDec
.1163	c8		iny				iny
.1164	c8		iny				iny
.1165					_DWBNoDec:
.1165	4a		lsr a				lsr 	a
.1166	90 02		bcc $116a			bcc 	_DWBNoEnc
.1168	c8		iny				iny
.1169	c8		iny				iny
.116a					_DWBNoEnc:
.116a					_DWBWordOut:
.116a	b1 0c		lda ($0c),y			lda 	(matchPtr),y 				; output until bit 7 set.
.116c	48		pha				pha
.116d	29 7f		and #$7f			and 	#$7F
.116f	20 78 11	jsr $1178			jsr		DecodeWriteBuffer
.1172	c8		iny				iny
.1173	68		pla				pla
.1174	10 f4		bpl $116a			bpl 	_DWBWordOut
.1176	7a		ply				ply 								; restore Y and exit
.1177	60		rts				rts
.1178					DecodeWriteBuffer:
.1178	92 0a		sta ($0a)			sta 	(bufPtr)
.117a	e6 0a		inc $0a				inc 	bufPtr
.117c	d0 02		bne $1180			bne 	_DWBNoCarry
.117e	e6 0b		inc $0b				inc 	bufPtr+1
.1180					_DWBNoCarry:
.1180	60		rts				rts
.1181					DecodeOutputData:
.1181	48		pha				pha
.1182	da		phx				phx
.1183	5a		phy				phy
.1184	b1 08		lda ($08),y			lda 	(srcPtr),y 					; length + 1
.1186	aa		tax				tax
.1187					_DODLoop:
.1187	ca		dex				dex 								; done it all ?
.1188	f0 0c		beq $1196			beq		_DODExit
.118a	c8		iny				iny 								; output next character
.118b	b1 08		lda ($08),y			lda 	(srcPtr),y
.118d	29 7f		and #$7f			and 	#$7F
.118f	f0 f6		beq $1187			beq 	_DODLoop 					; don't print NULL
.1191	20 78 11	jsr $1178			jsr 	DecodeWriteBuffer
.1194	80 f1		bra $1187			bra 	_DODLoop
.1196					_DODExit:
.1196	7a		ply				ply
.1197	fa		plx				plx
.1198	68		pla				pla
.1199	60		rts				rts
.119a					DecodeYAToBuffer:
.119a	da		phx				phx
.119b	5a		phy				phy
.119c	48		pha				pha
.119d	a5 0a		lda $0a				lda 	bufPtr 						; copy bufPtr to temp2
.119f	85 14		sta $14				sta 	temp2
.11a1	a5 0b		lda $0b				lda 	bufPtr+1
.11a3	85 15		sta $15				sta 	temp2+1
.11a5	68		pla				pla
.11a6	20 32 19	jsr $1932			jsr 	ConvertToStringMain 		; convert YA to string there
.11a9	aa		tax				tax 								; chars output to X
.11aa	18		clc				clc
.11ab	65 0a		adc $0a				adc 	bufPtr 						; add to buffer pointer
.11ad	85 0a		sta $0a				sta 	bufPtr
.11af	90 02		bcc $11b3			bcc 	_DYABNoCarry
.11b1	e6 0b		inc $0b				inc 	bufPtr+1
.11b3					_DYABNoCarry:
.11b3	8a		txa				txa 								; count in A
.11b4	7a		ply				ply									; restore and exit.
.11b5	fa		plx				plx
.11b6	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/binary.src

.11b7					Add:
.11b7	7a		ply				ply
.11b8	68		pla				pla
.11b9	18		clc				clc
.11ba	65 06		adc $06				adc 	TOS
.11bc	85 06		sta $06				sta 	TOS
.11be	98		tya				tya
.11bf	65 07		adc $07				adc 	TOS+1
.11c1	85 07		sta $07				sta 	TOS+1
.11c3	4c 00 00	jmp $0000			jmp 	Next
.11c6					Subtract:
.11c6	7a		ply				ply
.11c7	68		pla				pla
.11c8	38		sec				sec
.11c9	49 ff		eor #$ff			eor 	#$FF
.11cb	65 06		adc $06				adc 	TOS
.11cd	85 06		sta $06				sta 	TOS
.11cf	98		tya				tya
.11d0	49 ff		eor #$ff			eor 	#$FF
.11d2	65 07		adc $07				adc 	TOS+1
.11d4	85 07		sta $07				sta 	TOS+1
.11d6	4c 00 00	jmp $0000			jmp 	Next
.11d9					And:
.11d9	68		pla				pla
.11da	25 07		and $07				and 	TOS+1
.11dc	85 07		sta $07				sta 	TOS+1
.11de	68		pla				pla
.11df	25 06		and $06				and 	TOS
.11e1	85 06		sta $06				sta 	TOS
.11e3	4c 00 00	jmp $0000			jmp 	Next
.11e6					Xor:
.11e6	68		pla				pla
.11e7	45 07		eor $07				eor 	TOS+1
.11e9	85 07		sta $07				sta 	TOS+1
.11eb	68		pla				pla
.11ec	45 06		eor $06				eor 	TOS
.11ee	85 06		sta $06				sta 	TOS
.11f0	4c 00 00	jmp $0000			jmp 	Next
.11f3					LogOr:
.11f3	68		pla				pla
.11f4	05 07		ora $07				ora 	TOS+1
.11f6	85 07		sta $07				sta 	TOS+1
.11f8	68		pla				pla
.11f9	05 06		ora $06				ora 	TOS
.11fb	85 06		sta $06				sta 	TOS
.11fd	4c 00 00	jmp $0000			jmp 	Next

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/compare.src

.1200					CheckNotEqual:
.1200	38		sec				sec
.1201	80 01		bra $1204			bra 	CECode
.1203					CheckEqual:
.1203	18		clc				clc
.1204					CECode:
.1204	86 12		stx $12				stx 	temp1
.1206	ba		tsx				tsx
.1207	08		php				php
.1208	a5 06		lda $06				lda 	TOS
.120a	5d 02 01	eor $0102,x			eor 	Stack2Low,x
.120d	d0 17		bne $1226			bne	 	CompareFalse
.120f	a5 07		lda $07				lda 	TOS+1
.1211	5d 01 01	eor $0101,x			eor 	Stack2High,x
.1214	d0 10		bne $1226			bne 	CompareFalse
.1216					CompareTrue:
.1216	a6 12		ldx $12				ldx 	temp1
.1218	28		plp				plp
.1219	b0 10		bcs $122b			bcs		CompareFalse2
.121b					CompareTrue2:
.121b	68		pla				pla
.121c	68		pla				pla
.121d	a9 ff		lda #$ff			lda 	#$FF
.121f	85 06		sta $06				sta 	TOS
.1221	85 07		sta $07				sta 	TOS+1
.1223	4c 00 00	jmp $0000			jmp 	Next
.1226					CompareFalse:
.1226	a6 12		ldx $12				ldx 	temp1
.1228	28		plp				plp
.1229	b0 f0		bcs $121b			bcs		CompareTrue2
.122b					CompareFalse2:
.122b	68		pla				pla
.122c	68		pla				pla
.122d	64 06		stz $06				stz 	TOS
.122f	64 07		stz $07				stz 	TOS+1
.1231	4c 00 00	jmp $0000			jmp 	Next
.1234					CheckGreaterEq:
.1234	38		sec				sec
.1235	80 01		bra $1238			bra		CLCode
.1237					CheckLess:
.1237	18		clc				clc
.1238	86 12		stx $12		CLCode:	stx 	temp1
.123a	ba		tsx				tsx
.123b	08		php				php
.123c	18		clc				clc
.123d	a5 06		lda $06				lda 	TOS
.123f	fd 02 01	sbc $0102,x			sbc 	Stack2Low,x
.1242	a5 07		lda $07				lda 	TOS+1
.1244	fd 01 01	sbc $0101,x			sbc 	Stack2High,x
.1247	50 02		bvc $124b			bvc 	_CLNoFlip
.1249	49 80		eor #$80			eor 	#$80
.124b					_CLNoFlip:
.124b	0a		asl a				asl 	a
.124c	b0 d8		bcs $1226			bcs 	CompareFalse
.124e	80 c6		bra $1216			bra 	CompareTrue
.1250					CheckLessEq:
.1250	38		sec				sec
.1251	80 01		bra $1254			bra		CGCode
.1253					CheckGreater:
.1253	18		clc				clc
.1254					CGCode:
.1254	86 12		stx $12				stx 	temp1
.1256	ba		tsx				tsx
.1257	08		php				php
.1258	18		clc				clc
.1259	bd 02 01	lda $0102,x			lda 	Stack2Low,x
.125c	e5 06		sbc $06				sbc 	TOS
.125e	bd 01 01	lda $0101,x			lda 	Stack2High,x
.1261	e5 07		sbc $07				sbc 	TOS+1
.1263	50 02		bvc $1267			bvc 	_CGNoFlip
.1265	49 80		eor #$80			eor 	#$80
.1267					_CGNoFlip:
.1267	0a		asl a				asl 	a
.1268	b0 bc		bcs $1226			bcs 	CompareFalse
.126a	80 aa		bra $1216			bra 	CompareTrue
.126c					Minimum:
.126c	a9 00		lda #$00			lda 	#0
.126e	80 02		bra $1272			bra 	MinMaxCode
.1270					Maximum:
.1270	a9 80		lda #$80			lda 	#$80
.1272					MinMaxCode:
.1272	85 13		sta $13				sta 	temp1+1
.1274	86 12		stx $12				stx 	temp1
.1276	ba		tsx				tsx
.1277	38		sec				sec
.1278	a5 06		lda $06				lda 	TOS
.127a	fd 02 01	sbc $0102,x			sbc 	Stack2Low,x
.127d	a5 07		lda $07				lda 	TOS+1
.127f	fd 01 01	sbc $0101,x			sbc 	Stack2High,x
.1282	50 02		bvc $1286			bvc 	_MMNoFlip
.1284	49 80		eor #$80			eor 	#$80
.1286					_MMNoFlip:
.1286	45 13		eor $13				eor 	temp1+1
.1288	30 0a		bmi $1294			bmi 	_MMNoCopy
.128a	bd 02 01	lda $0102,x			lda 	Stack2Low,x
.128d	85 06		sta $06				sta 	TOS
.128f	bd 01 01	lda $0101,x			lda 	Stack2High,x
.1292	85 07		sta $07				sta 	TOS+1
.1294					_MMNoCopy:
.1294	a6 12		ldx $12				ldx 	temp1
.1296	68		pla				pla
.1297	68		pla				pla
.1298	4c 00 00	jmp $0000			jmp 	Next

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/divide.src

.129b					Divide16x16:
.129b	86 14		stx $14				stx 	temp2
.129d	ba		tsx				tsx
.129e	20 c1 12	jsr $12c1			jsr 	IntegerDivide
.12a1	68		pla				pla
.12a2	85 07		sta $07				sta 	TOS+1
.12a4	68		pla				pla
.12a5	85 06		sta $06				sta 	TOS
.12a7	a6 14		ldx $14				ldx 	temp2
.12a9	4c 00 00	jmp $0000			jmp 	Next
.12ac					Modulus16x16:
.12ac	86 14		stx $14				stx 	temp2
.12ae	ba		tsx				tsx
.12af	20 c1 12	jsr $12c1			jsr 	IntegerDivide
.12b2	a6 14		ldx $14				ldx 	temp2
.12b4	68		pla				pla
.12b5	68		pla				pla
.12b6	a5 12		lda $12				lda 	temp1
.12b8	85 06		sta $06				sta 	TOS
.12ba	a5 13		lda $13				lda 	temp1+1
.12bc	85 07		sta $07				sta 	TOS+1
.12be	4c 00 00	jmp $0000			jmp 	Next
.12c1					IntegerDivide:
.12c1	a5 06		lda $06				lda 	TOS 				; check for division by zero.
.12c3	05 07		ora $07				ora 	TOS+1
.12c5	d0 14		bne $12db			bne 	_BFDOkay
.12c7	20 f4 1a	jsr $1af4			jsr 	ErrorHandler
>12ca	44 49 56 49 53 49 4f 4e				.text 	"DIVISION BY ZERO",0
>12d2	20 42 59 20 5a 45 52 4f 00
.12db					_BFDOkay:
.12db	64 12		stz $12				stz 	temp1 						; Q/Dividend/Left in +0
.12dd	64 13		stz $13				stz 	temp1+1 					; M/Divisor/Right in +2
.12df	64 1a		stz $1a				stz 	SignCount 					; Count of signs.
.12e1	20 1c 13	jsr $131c			jsr 	CheckIntegerNegate 			; negate 2nd (and bump sign count)
.12e4	20 36 13	jsr $1336			jsr 	CheckTOSNegate 				; negate TOS (and bump sign count)
.12e7	5a		phy				phy 								; Y is the counter
.12e8	a0 10		ldy #$10			ldy 	#16 						; 16 iterations of the loop.
.12ea					_BFDLoop:
.12ea	1e 02 01	asl $0102,x			asl 	Stack2Low,x 				; shift AQ left.
.12ed	3e 01 01	rol $0101,x			rol 	Stack2High,x
.12f0	26 12		rol $12				rol 	temp1
.12f2	26 13		rol $13				rol 	temp1+1
.12f4	38		sec				sec
.12f5	a5 12		lda $12				lda 	temp1+0 					; Calculate A-M on stack.
.12f7	e5 06		sbc $06				sbc 	TOS
.12f9	48		pha				pha
.12fa	a5 13		lda $13				lda 	temp1+1
.12fc	e5 07		sbc $07				sbc 	TOS+1
.12fe	90 0f		bcc $130f			bcc 	_BFDNoAdd
.1300	85 13		sta $13				sta 	temp1+1
.1302	68		pla				pla
.1303	85 12		sta $12				sta 	temp1+0
.1305	bd 02 01	lda $0102,x			lda 	Stack2Low,x 				; set Q bit 1.
.1308	09 01		ora #$01			ora 	#1
.130a	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.130d	80 01		bra $1310			bra 	_BFDNext
.130f					_BFDNoAdd:
.130f	68		pla				pla 								; Throw away the intermediate calculations
.1310					_BFDNext:
.1310	88		dey				dey
.1311	d0 d7		bne $12ea			bne 	_BFDLoop
.1313	7a		ply				ply 								; restore Y
.1314	46 1a		lsr $1a				lsr 	SignCount 					; if sign count odd,
.1316	90 03		bcc $131b			bcc 	_BFDUnsigned 				; then the result is signed
.1318	20 22 13	jsr $1322			jsr		IntegerNegateAlways 		; negate the result
.131b					_BFDUnsigned:
.131b	60		rts				rts
.131c					CheckIntegerNegate:
.131c	bd 01 01	lda $0101,x			lda 	Stack2High,x 				; is it -ve = MSB set ?
.131f	30 01		bmi $1322			bmi 	IntegerNegateAlways 		; if so negate it
.1321	60		rts				rts
.1322					IntegerNegateAlways:
.1322	e6 1a		inc $1a				inc 	SignCount 					; bump the count of signs
.1324	38		sec				sec 								; negate
.1325	a9 00		lda #$00			lda 	#0
.1327	fd 02 01	sbc $0102,x			sbc 	Stack2Low,x
.132a	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.132d	a9 00		lda #$00			lda 	#0
.132f	fd 01 01	sbc $0101,x			sbc 	Stack2High,x
.1332	9d 01 01	sta $0101,x			sta 	Stack2High,x
.1335	60		rts				rts
.1336					CheckTOSNegate:
.1336	a5 07		lda $07				lda 	TOS+1
.1338	10 0f		bpl $1349			bpl		CTNNoChange
.133a	e6 1a		inc $1a				inc 	SignCount
.133c					TOSNegateAlways:
.133c	38		sec				sec
.133d	a9 00		lda #$00			lda 	#0
.133f	e5 06		sbc $06				sbc 	TOS
.1341	85 06		sta $06				sta 	TOS
.1343	a9 00		lda #$00			lda 	#0
.1345	e5 07		sbc $07				sbc 	TOS+1
.1347	85 07		sta $07				sta 	TOS+1
.1349					CTNNoChange:
.1349	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/multiply.src

.134a					Multiply16x16:
.134a	86 12		stx $12				stx 	temp1
.134c	ba		tsx				tsx
.134d	bd 02 01	lda $0102,x			lda 	Stack2Low,x 				; 2nd value on stack to temp1
.1350	85 14		sta $14				sta 	temp2
.1352	bd 01 01	lda $0101,x			lda		Stack2High,x
.1355	85 15		sta $15				sta 	temp2+1
.1357	9e 02 01	stz $0102,x			stz 	Stack2Low,x 				; zero 2nd value on stack
.135a	9e 01 01	stz $0101,x			stz 	Stack2High,x
.135d					_MultLoop:
.135d	46 15		lsr $15				lsr 	temp2+1 					; ror temp2 into C
.135f	66 14		ror $14				ror 	temp2
.1361	90 11		bcc $1374			bcc 	_MultNoAdd
.1363	18		clc				clc 								; add 1st to 2nd
.1364	a5 06		lda $06				lda 	TOS
.1366	7d 02 01	adc $0102,x			adc 	Stack2Low,x
.1369	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.136c	a5 07		lda $07				lda 	TOS+1
.136e	7d 01 01	adc $0101,x			adc 	Stack2High,x
.1371	9d 01 01	sta $0101,x			sta 	Stack2High,x
.1374					_MultNoAdd:
.1374	06 06		asl $06				asl 	TOS 						; shift 1st left
.1376	26 07		rol $07				rol 	TOS+1
.1378	a5 14		lda $14				lda 	temp2	 					; until zero
.137a	05 15		ora $15				ora 	temp2+1
.137c	d0 df		bne $135d			bne 	_MultLoop
.137e	a6 12		ldx $12				ldx 	temp1 						; restore X load result
.1380	68		pla				pla
.1381	85 07		sta $07				sta 	TOS+1
.1383	68		pla				pla
.1384	85 06		sta $06				sta 	TOS
.1386	4c 00 00	jmp $0000			jmp 	Next

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/unary.src

.1389					Unary1Plus:
.1389	e6 06		inc $06				inc 	TOS
.138b	d0 02		bne $138f			bne 	_U1PSkip
.138d	e6 07		inc $07				inc 	TOS+1
.138f					_U1PSkip:
.138f	4c 00 00	jmp $0000			jmp 	Next
.1392					Unary2Plus:
.1392	18		clc				clc
.1393	a5 06		lda $06				lda 	TOS
.1395	69 02		adc #$02			adc 	#2
.1397	85 06		sta $06				sta 	TOS
.1399	90 02		bcc $139d			bcc 	_U1PSkip
.139b	e6 07		inc $07				inc 	TOS+1
.139d					_U1PSkip:
.139d	4c 00 00	jmp $0000			jmp 	Next
.13a0					Unary1Minus:
.13a0	a5 06		lda $06				lda 	TOS
.13a2	d0 02		bne $13a6			bne 	_U1MSkip
.13a4	c6 07		dec $07				dec 	TOS+1
.13a6					_U1MSkip:
.13a6	c6 06		dec $06				dec 	TOS
.13a8	4c 00 00	jmp $0000			jmp 	Next
.13ab					Unary2Minus:
.13ab	38		sec				sec
.13ac	a5 06		lda $06				lda 	TOS
.13ae	e9 02		sbc #$02			sbc 	#2
.13b0	85 06		sta $06				sta 	TOS
.13b2	b0 02		bcs $13b6			bcs 	_U1PSkip
.13b4	c6 07		dec $07				dec 	TOS+1
.13b6					_U1PSkip:
.13b6	4c 00 00	jmp $0000			jmp 	Next
.13b9					Absolute:
.13b9	a5 07		lda $07				lda 	TOS+1
.13bb	30 03		bmi $13c0			bmi 	Negate
.13bd	4c 00 00	jmp $0000			jmp 	Next
.13c0					Negate:
.13c0	38		sec				sec
.13c1	a9 00		lda #$00			lda 	#0
.13c3	e5 06		sbc $06				sbc 	TOS
.13c5	85 06		sta $06				sta 	TOS
.13c7	a9 00		lda #$00			lda 	#0
.13c9	e5 07		sbc $07				sbc 	TOS+1
.13cb	85 07		sta $07				sta 	TOS+1
.13cd	4c 00 00	jmp $0000			jmp 	Next
.13d0					OneComplement:
.13d0	a5 06		lda $06				lda 	TOS
.13d2	49 ff		eor #$ff			eor 	#$FF
.13d4	85 06		sta $06				sta 	TOS
.13d6	a5 07		lda $07				lda 	TOS+1
.13d8	49 ff		eor #$ff			eor 	#$FF
.13da	85 07		sta $07				sta 	TOS+1
.13dc	4c 00 00	jmp $0000			jmp 	Next
.13df					CheckMinus:
.13df	a5 07		lda $07				lda 	TOS+1
.13e1	30 07		bmi $13ea			bmi 	UnaryTrue
.13e3					UnaryFalse:
.13e3	64 06		stz $06				stz 	TOS
.13e5	64 07		stz $07				stz 	TOS+1
.13e7	4c 00 00	jmp $0000			jmp 	Next
.13ea					UnaryTrue:
.13ea	a9 ff		lda #$ff			lda 	#$FF
.13ec	85 06		sta $06				sta 	TOS
.13ee	85 07		sta $07				sta 	TOS+1
.13f0	4c 00 00	jmp $0000			jmp 	Next
.13f3					CheckZero:
.13f3	a5 06		lda $06				lda 	TOS
.13f5	05 07		ora $07				ora 	TOS+1
.13f7	d0 ea		bne $13e3			bne 	UnaryFalse
.13f9	80 ef		bra $13ea			bra 	UnaryTrue
.13fb					SignTOS:
.13fb	a5 07		lda $07				lda 	TOS+1
.13fd	30 eb		bmi $13ea			bmi		UnaryTrue
.13ff	05 06		ora $06				ora 	TOS
.1401	f0 e0		beq $13e3			beq 	UnaryFalse
.1403	a9 01		lda #$01			lda 	#1
.1405	85 06		sta $06				sta 	TOS
.1407	64 07		stz $07				stz		TOS+1
.1409	4c 00 00	jmp $0000			jmp 	Next
.140c					ByteSwap:
.140c	a5 06		lda $06				lda 	TOS
.140e	a4 07		ldy $07				ldy 	TOS+1
.1410	85 07		sta $07				sta 	TOS+1
.1412	84 06		sty $06				sty 	TOS
.1414	4c 00 00	jmp $0000			jmp 	Next
.1417					Times16:
.1417	06 06		asl $06				asl 	TOS
.1419	26 07		rol $07				rol 	TOS+1
.141b					Times8:
.141b	06 06		asl $06				asl 	TOS
.141d	26 07		rol $07				rol 	TOS+1
.141f					Times4:
.141f	06 06		asl $06				asl 	TOS
.1421	26 07		rol $07				rol 	TOS+1
.1423					Times2:
.1423	06 06		asl $06				asl 	TOS
.1425	26 07		rol $07				rol 	TOS+1
.1427	4c 00 00	jmp $0000			jmp 	Next
.142a					Divide16:
.142a	46 07		lsr $07				lsr 	TOS+1
.142c	66 06		ror $06				ror 	TOS
.142e					Divide8:
.142e	46 07		lsr $07				lsr 	TOS+1
.1430	66 06		ror $06				ror 	TOS
.1432					Divide4:
.1432	46 07		lsr $07				lsr 	TOS+1
.1434	66 06		ror $06				ror 	TOS
.1436					Divide2:
.1436	46 07		lsr $07				lsr 	TOS+1
.1438	66 06		ror $06				ror 	TOS
.143a	4c 00 00	jmp $0000			jmp 	Next
.143d					Times256:
.143d	a5 06		lda $06				lda 	TOS
.143f	85 07		sta $07				sta 	TOS+1
.1441	64 06		stz $06				stz 	TOS
.1443	4c 00 00	jmp $0000			jmp 	Next
.1446					Divide256:
.1446	a5 07		lda $07				lda 	TOS+1
.1448	85 06		sta $06				sta 	TOS
.144a	64 07		stz $07				stz 	TOS+1
.144c	4c 00 00	jmp $0000			jmp 	Next
.144f					RandomNumber:
.144f	a5 06		lda $06				lda 	TOS
.1451	48		pha				pha
.1452	a5 07		lda $07				lda 	TOS+1
.1454	48		pha				pha
.1455	a5 1b		lda $1b				lda 	randomSeed
.1457	05 1c		ora $1c				ora 	randomSeed+1
.1459	d0 08		bne $1463			bne 	_RH_NoInit
.145b	a9 7c		lda #$7c			lda 	#$7C
.145d	85 1b		sta $1b				sta 	randomSeed
.145f	a9 a1		lda #$a1			lda 	#$A1
.1461	85 1c		sta $1c				sta 	randomSeed+1
.1463					_RH_NoInit:
.1463	a5 1b		lda $1b				lda 	randomSeed
.1465	4a		lsr a		        lsr		a
.1466	26 1c		rol $1c		        rol 	randomSeed+1
.1468	90 02		bcc $146c	        bcc 	_RH_NoEor
.146a	49 b4		eor #$b4	        eor 	#$B4
.146c					_RH_NoEor:
.146c	85 1b		sta $1b		        sta 	randomSeed
.146e	45 1c		eor $1c		        eor 	randomSeed+1
.1470	85 07		sta $07		        sta 	TOS+1
.1472	a5 1b		lda $1b		        lda 	randomSeed
.1474	85 06		sta $06		        sta 	TOS
.1476	4c 00 00	jmp $0000			jmp 	Next

;******  Return to file: kernel.asm


;******  Processing file: words/data/literals.src

.1479					Constant0:
.1479	a5 06		lda $06				lda 	TOS
.147b	48		pha				pha
.147c	a5 07		lda $07				lda 	TOS+1
.147e	48		pha				pha
.147f	64 06		stz $06				stz 	TOS
.1481	64 07		stz $07				stz 	TOS+1
.1483	4c 00 00	jmp $0000			jmp 	Next
.1486					ConstantMinus1:
.1486	a5 06		lda $06				lda 	TOS
.1488	48		pha				pha
.1489	a5 07		lda $07				lda 	TOS+1
.148b	48		pha				pha
.148c	a9 ff		lda #$ff			lda 	#$FF
.148e	85 06		sta $06				sta 	TOS
.1490	85 07		sta $07				sta 	TOS+1
.1492	4c 00 00	jmp $0000			jmp 	Next
.1495					C1:
.1495	a0 01		ldy #$01			ldy 	#1
.1497	80 24		bra $14bd			bra 	Const1Byte
.1499					C2:
.1499	a0 02		ldy #$02			ldy 	#2
.149b	80 20		bra $14bd			bra 	Const1Byte
.149d					C3:
.149d	a0 03		ldy #$03			ldy 	#3
.149f	80 1c		bra $14bd			bra 	Const1Byte
.14a1					C4:
.14a1	a0 04		ldy #$04			ldy 	#4
.14a3	80 18		bra $14bd			bra 	Const1Byte
.14a5					C5:
.14a5	a0 05		ldy #$05			ldy 	#5
.14a7	80 14		bra $14bd			bra 	Const1Byte
.14a9					C8:
.14a9	a0 08		ldy #$08			ldy 	#8
.14ab	80 10		bra $14bd			bra 	Const1Byte
.14ad					C10:
.14ad	a0 0a		ldy #$0a			ldy 	#10
.14af	80 0c		bra $14bd			bra 	Const1Byte
.14b1					C15:
.14b1	a0 0f		ldy #$0f			ldy 	#15
.14b3	80 08		bra $14bd			bra 	Const1Byte
.14b5					C16:
.14b5	a0 10		ldy #$10			ldy 	#16
.14b7	80 04		bra $14bd			bra 	Const1Byte
.14b9					C24:
.14b9	a0 18		ldy #$18			ldy 	#24
.14bb	80 00		bra $14bd			bra 	Const1Byte
.14bd					Const1Byte:
.14bd	a5 06		lda $06				lda 	TOS
.14bf	48		pha				pha
.14c0	a5 07		lda $07				lda 	TOS+1
.14c2	48		pha				pha
.14c3	84 06		sty $06				sty 	TOS
.14c5	64 07		stz $07				stz 	TOS+1
.14c7	4c 00 00	jmp $0000			jmp 	Next
.14ca					C32:
.14ca	a0 20		ldy #$20			ldy 	#32
.14cc	80 ef		bra $14bd			bra 	Const1Byte
.14ce					C63:
.14ce	a0 3f		ldy #$3f			ldy 	#63
.14d0	80 eb		bra $14bd			bra 	Const1Byte
.14d2					C64:
.14d2	a0 40		ldy #$40			ldy 	#64
.14d4	80 e7		bra $14bd			bra 	Const1Byte
.14d6					C100:
.14d6	a0 64		ldy #$64			ldy 	#100
.14d8	80 e3		bra $14bd			bra 	Const1Byte
.14da					C127:
.14da	a0 7f		ldy #$7f			ldy 	#127
.14dc	80 df		bra $14bd			bra 	Const1Byte
.14de					C128:
.14de	a0 80		ldy #$80			ldy 	#128
.14e0	80 db		bra $14bd			bra 	Const1Byte
.14e2					C255:
.14e2	a0 ff		ldy #$ff			ldy 	#255
.14e4	80 d7		bra $14bd			bra 	Const1Byte
.14e6					Const2Byte:
.14e6	85 06		sta $06				sta 	TOS
.14e8	84 07		sty $07				sty 	TOS+1
.14ea	4c 00 00	jmp $0000			jmp 	Next
.14ed					C256:
.14ed	a5 06		lda $06				lda 	TOS
.14ef	48		pha				pha
.14f0	a5 07		lda $07				lda 	TOS+1
.14f2	48		pha				pha
.14f3	a9 00		lda #$00			lda 	#(256) & $FF
.14f5	a0 01		ldy #$01			ldy 	#(256) >> 8
.14f7	80 ed		bra $14e6			bra 	Const2Byte
.14f9					C512:
.14f9	a5 06		lda $06				lda 	TOS
.14fb	48		pha				pha
.14fc	a5 07		lda $07				lda 	TOS+1
.14fe	48		pha				pha
.14ff	a9 00		lda #$00			lda 	#(512) & $FF
.1501	a0 02		ldy #$02			ldy 	#(512) >> 8
.1503	80 e1		bra $14e6			bra 	Const2Byte
.1505					C1024:
.1505	a5 06		lda $06				lda 	TOS
.1507	48		pha				pha
.1508	a5 07		lda $07				lda 	TOS+1
.150a	48		pha				pha
.150b	a9 00		lda #$00			lda 	#(1024) & $FF
.150d	a0 04		ldy #$04			ldy 	#(1024) >> 8
.150f	80 d5		bra $14e6			bra 	Const2Byte
.1511					C4096:
.1511	a5 06		lda $06				lda 	TOS
.1513	48		pha				pha
.1514	a5 07		lda $07				lda 	TOS+1
.1516	48		pha				pha
.1517	a9 00		lda #$00			lda 	#(4096) & $FF
.1519	a0 10		ldy #$10			ldy 	#(4096) >> 8
.151b	80 c9		bra $14e6			bra 	Const2Byte
.151d					C32767:
.151d	a5 06		lda $06				lda 	TOS
.151f	48		pha				pha
.1520	a5 07		lda $07				lda 	TOS+1
.1522	48		pha				pha
.1523	a9 ff		lda #$ff			lda 	#(32767) & $FF
.1525	a0 7f		ldy #$7f			ldy 	#(32767) >> 8
.1527	80 bd		bra $14e6			bra 	Const2Byte
.1529					C32768:
.1529	a5 06		lda $06				lda 	TOS
.152b	48		pha				pha
.152c	a5 07		lda $07				lda 	TOS+1
.152e	48		pha				pha
.152f	a9 00		lda #$00			lda 	#(32768) & $FF
.1531	a0 80		ldy #$80			ldy 	#(32768) >> 8
.1533	80 b1		bra $14e6			bra 	Const2Byte

;******  Return to file: kernel.asm


;******  Processing file: words/data/stack.src

.1535					Drop:
.1535	68		pla				pla
.1536	85 07		sta $07				sta 	TOS+1
.1538	68		pla				pla
.1539	85 06		sta $06				sta 	TOS
.153b	4c 00 00	jmp $0000			jmp 	Next
.153e					TestDup:
.153e	a5 06		lda $06				lda 	TOS
.1540	05 07		ora $07				ora 	TOS+1
.1542	d0 03		bne $1547			bne 	Dup
.1544	4c 00 00	jmp $0000			jmp 	Next
.1547					Dup:
.1547	a5 06		lda $06				lda 	TOS
.1549	48		pha				pha
.154a	a5 07		lda $07				lda 	TOS+1
.154c	48		pha				pha
.154d	4c 00 00	jmp $0000			jmp 	Next
.1550					Swap:
.1550	86 12		stx $12				stx 	temp1
.1552	7a		ply				ply
.1553	fa		plx				plx
.1554	a5 06		lda $06				lda 	TOS
.1556	48		pha				pha
.1557	a5 07		lda $07				lda 	TOS+1
.1559	48		pha				pha
.155a	86 06		stx $06				stx 	TOS
.155c	84 07		sty $07				sty 	TOS+1
.155e	a6 12		ldx $12				ldx 	temp1
.1560	4c 00 00	jmp $0000			jmp 	Next
.1563					Over:
.1563	a5 06		lda $06				lda 	TOS
.1565	48		pha				pha
.1566	a5 07		lda $07				lda 	TOS+1
.1568	48		pha				pha
.1569	86 12		stx $12				stx 	temp1
.156b	ba		tsx				tsx
.156c	bd 04 01	lda $0104,x			lda 	stack3low,x
.156f	85 06		sta $06				sta 	TOS
.1571	bd 03 01	lda $0103,x			lda 	stack3High,x
.1574	85 07		sta $07				sta 	TOS+1
.1576	a6 12		ldx $12				ldx 	temp1
.1578	4c 00 00	jmp $0000			jmp 	Next
.157b					Nip:
.157b	68		pla				pla
.157c	68		pla				pla
.157d	4c 00 00	jmp $0000			jmp 	Next
.1580					Rot:
.1580	86 12		stx $12				stx 	temp1
.1582	ba		tsx				tsx
.1583	bd 04 01	lda $0104,x			lda 	Stack3Low,x
.1586	a8		tay				tay
.1587	bd 02 01	lda $0102,x			lda 	Stack2Low,x
.158a	9d 04 01	sta $0104,x			sta 	Stack3Low,x
.158d	a5 06		lda $06				lda 	TOS
.158f	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.1592	84 06		sty $06				sty 	TOS
.1594	bd 03 01	lda $0103,x			lda 	Stack3High,x
.1597	a8		tay				tay
.1598	bd 01 01	lda $0101,x			lda 	Stack2High,x
.159b	9d 03 01	sta $0103,x			sta 	Stack3High,x
.159e	a5 07		lda $07				lda 	TOS+1
.15a0	9d 01 01	sta $0101,x			sta 	Stack2High,x
.15a3	84 07		sty $07				sty 	TOS+1
.15a5	a6 12		ldx $12				ldx 	temp1
.15a7	4c 00 00	jmp $0000			jmp 	Next

;******  Return to file: kernel.asm


;******  Processing file: words/data/memory.src

.15aa					ByteRead:
.15aa	b2 06		lda ($06)			lda 	(TOS)
.15ac	85 06		sta $06				sta 	TOS
.15ae	64 07		stz $07				stz 	TOS+1
.15b0	4c 00 00	jmp $0000			jmp 	Next
.15b3					WordRead:
.15b3	a0 01		ldy #$01			ldy 	#1
.15b5	b1 06		lda ($06),y			lda 	(TOS),y
.15b7	a8		tay				tay
.15b8	b2 06		lda ($06)			lda 	(TOS)
.15ba	85 06		sta $06				sta 	TOS
.15bc	84 07		sty $07				sty 	TOS+1
.15be	4c 00 00	jmp $0000			jmp 	Next
.15c1					ByteWrite:
.15c1	68		pla				pla
.15c2	68		pla				pla
.15c3	92 06		sta ($06)			sta 	(TOS)
.15c5	68		pla				pla
.15c6	85 07		sta $07				sta 	TOS+1
.15c8	68		pla				pla
.15c9	85 06		sta $06				sta 	TOS
.15cb	4c 00 00	jmp $0000			jmp 	Next
.15ce					WordWrite:
.15ce	68		pla				pla
.15cf	a0 01		ldy #$01			ldy 	#1
.15d1	91 06		sta ($06),y			sta 	(TOS),y
.15d3	68		pla				pla
.15d4	92 06		sta ($06)			sta 	(TOS)
.15d6	68		pla				pla
.15d7	85 07		sta $07				sta 	TOS+1
.15d9	68		pla				pla
.15da	85 06		sta $06				sta 	TOS
.15dc	4c 00 00	jmp $0000			jmp 	Next
.15df					WordAdd:
.15df	7a		ply				ply
.15e0	68		pla				pla
.15e1	18		clc				clc
.15e2	72 06		adc ($06)			adc 	(TOS)
.15e4	92 06		sta ($06)			sta 	(TOS)
.15e6	98		tya				tya
.15e7	a0 01		ldy #$01			ldy 	#1
.15e9	71 06		adc ($06),y			adc 	(TOS),y
.15eb	91 06		sta ($06),y			sta 	(TOS),y
.15ed	68		pla				pla
.15ee	85 07		sta $07				sta 	TOS+1
.15f0	68		pla				pla
.15f1	85 06		sta $06				sta 	TOS
.15f3	4c 00 00	jmp $0000			jmp 	Next
.15f6					AllocateMemory:
.15f6	a5 06		lda $06				lda 	TOS 						; save memory required on stack.
.15f8	48		pha				pha
.15f9	a5 07		lda $07				lda 	TOS+1
.15fb	48		pha				pha
.15fc	a5 0e		lda $0e				lda 	nextFreeMem 				; copy free mem address to TOS
.15fe	85 06		sta $06				sta 	TOS
.1600	a5 0f		lda $0f				lda 	nextFreeMem+1
.1602	85 07		sta $07				sta 	TOS+1
.1604	7a		ply				ply 								; advance the free ram pointer
.1605	68		pla				pla
.1606	20 b8 17	jsr $17b8			jsr 	AdvanceFreeMem
.1609	4c 00 00	jmp $0000			jmp 	Next 						; and continue

;******  Return to file: kernel.asm


;******  Processing file: words/structures/fornext.src

.160c					ForHandler:
.160c	e6 05		inc $05				inc 	rsp 						; bump the RSP
.160e	a4 05		ldy $05				ldy 	rsp 						; get return stack and push TOS/$FF on it.
.1610	c0 40		cpy #$40			cpy 	#$40 						; overflow
.1612	f0 18		beq $162c			beq 	_FHOverflow
.1614	a5 07		lda $07				lda 	TOS+1
.1616	99 40 07	sta $0740,y			sta 	returnStackHigh,y
.1619	a5 06		lda $06				lda 	TOS
.161b	99 00 07	sta $0700,y			sta 	returnStackLow,y
.161e	a9 ff		lda #$ff			lda 	#$FF
.1620	99 80 07	sta $0780,y			sta 	returnStackX,y
.1623	68		pla				pla
.1624	85 07		sta $07				sta 	TOS+1
.1626	68		pla				pla
.1627	85 06		sta $06				sta 	TOS
.1629	4c 00 00	jmp $0000			jmp 	Next
.162c					_FHOverflow:
.162c	20 f4 1a	jsr $1af4			jsr 	ErrorHandler
>162f	46 4f 52 20 53 54 41 43				.text 	"FOR STACK?",0
>1637	4b 3f 00
.163a					NextHandler:
.163a	da		phx				phx
.163b	a6 05		ldx $05				ldx 	rsp 						; get current stack ptr
.163d	bd 80 07	lda $0780,x			lda 	returnStackX,x 				; check it's a FOR Loop
.1640	c9 ff		cmp #$ff			cmp 	#$FF
.1642	d0 21		bne $1665			bne 	NHNoFor
.1644	bd 00 07	lda $0700,x			lda 	returnStackLow,x 			; decrement the count
.1647	d0 03		bne $164c			bne 	_NHNoBorrow
.1649	de 40 07	dec $0740,x			dec 	returnStackHigh,x
.164c					_NHNoBorrow:
.164c	de 00 07	dec $0700,x			dec 	returnStackLow,x
.164f	bd 00 07	lda $0700,x			lda 	returnStackLow,x 			; have we reached the end ?
.1652	1d 40 07	ora $0740,x			ora 	returnStackHigh,x
.1655	fa		plx				plx 								; restore X and re-test
.1656	09 00		ora #$00			ora 	#0
.1658	f0 05		beq $165f			beq 	_NHComplete 				; if so then complete, else loop.
.165a	e8		inx				inx 								; advance to branch
.165b	e8		inx				inx
.165c	4c b8 16	jmp $16b8			jmp 	BranchAlways
.165f					_NHComplete:
.165f	e8		inx				inx 								; skip over the branch quantity
.1660	c6 05		dec $05				dec 	rsp 						; drop the indx
.1662	4c 00 00	jmp $0000			jmp 	Next
.1665					NHNoFor:
.1665	20 f4 1a	jsr $1af4			jsr 	ErrorHandler
>1668	4e 4f 20 46 4f 52 3f 00				.text 	"NO FOR?",0
.1670					GetIndex:
.1670	a4 05		ldy $05				ldy 	rsp 						; get current stack ptr
.1672	b9 80 07	lda $0780,y			lda 	returnStackX,y 				; check it's a FOR Loop
.1675	c9 ff		cmp #$ff			cmp 	#$FF
.1677	d0 ec		bne $1665			bne 	NHNoFor
.1679	a5 06		lda $06				lda 	TOS
.167b	48		pha				pha
.167c	a5 07		lda $07				lda 	TOS+1
.167e	48		pha				pha
.167f	b9 00 07	lda $0700,y			lda 	returnStackLow,y 			; put counter-1 out
.1682	38		sec				sec
.1683	e9 01		sbc #$01			sbc 	#1
.1685	85 06		sta $06				sta 	TOS
.1687	b9 40 07	lda $0740,y			lda 	returnStackHigh,y
.168a	e9 00		sbc #$00			sbc 	#0
.168c	85 07		sta $07				sta 	TOS+1
.168e	4c 00 00	jmp $0000			jmp 	Next

;******  Return to file: kernel.asm


;******  Processing file: words/structures/ifelseendif.src

.1691					IfHandler:
.1691	4c a0 16	jmp $16a0			jmp 	BranchIfZero
.1694					ElseHandler:
.1694	4c b6 16	jmp $16b6			jmp 	BranchTestSucceedsNoPop
.1697					EndIfHandler:
.1697	4c 00 00	jmp $0000			jmp 	Next

;******  Return to file: kernel.asm


;******  Processing file: words/structures/repeatuntil.src

.169a					RepeatHandler:
.169a	4c 00 00	jmp $0000			jmp 	Next
.169d					UntilHandler:
.169d	4c a0 16	jmp $16a0			jmp 	BranchIfZero

;******  Return to file: kernel.asm


;******  Processing file: words/system/branch.src

.16a0					BranchIfZero:
.16a0	a5 06		lda $06				lda 	TOS 						; check TOS = 0
.16a2	05 07		ora $07				ora 	TOS+1
.16a4	f0 0a		beq $16b0			beq 	BranchTestSucceeds
.16a6					BranchTestFails:
.16a6	68		pla				pla
.16a7	85 07		sta $07				sta 	TOS+1
.16a9	68		pla				pla
.16aa	85 06		sta $06				sta 	TOS
.16ac	e8		inx				inx 								; skip over the relative branch.
.16ad	4c 00 00	jmp $0000			jmp 	Next
.16b0					BranchTestSucceeds:
.16b0	68		pla				pla
.16b1	85 07		sta $07				sta 	TOS+1
.16b3	68		pla				pla
.16b4	85 06		sta $06				sta 	TOS
.16b6					BranchTestSucceedsNoPop:
.16b6	e8		inx				inx 								; advance by two, to the offset
.16b7	e8		inx				inx
.16b8					BranchAlways:
.16b8	8a		txa				txa 								; A = Y = position
.16b9	a8		tay				tay 								; (IP),Y now points to the branch target
.16ba	b1 03		lda ($03),y			lda 	(IP),y 						; adjust the position
.16bc	aa		tax				tax 								; position back in this line.
.16bd	4c 02 00	jmp $0002			jmp 	Next+2 						; and continue

;******  Return to file: kernel.asm


;******  Processing file: words/system/callhandler.src

.16c0					CallHandler:
.16c0	e8		inx				inx									; bump X to the call address.
.16c1	e8		inx				inx
.16c2	e6 05		inc $05				inc 	rsp 						; bump the RSP (first time to zero)
.16c4	a4 05		ldy $05				ldy 	rsp 						; get return stack and push IP/X on it.
.16c6	c0 40		cpy #$40			cpy 	#$40 						; overflow
.16c8	f0 4b		beq $1715			beq 	_CHOverflow
.16ca	a5 04		lda $04				lda 	IP+1
.16cc	99 40 07	sta $0740,y			sta 	returnStackHigh,y
.16cf	a5 03		lda $03				lda 	IP
.16d1	99 00 07	sta $0700,y			sta 	returnStackLow,y
.16d4	8a		txa				txa
.16d5	99 80 07	sta $0780,y			sta 	returnStackX,y
.16d8	8a		txa				txa 								; get the line number into temp1.
.16d9	a8		tay				tay
.16da	b1 03		lda ($03),y			lda 	(IP),y
.16dc	85 12		sta $12				sta 	temp1
.16de	c8		iny				iny
.16df	b1 03		lda ($03),y			lda 	(IP),y
.16e1	85 13		sta $13				sta 	temp1+1
.16e3	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.16e5	85 03		sta $03				sta 	0+(IP)
.16e7	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.16e9	85 04		sta $04				sta 	1+(IP)
.16eb	b2 03		lda ($03)			lda 	(IP)						; no program code ?
.16ed	f0 17		beq $1706			beq 	_CHFail
.16ef	a0 01		ldy #$01			ldy 	#1 							; Y = 1 throughout.
.16f1					_CHSearch:
.16f1	b1 03		lda ($03),y			lda 	(IP),y 						; check LSB of line number
.16f3	c5 12		cmp $12				cmp 	temp1
.16f5	f0 2d		beq $1724			beq 	_CHFoundLSB
.16f7					_CHSearchNext:
.16f7	18		clc				clc
.16f8	a5 03		lda $03				lda 	IP
.16fa	72 03		adc ($03)			adc 	(IP)
.16fc	85 03		sta $03				sta 	IP
.16fe	90 02		bcc $1702			bcc 	_NoCarryAdv
.1700	e6 04		inc $04				inc 	IP+1
.1702					_NoCarryAdv:
.1702	b2 03		lda ($03)			lda 	(IP)						; check reached the end.
.1704	d0 eb		bne $16f1			bne 	_CHSearch
.1706					_CHFail:
.1706	20 f4 1a	jsr $1af4			jsr 	ErrorHandler
>1709	44 45 46 49 4e 49 54 49				.text 	"DEFINITION?",0
>1711	4f 4e 3f 00
.1715					_CHOverflow:
.1715	20 f4 1a	jsr $1af4			jsr 	ErrorHandler
>1718	53 54 41 43 4b 44 45 50				.text 	"STACKDEPTH?",0
>1720	54 48 3f 00
.1724					_CHFoundLSB:
.1724	c8		iny				iny 								; get MSB
.1725	b1 03		lda ($03),y			lda 	(IP),y
.1727	88		dey				dey
.1728	c5 13		cmp $13				cmp 	temp1+1 					; matches, if not contineu
.172a	d0 cb		bne $16f7			bne 	_CHSearchNext
.172c	a0 03		ldy #$03			ldy 	#3	 						; check it begins with $$define
.172e	b1 03		lda ($03),y			lda 	(IP),y
.1730	c9 f2		cmp #$f2			cmp 	#DefineCode & $FF
.1732	d0 d2		bne $1706			bne 	_CHFail
.1734	c8		iny				iny
.1735	b1 03		lda ($03),y			lda 	(IP),y
.1737	c9 18		cmp #$18			cmp 	#DefineCode >> 8
.1739	d0 cb		bne $1706			bne 	_CHFail
.173b	c8		iny				iny
.173c	b1 03		lda ($03),y			lda 	(IP),y 						; this is the length of the define name
.173e	18		clc				clc
.173f	69 05		adc #$05			adc 	#5 							; $$define token, line number, offset
.1741	aa		tax				tax
.1742	4c 02 00	jmp $0002			jmp 	Next+2 						; and execute
.1745					ReturnHandler:
.1745	a4 05		ldy $05				ldy 	rsp 						; get rsp
.1747	30 15		bmi $175e			bmi 	_RHUnderflow 				; if -ve underflowed
.1749	c6 05		dec $05				dec 	rsp 						; decrement rsp
.174b	b9 40 07	lda $0740,y			lda 	returnStackHigh,y 			; restore IP/X
.174e	85 04		sta $04				sta 	IP+1
.1750	b9 00 07	lda $0700,y			lda 	returnStackLow,y
.1753	85 03		sta $03				sta 	IP
.1755	b9 80 07	lda $0780,y			lda 	returnStackX,y
.1758	aa		tax				tax
.1759	f0 0e		beq $1769			beq 	_RHInLoop 					; this means you have done :something for ; next
.175b	4c 00 00	jmp $0000			jmp 	Next
.175e					_RHUnderflow:
.175e	20 f4 1a	jsr $1af4			jsr 	ErrorHandler
>1761	52 45 54 55 52 4e 3f 00				.text 	"RETURN?",0
.1769					_RHInLoop:
.1769	20 f4 1a	jsr $1af4			jsr 	ErrorHandler
>176c	52 45 54 55 52 4e 20 49				.text 	"RETURN IN LOOP?",0
>1774	4e 20 4c 4f 4f 50 3f 00

;******  Return to file: kernel.asm


;******  Processing file: words/system/clrnew.src

.177c					NewHandler:
.177c	9c 00 40	stz $4000			stz 	ProgramMemory 				; Make the first offset zero.
.177f	20 8b 17	jsr $178b			jsr 	ClearVariableSpace 			; clear variables, reset pointers
.1782	4c 00 00	jmp $0000			jmp 	Next
.1785					ClrHandler:
.1785	20 8b 17	jsr $178b			jsr 	ClearVariableSpace 			; clear variables, reset pointers
.1788	4c 00 00	jmp $0000			jmp 	Next
.178b					ClearVariableSpace:
.178b	a9 ff		lda #$ff			lda 	#$FF 						; empty return stack
.178d	85 05		sta $05				sta 	rsp
.178f	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.1791	85 0e		sta $0e				sta 	0+(nextFreeMem)
.1793	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.1795	85 0f		sta $0f				sta 	1+(nextFreeMem)
.1797	a0 1f		ldy #$1f			ldy 	#hashTableSize*2-1 			; erase the hash table (used for variables)
.1799					_CVSHashClear:
.1799	a9 00		lda #$00			lda 	#0 							; all the first record pointers are $00
.179b	99 40 06	sta $0640,y			sta 	hashTable,y
.179e	88		dey				dey
.179f	10 f8		bpl $1799			bpl 	_CVSHashClear
.17a1					_CVSFindEnd:
.17a1	18		clc				clc
.17a2	a5 0e		lda $0e				lda 	nextFreeMem
.17a4	72 0e		adc ($0e)			adc 	(nextFreeMem)
.17a6	85 0e		sta $0e				sta 	nextFreeMem
.17a8	90 02		bcc $17ac			bcc 	_NoCarryAdv
.17aa	e6 0f		inc $0f				inc 	nextFreeMem+1
.17ac					_NoCarryAdv:
.17ac	b2 0e		lda ($0e)			lda 	(nextFreeMem)
.17ae	d0 f1		bne $17a1			bne 	_CVSFindEnd
.17b0	a9 08		lda #$08			lda 	#8 							; this puts a gap in, more for clarity than anything.
.17b2	a0 00		ldy #$00			ldy 	#0
.17b4	20 b8 17	jsr $17b8			jsr 	AdvanceFreeMem				; we need +1 because the previous code leaves the
.17b7	60		rts				rts 								; free mem pointer pointing to the last zero offset
.17b8					AdvanceFreeMem:
.17b8	18		clc				clc
.17b9	65 0e		adc $0e				adc 	nextFreeMem
.17bb	85 0e		sta $0e				sta 	nextFreeMem
.17bd	98		tya				tya
.17be	65 0f		adc $0f				adc 	nextFreeMem+1
.17c0	85 0f		sta $0f				sta 	nextFreeMem+1
.17c2	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/debug.src

.17c3					ExitDump:
.17c3	ba		tsx				tsx 								; save Data Stack in temp1
.17c4	86 12		stx $12				stx 	temp1
.17c6	4c ff ff	jmp $ffff			jmp 	$FFFF 						; makes the X16-Emulator dump-exit.
.17c9					BreakCmd:
>17c9	ff						.byte 	$FF
.17ca	4c 00 00	jmp $0000			jmp 	Next

;******  Return to file: kernel.asm


;******  Processing file: words/system/miscellany.src

.17cd					Call6502:
.17cd	a5 06		lda $06				lda 	TOS 						; copy call address
.17cf	85 12		sta $12				sta 	temp1
.17d1	a5 07		lda $07				lda 	TOS+1
.17d3	85 13		sta $13				sta 	temp1+1
.17d5	68		pla				pla
.17d6	85 07		sta $07				sta 	TOS+1
.17d8	68		pla				pla
.17d9	85 06		sta $06				sta 	TOS
.17db	20 e1 17	jsr $17e1			jsr 	_CallTemp1 					; call it
.17de	4c 00 00	jmp $0000			jmp 	Next
.17e1					_CallTemp1:
.17e1	6c 12 00	jmp ($0012)			jmp 	(temp1)
.17e4					AssertCode:
.17e4	a5 06		lda $06				lda 	TOS 						; TOS = 0
.17e6	05 07		ora $07				ora 	TOS+1
.17e8	f0 09		beq $17f3			beq 	_ASFail 					; if zero fail
.17ea	68		pla				pla
.17eb	85 07		sta $07				sta 	TOS+1
.17ed	68		pla				pla
.17ee	85 06		sta $06				sta 	TOS
.17f0	4c 00 00	jmp $0000			jmp 	Next
.17f3					_ASFail:
.17f3	20 f4 1a	jsr $1af4			jsr 	ErrorHandler
>17f6	41 53 53 45 52 54 00				.text 	"ASSERT",0
.17fd					StopCode:
.17fd	20 f4 1a	jsr $1af4			jsr 	ErrorHandler
>1800	53 54 4f 50 00					.text 	"STOP",0
.1805					EndProgram:
.1805	4c f1 1a	jmp $1af1			jmp 	WarmStart

;******  Return to file: kernel.asm


;******  Processing file: words/system/toint.src

.1808					NumToInt:
.1808	a5 06		lda $06				lda 	TOS 						; TOS to temp4
.180a	85 18		sta $18				sta 	temp4
.180c	a5 07		lda $07				lda		TOS+1
.180e	85 19		sta $19				sta 	temp4+1
.1810	20 31 18	jsr $1831			jsr 	ConvertToInteger
.1813	90 0f		bcc $1824			bcc 	_NTIFail
.1815	a5 16		lda $16				lda 	temp3
.1817	48		pha				pha
.1818	a5 17		lda $17				lda 	temp3+1
.181a	48		pha				pha
.181b	a9 ff		lda #$ff			lda 	#$FF 						; TOS = -1
.181d	85 06		sta $06				sta 	TOS
.181f	85 07		sta $07				sta 	TOS+1
.1821	4c 00 00	jmp $0000			jmp 	Next
.1824					_NTIFail:
.1824	64 06		stz $06				stz 	TOS 						; zero TOS and push on stack as null answer
.1826	64 07		stz $07				stz 	TOS+1
.1828	a5 06		lda $06				lda 	TOS
.182a	48		pha				pha
.182b	a5 07		lda $07				lda 	TOS+1
.182d	48		pha				pha
.182e	4c 00 00	jmp $0000			jmp 	Next
.1831					ConvertToInteger:
.1831	64 16		stz $16				stz 	temp3 						; reset value
.1833	64 17		stz $17				stz 	temp3+1
.1835	64 12		stz $12				stz 	temp1 						; temp1 = 0 (decimal) 255 (hex)
.1837	a0 00		ldy #$00			ldy 	#0 							; look at first character
.1839	b1 18		lda ($18),y			lda 	(temp4),y
.183b	49 2d		eor #$2d			eor 	#"-"						; zero if '-'
.183d	85 13		sta $13				sta 	temp1+1 					; save this in temp1+1
.183f	d0 01		bne $1842			bne 	_CTINotMinus
.1841	c8		iny				iny									; skip -
.1842					_CTINotMinus:
.1842	b1 18		lda ($18),y			lda 	(temp4),y
.1844	c9 24		cmp #$24			cmp		#'$'						; if $ then skip it and set hex flag
.1846	d0 03		bne $184b			bne 	_CTILoop
.1848	c6 12		dec $12				dec 	temp1
.184a	c8		iny				iny
.184b					_CTILoop:
.184b	b1 18		lda ($18),y			lda 	(temp4),y 					; next digit
.184d	29 7f		and #$7f			and 	#$7F 						; drop end of word flag
.184f	38		sec				sec
.1850	e9 30		sbc #$30			sbc 	#'0' 						; put in range '0'+
.1852	90 62		bcc $18b6			bcc 	_CTIFail 					; out of range.
.1854	c9 0a		cmp #$0a			cmp 	#10 						; in 0-9 ?
.1856	90 0b		bcc $1863			bcc 	_CTILegal
.1858	c9 11		cmp #$11			cmp 	#'A'-'0'					; between 9 and A ?
.185a	90 5a		bcc $18b6			bcc 	_CTIFail
.185c	38		sec				sec
.185d	e9 07		sbc #$07			sbc 	#7 							; hex adjust
.185f	c9 10		cmp #$10			cmp 	#16 						; out of range ?
.1861	b0 53		bcs $18b6			bcs 	_CTIFail
.1863					_CTILegal:
.1863	48		pha				pha 								; save digit value.
.1864	06 16		asl $16				asl 	temp3
.1866	26 17		rol $17				rol 	temp3+1
.1868	a5 16		lda $16				lda 	temp3 						; copy x2 into temp2
.186a	85 14		sta $14				sta 	temp2
.186c	a5 17		lda $17				lda 	temp3+1
.186e	85 15		sta $15				sta 	temp2+1
.1870	06 16		asl $16				asl 	temp3
.1872	26 17		rol $17				rol 	temp3+1
.1874	06 16		asl $16				asl 	temp3
.1876	26 17		rol $17				rol 	temp3+1
.1878	24 12		bit $12				bit 	temp1 						; hexadecimal
.187a	10 07		bpl $1883			bpl 	_CTIDecimal
.187c	06 16		asl $16				asl 	temp3
.187e	26 17		rol $17				rol 	temp3+1
.1880	68		pla				pla 								; get digit back
.1881	80 12		bra $1895			bra 	_CTIAddLoop
.1883					_CTIDecimal:
.1883	18		clc				clc 								; x 8 + x 2 = x 10
.1884	a5 16		lda $16				lda 	temp3
.1886	65 14		adc $14				adc 	temp2
.1888	85 16		sta $16				sta 	temp3
.188a	a5 17		lda $17				lda 	temp3+1
.188c	65 15		adc $15				adc 	temp2+1
.188e	85 17		sta $17				sta 	temp3+1
.1890	68		pla				pla 					; check digit 0-9
.1891	c9 0a		cmp #$0a			cmp 	#10
.1893	b0 21		bcs $18b6			bcs 	_CTIFail
.1895					_CTIAddLoop:
.1895	18		clc				clc
.1896	65 16		adc $16				adc 	temp3
.1898	85 16		sta $16				sta 	temp3
.189a	90 02		bcc $189e			bcc 	_CTINoCarry
.189c	e6 17		inc $17				inc 	temp3+1
.189e					_CTINoCarry:
.189e	c8		iny				iny
.189f	b1 18		lda ($18),y			lda 	(temp4),y 					; was this the last character
.18a1	d0 a8		bne $184b			bne 	_CTILoop 					; no, go back.
.18a3	a5 13		lda $13				lda 	temp1+1 					; was it - ?
.18a5	d0 0d		bne $18b4			bne 	_CTIOkay
.18a7	38		sec				sec
.18a8	a9 00		lda #$00			lda 	#0 							; negate temp3.
.18aa	e5 16		sbc $16				sbc 	temp3
.18ac	85 16		sta $16				sta 	temp3
.18ae	a9 00		lda #$00			lda 	#0
.18b0	e5 17		sbc $17				sbc 	temp3+1
.18b2	85 17		sta $17				sta 	temp3+1
.18b4					_CTIOkay:
.18b4	38		sec				sec
.18b5	60		rts				rts
.18b6					_CTIFail:
.18b6	18		clc				clc
.18b7	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/skipper.src

.18b8					NextLine:
.18b8	18		clc				clc
.18b9	a5 03		lda $03				lda 	IP
.18bb	72 03		adc ($03)			adc 	(IP)
.18bd	85 03		sta $03				sta 	IP
.18bf	90 02		bcc $18c3			bcc 	_NoCarryAdv
.18c1	e6 04		inc $04				inc 	IP+1
.18c3					_NoCarryAdv:
.18c3	b2 03		lda ($03)			lda 	(IP)						; is there any following program ?
.18c5	f0 05		beq $18cc			beq 	_NLGoEnd
.18c7	a2 03		ldx #$03			ldx 	#3 							; start 3 in
.18c9	4c 02 00	jmp $0002			jmp 	Next+2 						; avoid the first two INXs
.18cc					_NLGoEnd:
.18cc	4c f1 1a	jmp $1af1			jmp 	WarmStart
.18cf					SkipComment:
.18cf	e8		inx				inx									; (IP),X points to the length.
.18d0	e8		inx				inx
.18d1	8a		txa				txa
.18d2	a8		tay				tay 								; put into Y
.18d3	18		clc				clc
.18d4	71 03		adc ($03),y			adc 	(IP),y 						; add the length to X
.18d6	aa		tax				tax 								; put back in X
.18d7	4c 02 00	jmp $0002			jmp 	Next+2 						; continue skipping the pre-increment.
.18da					CommentDecoder:
.18da	a9 20		lda #$20			lda 	#32
.18dc	20 78 11	jsr $1178			jsr 	DecodeWriteBuffer
.18df	a9 27		lda #$27			lda 	#"'"
.18e1	20 78 11	jsr $1178			jsr 	DecodeWriteBuffer
.18e4	a9 20		lda #$20			lda 	#32
.18e6	20 78 11	jsr $1178			jsr 	DecodeWriteBuffer
.18e9	20 81 11	jsr $1181			jsr 	DecodeOutputData
.18ec	a9 20		lda #$20			lda 	#32
.18ee	20 78 11	jsr $1178			jsr 	DecodeWriteBuffer
.18f1	60		rts				rts
.18f2					DefineCode:
.18f2	20 f4 1a	jsr $1af4			jsr 	ErrorHandler
>18f5	44 45 46 49 4e 49 54 49				.text 	"DEFINITION?",0
>18fd	4f 4e 3f 00
.1901					DefineDecoder:
.1901	a9 20		lda #$20			lda 	#32
.1903	20 78 11	jsr $1178			jsr 	DecodeWriteBuffer
.1906	a9 3a		lda #$3a			lda 	#":"
.1908	20 78 11	jsr $1178			jsr 	DecodeWriteBuffer
.190b	20 81 11	jsr $1181			jsr 	DecodeOutputData
.190e	a9 20		lda #$20			lda 	#32
.1910	20 78 11	jsr $1178			jsr 	DecodeWriteBuffer
.1913	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/tostr.src

.1914					IntToString:
.1914	a9 10		lda #$10			lda 	#(textBuffer) & $FF
.1916	85 14		sta $14				sta 	0+(temp2)
.1918	a9 08		lda #$08			lda 	#(textBuffer) >> 8
.191a	85 15		sta $15				sta 	1+(temp2)
.191c	a5 06		lda $06				lda 	TOS 						; value in YA
.191e	a4 07		ldy $07				ldy 	TOS+1
.1920	20 2e 19	jsr $192e			jsr 	ConvertToString
.1923	a9 10		lda #$10			lda 	#(textBuffer) & $FF
.1925	85 06		sta $06				sta 	0+(TOS)
.1927	a9 08		lda #$08			lda 	#(textBuffer) >> 8
.1929	85 07		sta $07				sta 	1+(TOS)
.192b	4c 00 00	jmp $0000			jmp 	Next
.192e					ConvertToString:
.192e	38		sec				sec
.192f	80 01		bra $1932			bra 	ConvertToStringMain
.1931					ConvertToStringUnsigned:
.1931	18		clc				clc
.1932					ConvertToStringMain:
.1932	da		phx				phx									; save XY
.1933	5a		phy				phy
.1934	64 1a		stz $1a				stz 	SignCount 					; this is zero suppression
.1936	85 12		sta $12				sta 	temp1 						; save YA in temp1
.1938	84 13		sty $13				sty 	temp1+1
.193a	a0 00		ldy #$00			ldy 	#0 							; index to result.
.193c	90 16		bcc $1954			bcc 	_CTSUnsigned 				; if carry clear do not adjust for -
.193e	a5 13		lda $13				lda 	temp1+1 					; is it negative
.1940	10 12		bpl $1954			bpl 	_CTSUnsigned
.1942	a9 2d		lda #$2d			lda 	#"-"						; output - sign
.1944	91 14		sta ($14),y			sta 	(temp2),y
.1946	c8		iny				iny
.1947	38		sec				sec 								; negate temp1
.1948	a9 00		lda #$00			lda 	#0
.194a	e5 12		sbc $12				sbc 	temp1
.194c	85 12		sta $12				sta 	temp1
.194e	a9 00		lda #$00			lda 	#0
.1950	e5 13		sbc $13				sbc 	temp1+1
.1952	85 13		sta $13				sta 	temp1+1
.1954					_CTSUnsigned:
.1954	a2 00		ldx #$00			ldx 	#0 							; index into subtraction table
.1956					_CTSLoop:
.1956	a9 2f		lda #$2f			lda 	#"0"-1						; set the digit to '0' code.
.1958	91 14		sta ($14),y			sta 	(temp2),y
.195a					_CTSSubLoop:
.195a	b1 14		lda ($14),y			lda 	(temp2),y 					; bump the count
.195c	1a		inc a				inc 	a
.195d	91 14		sta ($14),y			sta 	(temp2),y
.195f	38		sec				sec 								; do subtraction saving interim result
.1960	a5 12		lda $12				lda 	temp1
.1962	fd 95 19	sbc $1995,x			sbc 	_CTSTable,x
.1965	48		pha				pha
.1966	a5 13		lda $13				lda 	temp1+1
.1968	fd 96 19	sbc $1996,x			sbc 	_CTSTable+1,x
.196b	90 07		bcc $1974			bcc 	_CTSCantSubtract 			; end of subtraction.
.196d	85 13		sta $13				sta 	temp1+1 					; save result back
.196f	68		pla				pla
.1970	85 12		sta $12				sta 	temp1
.1972	80 e6		bra $195a			bra 	_CTSSubLoop
.1974					_CTSCantSubtract:
.1974	68		pla				pla 								; throw away interim
.1975	e8		inx				inx 								; next subtractor
.1976	e8		inx				inx
.1977	b1 14		lda ($14),y			lda 	(temp2),y 					; update leading zero
.1979	49 30		eor #$30			eor 	#"0"
.197b	05 1a		ora $1a				ora 	SignCount
.197d	85 1a		sta $1a				sta 	SignCount
.197f	f0 01		beq $1982			beq		_CTSLZ 						; if all zeros so far suppress.
.1981	c8		iny				iny 								; next character
.1982					_CTSLZ:
.1982	e0 08		cpx #$08			cpx 	#_CTSTableEnd-_CTSTable 	; done them all ?
.1984	d0 d0		bne $1956			bne 	_CTSLoop
.1986					_CTSComplete:
.1986	a5 12		lda $12				lda		temp1 						; get remainder 0-9
.1988	09 30		ora #$30			ora 	#48 						; ASCII
.198a	91 14		sta ($14),y			sta 	(temp2),y					; write out
.198c	c8		iny				iny
.198d	a9 00		lda #$00			lda 	#0							; make ASCIIZ
.198f	91 14		sta ($14),y			sta 	(temp2),y
.1991	98		tya				tya 								; size in A
.1992	7a		ply				ply									; pull and exit.
.1993	fa		plx				plx
.1994	60		rts				rts
.1995					_CTSTable:
>1995	10 27 e8 03 64 00 0a 00				.word 	10000,1000,100,10 			; subtractors, this is a simple version.
.199d					_CTSTableEnd:

;******  Return to file: kernel.asm


;******  Processing file: words/system/varhandlers.src

.199d					VarAddressHandler:
.199d	18		clc				clc 								; find variable, error if it doesn't exist.
.199e	20 ef 19	jsr $19ef			jsr 	VariableFind
.19a1	a5 06		lda $06				lda 	TOS
.19a3	48		pha				pha
.19a4	a5 07		lda $07				lda 	TOS+1
.19a6	48		pha				pha
.19a7	a5 12		lda $12				lda 	temp1 						; the address is the new value
.19a9	85 06		sta $06				sta 	TOS
.19ab	a5 13		lda $13				lda		temp1+1
.19ad	85 07		sta $07				sta 	TOS+1
.19af	4c 00 00	jmp $0000			jmp 	Next
.19b2					VarAddrHandlerDecode:
.19b2	a9 26		lda #$26			lda 	#"&"
.19b4	4c 9d 1a	jmp $1a9d			jmp 	VarHandlerDecode
.19b7					VarReadHandler:
.19b7	18		clc				clc 								; find variable, error if it doesn't exist.
.19b8	20 ef 19	jsr $19ef			jsr 	VariableFind
.19bb	a5 06		lda $06				lda 	TOS
.19bd	48		pha				pha
.19be	a5 07		lda $07				lda 	TOS+1
.19c0	48		pha				pha
.19c1	b2 12		lda ($12)			lda 	(temp1)						; read variable address to TOS
.19c3	85 06		sta $06				sta 	TOS
.19c5	a0 01		ldy #$01			ldy 	#1
.19c7	b1 12		lda ($12),y			lda 	(temp1),y
.19c9	85 07		sta $07				sta 	TOS+1
.19cb	4c 00 00	jmp $0000			jmp 	Next
.19ce					VarReadHandlerDecode:
.19ce	a9 40		lda #$40			lda 	#"@"
.19d0	4c 9d 1a	jmp $1a9d			jmp 	VarHandlerDecode
.19d3					VarWriteHandler:
.19d3	38		sec				sec 								; find variable, create it if it doesn't exist.
.19d4	20 ef 19	jsr $19ef			jsr 	VariableFind
.19d7	a5 06		lda $06				lda 	TOS 						; write TOS to that address.
.19d9	92 12		sta ($12)			sta 	(temp1)
.19db	a5 07		lda $07				lda 	TOS+1
.19dd	a0 01		ldy #$01			ldy 	#1
.19df	91 12		sta ($12),y			sta 	(temp1),y
.19e1	68		pla				pla
.19e2	85 07		sta $07				sta 	TOS+1
.19e4	68		pla				pla
.19e5	85 06		sta $06				sta 	TOS
.19e7	4c 00 00	jmp $0000			jmp 	Next
.19ea					VarWriteHandlerDecode:
.19ea	a9 21		lda #$21			lda 	#"!"
.19ec	4c 9d 1a	jmp $1a9d			jmp 	VarHandlerDecode
.19ef					VariableFind:
.19ef	08		php				php 								; save autocreate flag.
.19f0	e8		inx				inx 								; advance to/over the variable name.
.19f1	e8		inx				inx
.19f2	8a		txa				txa 								; put in Y
.19f3	a8		tay				tay
.19f4	b1 03		lda ($03),y			lda 	(IP),y 						; copy name word into temp2
.19f6	85 14		sta $14				sta 	temp2
.19f8	c8		iny				iny
.19f9	b1 03		lda ($03),y			lda 	(IP),y
.19fb	85 15		sta $15				sta 	temp2+1
.19fd	c9 1b		cmp #$1b			cmp 	#27 						; check for A-Z
.19ff	b0 0f		bcs $1a10			bcs 	_VFLong
.1a01	a5 15		lda $15				lda 	temp2+1
.1a03	d0 0b		bne $1a10			bne 	_VFLong
.1a05	a5 14		lda $14				lda 	temp2						; this is the index
.1a07	0a		asl a				asl 	a 							; double it
.1a08	85 12		sta $12				sta 	temp1
.1a0a	a9 06		lda #$06			lda 	#azVariables >> 8			; set the MSB
.1a0c	85 13		sta $13				sta 	temp1+1
.1a0e	28		plp				plp 								; throw creation flag, it always exists.
.1a0f	60		rts				rts
.1a10					_VFLong:
.1a10	a5 14		lda $14				lda 	temp2 						; built a hash table index into temp3/temp4
.1a12	6a		ror a				ror 	a
.1a13	6a		ror a				ror 	a
.1a14	6a		ror a				ror 	a
.1a15	6a		ror a				ror 	a
.1a16	45 14		eor $14				eor 	temp2
.1a18	45 15		eor $15				eor 	temp2+1
.1a1a	29 0f		and #$0f			and 	#(hashTableSize-1)			; force into range
.1a1c	0a		asl a				asl 	a
.1a1d	69 40		adc #$40			adc 	#hashTable & $FF 			; make an address of the head => temp1/3
.1a1f	85 12		sta $12				sta 	temp1
.1a21	85 16		sta $16				sta 	temp3
.1a23	a9 06		lda #$06			lda 	#hashTable >> 8
.1a25	85 13		sta $13				sta 	temp1+1
.1a27	85 17		sta $17				sta 	temp3+1
.1a29					_VFSearch:
.1a29	a0 01		ldy #$01			ldy 	#1							; read MSB of first record
.1a2b	b1 12		lda ($12),y			lda 	(temp1),y
.1a2d	f0 23		beq $1a52			beq 	_VFNotFound 				; is MSB is zero, can't be a variable record
.1a2f	a8		tay				tay 								; follow the link through.
.1a30	b2 12		lda ($12)			lda 	(temp1)
.1a32	85 12		sta $12				sta 	temp1
.1a34	84 13		sty $13				sty 	temp1+1
.1a36	a0 04		ldy #$04			ldy 	#4							; check if the name matches
.1a38	b1 12		lda ($12),y			lda 	(temp1),y
.1a3a	c5 14		cmp $14				cmp 	temp2
.1a3c	d0 eb		bne $1a29			bne 	_VFSearch 					; if it doesn't, follow the next link.
.1a3e	c8		iny				iny 								; same for 2nd byte of name
.1a3f	b1 12		lda ($12),y			lda 	(temp1),y
.1a41	c5 15		cmp $15				cmp 	temp2+1
.1a43	d0 e4		bne $1a29			bne 	_VFSearch
.1a45	18		clc				clc
.1a46	a5 12		lda $12				lda 	temp1 						; make temp1 point to the data at offset 2
.1a48	69 02		adc #$02			adc 	#2
.1a4a	85 12		sta $12				sta 	temp1
.1a4c	90 02		bcc $1a50			bcc 	_VFNoPage1
.1a4e	e6 13		inc $13				inc 	temp1+1
.1a50					_VFNoPage1:
.1a50	28		plp				plp 								; don't need to worry about creation flag
.1a51	60		rts				rts
.1a52					_VFNotFound:
.1a52	28		plp				plp 								; was carry set, e.g. create a new record if not found ?
.1a53	b0 0d		bcs $1a62			bcs 	_VFCreate
.1a55	20 f4 1a	jsr $1af4			jsr 	ErrorHandler
>1a58	56 41 52 49 41 42 4c 45				.text 	"VARIABLE?",0
>1a60	3f 00
.1a62					_VFCreate:
.1a62	a0 01		ldy #$01			ldy 	#1
.1a64	b2 16		lda ($16)			lda 	(temp3) 					; copy the head link to the first 2 bytes
.1a66	92 0e		sta ($0e)			sta 	(nextFreeMem)
.1a68	b1 16		lda ($16),y			lda 	(temp3),y
.1a6a	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.1a6c	c8		iny				iny
.1a6d	a9 00		lda #$00			lda 	#0	 						; write zero initialised data out.
.1a6f	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.1a71	c8		iny				iny
.1a72	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.1a74	c8		iny				iny
.1a75	a5 14		lda $14				lda 	temp2 						; copy the name out
.1a77	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.1a79	c8		iny				iny
.1a7a	a5 15		lda $15				lda 	temp2+1
.1a7c	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.1a7e	a0 01		ldy #$01			ldy 	#1
.1a80	a5 0e		lda $0e				lda 	nextFreeMem 				; update the head link
.1a82	92 16		sta ($16)			sta 	(temp3)
.1a84	a5 0f		lda $0f				lda 	nextFreeMem+1
.1a86	91 16		sta ($16),y			sta 	(temp3),y
.1a88	18		clc				clc
.1a89	a5 0e		lda $0e				lda 	nextFreeMem 				; put nextFreeMem+2 in temp1 (data pointer)
.1a8b	69 02		adc #$02			adc 	#2
.1a8d	85 12		sta $12				sta 	temp1
.1a8f	a5 0f		lda $0f				lda 	nextFreeMem+1
.1a91	69 00		adc #$00			adc 	#0
.1a93	85 13		sta $13				sta 	temp1+1
.1a95	a9 06		lda #$06			lda 	#6							; shift freemem pointer up 6
.1a97	a0 00		ldy #$00			ldy 	#0
.1a99	20 b8 17	jsr $17b8			jsr 	AdvanceFreeMem
.1a9c	60		rts				rts
.1a9d					VarHandlerDecode:
.1a9d	48		pha				pha 								; save, leading space
.1a9e	a9 20		lda #$20			lda 	#" "
.1aa0	20 78 11	jsr $1178			jsr 	DecodeWriteBuffer
>1aa3	ff						.byte 	$FF
.1aa4	b1 08		lda ($08),y			lda 	(srcPtr),y 					; copy to temp1
.1aa6	85 12		sta $12				sta 	temp1
.1aa8	c8		iny				iny
.1aa9	b1 08		lda ($08),y			lda 	(srcPtr),y
.1aab	85 13		sta $13				sta 	temp1+1
.1aad	a5 12		lda $12				lda 	temp1 						; output the first character
.1aaf	29 1f		and #$1f			and 	#31
.1ab1	20 e0 1a	jsr $1ae0			jsr 	VHOutVarChar
.1ab4	a2 05		ldx #$05			ldx 	#5 							; divide temp1 by 32
.1ab6					_VHDShift:
.1ab6	46 13		lsr $13				lsr 	temp1+1
.1ab8	66 12		ror $12				ror 	temp1
.1aba	ca		dex				dex
.1abb	d0 f9		bne $1ab6			bne 	_VHDShift
.1abd	a2 ff		ldx #$ff			ldx 	#255 						; now divide that by 40 by repeated subtraction.
.1abf					_VHDDiv40:
.1abf	e8		inx				inx
.1ac0	38		sec				sec
.1ac1	a5 12		lda $12				lda 	temp1
.1ac3	e9 28		sbc #$28			sbc 	#40
.1ac5	a8		tay				tay
.1ac6	a5 13		lda $13				lda 	temp1+1
.1ac8	e9 00		sbc #$00			sbc 	#0
.1aca	90 06		bcc $1ad2			bcc 	_VHDivDone
.1acc	85 13		sta $13				sta 	temp1+1
.1ace	84 12		sty $12				sty 	temp1
.1ad0	80 ed		bra $1abf			bra 	_VHDDiv40
.1ad2					_VHDivDone:
.1ad2	a5 12		lda $12				lda 	temp1 						; remainder
.1ad4	20 e0 1a	jsr $1ae0			jsr 	VHOutVarChar
.1ad7	8a		txa				txa
.1ad8	20 e0 1a	jsr $1ae0			jsr 	VHOutVarChar 				; and result.
.1adb	68		pla				pla 								; restore and write type
.1adc	20 78 11	jsr $1178			jsr 	DecodeWriteBuffer
.1adf	60		rts				rts
.1ae0					VHOutVarChar:
.1ae0	c9 00		cmp #$00			cmp 	#0
.1ae2	f0 0c		beq $1af0			beq 	_VHOExit
.1ae4	18		clc				clc
.1ae5	69 40		adc #$40			adc 	#64 						; 65-90 A-Z 91-100 0-9
.1ae7	c9 5b		cmp #$5b			cmp 	#91 						; convert back ?
.1ae9	90 02		bcc $1aed			bcc 	_VHOOut
.1aeb	e9 2b		sbc #$2b			sbc 	#91-48 						; adjust to digit
.1aed					_VHOOut:
.1aed	20 78 11	jsr $1178			jsr 	DecodeWriteBuffer
.1af0					_VHOExit:
.1af0	60		rts				rts

;******  Return to file: kernel.asm

.1af1					WarmStart:
>1af1	ff						.byte 	$FF
.1af2	a2 00		ldx #$00			ldx 	#$00
.1af4					ErrorHandler:
>1af4	ff						.byte 	$FF
.1af5	a2 5e		ldx #$5e			ldx 	#$5E
.1af7					Dictionary:

;******  Processing file: generated/dictionary.inc

>1af7	05					.byte	_end1-*
>1af8	00					.byte	$00
>1af9	ce 15					.word	WordWrite
>1afb	a1					.byte	$a1
.1afc					_end1:
>1afc	10					.byte	_end2-*
>1afd	52					.byte	$52
>1afe	d3 19					.word	VarWriteHandler
>1b00	ea 19					.word	VarWriteHandlerDecode
>1b02	24 24 21 48 41 4e 44 4c			.byte	$24,$24,$21,$48,$41,$4e,$44,$4c,$45,$d2
>1b0a	45 d2
.1b0c					_end2:
>1b0c	10					.byte	_end3-*
>1b0d	52					.byte	$52
>1b0e	9d 19					.word	VarAddressHandler
>1b10	b2 19					.word	VarAddrHandlerDecode
>1b12	24 24 26 48 41 4e 44 4c			.byte	$24,$24,$26,$48,$41,$4e,$44,$4c,$45,$d2
>1b1a	45 d2
.1b1c					_end3:
>1b1c	10					.byte	_end4-*
>1b1d	52					.byte	$52
>1b1e	b7 19					.word	VarReadHandler
>1b20	ce 19					.word	VarReadHandlerDecode
>1b22	24 24 40 48 41 4e 44 4c			.byte	$24,$24,$40,$48,$41,$4e,$44,$4c,$45,$d2
>1b2a	45 d2
.1b2c					_end4:
>1b2c	0a					.byte	_end5-*
>1b2d	42					.byte	$42
>1b2e	c0 16					.word	CallHandler
>1b30	24 24 43 41 4c cc			.byte	$24,$24,$43,$41,$4c,$cc
.1b36					_end5:
>1b36	0f					.byte	_end6-*
>1b37	53					.byte	$53
>1b38	cf 18					.word	SkipComment
>1b3a	da 18					.word	CommentDecoder
>1b3c	24 24 43 4f 4d 4d 45 4e			.byte	$24,$24,$43,$4f,$4d,$4d,$45,$4e,$d4
>1b44	d4
.1b45					_end6:
>1b45	0e					.byte	_end7-*
>1b46	53					.byte	$53
>1b47	f2 18					.word	DefineCode
>1b49	01 19					.word	DefineDecoder
>1b4b	24 24 44 45 46 49 4e c5			.byte	$24,$24,$44,$45,$46,$49,$4e,$c5
.1b53					_end7:
>1b53	0f					.byte	_end8-*
>1b54	52					.byte	$52
>1b55	21 10					.word	Literal2Byte
>1b57	37 10					.word	Literal2ByteDecode
>1b59	24 24 4c 49 54 45 52 41			.byte	$24,$24,$4c,$49,$54,$45,$52,$41,$cc
>1b61	cc
.1b62					_end8:
>1b62	0e					.byte	_end9-*
>1b63	80					.byte	$80
>1b64	b8 18					.word	NextLine
>1b66	24 24 4e 45 58 54 4c 49			.byte	$24,$24,$4e,$45,$58,$54,$4c,$49,$4e,$c5
>1b6e	4e c5
.1b70					_end9:
>1b70	0e					.byte	_end10-*
>1b71	53					.byte	$53
>1b72	49 10					.word	LiteralString
>1b74	66 10					.word	LiteralStringDecoder
>1b76	24 24 53 54 52 49 4e c7			.byte	$24,$24,$53,$54,$52,$49,$4e,$c7
.1b7e					_end10:
>1b7e	05					.byte	_end11-*
>1b7f	00					.byte	$00
>1b80	4a 13					.word	Multiply16x16
>1b82	aa					.byte	$aa
.1b83					_end11:
>1b83	05					.byte	_end12-*
>1b84	00					.byte	$00
>1b85	b7 11					.word	Add
>1b87	ab					.byte	$ab
.1b88					_end12:
>1b88	06					.byte	_end13-*
>1b89	00					.byte	$00
>1b8a	df 15					.word	WordAdd
>1b8c	2b a1					.byte	$2b,$a1
.1b8e					_end13:
>1b8e	05					.byte	_end14-*
>1b8f	00					.byte	$00
>1b90	c6 11					.word	Subtract
>1b92	ad					.byte	$ad
.1b93					_end14:
>1b93	06					.byte	_end15-*
>1b94	00					.byte	$00
>1b95	86 14					.word	ConstantMinus1
>1b97	2d b1					.byte	$2d,$b1
.1b99					_end15:
>1b99	05					.byte	_end16-*
>1b9a	00					.byte	$00
>1b9b	9b 12					.word	Divide16x16
>1b9d	af					.byte	$af
.1b9e					_end16:
>1b9e	05					.byte	_end17-*
>1b9f	00					.byte	$00
>1ba0	79 14					.word	Constant0
>1ba2	b0					.byte	$b0
.1ba3					_end17:
>1ba3	06					.byte	_end18-*
>1ba4	00					.byte	$00
>1ba5	df 13					.word	CheckMinus
>1ba7	30 bc					.byte	$30,$bc
.1ba9					_end18:
>1ba9	06					.byte	_end19-*
>1baa	00					.byte	$00
>1bab	f3 13					.word	CheckZero
>1bad	30 bd					.byte	$30,$bd
.1baf					_end19:
>1baf	05					.byte	_end20-*
>1bb0	00					.byte	$00
>1bb1	95 14					.word	C1
>1bb3	b1					.byte	$b1
.1bb4					_end20:
>1bb4	06					.byte	_end21-*
>1bb5	00					.byte	$00
>1bb6	89 13					.word	Unary1Plus
>1bb8	31 ab					.byte	$31,$ab
.1bba					_end21:
>1bba	06					.byte	_end22-*
>1bbb	00					.byte	$00
>1bbc	a0 13					.word	Unary1Minus
>1bbe	31 ad					.byte	$31,$ad
.1bc0					_end22:
>1bc0	06					.byte	_end23-*
>1bc1	00					.byte	$00
>1bc2	ad 14					.word	C10
>1bc4	31 b0					.byte	$31,$b0
.1bc6					_end23:
>1bc6	07					.byte	_end24-*
>1bc7	00					.byte	$00
>1bc8	d6 14					.word	C100
>1bca	31 30 b0				.byte	$31,$30,$b0
.1bcd					_end24:
>1bcd	08					.byte	_end25-*
>1bce	00					.byte	$00
>1bcf	05 15					.word	C1024
>1bd1	31 30 32 b4				.byte	$31,$30,$32,$b4
.1bd5					_end25:
>1bd5	07					.byte	_end26-*
>1bd6	00					.byte	$00
>1bd7	da 14					.word	C127
>1bd9	31 32 b7				.byte	$31,$32,$b7
.1bdc					_end26:
>1bdc	07					.byte	_end27-*
>1bdd	00					.byte	$00
>1bde	de 14					.word	C128
>1be0	31 32 b8				.byte	$31,$32,$b8
.1be3					_end27:
>1be3	06					.byte	_end28-*
>1be4	00					.byte	$00
>1be5	b1 14					.word	C15
>1be7	31 b5					.byte	$31,$b5
.1be9					_end28:
>1be9	06					.byte	_end29-*
>1bea	00					.byte	$00
>1beb	b5 14					.word	C16
>1bed	31 b6					.byte	$31,$b6
.1bef					_end29:
>1bef	07					.byte	_end30-*
>1bf0	00					.byte	$00
>1bf1	17 14					.word	Times16
>1bf3	31 36 aa				.byte	$31,$36,$aa
.1bf6					_end30:
>1bf6	07					.byte	_end31-*
>1bf7	00					.byte	$00
>1bf8	2a 14					.word	Divide16
>1bfa	31 36 af				.byte	$31,$36,$af
.1bfd					_end31:
>1bfd	05					.byte	_end32-*
>1bfe	00					.byte	$00
>1bff	99 14					.word	C2
>1c01	b2					.byte	$b2
.1c02					_end32:
>1c02	06					.byte	_end33-*
>1c03	00					.byte	$00
>1c04	23 14					.word	Times2
>1c06	32 aa					.byte	$32,$aa
.1c08					_end33:
>1c08	06					.byte	_end34-*
>1c09	00					.byte	$00
>1c0a	92 13					.word	Unary2Plus
>1c0c	32 ab					.byte	$32,$ab
.1c0e					_end34:
>1c0e	06					.byte	_end35-*
>1c0f	00					.byte	$00
>1c10	ab 13					.word	Unary2Minus
>1c12	32 ad					.byte	$32,$ad
.1c14					_end35:
>1c14	06					.byte	_end36-*
>1c15	00					.byte	$00
>1c16	36 14					.word	Divide2
>1c18	32 af					.byte	$32,$af
.1c1a					_end36:
>1c1a	06					.byte	_end37-*
>1c1b	00					.byte	$00
>1c1c	b9 14					.word	C24
>1c1e	32 b4					.byte	$32,$b4
.1c20					_end37:
>1c20	07					.byte	_end38-*
>1c21	00					.byte	$00
>1c22	e2 14					.word	C255
>1c24	32 35 b5				.byte	$32,$35,$b5
.1c27					_end38:
>1c27	07					.byte	_end39-*
>1c28	00					.byte	$00
>1c29	ed 14					.word	C256
>1c2b	32 35 b6				.byte	$32,$35,$b6
.1c2e					_end39:
>1c2e	08					.byte	_end40-*
>1c2f	00					.byte	$00
>1c30	3d 14					.word	Times256
>1c32	32 35 36 aa				.byte	$32,$35,$36,$aa
.1c36					_end40:
>1c36	08					.byte	_end41-*
>1c37	00					.byte	$00
>1c38	46 14					.word	Divide256
>1c3a	32 35 36 af				.byte	$32,$35,$36,$af
.1c3e					_end41:
>1c3e	05					.byte	_end42-*
>1c3f	00					.byte	$00
>1c40	9d 14					.word	C3
>1c42	b3					.byte	$b3
.1c43					_end42:
>1c43	06					.byte	_end43-*
>1c44	00					.byte	$00
>1c45	ca 14					.word	C32
>1c47	33 b2					.byte	$33,$b2
.1c49					_end43:
>1c49	09					.byte	_end44-*
>1c4a	00					.byte	$00
>1c4b	1d 15					.word	C32767
>1c4d	33 32 37 36 b7				.byte	$33,$32,$37,$36,$b7
.1c52					_end44:
>1c52	09					.byte	_end45-*
>1c53	00					.byte	$00
>1c54	29 15					.word	C32768
>1c56	33 32 37 36 b8				.byte	$33,$32,$37,$36,$b8
.1c5b					_end45:
>1c5b	05					.byte	_end46-*
>1c5c	00					.byte	$00
>1c5d	a1 14					.word	C4
>1c5f	b4					.byte	$b4
.1c60					_end46:
>1c60	06					.byte	_end47-*
>1c61	00					.byte	$00
>1c62	1f 14					.word	Times4
>1c64	34 aa					.byte	$34,$aa
.1c66					_end47:
>1c66	06					.byte	_end48-*
>1c67	00					.byte	$00
>1c68	32 14					.word	Divide4
>1c6a	34 af					.byte	$34,$af
.1c6c					_end48:
>1c6c	08					.byte	_end49-*
>1c6d	00					.byte	$00
>1c6e	11 15					.word	C4096
>1c70	34 30 39 b6				.byte	$34,$30,$39,$b6
.1c74					_end49:
>1c74	05					.byte	_end50-*
>1c75	00					.byte	$00
>1c76	a5 14					.word	C5
>1c78	b5					.byte	$b5
.1c79					_end50:
>1c79	07					.byte	_end51-*
>1c7a	00					.byte	$00
>1c7b	f9 14					.word	C512
>1c7d	35 31 b2				.byte	$35,$31,$b2
.1c80					_end51:
>1c80	06					.byte	_end52-*
>1c81	00					.byte	$00
>1c82	ce 14					.word	C63
>1c84	36 b3					.byte	$36,$b3
.1c86					_end52:
>1c86	06					.byte	_end53-*
>1c87	00					.byte	$00
>1c88	d2 14					.word	C64
>1c8a	36 b4					.byte	$36,$b4
.1c8c					_end53:
>1c8c	05					.byte	_end54-*
>1c8d	00					.byte	$00
>1c8e	a9 14					.word	C8
>1c90	b8					.byte	$b8
.1c91					_end54:
>1c91	06					.byte	_end55-*
>1c92	00					.byte	$00
>1c93	1b 14					.word	Times8
>1c95	38 aa					.byte	$38,$aa
.1c97					_end55:
>1c97	06					.byte	_end56-*
>1c98	00					.byte	$00
>1c99	2e 14					.word	Divide8
>1c9b	38 af					.byte	$38,$af
.1c9d					_end56:
>1c9d	05					.byte	_end57-*
>1c9e	40					.byte	$40
>1c9f	45 17					.word	ReturnHandler
>1ca1	bb					.byte	$bb
.1ca2					_end57:
>1ca2	05					.byte	_end58-*
>1ca3	00					.byte	$00
>1ca4	37 12					.word	CheckLess
>1ca6	bc					.byte	$bc
.1ca7					_end58:
>1ca7	06					.byte	_end59-*
>1ca8	00					.byte	$00
>1ca9	50 12					.word	CheckLessEq
>1cab	3c bd					.byte	$3c,$bd
.1cad					_end59:
>1cad	06					.byte	_end60-*
>1cae	00					.byte	$00
>1caf	00 12					.word	CheckNotEqual
>1cb1	3c be					.byte	$3c,$be
.1cb3					_end60:
>1cb3	05					.byte	_end61-*
>1cb4	00					.byte	$00
>1cb5	03 12					.word	CheckEqual
>1cb7	bd					.byte	$bd
.1cb8					_end61:
>1cb8	05					.byte	_end62-*
>1cb9	00					.byte	$00
>1cba	53 12					.word	CheckGreater
>1cbc	be					.byte	$be
.1cbd					_end62:
>1cbd	06					.byte	_end63-*
>1cbe	00					.byte	$00
>1cbf	34 12					.word	CheckGreaterEq
>1cc1	3e bd					.byte	$3e,$bd
.1cc3					_end63:
>1cc3	08					.byte	_end64-*
>1cc4	00					.byte	$00
>1cc5	3e 15					.word	TestDup
>1cc7	3f 44 55 d0				.byte	$3f,$44,$55,$d0
.1ccb					_end64:
>1ccb	05					.byte	_end65-*
>1ccc	00					.byte	$00
>1ccd	b3 15					.word	WordRead
>1ccf	c0					.byte	$c0
.1cd0					_end65:
>1cd0	07					.byte	_end66-*
>1cd1	00					.byte	$00
>1cd2	b9 13					.word	Absolute
>1cd4	41 42 d3				.byte	$41,$42,$d3
.1cd7					_end66:
>1cd7	09					.byte	_end67-*
>1cd8	00					.byte	$00
>1cd9	f6 15					.word	AllocateMemory
>1cdb	41 4c 4c 4f c3				.byte	$41,$4c,$4c,$4f,$c3
.1ce0					_end67:
>1ce0	07					.byte	_end68-*
>1ce1	00					.byte	$00
>1ce2	d9 11					.word	And
>1ce4	41 4e c4				.byte	$41,$4e,$c4
.1ce7					_end68:
>1ce7	0a					.byte	_end69-*
>1ce8	00					.byte	$00
>1ce9	e4 17					.word	AssertCode
>1ceb	41 53 53 45 52 d4			.byte	$41,$53,$53,$45,$52,$d4
.1cf1					_end69:
>1cf1	09					.byte	_end70-*
>1cf2	00					.byte	$00
>1cf3	0c 14					.word	ByteSwap
>1cf5	42 53 57 41 d0				.byte	$42,$53,$57,$41,$d0
.1cfa					_end70:
>1cfa	06					.byte	_end71-*
>1cfb	00					.byte	$00
>1cfc	c1 15					.word	ByteWrite
>1cfe	43 a1					.byte	$43,$a1
.1d00					_end71:
>1d00	06					.byte	_end72-*
>1d01	00					.byte	$00
>1d02	aa 15					.word	ByteRead
>1d04	43 c0					.byte	$43,$c0
.1d06					_end72:
>1d06	07					.byte	_end73-*
>1d07	00					.byte	$00
>1d08	85 17					.word	ClrHandler
>1d0a	43 4c d2				.byte	$43,$4c,$d2
.1d0d					_end73:
>1d0d	08					.byte	_end74-*
>1d0e	00					.byte	$00
>1d0f	35 15					.word	Drop
>1d11	44 52 4f d0				.byte	$44,$52,$4f,$d0
.1d15					_end74:
>1d15	07					.byte	_end75-*
>1d16	00					.byte	$00
>1d17	47 15					.word	Dup
>1d19	44 55 d0				.byte	$44,$55,$d0
.1d1c					_end75:
>1d1c	08					.byte	_end76-*
>1d1d	01					.byte	$01
>1d1e	94 16					.word	ElseHandler
>1d20	45 4c 53 c5				.byte	$45,$4c,$53,$c5
.1d24					_end76:
>1d24	07					.byte	_end77-*
>1d25	00					.byte	$00
>1d26	05 18					.word	EndProgram
>1d28	45 4e c4				.byte	$45,$4e,$c4
.1d2b					_end77:
>1d2b	09					.byte	_end78-*
>1d2c	00					.byte	$00
>1d2d	97 16					.word	EndIfHandler
>1d2f	45 4e 44 49 c6				.byte	$45,$4e,$44,$49,$c6
.1d34					_end78:
>1d34	07					.byte	_end79-*
>1d35	00					.byte	$00
>1d36	0c 16					.word	ForHandler
>1d38	46 4f d2				.byte	$46,$4f,$d2
.1d3b					_end79:
>1d3b	06					.byte	_end80-*
>1d3c	01					.byte	$01
>1d3d	91 16					.word	IfHandler
>1d3f	49 c6					.byte	$49,$c6
.1d41					_end80:
>1d41	09					.byte	_end81-*
>1d42	00					.byte	$00
>1d43	70 16					.word	GetIndex
>1d45	49 4e 44 45 d8				.byte	$49,$4e,$44,$45,$d8
.1d4a					_end81:
>1d4a	08					.byte	_end82-*
>1d4b	00					.byte	$00
>1d4c	77 10					.word	listcode
>1d4e	4c 49 53 d4				.byte	$4c,$49,$53,$d4
.1d52					_end82:
>1d52	07					.byte	_end83-*
>1d53	00					.byte	$00
>1d54	70 12					.word	Maximum
>1d56	4d 41 d8				.byte	$4d,$41,$d8
.1d59					_end83:
>1d59	07					.byte	_end84-*
>1d5a	00					.byte	$00
>1d5b	6c 12					.word	Minimum
>1d5d	4d 49 ce				.byte	$4d,$49,$ce
.1d60					_end84:
>1d60	07					.byte	_end85-*
>1d61	00					.byte	$00
>1d62	ac 12					.word	Modulus16x16
>1d64	4d 4f c4				.byte	$4d,$4f,$c4
.1d67					_end85:
>1d67	0a					.byte	_end86-*
>1d68	00					.byte	$00
>1d69	c0 13					.word	Negate
>1d6b	4e 45 47 41 54 c5			.byte	$4e,$45,$47,$41,$54,$c5
.1d71					_end86:
>1d71	07					.byte	_end87-*
>1d72	00					.byte	$00
>1d73	7c 17					.word	NewHandler
>1d75	4e 45 d7				.byte	$4e,$45,$d7
.1d78					_end87:
>1d78	08					.byte	_end88-*
>1d79	01					.byte	$01
>1d7a	3a 16					.word	NextHandler
>1d7c	4e 45 58 d4				.byte	$4e,$45,$58,$d4
.1d80					_end88:
>1d80	07					.byte	_end89-*
>1d81	00					.byte	$00
>1d82	7b 15					.word	Nip
>1d84	4e 49 d0				.byte	$4e,$49,$d0
.1d87					_end89:
>1d87	07					.byte	_end90-*
>1d88	00					.byte	$00
>1d89	d0 13					.word	OneComplement
>1d8b	4e 4f d4				.byte	$4e,$4f,$d4
.1d8e					_end90:
>1d8e	06					.byte	_end91-*
>1d8f	00					.byte	$00
>1d90	f3 11					.word	LogOr
>1d92	4f d2					.byte	$4f,$d2
.1d94					_end91:
>1d94	08					.byte	_end92-*
>1d95	00					.byte	$00
>1d96	63 15					.word	Over
>1d98	4f 56 45 d2				.byte	$4f,$56,$45,$d2
.1d9c					_end92:
>1d9c	0a					.byte	_end93-*
>1d9d	00					.byte	$00
>1d9e	9a 16					.word	RepeatHandler
>1da0	52 45 50 45 41 d4			.byte	$52,$45,$50,$45,$41,$d4
.1da6					_end93:
>1da6	07					.byte	_end94-*
>1da7	00					.byte	$00
>1da8	4f 14					.word	RandomNumber
>1daa	52 4e c4				.byte	$52,$4e,$c4
.1dad					_end94:
>1dad	07					.byte	_end95-*
>1dae	00					.byte	$00
>1daf	80 15					.word	Rot
>1db1	52 4f d4				.byte	$52,$4f,$d4
.1db4					_end95:
>1db4	07					.byte	_end96-*
>1db5	00					.byte	$00
>1db6	fb 13					.word	SignTOS
>1db8	53 47 ce				.byte	$53,$47,$ce
.1dbb					_end96:
>1dbb	08					.byte	_end97-*
>1dbc	00					.byte	$00
>1dbd	fd 17					.word	StopCode
>1dbf	53 54 4f d0				.byte	$53,$54,$4f,$d0
.1dc3					_end97:
>1dc3	08					.byte	_end98-*
>1dc4	00					.byte	$00
>1dc5	50 15					.word	Swap
>1dc7	53 57 41 d0				.byte	$53,$57,$41,$d0
.1dcb					_end98:
>1dcb	07					.byte	_end99-*
>1dcc	00					.byte	$00
>1dcd	cd 17					.word	Call6502
>1dcf	53 59 d3				.byte	$53,$59,$d3
.1dd2					_end99:
>1dd2	0e					.byte	_end100-*
>1dd3	00					.byte	$00
>1dd4	08 18					.word	NumToInt
>1dd6	54 4f 2e 49 4e 54 45 47			.byte	$54,$4f,$2e,$49,$4e,$54,$45,$47,$45,$d2
>1dde	45 d2
.1de0					_end100:
>1de0	0d					.byte	_end101-*
>1de1	00					.byte	$00
>1de2	14 19					.word	IntToString
>1de4	54 4f 2e 53 54 52 49 4e			.byte	$54,$4f,$2e,$53,$54,$52,$49,$4e,$c7
>1dec	c7
.1ded					_end101:
>1ded	09					.byte	_end102-*
>1dee	01					.byte	$01
>1def	9d 16					.word	UntilHandler
>1df1	55 4e 54 49 cc				.byte	$55,$4e,$54,$49,$cc
.1df6					_end102:
>1df6	0a					.byte	_end103-*
>1df7	40					.byte	$40
>1df8	c9 17					.word	BreakCmd
>1dfa	58 42 52 45 41 cb			.byte	$58,$42,$52,$45,$41,$cb
.1e00					_end103:
>1e00	09					.byte	_end104-*
>1e01	00					.byte	$00
>1e02	c3 17					.word	ExitDump
>1e04	58 44 55 4d d0				.byte	$58,$44,$55,$4d,$d0
.1e09					_end104:
>1e09	07					.byte	_end105-*
>1e0a	00					.byte	$00
>1e0b	e6 11					.word	Xor
>1e0d	58 4f d2				.byte	$58,$4f,$d2
.1e10					_end105:
>1e10	00					.byte	0

;******  Return to file: kernel.asm

>3fff	ff						.byte 	$FF
.4000					ProgramMemory:

;******  End of listing
