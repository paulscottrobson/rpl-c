
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -q -c -o kernel_nocode.prg -L kernel.lst -l kernel.lbl kernel.asm
; Thu Jan 09 15:26:51 2020

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: kernel.asm

=$1000					RplBuild = $1000 							; code starts here.

;******  Processing file: data.asm

.0000					Next:
>0000							.fill 	5
=3					IP = Next+3 								; the IP which points to the current instruction
.0005					rsp:
>0005							.byte 	?
.0006					tos:
>0006							.word 	?
.0008					nextFreeMem:
>0008							.word 	?
.000a					temp1:
>000a							.word 	?
.000c					temp2:
>000c							.word 	?
.000e					temp3:
>000e							.word 	?
.0010					temp4:
>0010							.word 	?
.0012					freeMemory:
>0012							.word 	?
.0014					SignCount:
>0014							.byte 	?
.0015					RandomSeed:
>0015							.byte 	?
=$102					stack2Low = $102							; access other stack members following tsx
=$101					stack2High = $101							; (which requires saving X, not on the stack !)
=$104					stack3Low = $104
=$103					stack3High = $103
=$600					azVariables = $600 							; 26 x 2 variables occupying 52 bytes * PAGE BOUNDARY *
=16					hashTableSize = 16 							; hash tables for variables.
=$640					hashTable = $640 							; hash tables start here * ALL ON ONE PAGE *
=$810					textBuffer = $810 							; buffer for text.
=$700					returnStack = $700							; return stack (1 page)
=$700					returnStackLow = returnStack
=1856					returnStackHigh = returnStack+$40
=1920					returnStackX = returnStack+$80

;******  Return to file: kernel.asm

.1000	a2 ff		ldx #$ff			ldx 		#$FF 					; reset the stack
.1002	9a		txs				txs
.1003	a2 00		ldx #$00			ldx			#ProgramMemory & $FF	; boot address
.1005	a0 40		ldy #$40			ldy 		#ProgramMemory >>8
.1007	20 10 10	jsr $1010			jsr 		InitialiseCoreCode 		; initialise the NEXT routine at $00
.100a	20 28 16	jsr $1628			jsr 		ClearVariableSpace 		; clear variables etc.
.100d	4c 00 00	jmp $0000			jmp 		Next

;******  Processing file: core.src

.1010					InitialiseCoreCode:
.1010	a9 e8		lda #$e8			lda 	#$E8 					; Copy INX INX 			4 cycles when run
.1012	85 00		sta $00				sta 	Next
.1014	85 01		sta $01				sta 	Next+1
.1016	a9 7c		lda #$7c			lda 	#$7C 					; Copy JMP ($aaaa,x) 	6 cycles when run
.1018	85 02		sta $02				sta 	Next+2
.101a	86 03		stx $03				stx 	Next+3 					; set the indirect address (IP)
.101c	84 04		sty $04				sty 	Next+4
.101e	a2 01		ldx #$01			ldx 	#1 						; set up to run from provided word.
.1020	60		rts				rts								; (2 INX skip offset and line#)
.1021					Literal2Byte:
.1021	a5 06		lda $06				lda 	TOS
.1023	48		pha				pha
.1024	a5 07		lda $07				lda 	TOS+1
.1026	48		pha				pha
.1027	e8		inx				inx  							; point X to the word
.1028	e8		inx				inx
.1029	8a		txa				txa 							; copy into Y
.102a	a8		tay				tay
.102b	b1 03		lda ($03),y			lda 	(IP),y 					; read it. the LSB
.102d	85 06		sta $06				sta 	TOS
.102f	c8		iny				iny 							; read and push the MSB
.1030	b1 03		lda ($03),y			lda 	(IP),y
.1032	85 07		sta $07				sta 	TOS+1
.1034	4c 00 00	jmp $0000			jmp 	Next
.1037					LiteralString:
.1037	a5 06		lda $06				lda 	TOS
.1039	48		pha				pha
.103a	a5 07		lda $07				lda 	TOS+1
.103c	48		pha				pha
.103d	e8		inx				inx
.103e	e8		inx				inx 							; skip over current word
.103f	8a		txa				txa 							; add to IP + 1 to give string address
.1040	a8		tay				tay 							; put in Y
.1041	38		sec				sec 							; make that TOS
.1042	65 03		adc $03				adc 	IP
.1044	85 06		sta $06				sta 	TOS
.1046	a5 04		lda $04				lda 	IP+1
.1048	69 00		adc #$00			adc 	#0
.104a	85 07		sta $07				sta 	TOS+1
.104c	8a		txa				txa 							; add data length to X
.104d	18		clc				clc
.104e	71 03		adc ($03),y			adc 	(IP),y
.1050	aa		tax				tax
.1051	4c 02 00	jmp $0002			jmp 	Next+2 					; jump without pre-increment

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/binary.src

.1054					Add:
.1054	7a		ply				ply
.1055	68		pla				pla
.1056	18		clc				clc
.1057	65 06		adc $06				adc 	TOS
.1059	85 06		sta $06				sta 	TOS
.105b	98		tya				tya
.105c	65 07		adc $07				adc 	TOS+1
.105e	85 07		sta $07				sta 	TOS+1
.1060	4c 00 00	jmp $0000			jmp 	Next
.1063					Subtract:
.1063	7a		ply				ply
.1064	68		pla				pla
.1065	38		sec				sec
.1066	49 ff		eor #$ff			eor 	#$FF
.1068	65 06		adc $06				adc 	TOS
.106a	85 06		sta $06				sta 	TOS
.106c	98		tya				tya
.106d	49 ff		eor #$ff			eor 	#$FF
.106f	65 07		adc $07				adc 	TOS+1
.1071	85 07		sta $07				sta 	TOS+1
.1073	4c 00 00	jmp $0000			jmp 	Next
.1076					And:
.1076	68		pla				pla
.1077	25 07		and $07				and 	TOS+1
.1079	85 07		sta $07				sta 	TOS+1
.107b	68		pla				pla
.107c	25 06		and $06				and 	TOS
.107e	85 06		sta $06				sta 	TOS
.1080	4c 00 00	jmp $0000			jmp 	Next
.1083					Xor:
.1083	68		pla				pla
.1084	45 07		eor $07				eor 	TOS+1
.1086	85 07		sta $07				sta 	TOS+1
.1088	68		pla				pla
.1089	45 06		eor $06				eor 	TOS
.108b	85 06		sta $06				sta 	TOS
.108d	4c 00 00	jmp $0000			jmp 	Next
.1090					LogOr:
.1090	68		pla				pla
.1091	05 07		ora $07				ora 	TOS+1
.1093	85 07		sta $07				sta 	TOS+1
.1095	68		pla				pla
.1096	05 06		ora $06				ora 	TOS
.1098	85 06		sta $06				sta 	TOS
.109a	4c 00 00	jmp $0000			jmp 	Next

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/compare.src

.109d					CheckNotEqual:
.109d	38		sec				sec
.109e	80 01		bra $10a1			bra 	CECode
.10a0					CheckEqual:
.10a0	18		clc				clc
.10a1					CECode:
.10a1	86 0a		stx $0a				stx 	temp1
.10a3	ba		tsx				tsx
.10a4	08		php				php
.10a5	a5 06		lda $06				lda 	TOS
.10a7	5d 02 01	eor $0102,x			eor 	Stack2Low,x
.10aa	d0 17		bne $10c3			bne	 	CompareFalse
.10ac	a5 07		lda $07				lda 	TOS+1
.10ae	5d 01 01	eor $0101,x			eor 	Stack2High,x
.10b1	d0 10		bne $10c3			bne 	CompareFalse
.10b3					CompareTrue:
.10b3	a6 0a		ldx $0a				ldx 	temp1
.10b5	28		plp				plp
.10b6	b0 10		bcs $10c8			bcs		CompareFalse2
.10b8					CompareTrue2:
.10b8	68		pla				pla
.10b9	68		pla				pla
.10ba	a9 ff		lda #$ff			lda 	#$FF
.10bc	85 06		sta $06				sta 	TOS
.10be	85 07		sta $07				sta 	TOS+1
.10c0	4c 00 00	jmp $0000			jmp 	Next
.10c3					CompareFalse:
.10c3	a6 0a		ldx $0a				ldx 	temp1
.10c5	28		plp				plp
.10c6	b0 f0		bcs $10b8			bcs		CompareTrue2
.10c8					CompareFalse2:
.10c8	68		pla				pla
.10c9	68		pla				pla
.10ca	64 06		stz $06				stz 	TOS
.10cc	64 07		stz $07				stz 	TOS+1
.10ce	4c 00 00	jmp $0000			jmp 	Next
.10d1					CheckGreaterEq:
.10d1	38		sec				sec
.10d2	80 01		bra $10d5			bra		CLCode
.10d4					CheckLess:
.10d4	18		clc				clc
.10d5	86 0a		stx $0a		CLCode:	stx 	temp1
.10d7	ba		tsx				tsx
.10d8	08		php				php
.10d9	18		clc				clc
.10da	a5 06		lda $06				lda 	TOS
.10dc	fd 02 01	sbc $0102,x			sbc 	Stack2Low,x
.10df	a5 07		lda $07				lda 	TOS+1
.10e1	fd 01 01	sbc $0101,x			sbc 	Stack2High,x
.10e4	50 02		bvc $10e8			bvc 	_CLNoFlip
.10e6	49 80		eor #$80			eor 	#$80
.10e8					_CLNoFlip:
.10e8	0a		asl a				asl 	a
.10e9	b0 d8		bcs $10c3			bcs 	CompareFalse
.10eb	80 c6		bra $10b3			bra 	CompareTrue
.10ed					CheckLessEq:
.10ed	38		sec				sec
.10ee	80 01		bra $10f1			bra		CGCode
.10f0					CheckGreater:
.10f0	18		clc				clc
.10f1					CGCode:
.10f1	86 0a		stx $0a				stx 	temp1
.10f3	ba		tsx				tsx
.10f4	08		php				php
.10f5	18		clc				clc
.10f6	bd 02 01	lda $0102,x			lda 	Stack2Low,x
.10f9	e5 06		sbc $06				sbc 	TOS
.10fb	bd 01 01	lda $0101,x			lda 	Stack2High,x
.10fe	e5 07		sbc $07				sbc 	TOS+1
.1100	50 02		bvc $1104			bvc 	_CGNoFlip
.1102	49 80		eor #$80			eor 	#$80
.1104					_CGNoFlip:
.1104	0a		asl a				asl 	a
.1105	b0 bc		bcs $10c3			bcs 	CompareFalse
.1107	80 aa		bra $10b3			bra 	CompareTrue
.1109					Minimum:
.1109	a9 00		lda #$00			lda 	#0
.110b	80 02		bra $110f			bra 	MinMaxCode
.110d					Maximum:
.110d	a9 80		lda #$80			lda 	#$80
.110f					MinMaxCode:
.110f	85 0b		sta $0b				sta 	temp1+1
.1111	86 0a		stx $0a				stx 	temp1
.1113	ba		tsx				tsx
.1114	38		sec				sec
.1115	a5 06		lda $06				lda 	TOS
.1117	fd 02 01	sbc $0102,x			sbc 	Stack2Low,x
.111a	a5 07		lda $07				lda 	TOS+1
.111c	fd 01 01	sbc $0101,x			sbc 	Stack2High,x
.111f	50 02		bvc $1123			bvc 	_MMNoFlip
.1121	49 80		eor #$80			eor 	#$80
.1123					_MMNoFlip:
.1123	45 0b		eor $0b				eor 	temp1+1
.1125	30 0a		bmi $1131			bmi 	_MMNoCopy
.1127	bd 02 01	lda $0102,x			lda 	Stack2Low,x
.112a	85 06		sta $06				sta 	TOS
.112c	bd 01 01	lda $0101,x			lda 	Stack2High,x
.112f	85 07		sta $07				sta 	TOS+1
.1131					_MMNoCopy:
.1131	a6 0a		ldx $0a				ldx 	temp1
.1133	68		pla				pla
.1134	68		pla				pla
.1135	4c 00 00	jmp $0000			jmp 	Next

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/divide.src

.1138					Divide16x16:
.1138	86 0c		stx $0c				stx 	temp2
.113a	ba		tsx				tsx
.113b	20 5e 11	jsr $115e			jsr 	IntegerDivide
.113e	68		pla				pla
.113f	85 07		sta $07				sta 	TOS+1
.1141	68		pla				pla
.1142	85 06		sta $06				sta 	TOS
.1144	a6 0c		ldx $0c				ldx 	temp2
.1146	4c 00 00	jmp $0000			jmp 	Next
.1149					Modulus16x16:
.1149	86 0c		stx $0c				stx 	temp2
.114b	ba		tsx				tsx
.114c	20 5e 11	jsr $115e			jsr 	IntegerDivide
.114f	a6 0c		ldx $0c				ldx 	temp2
.1151	68		pla				pla
.1152	68		pla				pla
.1153	a5 0a		lda $0a				lda 	temp1
.1155	85 06		sta $06				sta 	TOS
.1157	a5 0b		lda $0b				lda 	temp1+1
.1159	85 07		sta $07				sta 	TOS+1
.115b	4c 00 00	jmp $0000			jmp 	Next
.115e					IntegerDivide:
.115e	a5 06		lda $06				lda 	TOS 				; check for division by zero.
.1160	05 07		ora $07				ora 	TOS+1
.1162	d0 14		bne $1178			bne 	_BFDOkay
.1164	20 d6 18	jsr $18d6			jsr 	ErrorHandler
>1167	44 49 56 49 53 49 4f 4e				.text 	"DIVISION BY ZERO",0
>116f	20 42 59 20 5a 45 52 4f 00
.1178					_BFDOkay:
.1178	64 0a		stz $0a				stz 	temp1 						; Q/Dividend/Left in +0
.117a	64 0b		stz $0b				stz 	temp1+1 					; M/Divisor/Right in +2
.117c	64 14		stz $14				stz 	SignCount 					; Count of signs.
.117e	20 b9 11	jsr $11b9			jsr 	CheckIntegerNegate 			; negate 2nd (and bump sign count)
.1181	20 d3 11	jsr $11d3			jsr 	CheckTOSNegate 				; negate TOS (and bump sign count)
.1184	5a		phy				phy 								; Y is the counter
.1185	a0 10		ldy #$10			ldy 	#16 						; 16 iterations of the loop.
.1187					_BFDLoop:
.1187	1e 02 01	asl $0102,x			asl 	Stack2Low,x 				; shift AQ left.
.118a	3e 01 01	rol $0101,x			rol 	Stack2High,x
.118d	26 0a		rol $0a				rol 	temp1
.118f	26 0b		rol $0b				rol 	temp1+1
.1191	38		sec				sec
.1192	a5 0a		lda $0a				lda 	temp1+0 					; Calculate A-M on stack.
.1194	e5 06		sbc $06				sbc 	TOS
.1196	48		pha				pha
.1197	a5 0b		lda $0b				lda 	temp1+1
.1199	e5 07		sbc $07				sbc 	TOS+1
.119b	90 0f		bcc $11ac			bcc 	_BFDNoAdd
.119d	85 0b		sta $0b				sta 	temp1+1
.119f	68		pla				pla
.11a0	85 0a		sta $0a				sta 	temp1+0
.11a2	bd 02 01	lda $0102,x			lda 	Stack2Low,x 				; set Q bit 1.
.11a5	09 01		ora #$01			ora 	#1
.11a7	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.11aa	80 01		bra $11ad			bra 	_BFDNext
.11ac					_BFDNoAdd:
.11ac	68		pla				pla 								; Throw away the intermediate calculations
.11ad					_BFDNext:
.11ad	88		dey				dey
.11ae	d0 d7		bne $1187			bne 	_BFDLoop
.11b0	7a		ply				ply 								; restore Y
.11b1	46 14		lsr $14				lsr 	SignCount 					; if sign count odd,
.11b3	90 03		bcc $11b8			bcc 	_BFDUnsigned 				; then the result is signed
.11b5	20 bf 11	jsr $11bf			jsr		IntegerNegateAlways 		; negate the result
.11b8					_BFDUnsigned:
.11b8	60		rts				rts
.11b9					CheckIntegerNegate:
.11b9	bd 01 01	lda $0101,x			lda 	Stack2High,x 				; is it -ve = MSB set ?
.11bc	30 01		bmi $11bf			bmi 	IntegerNegateAlways 		; if so negate it
.11be	60		rts				rts
.11bf					IntegerNegateAlways:
.11bf	e6 14		inc $14				inc 	SignCount 					; bump the count of signs
.11c1	38		sec				sec 								; negate
.11c2	a9 00		lda #$00			lda 	#0
.11c4	fd 02 01	sbc $0102,x			sbc 	Stack2Low,x
.11c7	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.11ca	a9 00		lda #$00			lda 	#0
.11cc	fd 01 01	sbc $0101,x			sbc 	Stack2High,x
.11cf	9d 01 01	sta $0101,x			sta 	Stack2High,x
.11d2	60		rts				rts
.11d3					CheckTOSNegate:
.11d3	a5 07		lda $07				lda 	TOS+1
.11d5	10 0f		bpl $11e6			bpl		CTNNoChange
.11d7	e6 14		inc $14				inc 	SignCount
.11d9					TOSNegateAlways:
.11d9	38		sec				sec
.11da	a9 00		lda #$00			lda 	#0
.11dc	e5 06		sbc $06				sbc 	TOS
.11de	85 06		sta $06				sta 	TOS
.11e0	a9 00		lda #$00			lda 	#0
.11e2	e5 07		sbc $07				sbc 	TOS+1
.11e4	85 07		sta $07				sta 	TOS+1
.11e6					CTNNoChange:
.11e6	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/multiply.src

.11e7					Multiply16x16:
.11e7	86 0a		stx $0a				stx 	temp1
.11e9	ba		tsx				tsx
.11ea	bd 02 01	lda $0102,x			lda 	Stack2Low,x 				; 2nd value on stack to temp1
.11ed	85 0c		sta $0c				sta 	temp2
.11ef	bd 01 01	lda $0101,x			lda		Stack2High,x
.11f2	85 0d		sta $0d				sta 	temp2+1
.11f4	9e 02 01	stz $0102,x			stz 	Stack2Low,x 				; zero 2nd value on stack
.11f7	9e 01 01	stz $0101,x			stz 	Stack2High,x
.11fa					_MultLoop:
.11fa	46 0d		lsr $0d				lsr 	temp2+1 					; ror temp2 into C
.11fc	66 0c		ror $0c				ror 	temp2
.11fe	90 11		bcc $1211			bcc 	_MultNoAdd
.1200	18		clc				clc 								; add 1st to 2nd
.1201	a5 06		lda $06				lda 	TOS
.1203	7d 02 01	adc $0102,x			adc 	Stack2Low,x
.1206	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.1209	a5 07		lda $07				lda 	TOS+1
.120b	7d 01 01	adc $0101,x			adc 	Stack2High,x
.120e	9d 01 01	sta $0101,x			sta 	Stack2High,x
.1211					_MultNoAdd:
.1211	06 06		asl $06				asl 	TOS 						; shift 1st left
.1213	26 07		rol $07				rol 	TOS+1
.1215	a5 0c		lda $0c				lda 	temp2	 					; until zero
.1217	05 0d		ora $0d				ora 	temp2+1
.1219	d0 df		bne $11fa			bne 	_MultLoop
.121b	a6 0a		ldx $0a				ldx 	temp1 						; restore X load result
.121d	68		pla				pla
.121e	85 07		sta $07				sta 	TOS+1
.1220	68		pla				pla
.1221	85 06		sta $06				sta 	TOS
.1223	4c 00 00	jmp $0000			jmp 	Next

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/unary.src

.1226					Unary1Plus:
.1226	e6 06		inc $06				inc 	TOS
.1228	d0 02		bne $122c			bne 	_U1PSkip
.122a	e6 07		inc $07				inc 	TOS+1
.122c					_U1PSkip:
.122c	4c 00 00	jmp $0000			jmp 	Next
.122f					Unary2Plus:
.122f	18		clc				clc
.1230	a5 06		lda $06				lda 	TOS
.1232	69 02		adc #$02			adc 	#2
.1234	85 06		sta $06				sta 	TOS
.1236	90 02		bcc $123a			bcc 	_U1PSkip
.1238	e6 07		inc $07				inc 	TOS+1
.123a					_U1PSkip:
.123a	4c 00 00	jmp $0000			jmp 	Next
.123d					Unary1Minus:
.123d	a5 06		lda $06				lda 	TOS
.123f	d0 02		bne $1243			bne 	_U1MSkip
.1241	c6 07		dec $07				dec 	TOS+1
.1243					_U1MSkip:
.1243	c6 06		dec $06				dec 	TOS
.1245	4c 00 00	jmp $0000			jmp 	Next
.1248					Unary2Minus:
.1248	38		sec				sec
.1249	a5 06		lda $06				lda 	TOS
.124b	e9 02		sbc #$02			sbc 	#2
.124d	85 06		sta $06				sta 	TOS
.124f	b0 02		bcs $1253			bcs 	_U1PSkip
.1251	c6 07		dec $07				dec 	TOS+1
.1253					_U1PSkip:
.1253	4c 00 00	jmp $0000			jmp 	Next
.1256					Absolute:
.1256	a5 07		lda $07				lda 	TOS+1
.1258	30 03		bmi $125d			bmi 	Negate
.125a	4c 00 00	jmp $0000			jmp 	Next
.125d					Negate:
.125d	38		sec				sec
.125e	a9 00		lda #$00			lda 	#0
.1260	e5 06		sbc $06				sbc 	TOS
.1262	85 06		sta $06				sta 	TOS
.1264	a9 00		lda #$00			lda 	#0
.1266	e5 07		sbc $07				sbc 	TOS+1
.1268	85 07		sta $07				sta 	TOS+1
.126a	4c 00 00	jmp $0000			jmp 	Next
.126d					OneComplement:
.126d	a5 06		lda $06				lda 	TOS
.126f	49 ff		eor #$ff			eor 	#$FF
.1271	85 06		sta $06				sta 	TOS
.1273	a5 07		lda $07				lda 	TOS+1
.1275	49 ff		eor #$ff			eor 	#$FF
.1277	85 07		sta $07				sta 	TOS+1
.1279	4c 00 00	jmp $0000			jmp 	Next
.127c					CheckMinus:
.127c	a5 07		lda $07				lda 	TOS+1
.127e	30 07		bmi $1287			bmi 	UnaryTrue
.1280					UnaryFalse:
.1280	64 06		stz $06				stz 	TOS
.1282	64 07		stz $07				stz 	TOS+1
.1284	4c 00 00	jmp $0000			jmp 	Next
.1287					UnaryTrue:
.1287	a9 ff		lda #$ff			lda 	#$FF
.1289	85 06		sta $06				sta 	TOS
.128b	85 07		sta $07				sta 	TOS+1
.128d	4c 00 00	jmp $0000			jmp 	Next
.1290					CheckZero:
.1290	a5 06		lda $06				lda 	TOS
.1292	05 07		ora $07				ora 	TOS+1
.1294	d0 ea		bne $1280			bne 	UnaryFalse
.1296	80 ef		bra $1287			bra 	UnaryTrue
.1298					SignTOS:
.1298	a5 07		lda $07				lda 	TOS+1
.129a	30 eb		bmi $1287			bmi		UnaryTrue
.129c	05 06		ora $06				ora 	TOS
.129e	f0 e0		beq $1280			beq 	UnaryFalse
.12a0	a9 01		lda #$01			lda 	#1
.12a2	85 06		sta $06				sta 	TOS
.12a4	64 07		stz $07				stz		TOS+1
.12a6	4c 00 00	jmp $0000			jmp 	Next
.12a9					ByteSwap:
.12a9	a5 06		lda $06				lda 	TOS
.12ab	a4 07		ldy $07				ldy 	TOS+1
.12ad	85 07		sta $07				sta 	TOS+1
.12af	84 06		sty $06				sty 	TOS
.12b1	4c 00 00	jmp $0000			jmp 	Next
.12b4					Times16:
.12b4	06 06		asl $06				asl 	TOS
.12b6	26 07		rol $07				rol 	TOS+1
.12b8					Times8:
.12b8	06 06		asl $06				asl 	TOS
.12ba	26 07		rol $07				rol 	TOS+1
.12bc					Times4:
.12bc	06 06		asl $06				asl 	TOS
.12be	26 07		rol $07				rol 	TOS+1
.12c0					Times2:
.12c0	06 06		asl $06				asl 	TOS
.12c2	26 07		rol $07				rol 	TOS+1
.12c4	4c 00 00	jmp $0000			jmp 	Next
.12c7					Divide16:
.12c7	46 07		lsr $07				lsr 	TOS+1
.12c9	66 06		ror $06				ror 	TOS
.12cb					Divide8:
.12cb	46 07		lsr $07				lsr 	TOS+1
.12cd	66 06		ror $06				ror 	TOS
.12cf					Divide4:
.12cf	46 07		lsr $07				lsr 	TOS+1
.12d1	66 06		ror $06				ror 	TOS
.12d3					Divide2:
.12d3	46 07		lsr $07				lsr 	TOS+1
.12d5	66 06		ror $06				ror 	TOS
.12d7	4c 00 00	jmp $0000			jmp 	Next
.12da					Times256:
.12da	a5 06		lda $06				lda 	TOS
.12dc	85 07		sta $07				sta 	TOS+1
.12de	64 06		stz $06				stz 	TOS
.12e0	4c 00 00	jmp $0000			jmp 	Next
.12e3					Divide256:
.12e3	a5 07		lda $07				lda 	TOS+1
.12e5	85 06		sta $06				sta 	TOS
.12e7	64 07		stz $07				stz 	TOS+1
.12e9	4c 00 00	jmp $0000			jmp 	Next
.12ec					RandomNumber:
.12ec	a5 06		lda $06				lda 	TOS
.12ee	48		pha				pha
.12ef	a5 07		lda $07				lda 	TOS+1
.12f1	48		pha				pha
.12f2	a5 15		lda $15				lda 	randomSeed
.12f4	05 16		ora $16				ora 	randomSeed+1
.12f6	d0 08		bne $1300			bne 	_RH_NoInit
.12f8	a9 7c		lda #$7c			lda 	#$7C
.12fa	85 15		sta $15				sta 	randomSeed
.12fc	a9 a1		lda #$a1			lda 	#$A1
.12fe	85 16		sta $16				sta 	randomSeed+1
.1300					_RH_NoInit:
.1300	a5 15		lda $15				lda 	randomSeed
.1302	4a		lsr a		        lsr		a
.1303	26 16		rol $16		        rol 	randomSeed+1
.1305	90 02		bcc $1309	        bcc 	_RH_NoEor
.1307	49 b4		eor #$b4	        eor 	#$B4
.1309					_RH_NoEor:
.1309	85 15		sta $15		        sta 	randomSeed
.130b	45 16		eor $16		        eor 	randomSeed+1
.130d	85 07		sta $07		        sta 	TOS+1
.130f	a5 15		lda $15		        lda 	randomSeed
.1311	85 06		sta $06		        sta 	TOS
.1313	4c 00 00	jmp $0000			jmp 	Next

;******  Return to file: kernel.asm


;******  Processing file: words/data/literals.src

.1316					Constant0:
.1316	a5 06		lda $06				lda 	TOS
.1318	48		pha				pha
.1319	a5 07		lda $07				lda 	TOS+1
.131b	48		pha				pha
.131c	64 06		stz $06				stz 	TOS
.131e	64 07		stz $07				stz 	TOS+1
.1320	4c 00 00	jmp $0000			jmp 	Next
.1323					ConstantMinus1:
.1323	a5 06		lda $06				lda 	TOS
.1325	48		pha				pha
.1326	a5 07		lda $07				lda 	TOS+1
.1328	48		pha				pha
.1329	a9 ff		lda #$ff			lda 	#$FF
.132b	85 06		sta $06				sta 	TOS
.132d	85 07		sta $07				sta 	TOS+1
.132f	4c 00 00	jmp $0000			jmp 	Next
.1332					C1:
.1332	a0 01		ldy #$01			ldy 	#1
.1334	80 24		bra $135a			bra 	Const1Byte
.1336					C2:
.1336	a0 02		ldy #$02			ldy 	#2
.1338	80 20		bra $135a			bra 	Const1Byte
.133a					C3:
.133a	a0 03		ldy #$03			ldy 	#3
.133c	80 1c		bra $135a			bra 	Const1Byte
.133e					C4:
.133e	a0 04		ldy #$04			ldy 	#4
.1340	80 18		bra $135a			bra 	Const1Byte
.1342					C5:
.1342	a0 05		ldy #$05			ldy 	#5
.1344	80 14		bra $135a			bra 	Const1Byte
.1346					C8:
.1346	a0 08		ldy #$08			ldy 	#8
.1348	80 10		bra $135a			bra 	Const1Byte
.134a					C10:
.134a	a0 0a		ldy #$0a			ldy 	#10
.134c	80 0c		bra $135a			bra 	Const1Byte
.134e					C15:
.134e	a0 0f		ldy #$0f			ldy 	#15
.1350	80 08		bra $135a			bra 	Const1Byte
.1352					C16:
.1352	a0 10		ldy #$10			ldy 	#16
.1354	80 04		bra $135a			bra 	Const1Byte
.1356					C24:
.1356	a0 18		ldy #$18			ldy 	#24
.1358	80 00		bra $135a			bra 	Const1Byte
.135a					Const1Byte:
.135a	a5 06		lda $06				lda 	TOS
.135c	48		pha				pha
.135d	a5 07		lda $07				lda 	TOS+1
.135f	48		pha				pha
.1360	84 06		sty $06				sty 	TOS
.1362	64 07		stz $07				stz 	TOS+1
.1364	4c 00 00	jmp $0000			jmp 	Next
.1367					C32:
.1367	a0 20		ldy #$20			ldy 	#32
.1369	80 ef		bra $135a			bra 	Const1Byte
.136b					C63:
.136b	a0 3f		ldy #$3f			ldy 	#63
.136d	80 eb		bra $135a			bra 	Const1Byte
.136f					C64:
.136f	a0 40		ldy #$40			ldy 	#64
.1371	80 e7		bra $135a			bra 	Const1Byte
.1373					C100:
.1373	a0 64		ldy #$64			ldy 	#100
.1375	80 e3		bra $135a			bra 	Const1Byte
.1377					C127:
.1377	a0 7f		ldy #$7f			ldy 	#127
.1379	80 df		bra $135a			bra 	Const1Byte
.137b					C128:
.137b	a0 80		ldy #$80			ldy 	#128
.137d	80 db		bra $135a			bra 	Const1Byte
.137f					C255:
.137f	a0 ff		ldy #$ff			ldy 	#255
.1381	80 d7		bra $135a			bra 	Const1Byte
.1383					Const2Byte:
.1383	85 06		sta $06				sta 	TOS
.1385	84 07		sty $07				sty 	TOS+1
.1387	4c 00 00	jmp $0000			jmp 	Next
.138a					C256:
.138a	a5 06		lda $06				lda 	TOS
.138c	48		pha				pha
.138d	a5 07		lda $07				lda 	TOS+1
.138f	48		pha				pha
.1390	a9 00		lda #$00			lda 	#(256) & $FF
.1392	a0 01		ldy #$01			ldy 	#(256) >> 8
.1394	80 ed		bra $1383			bra 	Const2Byte
.1396					C512:
.1396	a5 06		lda $06				lda 	TOS
.1398	48		pha				pha
.1399	a5 07		lda $07				lda 	TOS+1
.139b	48		pha				pha
.139c	a9 00		lda #$00			lda 	#(512) & $FF
.139e	a0 02		ldy #$02			ldy 	#(512) >> 8
.13a0	80 e1		bra $1383			bra 	Const2Byte
.13a2					C1024:
.13a2	a5 06		lda $06				lda 	TOS
.13a4	48		pha				pha
.13a5	a5 07		lda $07				lda 	TOS+1
.13a7	48		pha				pha
.13a8	a9 00		lda #$00			lda 	#(1024) & $FF
.13aa	a0 04		ldy #$04			ldy 	#(1024) >> 8
.13ac	80 d5		bra $1383			bra 	Const2Byte
.13ae					C4096:
.13ae	a5 06		lda $06				lda 	TOS
.13b0	48		pha				pha
.13b1	a5 07		lda $07				lda 	TOS+1
.13b3	48		pha				pha
.13b4	a9 00		lda #$00			lda 	#(4096) & $FF
.13b6	a0 10		ldy #$10			ldy 	#(4096) >> 8
.13b8	80 c9		bra $1383			bra 	Const2Byte
.13ba					C32767:
.13ba	a5 06		lda $06				lda 	TOS
.13bc	48		pha				pha
.13bd	a5 07		lda $07				lda 	TOS+1
.13bf	48		pha				pha
.13c0	a9 ff		lda #$ff			lda 	#(32767) & $FF
.13c2	a0 7f		ldy #$7f			ldy 	#(32767) >> 8
.13c4	80 bd		bra $1383			bra 	Const2Byte
.13c6					C32768:
.13c6	a5 06		lda $06				lda 	TOS
.13c8	48		pha				pha
.13c9	a5 07		lda $07				lda 	TOS+1
.13cb	48		pha				pha
.13cc	a9 00		lda #$00			lda 	#(32768) & $FF
.13ce	a0 80		ldy #$80			ldy 	#(32768) >> 8
.13d0	80 b1		bra $1383			bra 	Const2Byte

;******  Return to file: kernel.asm


;******  Processing file: words/data/stack.src

.13d2					Drop:
.13d2	68		pla				pla
.13d3	85 07		sta $07				sta 	TOS+1
.13d5	68		pla				pla
.13d6	85 06		sta $06				sta 	TOS
.13d8	4c 00 00	jmp $0000			jmp 	Next
.13db					TestDup:
.13db	a5 06		lda $06				lda 	TOS
.13dd	05 07		ora $07				ora 	TOS+1
.13df	d0 03		bne $13e4			bne 	Dup
.13e1	4c 00 00	jmp $0000			jmp 	Next
.13e4					Dup:
.13e4	a5 06		lda $06				lda 	TOS
.13e6	48		pha				pha
.13e7	a5 07		lda $07				lda 	TOS+1
.13e9	48		pha				pha
.13ea	4c 00 00	jmp $0000			jmp 	Next
.13ed					Swap:
.13ed	86 0a		stx $0a				stx 	temp1
.13ef	7a		ply				ply
.13f0	fa		plx				plx
.13f1	a5 06		lda $06				lda 	TOS
.13f3	48		pha				pha
.13f4	a5 07		lda $07				lda 	TOS+1
.13f6	48		pha				pha
.13f7	86 06		stx $06				stx 	TOS
.13f9	84 07		sty $07				sty 	TOS+1
.13fb	a6 0a		ldx $0a				ldx 	temp1
.13fd	4c 00 00	jmp $0000			jmp 	Next
.1400					Over:
.1400	a5 06		lda $06				lda 	TOS
.1402	48		pha				pha
.1403	a5 07		lda $07				lda 	TOS+1
.1405	48		pha				pha
.1406	86 0a		stx $0a				stx 	temp1
.1408	ba		tsx				tsx
.1409	bd 04 01	lda $0104,x			lda 	stack3low,x
.140c	85 06		sta $06				sta 	TOS
.140e	bd 03 01	lda $0103,x			lda 	stack3High,x
.1411	85 07		sta $07				sta 	TOS+1
.1413	a6 0a		ldx $0a				ldx 	temp1
.1415	4c 00 00	jmp $0000			jmp 	Next
.1418					Nip:
.1418	68		pla				pla
.1419	68		pla				pla
.141a	4c 00 00	jmp $0000			jmp 	Next
.141d					Rot:
.141d	86 0a		stx $0a				stx 	temp1
.141f	ba		tsx				tsx
.1420	bd 04 01	lda $0104,x			lda 	Stack3Low,x
.1423	a8		tay				tay
.1424	bd 02 01	lda $0102,x			lda 	Stack2Low,x
.1427	9d 04 01	sta $0104,x			sta 	Stack3Low,x
.142a	a5 06		lda $06				lda 	TOS
.142c	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.142f	84 06		sty $06				sty 	TOS
.1431	bd 03 01	lda $0103,x			lda 	Stack3High,x
.1434	a8		tay				tay
.1435	bd 01 01	lda $0101,x			lda 	Stack2High,x
.1438	9d 03 01	sta $0103,x			sta 	Stack3High,x
.143b	a5 07		lda $07				lda 	TOS+1
.143d	9d 01 01	sta $0101,x			sta 	Stack2High,x
.1440	84 07		sty $07				sty 	TOS+1
.1442	a6 0a		ldx $0a				ldx 	temp1
.1444	4c 00 00	jmp $0000			jmp 	Next

;******  Return to file: kernel.asm


;******  Processing file: words/data/memory.src

.1447					ByteRead:
.1447	b2 06		lda ($06)			lda 	(TOS)
.1449	85 06		sta $06				sta 	TOS
.144b	64 07		stz $07				stz 	TOS+1
.144d	4c 00 00	jmp $0000			jmp 	Next
.1450					WordRead:
.1450	a0 01		ldy #$01			ldy 	#1
.1452	b1 06		lda ($06),y			lda 	(TOS),y
.1454	a8		tay				tay
.1455	b2 06		lda ($06)			lda 	(TOS)
.1457	85 06		sta $06				sta 	TOS
.1459	84 07		sty $07				sty 	TOS+1
.145b	4c 00 00	jmp $0000			jmp 	Next
.145e					ByteWrite:
.145e	68		pla				pla
.145f	68		pla				pla
.1460	92 06		sta ($06)			sta 	(TOS)
.1462	68		pla				pla
.1463	85 07		sta $07				sta 	TOS+1
.1465	68		pla				pla
.1466	85 06		sta $06				sta 	TOS
.1468	4c 00 00	jmp $0000			jmp 	Next
.146b					WordWrite:
.146b	68		pla				pla
.146c	a0 01		ldy #$01			ldy 	#1
.146e	91 06		sta ($06),y			sta 	(TOS),y
.1470	68		pla				pla
.1471	92 06		sta ($06)			sta 	(TOS)
.1473	68		pla				pla
.1474	85 07		sta $07				sta 	TOS+1
.1476	68		pla				pla
.1477	85 06		sta $06				sta 	TOS
.1479	4c 00 00	jmp $0000			jmp 	Next
.147c					WordAdd:
.147c	7a		ply				ply
.147d	68		pla				pla
.147e	18		clc				clc
.147f	72 06		adc ($06)			adc 	(TOS)
.1481	92 06		sta ($06)			sta 	(TOS)
.1483	98		tya				tya
.1484	a0 01		ldy #$01			ldy 	#1
.1486	71 06		adc ($06),y			adc 	(TOS),y
.1488	91 06		sta ($06),y			sta 	(TOS),y
.148a	68		pla				pla
.148b	85 07		sta $07				sta 	TOS+1
.148d	68		pla				pla
.148e	85 06		sta $06				sta 	TOS
.1490	4c 00 00	jmp $0000			jmp 	Next
.1493					AllocateMemory:
.1493	a5 06		lda $06				lda 	TOS 						; save memory required on stack.
.1495	48		pha				pha
.1496	a5 07		lda $07				lda 	TOS+1
.1498	48		pha				pha
.1499	a5 08		lda $08				lda 	nextFreeMem 				; copy free mem address to TOS
.149b	85 06		sta $06				sta 	TOS
.149d	a5 09		lda $09				lda 	nextFreeMem+1
.149f	85 07		sta $07				sta 	TOS+1
.14a1	7a		ply				ply 								; advance the free ram pointer
.14a2	68		pla				pla
.14a3	20 55 16	jsr $1655			jsr 	AdvanceFreeMem
.14a6	4c 00 00	jmp $0000			jmp 	Next 						; and continue

;******  Return to file: kernel.asm


;******  Processing file: words/structures/fornext.src

.14a9					ForHandler:
.14a9	e6 05		inc $05				inc 	rsp 						; bump the RSP
.14ab	a4 05		ldy $05				ldy 	rsp 						; get return stack and push TOS/$FF on it.
.14ad	c0 40		cpy #$40			cpy 	#$40 						; overflow
.14af	f0 18		beq $14c9			beq 	_FHOverflow
.14b1	a5 07		lda $07				lda 	TOS+1
.14b3	99 40 07	sta $0740,y			sta 	returnStackHigh,y
.14b6	a5 06		lda $06				lda 	TOS
.14b8	99 00 07	sta $0700,y			sta 	returnStackLow,y
.14bb	a9 ff		lda #$ff			lda 	#$FF
.14bd	99 80 07	sta $0780,y			sta 	returnStackX,y
.14c0	68		pla				pla
.14c1	85 07		sta $07				sta 	TOS+1
.14c3	68		pla				pla
.14c4	85 06		sta $06				sta 	TOS
.14c6	4c 00 00	jmp $0000			jmp 	Next
.14c9					_FHOverflow:
.14c9	20 d6 18	jsr $18d6			jsr 	ErrorHandler
>14cc	46 4f 52 20 53 54 41 43				.text 	"FOR STACK?",0
>14d4	4b 3f 00
.14d7					NextHandler:
.14d7	da		phx				phx
.14d8	a6 05		ldx $05				ldx 	rsp 						; get current stack ptr
.14da	bd 80 07	lda $0780,x			lda 	returnStackX,x 				; check it's a FOR Loop
.14dd	c9 ff		cmp #$ff			cmp 	#$FF
.14df	d0 21		bne $1502			bne 	NHNoFor
.14e1	bd 00 07	lda $0700,x			lda 	returnStackLow,x 			; decrement the count
.14e4	d0 03		bne $14e9			bne 	_NHNoBorrow
.14e6	de 40 07	dec $0740,x			dec 	returnStackHigh,x
.14e9					_NHNoBorrow:
.14e9	de 00 07	dec $0700,x			dec 	returnStackLow,x
.14ec	bd 00 07	lda $0700,x			lda 	returnStackLow,x 			; have we reached the end ?
.14ef	1d 40 07	ora $0740,x			ora 	returnStackHigh,x
.14f2	fa		plx				plx 								; restore X and re-test
.14f3	09 00		ora #$00			ora 	#0
.14f5	f0 05		beq $14fc			beq 	_NHComplete 				; if so then complete, else loop.
.14f7	e8		inx				inx 								; advance to branch
.14f8	e8		inx				inx
.14f9	4c 55 15	jmp $1555			jmp 	BranchAlways
.14fc					_NHComplete:
.14fc	e8		inx				inx 								; skip over the branch quantity
.14fd	c6 05		dec $05				dec 	rsp 						; drop the indx
.14ff	4c 00 00	jmp $0000			jmp 	Next
.1502					NHNoFor:
.1502	20 d6 18	jsr $18d6			jsr 	ErrorHandler
>1505	4e 4f 20 46 4f 52 3f 00				.text 	"NO FOR?",0
.150d					GetIndex:
.150d	a4 05		ldy $05				ldy 	rsp 						; get current stack ptr
.150f	b9 80 07	lda $0780,y			lda 	returnStackX,y 				; check it's a FOR Loop
.1512	c9 ff		cmp #$ff			cmp 	#$FF
.1514	d0 ec		bne $1502			bne 	NHNoFor
.1516	a5 06		lda $06				lda 	TOS
.1518	48		pha				pha
.1519	a5 07		lda $07				lda 	TOS+1
.151b	48		pha				pha
.151c	b9 00 07	lda $0700,y			lda 	returnStackLow,y 			; put counter-1 out
.151f	38		sec				sec
.1520	e9 01		sbc #$01			sbc 	#1
.1522	85 06		sta $06				sta 	TOS
.1524	b9 40 07	lda $0740,y			lda 	returnStackHigh,y
.1527	e9 00		sbc #$00			sbc 	#0
.1529	85 07		sta $07				sta 	TOS+1
.152b	4c 00 00	jmp $0000			jmp 	Next

;******  Return to file: kernel.asm


;******  Processing file: words/structures/ifelseendif.src

.152e					IfHandler:
.152e	4c 3d 15	jmp $153d			jmp 	BranchIfZero
.1531					ElseHandler:
.1531	4c 53 15	jmp $1553			jmp 	BranchTestSucceedsNoPop
.1534					EndIfHandler:
.1534	4c 00 00	jmp $0000			jmp 	Next

;******  Return to file: kernel.asm


;******  Processing file: words/structures/repeatuntil.src

.1537					RepeatHandler:
.1537	4c 00 00	jmp $0000			jmp 	Next
.153a					UntilHandler:
.153a	4c 3d 15	jmp $153d			jmp 	BranchIfZero

;******  Return to file: kernel.asm


;******  Processing file: words/system/branch.src

.153d					BranchIfZero:
.153d	a5 06		lda $06				lda 	TOS 						; check TOS = 0
.153f	05 07		ora $07				ora 	TOS+1
.1541	f0 0a		beq $154d			beq 	BranchTestSucceeds
.1543					BranchTestFails:
.1543	68		pla				pla
.1544	85 07		sta $07				sta 	TOS+1
.1546	68		pla				pla
.1547	85 06		sta $06				sta 	TOS
.1549	e8		inx				inx 								; skip over the relative branch.
.154a	4c 00 00	jmp $0000			jmp 	Next
.154d					BranchTestSucceeds:
.154d	68		pla				pla
.154e	85 07		sta $07				sta 	TOS+1
.1550	68		pla				pla
.1551	85 06		sta $06				sta 	TOS
.1553					BranchTestSucceedsNoPop:
.1553	e8		inx				inx 								; advance by two, to the offset
.1554	e8		inx				inx
.1555					BranchAlways:
.1555	8a		txa				txa 								; A = Y = position
.1556	a8		tay				tay 								; (IP),Y now points to the branch target
.1557	b1 03		lda ($03),y			lda 	(IP),y 						; adjust the position
.1559	aa		tax				tax 								; position back in this line.
.155a	4c 02 00	jmp $0002			jmp 	Next+2 						; and continue

;******  Return to file: kernel.asm


;******  Processing file: words/system/callhandler.src

.155d					CallHandler:
.155d	e8		inx				inx									; bump X to the call address.
.155e	e8		inx				inx
.155f	e6 05		inc $05				inc 	rsp 						; bump the RSP (first time to zero)
.1561	a4 05		ldy $05				ldy 	rsp 						; get return stack and push IP/X on it.
.1563	c0 40		cpy #$40			cpy 	#$40 						; overflow
.1565	f0 4b		beq $15b2			beq 	_CHOverflow
.1567	a5 04		lda $04				lda 	IP+1
.1569	99 40 07	sta $0740,y			sta 	returnStackHigh,y
.156c	a5 03		lda $03				lda 	IP
.156e	99 00 07	sta $0700,y			sta 	returnStackLow,y
.1571	8a		txa				txa
.1572	99 80 07	sta $0780,y			sta 	returnStackX,y
.1575	8a		txa				txa 								; get the line number into temp1.
.1576	a8		tay				tay
.1577	b1 03		lda ($03),y			lda 	(IP),y
.1579	85 0a		sta $0a				sta 	temp1
.157b	c8		iny				iny
.157c	b1 03		lda ($03),y			lda 	(IP),y
.157e	85 0b		sta $0b				sta 	temp1+1
.1580	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.1582	85 03		sta $03				sta 	0+(IP)
.1584	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.1586	85 04		sta $04				sta 	1+(IP)
.1588	b2 03		lda ($03)			lda 	(IP)						; no program code ?
.158a	f0 17		beq $15a3			beq 	_CHFail
.158c	a0 01		ldy #$01			ldy 	#1 							; Y = 1 throughout.
.158e					_CHSearch:
.158e	b1 03		lda ($03),y			lda 	(IP),y 						; check LSB of line number
.1590	c5 0a		cmp $0a				cmp 	temp1
.1592	f0 2d		beq $15c1			beq 	_CHFoundLSB
.1594					_CHSearchNext:
.1594	18		clc				clc
.1595	a5 03		lda $03				lda 	IP
.1597	72 03		adc ($03)			adc 	(IP)
.1599	85 03		sta $03				sta 	IP
.159b	90 02		bcc $159f			bcc 	_NoCarryAdv
.159d	e6 04		inc $04				inc 	IP+1
.159f					_NoCarryAdv:
.159f	b2 03		lda ($03)			lda 	(IP)						; check reached the end.
.15a1	d0 eb		bne $158e			bne 	_CHSearch
.15a3					_CHFail:
.15a3	20 d6 18	jsr $18d6			jsr 	ErrorHandler
>15a6	44 45 46 49 4e 49 54 49				.text 	"DEFINITION?",0
>15ae	4f 4e 3f 00
.15b2					_CHOverflow:
.15b2	20 d6 18	jsr $18d6			jsr 	ErrorHandler
>15b5	53 54 41 43 4b 44 45 50				.text 	"STACKDEPTH?",0
>15bd	54 48 3f 00
.15c1					_CHFoundLSB:
.15c1	c8		iny				iny 								; get MSB
.15c2	b1 03		lda ($03),y			lda 	(IP),y
.15c4	88		dey				dey
.15c5	c5 0b		cmp $0b				cmp 	temp1+1 					; matches, if not contineu
.15c7	d0 cb		bne $1594			bne 	_CHSearchNext
.15c9	a0 03		ldy #$03			ldy 	#3	 						; check it begins with $$define
.15cb	b1 03		lda ($03),y			lda 	(IP),y
.15cd	c9 77		cmp #$77			cmp 	#DefineCode & $FF
.15cf	d0 d2		bne $15a3			bne 	_CHFail
.15d1	c8		iny				iny
.15d2	b1 03		lda ($03),y			lda 	(IP),y
.15d4	c9 17		cmp #$17			cmp 	#DefineCode >> 8
.15d6	d0 cb		bne $15a3			bne 	_CHFail
.15d8	c8		iny				iny
.15d9	b1 03		lda ($03),y			lda 	(IP),y 						; this is the length of the define name
.15db	18		clc				clc
.15dc	69 05		adc #$05			adc 	#5 							; $$define token, line number, offset
.15de	aa		tax				tax
.15df	4c 02 00	jmp $0002			jmp 	Next+2 						; and execute
.15e2					ReturnHandler:
.15e2	a4 05		ldy $05				ldy 	rsp 						; get rsp
.15e4	30 15		bmi $15fb			bmi 	_RHUnderflow 				; if -ve underflowed
.15e6	c6 05		dec $05				dec 	rsp 						; decrement rsp
.15e8	b9 40 07	lda $0740,y			lda 	returnStackHigh,y 			; restore IP/X
.15eb	85 04		sta $04				sta 	IP+1
.15ed	b9 00 07	lda $0700,y			lda 	returnStackLow,y
.15f0	85 03		sta $03				sta 	IP
.15f2	b9 80 07	lda $0780,y			lda 	returnStackX,y
.15f5	aa		tax				tax
.15f6	f0 0e		beq $1606			beq 	_RHInLoop 					; this means you have done :something for ; next
.15f8	4c 00 00	jmp $0000			jmp 	Next
.15fb					_RHUnderflow:
.15fb	20 d6 18	jsr $18d6			jsr 	ErrorHandler
>15fe	52 45 54 55 52 4e 3f 00				.text 	"RETURN?",0
.1606					_RHInLoop:
.1606	20 d6 18	jsr $18d6			jsr 	ErrorHandler
>1609	52 45 54 55 52 4e 20 49				.text 	"RETURN IN LOOP?",0
>1611	4e 20 4c 4f 4f 50 3f 00

;******  Return to file: kernel.asm


;******  Processing file: words/system/clrnew.src

.1619					NewHandler:
.1619	9c 00 40	stz $4000			stz 	ProgramMemory 				; Make the first offset zero.
.161c	20 28 16	jsr $1628			jsr 	ClearVariableSpace 			; clear variables, reset pointers
.161f	4c 00 00	jmp $0000			jmp 	Next
.1622					ClrHandler:
.1622	20 28 16	jsr $1628			jsr 	ClearVariableSpace 			; clear variables, reset pointers
.1625	4c 00 00	jmp $0000			jmp 	Next
.1628					ClearVariableSpace:
.1628	a9 ff		lda #$ff			lda 	#$FF 						; empty return stack
.162a	85 05		sta $05				sta 	rsp
.162c	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.162e	85 08		sta $08				sta 	0+(nextFreeMem)
.1630	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.1632	85 09		sta $09				sta 	1+(nextFreeMem)
.1634	a0 1f		ldy #$1f			ldy 	#hashTableSize*2-1 			; erase the hash table (used for variables)
.1636					_CVSHashClear:
.1636	a9 00		lda #$00			lda 	#0 							; all the first record pointers are $00
.1638	99 40 06	sta $0640,y			sta 	hashTable,y
.163b	88		dey				dey
.163c	10 f8		bpl $1636			bpl 	_CVSHashClear
.163e					_CVSFindEnd:
.163e	18		clc				clc
.163f	a5 08		lda $08				lda 	nextFreeMem
.1641	72 08		adc ($08)			adc 	(nextFreeMem)
.1643	85 08		sta $08				sta 	nextFreeMem
.1645	90 02		bcc $1649			bcc 	_NoCarryAdv
.1647	e6 09		inc $09				inc 	nextFreeMem+1
.1649					_NoCarryAdv:
.1649	b2 08		lda ($08)			lda 	(nextFreeMem)
.164b	d0 f1		bne $163e			bne 	_CVSFindEnd
.164d	a9 08		lda #$08			lda 	#8 							; this puts a gap in, more for clarity than anything.
.164f	a0 00		ldy #$00			ldy 	#0
.1651	20 55 16	jsr $1655			jsr 	AdvanceFreeMem				; we need +1 because the previous code leaves the
.1654	60		rts				rts 								; free mem pointer pointing to the last zero offset
.1655					AdvanceFreeMem:
.1655	18		clc				clc
.1656	65 08		adc $08				adc 	nextFreeMem
.1658	85 08		sta $08				sta 	nextFreeMem
.165a	98		tya				tya
.165b	65 09		adc $09				adc 	nextFreeMem+1
.165d	85 09		sta $09				sta 	nextFreeMem+1
.165f	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/debug.src

.1660					ExitDump:
.1660	ba		tsx				tsx 								; save Data Stack in temp1
.1661	86 0a		stx $0a				stx 	temp1
.1663	4c ff ff	jmp $ffff			jmp 	$FFFF 						; makes the X16-Emulator dump-exit.
.1666					BreakCmd:
>1666	ff						.byte 	$FF
.1667	4c 00 00	jmp $0000			jmp 	Next

;******  Return to file: kernel.asm


;******  Processing file: words/system/miscellany.src

.166a					Call6502:
.166a	a5 06		lda $06				lda 	TOS 						; copy call address
.166c	85 0a		sta $0a				sta 	temp1
.166e	a5 07		lda $07				lda 	TOS+1
.1670	85 0b		sta $0b				sta 	temp1+1
.1672	68		pla				pla
.1673	85 07		sta $07				sta 	TOS+1
.1675	68		pla				pla
.1676	85 06		sta $06				sta 	TOS
.1678	20 7e 16	jsr $167e			jsr 	_CallTemp1 					; call it
.167b	4c 00 00	jmp $0000			jmp 	Next
.167e					_CallTemp1:
.167e	6c 0a 00	jmp ($000a)			jmp 	(temp1)
.1681					AssertCode:
.1681	a5 06		lda $06				lda 	TOS 						; TOS = 0
.1683	05 07		ora $07				ora 	TOS+1
.1685	f0 09		beq $1690			beq 	_ASFail 					; if zero fail
.1687	68		pla				pla
.1688	85 07		sta $07				sta 	TOS+1
.168a	68		pla				pla
.168b	85 06		sta $06				sta 	TOS
.168d	4c 00 00	jmp $0000			jmp 	Next
.1690					_ASFail:
.1690	20 d6 18	jsr $18d6			jsr 	ErrorHandler
>1693	41 53 53 45 52 54 00				.text 	"ASSERT",0
.169a					StopCode:
.169a	20 d6 18	jsr $18d6			jsr 	ErrorHandler
>169d	53 54 4f 50 00					.text 	"STOP",0
.16a2					EndProgram:
.16a2	4c d3 18	jmp $18d3			jmp 	WarmStart

;******  Return to file: kernel.asm


;******  Processing file: words/system/toint.src

.16a5					NumToInt:
.16a5	a5 06		lda $06				lda 	TOS 						; TOS to temp4
.16a7	85 10		sta $10				sta 	temp4
.16a9	a5 07		lda $07				lda		TOS+1
.16ab	85 11		sta $11				sta 	temp4+1
.16ad	20 ce 16	jsr $16ce			jsr 	ConvertToInteger
.16b0	90 0f		bcc $16c1			bcc 	_NTIFail
.16b2	a5 0e		lda $0e				lda 	temp3
.16b4	48		pha				pha
.16b5	a5 0f		lda $0f				lda 	temp3+1
.16b7	48		pha				pha
.16b8	a9 ff		lda #$ff			lda 	#$FF 						; TOS = -1
.16ba	85 06		sta $06				sta 	TOS
.16bc	85 07		sta $07				sta 	TOS+1
.16be	4c 00 00	jmp $0000			jmp 	Next
.16c1					_NTIFail:
.16c1	64 06		stz $06				stz 	TOS 						; zero TOS and push on stack as null answer
.16c3	64 07		stz $07				stz 	TOS+1
.16c5	a5 06		lda $06				lda 	TOS
.16c7	48		pha				pha
.16c8	a5 07		lda $07				lda 	TOS+1
.16ca	48		pha				pha
.16cb	4c 00 00	jmp $0000			jmp 	Next
.16ce					ConvertToInteger:
.16ce	64 0e		stz $0e				stz 	temp3 						; reset value
.16d0	64 0f		stz $0f				stz 	temp3+1
.16d2	64 0a		stz $0a				stz 	temp1 						; temp1 = 0 (decimal) 255 (hex)
.16d4	a0 00		ldy #$00			ldy 	#0 							; look at first character
.16d6	b1 10		lda ($10),y			lda 	(temp4),y
.16d8	49 2d		eor #$2d			eor 	#"-"						; zero if '-'
.16da	85 0b		sta $0b				sta 	temp1+1 					; save this in temp1+1
.16dc	d0 01		bne $16df			bne 	_CTINotMinus
.16de	c8		iny				iny									; skip -
.16df					_CTINotMinus:
.16df	b1 10		lda ($10),y			lda 	(temp4),y
.16e1	c9 24		cmp #$24			cmp		#'$'						; if $ then skip it and set hex flag
.16e3	d0 03		bne $16e8			bne 	_CTILoop
.16e5	c6 0a		dec $0a				dec 	temp1
.16e7	c8		iny				iny
.16e8					_CTILoop:
.16e8	b1 10		lda ($10),y			lda 	(temp4),y 					; next digit
.16ea	29 7f		and #$7f			and 	#$7F 						; drop end of word flag
.16ec	38		sec				sec
.16ed	e9 30		sbc #$30			sbc 	#'0' 						; put in range '0'+
.16ef	90 62		bcc $1753			bcc 	_CTIFail 					; out of range.
.16f1	c9 0a		cmp #$0a			cmp 	#10 						; in 0-9 ?
.16f3	90 0b		bcc $1700			bcc 	_CTILegal
.16f5	c9 11		cmp #$11			cmp 	#'A'-'0'					; between 9 and A ?
.16f7	90 5a		bcc $1753			bcc 	_CTIFail
.16f9	38		sec				sec
.16fa	e9 07		sbc #$07			sbc 	#7 							; hex adjust
.16fc	c9 10		cmp #$10			cmp 	#16 						; out of range ?
.16fe	b0 53		bcs $1753			bcs 	_CTIFail
.1700					_CTILegal:
.1700	48		pha				pha 								; save digit value.
.1701	06 0e		asl $0e				asl 	temp3
.1703	26 0f		rol $0f				rol 	temp3+1
.1705	a5 0e		lda $0e				lda 	temp3 						; copy x2 into temp2
.1707	85 0c		sta $0c				sta 	temp2
.1709	a5 0f		lda $0f				lda 	temp3+1
.170b	85 0d		sta $0d				sta 	temp2+1
.170d	06 0e		asl $0e				asl 	temp3
.170f	26 0f		rol $0f				rol 	temp3+1
.1711	06 0e		asl $0e				asl 	temp3
.1713	26 0f		rol $0f				rol 	temp3+1
.1715	24 0a		bit $0a				bit 	temp1 						; hexadecimal
.1717	10 07		bpl $1720			bpl 	_CTIDecimal
.1719	06 0e		asl $0e				asl 	temp3
.171b	26 0f		rol $0f				rol 	temp3+1
.171d	68		pla				pla 								; get digit back
.171e	80 12		bra $1732			bra 	_CTIAddLoop
.1720					_CTIDecimal:
.1720	18		clc				clc 								; x 8 + x 2 = x 10
.1721	a5 0e		lda $0e				lda 	temp3
.1723	65 0c		adc $0c				adc 	temp2
.1725	85 0e		sta $0e				sta 	temp3
.1727	a5 0f		lda $0f				lda 	temp3+1
.1729	65 0d		adc $0d				adc 	temp2+1
.172b	85 0f		sta $0f				sta 	temp3+1
.172d	68		pla				pla 					; check digit 0-9
.172e	c9 0a		cmp #$0a			cmp 	#10
.1730	b0 21		bcs $1753			bcs 	_CTIFail
.1732					_CTIAddLoop:
.1732	18		clc				clc
.1733	65 0e		adc $0e				adc 	temp3
.1735	85 0e		sta $0e				sta 	temp3
.1737	90 02		bcc $173b			bcc 	_CTINoCarry
.1739	e6 0f		inc $0f				inc 	temp3+1
.173b					_CTINoCarry:
.173b	c8		iny				iny
.173c	b1 10		lda ($10),y			lda 	(temp4),y 					; was this the last character
.173e	d0 a8		bne $16e8			bne 	_CTILoop 					; no, go back.
.1740	a5 0b		lda $0b				lda 	temp1+1 					; was it - ?
.1742	d0 0d		bne $1751			bne 	_CTIOkay
.1744	38		sec				sec
.1745	a9 00		lda #$00			lda 	#0 							; negate temp3.
.1747	e5 0e		sbc $0e				sbc 	temp3
.1749	85 0e		sta $0e				sta 	temp3
.174b	a9 00		lda #$00			lda 	#0
.174d	e5 0f		sbc $0f				sbc 	temp3+1
.174f	85 0f		sta $0f				sta 	temp3+1
.1751					_CTIOkay:
.1751	38		sec				sec
.1752	60		rts				rts
.1753					_CTIFail:
.1753	18		clc				clc
.1754	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/skipper.src

.1755					NextLine:
.1755	18		clc				clc
.1756	a5 03		lda $03				lda 	IP
.1758	72 03		adc ($03)			adc 	(IP)
.175a	85 03		sta $03				sta 	IP
.175c	90 02		bcc $1760			bcc 	_NoCarryAdv
.175e	e6 04		inc $04				inc 	IP+1
.1760					_NoCarryAdv:
.1760	b2 03		lda ($03)			lda 	(IP)						; is there any following program ?
.1762	f0 05		beq $1769			beq 	_NLGoEnd
.1764	a2 03		ldx #$03			ldx 	#3 							; start 3 in
.1766	4c 02 00	jmp $0002			jmp 	Next+2 						; avoid the first two INXs
.1769					_NLGoEnd:
.1769	4c d3 18	jmp $18d3			jmp 	WarmStart
.176c					SkipComment:
.176c	e8		inx				inx									; (IP),X points to the length.
.176d	e8		inx				inx
.176e	8a		txa				txa
.176f	a8		tay				tay 								; put into Y
.1770	18		clc				clc
.1771	71 03		adc ($03),y			adc 	(IP),y 						; add the length to X
.1773	aa		tax				tax 								; put back in X
.1774	4c 02 00	jmp $0002			jmp 	Next+2 						; continue skipping the pre-increment.
.1777					DefineCode:
.1777	20 d6 18	jsr $18d6			jsr 	ErrorHandler
>177a	44 45 46 49 4e 49 54 49				.text 	"DEFINITION?",0
>1782	4f 4e 3f 00

;******  Return to file: kernel.asm


;******  Processing file: words/system/tostr.src

.1786					IntToString:
.1786	a9 10		lda #$10			lda 	#(textBuffer) & $FF
.1788	85 0c		sta $0c				sta 	0+(temp2)
.178a	a9 08		lda #$08			lda 	#(textBuffer) >> 8
.178c	85 0d		sta $0d				sta 	1+(temp2)
.178e	a5 06		lda $06				lda 	TOS 						; value in YA
.1790	a4 07		ldy $07				ldy 	TOS+1
.1792	20 a0 17	jsr $17a0			jsr 	ConvertToString
.1795	a9 10		lda #$10			lda 	#(textBuffer) & $FF
.1797	85 06		sta $06				sta 	0+(TOS)
.1799	a9 08		lda #$08			lda 	#(textBuffer) >> 8
.179b	85 07		sta $07				sta 	1+(TOS)
.179d	4c 00 00	jmp $0000			jmp 	Next
.17a0					ConvertToString:
.17a0	38		sec				sec
.17a1	80 01		bra $17a4			bra 	CTSMain
.17a3					ConvertToStringUnsigned:
.17a3	18		clc				clc
.17a4					CTSMain:
>17a4	ff						.byte 	$FF
.17a5	48		pha				pha 								; save AXY
.17a6	da		phx				phx
.17a7	5a		phy				phy
.17a8	85 0a		sta $0a				sta 	temp1 						; save YA in temp1
.17aa	84 0b		sty $0b				sty 	temp1+1
.17ac	a0 00		ldy #$00			ldy 	#0 							; index to result.
.17ae	90 16		bcc $17c6			bcc 	_CTSUnsigned 				; if carry clear do not adjust for -
.17b0	a5 0b		lda $0b				lda 	temp1+1 					; is it negative
.17b2	10 12		bpl $17c6			bpl 	_CTSUnsigned
.17b4	a9 2d		lda #$2d			lda 	#"-"						; output - sign
.17b6	91 0c		sta ($0c),y			sta 	(temp2),y
.17b8	c8		iny				iny
.17b9	38		sec				sec 								; negate temp1
.17ba	a9 00		lda #$00			lda 	#0
.17bc	e5 0a		sbc $0a				sbc 	temp1
.17be	85 0a		sta $0a				sta 	temp1
.17c0	a9 00		lda #$00			lda 	#0
.17c2	e5 0b		sbc $0b				sbc 	temp1+1
.17c4	85 0b		sta $0b				sta 	temp1+1
.17c6					_CTSUnsigned:
.17c6	a2 00		ldx #$00			ldx 	#0 							; index into subtraction table
.17c8					_CTSLoop:
.17c8	a5 0b		lda $0b				lda 	temp1+1 					; < 10
.17ca	d0 06		bne $17d2			bne 	_CTSNotDone
.17cc	a5 0a		lda $0a				lda 	temp1
.17ce	c9 0a		cmp #$0a			cmp 	#10
.17d0	90 01		bcc $17d3			bcc 	_CTSComplete 				; result < 10, so complete.
.17d2					_CTSNotDone:
>17d2	ff						.byte 	$FF
.17d3					_CTSComplete:
.17d3	a5 0a		lda $0a				lda		temp1 						; get remainder 0-9
.17d5	09 30		ora #$30			ora 	#48 						; ASCII
.17d7	91 0c		sta ($0c),y			sta 	(temp2),y					; write out
.17d9	c8		iny				iny
.17da	a9 00		lda #$00			lda 	#0							; make ASCIIZ
.17dc	91 0c		sta ($0c),y			sta 	(temp2),y
.17de	7a		ply				ply									; pull and exit.
.17df	fa		plx				plx
.17e0	68		pla				pla
.17e1	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/varhandlers.src

.17e2					VarAddressHandler:
.17e2	18		clc				clc 								; find variable, error if it doesn't exist.
.17e3	20 25 18	jsr $1825			jsr 	VariableFind
.17e6	a5 06		lda $06				lda 	TOS
.17e8	48		pha				pha
.17e9	a5 07		lda $07				lda 	TOS+1
.17eb	48		pha				pha
.17ec	a5 0a		lda $0a				lda 	temp1 						; the address is the new value
.17ee	85 06		sta $06				sta 	TOS
.17f0	a5 0b		lda $0b				lda		temp1+1
.17f2	85 07		sta $07				sta 	TOS+1
.17f4	4c 00 00	jmp $0000			jmp 	Next
.17f7					VarReadHandler:
.17f7	18		clc				clc 								; find variable, error if it doesn't exist.
.17f8	20 25 18	jsr $1825			jsr 	VariableFind
.17fb	a5 06		lda $06				lda 	TOS
.17fd	48		pha				pha
.17fe	a5 07		lda $07				lda 	TOS+1
.1800	48		pha				pha
.1801	b2 0a		lda ($0a)			lda 	(temp1)						; read variable address to TOS
.1803	85 06		sta $06				sta 	TOS
.1805	a0 01		ldy #$01			ldy 	#1
.1807	b1 0a		lda ($0a),y			lda 	(temp1),y
.1809	85 07		sta $07				sta 	TOS+1
.180b	4c 00 00	jmp $0000			jmp 	Next
.180e					VarWriteHandler:
.180e	38		sec				sec 								; find variable, create it if it doesn't exist.
.180f	20 25 18	jsr $1825			jsr 	VariableFind
.1812	a5 06		lda $06				lda 	TOS 						; write TOS to that address.
.1814	92 0a		sta ($0a)			sta 	(temp1)
.1816	a5 07		lda $07				lda 	TOS+1
.1818	a0 01		ldy #$01			ldy 	#1
.181a	91 0a		sta ($0a),y			sta 	(temp1),y
.181c	68		pla				pla
.181d	85 07		sta $07				sta 	TOS+1
.181f	68		pla				pla
.1820	85 06		sta $06				sta 	TOS
.1822	4c 00 00	jmp $0000			jmp 	Next
.1825					VariableFind:
.1825	08		php				php 								; save autocreate flag.
.1826	e8		inx				inx 								; advance to/over the variable name.
.1827	e8		inx				inx
.1828	8a		txa				txa 								; put in Y
.1829	a8		tay				tay
.182a	b1 03		lda ($03),y			lda 	(IP),y 						; copy name word into temp2, putting it the right way round.
.182c	85 0d		sta $0d				sta 	temp2+1
.182e	c8		iny				iny
.182f	b1 03		lda ($03),y			lda 	(IP),y
.1831	85 0c		sta $0c				sta 	temp2
.1833	c9 1b		cmp #$1b			cmp 	#27 						; check for A-Z
.1835	b0 0f		bcs $1846			bcs 	_VFLong
.1837	a5 0d		lda $0d				lda 	temp2+1
.1839	d0 0b		bne $1846			bne 	_VFLong
.183b	a5 0c		lda $0c				lda 	temp2						; this is the index
.183d	0a		asl a				asl 	a 							; double it
.183e	85 0a		sta $0a				sta 	temp1
.1840	a9 06		lda #$06			lda 	#azVariables >> 8			; set the MSB
.1842	85 0b		sta $0b				sta 	temp1+1
.1844	28		plp				plp 								; throw creation flag, it always exists.
.1845	60		rts				rts
.1846					_VFLong:
.1846	a5 0c		lda $0c				lda 	temp2 						; built a hash table index into temp3/temp4
.1848	6a		ror a				ror 	a
.1849	6a		ror a				ror 	a
.184a	6a		ror a				ror 	a
.184b	6a		ror a				ror 	a
.184c	45 0c		eor $0c				eor 	temp2
.184e	45 0d		eor $0d				eor 	temp2+1
.1850	29 0f		and #$0f			and 	#(hashTableSize-1)			; force into range
.1852	0a		asl a				asl 	a
.1853	69 40		adc #$40			adc 	#hashTable & $FF 			; make an address of the head => temp1/3
.1855	85 0a		sta $0a				sta 	temp1
.1857	85 0e		sta $0e				sta 	temp3
.1859	a9 06		lda #$06			lda 	#hashTable >> 8
.185b	85 0b		sta $0b				sta 	temp1+1
.185d	85 0f		sta $0f				sta 	temp3+1
.185f					_VFSearch:
.185f	a0 01		ldy #$01			ldy 	#1							; read MSB of first record
.1861	b1 0a		lda ($0a),y			lda 	(temp1),y
.1863	f0 23		beq $1888			beq 	_VFNotFound 				; is MSB is zero, can't be a variable record
.1865	a8		tay				tay 								; follow the link through.
.1866	b2 0a		lda ($0a)			lda 	(temp1)
.1868	85 0a		sta $0a				sta 	temp1
.186a	84 0b		sty $0b				sty 	temp1+1
.186c	a0 04		ldy #$04			ldy 	#4							; check if the name matches
.186e	b1 0a		lda ($0a),y			lda 	(temp1),y
.1870	c5 0c		cmp $0c				cmp 	temp2
.1872	d0 eb		bne $185f			bne 	_VFSearch 					; if it doesn't, follow the next link.
.1874	c8		iny				iny 								; same for 2nd byte of name
.1875	b1 0a		lda ($0a),y			lda 	(temp1),y
.1877	c5 0d		cmp $0d				cmp 	temp2+1
.1879	d0 e4		bne $185f			bne 	_VFSearch
.187b	18		clc				clc
.187c	a5 0a		lda $0a				lda 	temp1 						; make temp1 point to the data at offset 2
.187e	69 02		adc #$02			adc 	#2
.1880	85 0a		sta $0a				sta 	temp1
.1882	90 02		bcc $1886			bcc 	_VFNoPage1
.1884	e6 0b		inc $0b				inc 	temp1+1
.1886					_VFNoPage1:
.1886	28		plp				plp 								; don't need to worry about creation flag
.1887	60		rts				rts
.1888					_VFNotFound:
.1888	28		plp				plp 								; was carry set, e.g. create a new record if not found ?
.1889	b0 0d		bcs $1898			bcs 	_VFCreate
.188b	20 d6 18	jsr $18d6			jsr 	ErrorHandler
>188e	56 41 52 49 41 42 4c 45				.text 	"VARIABLE?",0
>1896	3f 00
.1898					_VFCreate:
.1898	a0 01		ldy #$01			ldy 	#1
.189a	b2 0e		lda ($0e)			lda 	(temp3) 					; copy the head link to the first 2 bytes
.189c	92 08		sta ($08)			sta 	(nextFreeMem)
.189e	b1 0e		lda ($0e),y			lda 	(temp3),y
.18a0	91 08		sta ($08),y			sta 	(nextFreeMem),y
.18a2	c8		iny				iny
.18a3	a9 00		lda #$00			lda 	#0	 						; write zero initialised data out.
.18a5	91 08		sta ($08),y			sta 	(nextFreeMem),y
.18a7	c8		iny				iny
.18a8	91 08		sta ($08),y			sta 	(nextFreeMem),y
.18aa	c8		iny				iny
.18ab	a5 0c		lda $0c				lda 	temp2 						; copy the name out
.18ad	91 08		sta ($08),y			sta 	(nextFreeMem),y
.18af	c8		iny				iny
.18b0	a5 0d		lda $0d				lda 	temp2+1
.18b2	91 08		sta ($08),y			sta 	(nextFreeMem),y
.18b4	a0 01		ldy #$01			ldy 	#1
.18b6	a5 08		lda $08				lda 	nextFreeMem 				; update the head link
.18b8	92 0e		sta ($0e)			sta 	(temp3)
.18ba	a5 09		lda $09				lda 	nextFreeMem+1
.18bc	91 0e		sta ($0e),y			sta 	(temp3),y
.18be	18		clc				clc
.18bf	a5 08		lda $08				lda 	nextFreeMem 				; put nextFreeMem+2 in temp1 (data pointer)
.18c1	69 02		adc #$02			adc 	#2
.18c3	85 0a		sta $0a				sta 	temp1
.18c5	a5 09		lda $09				lda 	nextFreeMem+1
.18c7	69 00		adc #$00			adc 	#0
.18c9	85 0b		sta $0b				sta 	temp1+1
.18cb	a9 06		lda #$06			lda 	#6							; shift freemem pointer up 6
.18cd	a0 00		ldy #$00			ldy 	#0
.18cf	20 55 16	jsr $1655			jsr 	AdvanceFreeMem
.18d2	60		rts				rts

;******  Return to file: kernel.asm

.18d3					WarmStart:
>18d3	ff						.byte 	$FF
.18d4	a2 00		ldx #$00			ldx 	#$00
.18d6					ErrorHandler:
>18d6	ff						.byte 	$FF
.18d7	a2 5e		ldx #$5e			ldx 	#$5E
.18d9					Dictionary:

;******  Processing file: generated/dictionary.inc

>18d9	05					.byte	_end1-*
>18da	00					.byte	$00
>18db	6b 14					.word	WordWrite
>18dd	a1					.byte	$a1
.18de					_end1:
>18de	0e					.byte	_end2-*
>18df	42					.byte	$42
>18e0	0e 18					.word	VarWriteHandler
>18e2	24 24 21 48 41 4e 44 4c			.byte	$24,$24,$21,$48,$41,$4e,$44,$4c,$45,$d2
>18ea	45 d2
.18ec					_end2:
>18ec	0e					.byte	_end3-*
>18ed	42					.byte	$42
>18ee	e2 17					.word	VarAddressHandler
>18f0	24 24 26 48 41 4e 44 4c			.byte	$24,$24,$26,$48,$41,$4e,$44,$4c,$45,$d2
>18f8	45 d2
.18fa					_end3:
>18fa	0e					.byte	_end4-*
>18fb	42					.byte	$42
>18fc	f7 17					.word	VarReadHandler
>18fe	24 24 40 48 41 4e 44 4c			.byte	$24,$24,$40,$48,$41,$4e,$44,$4c,$45,$d2
>1906	45 d2
.1908					_end4:
>1908	0a					.byte	_end5-*
>1909	42					.byte	$42
>190a	5d 15					.word	CallHandler
>190c	24 24 43 41 4c cc			.byte	$24,$24,$43,$41,$4c,$cc
.1912					_end5:
>1912	0d					.byte	_end6-*
>1913	43					.byte	$43
>1914	6c 17					.word	SkipComment
>1916	24 24 43 4f 4d 4d 45 4e			.byte	$24,$24,$43,$4f,$4d,$4d,$45,$4e,$d4
>191e	d4
.191f					_end6:
>191f	0c					.byte	_end7-*
>1920	43					.byte	$43
>1921	77 17					.word	DefineCode
>1923	24 24 44 45 46 49 4e c5			.byte	$24,$24,$44,$45,$46,$49,$4e,$c5
.192b					_end7:
>192b	0d					.byte	_end8-*
>192c	42					.byte	$42
>192d	21 10					.word	Literal2Byte
>192f	24 24 4c 49 54 45 52 41			.byte	$24,$24,$4c,$49,$54,$45,$52,$41,$cc
>1937	cc
.1938					_end8:
>1938	0e					.byte	_end9-*
>1939	80					.byte	$80
>193a	55 17					.word	NextLine
>193c	24 24 4e 45 58 54 4c 49			.byte	$24,$24,$4e,$45,$58,$54,$4c,$49,$4e,$c5
>1944	4e c5
.1946					_end9:
>1946	0c					.byte	_end10-*
>1947	43					.byte	$43
>1948	37 10					.word	LiteralString
>194a	24 24 53 54 52 49 4e c7			.byte	$24,$24,$53,$54,$52,$49,$4e,$c7
.1952					_end10:
>1952	05					.byte	_end11-*
>1953	00					.byte	$00
>1954	e7 11					.word	Multiply16x16
>1956	aa					.byte	$aa
.1957					_end11:
>1957	05					.byte	_end12-*
>1958	00					.byte	$00
>1959	54 10					.word	Add
>195b	ab					.byte	$ab
.195c					_end12:
>195c	06					.byte	_end13-*
>195d	00					.byte	$00
>195e	7c 14					.word	WordAdd
>1960	2b a1					.byte	$2b,$a1
.1962					_end13:
>1962	05					.byte	_end14-*
>1963	00					.byte	$00
>1964	63 10					.word	Subtract
>1966	ad					.byte	$ad
.1967					_end14:
>1967	06					.byte	_end15-*
>1968	00					.byte	$00
>1969	23 13					.word	ConstantMinus1
>196b	2d b1					.byte	$2d,$b1
.196d					_end15:
>196d	05					.byte	_end16-*
>196e	00					.byte	$00
>196f	38 11					.word	Divide16x16
>1971	af					.byte	$af
.1972					_end16:
>1972	05					.byte	_end17-*
>1973	00					.byte	$00
>1974	16 13					.word	Constant0
>1976	b0					.byte	$b0
.1977					_end17:
>1977	06					.byte	_end18-*
>1978	00					.byte	$00
>1979	7c 12					.word	CheckMinus
>197b	30 bc					.byte	$30,$bc
.197d					_end18:
>197d	06					.byte	_end19-*
>197e	00					.byte	$00
>197f	90 12					.word	CheckZero
>1981	30 bd					.byte	$30,$bd
.1983					_end19:
>1983	05					.byte	_end20-*
>1984	00					.byte	$00
>1985	32 13					.word	C1
>1987	b1					.byte	$b1
.1988					_end20:
>1988	06					.byte	_end21-*
>1989	00					.byte	$00
>198a	26 12					.word	Unary1Plus
>198c	31 ab					.byte	$31,$ab
.198e					_end21:
>198e	06					.byte	_end22-*
>198f	00					.byte	$00
>1990	3d 12					.word	Unary1Minus
>1992	31 ad					.byte	$31,$ad
.1994					_end22:
>1994	06					.byte	_end23-*
>1995	00					.byte	$00
>1996	4a 13					.word	C10
>1998	31 b0					.byte	$31,$b0
.199a					_end23:
>199a	07					.byte	_end24-*
>199b	00					.byte	$00
>199c	73 13					.word	C100
>199e	31 30 b0				.byte	$31,$30,$b0
.19a1					_end24:
>19a1	08					.byte	_end25-*
>19a2	00					.byte	$00
>19a3	a2 13					.word	C1024
>19a5	31 30 32 b4				.byte	$31,$30,$32,$b4
.19a9					_end25:
>19a9	07					.byte	_end26-*
>19aa	00					.byte	$00
>19ab	77 13					.word	C127
>19ad	31 32 b7				.byte	$31,$32,$b7
.19b0					_end26:
>19b0	07					.byte	_end27-*
>19b1	00					.byte	$00
>19b2	7b 13					.word	C128
>19b4	31 32 b8				.byte	$31,$32,$b8
.19b7					_end27:
>19b7	06					.byte	_end28-*
>19b8	00					.byte	$00
>19b9	4e 13					.word	C15
>19bb	31 b5					.byte	$31,$b5
.19bd					_end28:
>19bd	06					.byte	_end29-*
>19be	00					.byte	$00
>19bf	52 13					.word	C16
>19c1	31 b6					.byte	$31,$b6
.19c3					_end29:
>19c3	07					.byte	_end30-*
>19c4	00					.byte	$00
>19c5	b4 12					.word	Times16
>19c7	31 36 aa				.byte	$31,$36,$aa
.19ca					_end30:
>19ca	07					.byte	_end31-*
>19cb	00					.byte	$00
>19cc	c7 12					.word	Divide16
>19ce	31 36 af				.byte	$31,$36,$af
.19d1					_end31:
>19d1	05					.byte	_end32-*
>19d2	00					.byte	$00
>19d3	36 13					.word	C2
>19d5	b2					.byte	$b2
.19d6					_end32:
>19d6	06					.byte	_end33-*
>19d7	00					.byte	$00
>19d8	c0 12					.word	Times2
>19da	32 aa					.byte	$32,$aa
.19dc					_end33:
>19dc	06					.byte	_end34-*
>19dd	00					.byte	$00
>19de	2f 12					.word	Unary2Plus
>19e0	32 ab					.byte	$32,$ab
.19e2					_end34:
>19e2	06					.byte	_end35-*
>19e3	00					.byte	$00
>19e4	48 12					.word	Unary2Minus
>19e6	32 ad					.byte	$32,$ad
.19e8					_end35:
>19e8	06					.byte	_end36-*
>19e9	00					.byte	$00
>19ea	d3 12					.word	Divide2
>19ec	32 af					.byte	$32,$af
.19ee					_end36:
>19ee	06					.byte	_end37-*
>19ef	00					.byte	$00
>19f0	56 13					.word	C24
>19f2	32 b4					.byte	$32,$b4
.19f4					_end37:
>19f4	07					.byte	_end38-*
>19f5	00					.byte	$00
>19f6	7f 13					.word	C255
>19f8	32 35 b5				.byte	$32,$35,$b5
.19fb					_end38:
>19fb	07					.byte	_end39-*
>19fc	00					.byte	$00
>19fd	8a 13					.word	C256
>19ff	32 35 b6				.byte	$32,$35,$b6
.1a02					_end39:
>1a02	08					.byte	_end40-*
>1a03	00					.byte	$00
>1a04	da 12					.word	Times256
>1a06	32 35 36 aa				.byte	$32,$35,$36,$aa
.1a0a					_end40:
>1a0a	08					.byte	_end41-*
>1a0b	00					.byte	$00
>1a0c	e3 12					.word	Divide256
>1a0e	32 35 36 af				.byte	$32,$35,$36,$af
.1a12					_end41:
>1a12	05					.byte	_end42-*
>1a13	00					.byte	$00
>1a14	3a 13					.word	C3
>1a16	b3					.byte	$b3
.1a17					_end42:
>1a17	06					.byte	_end43-*
>1a18	00					.byte	$00
>1a19	67 13					.word	C32
>1a1b	33 b2					.byte	$33,$b2
.1a1d					_end43:
>1a1d	09					.byte	_end44-*
>1a1e	00					.byte	$00
>1a1f	ba 13					.word	C32767
>1a21	33 32 37 36 b7				.byte	$33,$32,$37,$36,$b7
.1a26					_end44:
>1a26	09					.byte	_end45-*
>1a27	00					.byte	$00
>1a28	c6 13					.word	C32768
>1a2a	33 32 37 36 b8				.byte	$33,$32,$37,$36,$b8
.1a2f					_end45:
>1a2f	05					.byte	_end46-*
>1a30	00					.byte	$00
>1a31	3e 13					.word	C4
>1a33	b4					.byte	$b4
.1a34					_end46:
>1a34	06					.byte	_end47-*
>1a35	00					.byte	$00
>1a36	bc 12					.word	Times4
>1a38	34 aa					.byte	$34,$aa
.1a3a					_end47:
>1a3a	06					.byte	_end48-*
>1a3b	00					.byte	$00
>1a3c	cf 12					.word	Divide4
>1a3e	34 af					.byte	$34,$af
.1a40					_end48:
>1a40	08					.byte	_end49-*
>1a41	00					.byte	$00
>1a42	ae 13					.word	C4096
>1a44	34 30 39 b6				.byte	$34,$30,$39,$b6
.1a48					_end49:
>1a48	05					.byte	_end50-*
>1a49	00					.byte	$00
>1a4a	42 13					.word	C5
>1a4c	b5					.byte	$b5
.1a4d					_end50:
>1a4d	07					.byte	_end51-*
>1a4e	00					.byte	$00
>1a4f	96 13					.word	C512
>1a51	35 31 b2				.byte	$35,$31,$b2
.1a54					_end51:
>1a54	06					.byte	_end52-*
>1a55	00					.byte	$00
>1a56	6b 13					.word	C63
>1a58	36 b3					.byte	$36,$b3
.1a5a					_end52:
>1a5a	06					.byte	_end53-*
>1a5b	00					.byte	$00
>1a5c	6f 13					.word	C64
>1a5e	36 b4					.byte	$36,$b4
.1a60					_end53:
>1a60	05					.byte	_end54-*
>1a61	00					.byte	$00
>1a62	46 13					.word	C8
>1a64	b8					.byte	$b8
.1a65					_end54:
>1a65	06					.byte	_end55-*
>1a66	00					.byte	$00
>1a67	b8 12					.word	Times8
>1a69	38 aa					.byte	$38,$aa
.1a6b					_end55:
>1a6b	06					.byte	_end56-*
>1a6c	00					.byte	$00
>1a6d	cb 12					.word	Divide8
>1a6f	38 af					.byte	$38,$af
.1a71					_end56:
>1a71	05					.byte	_end57-*
>1a72	40					.byte	$40
>1a73	e2 15					.word	ReturnHandler
>1a75	bb					.byte	$bb
.1a76					_end57:
>1a76	05					.byte	_end58-*
>1a77	00					.byte	$00
>1a78	d4 10					.word	CheckLess
>1a7a	bc					.byte	$bc
.1a7b					_end58:
>1a7b	06					.byte	_end59-*
>1a7c	00					.byte	$00
>1a7d	ed 10					.word	CheckLessEq
>1a7f	3c bd					.byte	$3c,$bd
.1a81					_end59:
>1a81	06					.byte	_end60-*
>1a82	00					.byte	$00
>1a83	9d 10					.word	CheckNotEqual
>1a85	3c be					.byte	$3c,$be
.1a87					_end60:
>1a87	05					.byte	_end61-*
>1a88	00					.byte	$00
>1a89	a0 10					.word	CheckEqual
>1a8b	bd					.byte	$bd
.1a8c					_end61:
>1a8c	05					.byte	_end62-*
>1a8d	00					.byte	$00
>1a8e	f0 10					.word	CheckGreater
>1a90	be					.byte	$be
.1a91					_end62:
>1a91	06					.byte	_end63-*
>1a92	00					.byte	$00
>1a93	d1 10					.word	CheckGreaterEq
>1a95	3e bd					.byte	$3e,$bd
.1a97					_end63:
>1a97	08					.byte	_end64-*
>1a98	00					.byte	$00
>1a99	db 13					.word	TestDup
>1a9b	3f 44 55 d0				.byte	$3f,$44,$55,$d0
.1a9f					_end64:
>1a9f	05					.byte	_end65-*
>1aa0	00					.byte	$00
>1aa1	50 14					.word	WordRead
>1aa3	c0					.byte	$c0
.1aa4					_end65:
>1aa4	07					.byte	_end66-*
>1aa5	00					.byte	$00
>1aa6	56 12					.word	Absolute
>1aa8	41 42 d3				.byte	$41,$42,$d3
.1aab					_end66:
>1aab	09					.byte	_end67-*
>1aac	00					.byte	$00
>1aad	93 14					.word	AllocateMemory
>1aaf	41 4c 4c 4f c3				.byte	$41,$4c,$4c,$4f,$c3
.1ab4					_end67:
>1ab4	07					.byte	_end68-*
>1ab5	00					.byte	$00
>1ab6	76 10					.word	And
>1ab8	41 4e c4				.byte	$41,$4e,$c4
.1abb					_end68:
>1abb	0a					.byte	_end69-*
>1abc	00					.byte	$00
>1abd	81 16					.word	AssertCode
>1abf	41 53 53 45 52 d4			.byte	$41,$53,$53,$45,$52,$d4
.1ac5					_end69:
>1ac5	09					.byte	_end70-*
>1ac6	00					.byte	$00
>1ac7	a9 12					.word	ByteSwap
>1ac9	42 53 57 41 d0				.byte	$42,$53,$57,$41,$d0
.1ace					_end70:
>1ace	06					.byte	_end71-*
>1acf	00					.byte	$00
>1ad0	5e 14					.word	ByteWrite
>1ad2	43 a1					.byte	$43,$a1
.1ad4					_end71:
>1ad4	06					.byte	_end72-*
>1ad5	00					.byte	$00
>1ad6	47 14					.word	ByteRead
>1ad8	43 c0					.byte	$43,$c0
.1ada					_end72:
>1ada	07					.byte	_end73-*
>1adb	00					.byte	$00
>1adc	22 16					.word	ClrHandler
>1ade	43 4c d2				.byte	$43,$4c,$d2
.1ae1					_end73:
>1ae1	08					.byte	_end74-*
>1ae2	00					.byte	$00
>1ae3	d2 13					.word	Drop
>1ae5	44 52 4f d0				.byte	$44,$52,$4f,$d0
.1ae9					_end74:
>1ae9	07					.byte	_end75-*
>1aea	00					.byte	$00
>1aeb	e4 13					.word	Dup
>1aed	44 55 d0				.byte	$44,$55,$d0
.1af0					_end75:
>1af0	08					.byte	_end76-*
>1af1	01					.byte	$01
>1af2	31 15					.word	ElseHandler
>1af4	45 4c 53 c5				.byte	$45,$4c,$53,$c5
.1af8					_end76:
>1af8	07					.byte	_end77-*
>1af9	00					.byte	$00
>1afa	a2 16					.word	EndProgram
>1afc	45 4e c4				.byte	$45,$4e,$c4
.1aff					_end77:
>1aff	09					.byte	_end78-*
>1b00	00					.byte	$00
>1b01	34 15					.word	EndIfHandler
>1b03	45 4e 44 49 c6				.byte	$45,$4e,$44,$49,$c6
.1b08					_end78:
>1b08	07					.byte	_end79-*
>1b09	00					.byte	$00
>1b0a	a9 14					.word	ForHandler
>1b0c	46 4f d2				.byte	$46,$4f,$d2
.1b0f					_end79:
>1b0f	06					.byte	_end80-*
>1b10	01					.byte	$01
>1b11	2e 15					.word	IfHandler
>1b13	49 c6					.byte	$49,$c6
.1b15					_end80:
>1b15	09					.byte	_end81-*
>1b16	00					.byte	$00
>1b17	0d 15					.word	GetIndex
>1b19	49 4e 44 45 d8				.byte	$49,$4e,$44,$45,$d8
.1b1e					_end81:
>1b1e	07					.byte	_end82-*
>1b1f	00					.byte	$00
>1b20	0d 11					.word	Maximum
>1b22	4d 41 d8				.byte	$4d,$41,$d8
.1b25					_end82:
>1b25	07					.byte	_end83-*
>1b26	00					.byte	$00
>1b27	09 11					.word	Minimum
>1b29	4d 49 ce				.byte	$4d,$49,$ce
.1b2c					_end83:
>1b2c	07					.byte	_end84-*
>1b2d	00					.byte	$00
>1b2e	49 11					.word	Modulus16x16
>1b30	4d 4f c4				.byte	$4d,$4f,$c4
.1b33					_end84:
>1b33	0a					.byte	_end85-*
>1b34	00					.byte	$00
>1b35	5d 12					.word	Negate
>1b37	4e 45 47 41 54 c5			.byte	$4e,$45,$47,$41,$54,$c5
.1b3d					_end85:
>1b3d	07					.byte	_end86-*
>1b3e	00					.byte	$00
>1b3f	19 16					.word	NewHandler
>1b41	4e 45 d7				.byte	$4e,$45,$d7
.1b44					_end86:
>1b44	08					.byte	_end87-*
>1b45	01					.byte	$01
>1b46	d7 14					.word	NextHandler
>1b48	4e 45 58 d4				.byte	$4e,$45,$58,$d4
.1b4c					_end87:
>1b4c	07					.byte	_end88-*
>1b4d	00					.byte	$00
>1b4e	18 14					.word	Nip
>1b50	4e 49 d0				.byte	$4e,$49,$d0
.1b53					_end88:
>1b53	07					.byte	_end89-*
>1b54	00					.byte	$00
>1b55	6d 12					.word	OneComplement
>1b57	4e 4f d4				.byte	$4e,$4f,$d4
.1b5a					_end89:
>1b5a	06					.byte	_end90-*
>1b5b	00					.byte	$00
>1b5c	90 10					.word	LogOr
>1b5e	4f d2					.byte	$4f,$d2
.1b60					_end90:
>1b60	08					.byte	_end91-*
>1b61	00					.byte	$00
>1b62	00 14					.word	Over
>1b64	4f 56 45 d2				.byte	$4f,$56,$45,$d2
.1b68					_end91:
>1b68	0a					.byte	_end92-*
>1b69	00					.byte	$00
>1b6a	37 15					.word	RepeatHandler
>1b6c	52 45 50 45 41 d4			.byte	$52,$45,$50,$45,$41,$d4
.1b72					_end92:
>1b72	07					.byte	_end93-*
>1b73	00					.byte	$00
>1b74	ec 12					.word	RandomNumber
>1b76	52 4e c4				.byte	$52,$4e,$c4
.1b79					_end93:
>1b79	07					.byte	_end94-*
>1b7a	00					.byte	$00
>1b7b	1d 14					.word	Rot
>1b7d	52 4f d4				.byte	$52,$4f,$d4
.1b80					_end94:
>1b80	07					.byte	_end95-*
>1b81	00					.byte	$00
>1b82	98 12					.word	SignTOS
>1b84	53 47 ce				.byte	$53,$47,$ce
.1b87					_end95:
>1b87	08					.byte	_end96-*
>1b88	00					.byte	$00
>1b89	9a 16					.word	StopCode
>1b8b	53 54 4f d0				.byte	$53,$54,$4f,$d0
.1b8f					_end96:
>1b8f	08					.byte	_end97-*
>1b90	00					.byte	$00
>1b91	ed 13					.word	Swap
>1b93	53 57 41 d0				.byte	$53,$57,$41,$d0
.1b97					_end97:
>1b97	07					.byte	_end98-*
>1b98	00					.byte	$00
>1b99	6a 16					.word	Call6502
>1b9b	53 59 d3				.byte	$53,$59,$d3
.1b9e					_end98:
>1b9e	0e					.byte	_end99-*
>1b9f	00					.byte	$00
>1ba0	a5 16					.word	NumToInt
>1ba2	54 4f 2e 49 4e 54 45 47			.byte	$54,$4f,$2e,$49,$4e,$54,$45,$47,$45,$d2
>1baa	45 d2
.1bac					_end99:
>1bac	0d					.byte	_end100-*
>1bad	00					.byte	$00
>1bae	86 17					.word	IntToString
>1bb0	54 4f 2e 53 54 52 49 4e			.byte	$54,$4f,$2e,$53,$54,$52,$49,$4e,$c7
>1bb8	c7
.1bb9					_end100:
>1bb9	09					.byte	_end101-*
>1bba	01					.byte	$01
>1bbb	3a 15					.word	UntilHandler
>1bbd	55 4e 54 49 cc				.byte	$55,$4e,$54,$49,$cc
.1bc2					_end101:
>1bc2	0a					.byte	_end102-*
>1bc3	40					.byte	$40
>1bc4	66 16					.word	BreakCmd
>1bc6	58 42 52 45 41 cb			.byte	$58,$42,$52,$45,$41,$cb
.1bcc					_end102:
>1bcc	09					.byte	_end103-*
>1bcd	00					.byte	$00
>1bce	60 16					.word	ExitDump
>1bd0	58 44 55 4d d0				.byte	$58,$44,$55,$4d,$d0
.1bd5					_end103:
>1bd5	07					.byte	_end104-*
>1bd6	00					.byte	$00
>1bd7	83 10					.word	Xor
>1bd9	58 4f d2				.byte	$58,$4f,$d2
.1bdc					_end104:
>1bdc	00					.byte	0

;******  Return to file: kernel.asm

>3fff	ff						.byte 	$FF
.4000					ProgramMemory:

;******  End of listing
