
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -q -c -D encode=1 -o kernel_nocode.prg -L kernel.lst -l kernel.lbl kernel.asm
; Wed Jan 15 14:42:00 2020

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=1					encode=1

;******  Processing input file: kernel.asm

=$1000					RplBuild = $1000 							; code starts here.

;******  Processing file: code/data.asm

.0000					NextCode:
>0000							.fill 	5
=3					IP = NextCode+3 							; the IP which points to the current instruction
.0005					rsp:
>0005							.byte 	?
.0006					tos:
>0006							.word 	?
.0008					srcPtr:
>0008							.word 	?
.000a					bufPtr:
>000a							.word 	?
.000c					matchPtr:
>000c							.word 	?
.000e					nextFreeMem:
>000e							.word 	?
.0010					temp1:
>0010							.word 	?
.0012					temp2:
>0012							.word 	?
.0014					temp3:
>0014							.word 	?
.0016					temp4:
>0016							.word 	?
.0018					listPtr:
>0018							.word 	?
.001a					SignCount:
>001a							.byte 	?
.001b					RandomSeed:
>001b							.word 	?
.001d					ListCount:
>001d							.byte 	?
.001e					ListLowest:
>001e							.word 	?
=$102					stack2Low = $102							; access other stack members following tsx
=$101					stack2High = $101							; (which requires saving X, not on the stack !)
=$104					stack3Low = $104
=$103					stack3High = $103
=$600					azVariables = $600 							; 26 x 2 variables occupying 52 bytes * PAGE BOUNDARY *
=16					hashTableSize = 16 							; hash tables for variables.
=$640					hashTable = $640 							; hash tables start here * ALL ON ONE PAGE *
=$810					textBuffer = $810 							; buffer for text.
=$700					returnStack = $700							; return stack (1 page)
=$700					returnStackLow = returnStack
=1856					returnStackHigh = returnStack+$40
=1920					returnStackX = returnStack+$80
=$80					NumberStackBase = $80 						; number stack down from here.
=$910					encodeBuffer = $910 						; buffer for encoded program
=0					COL_BLACK = 0
=1					COL_RED = 1
=2					COL_GREEN = 2
=3					COL_YELLOW = 3
=4					COL_BLUE = 4
=5					COL_MAGENTA = 5
=6					COL_CYAN = 6
=7					COL_WHITE = 7
=8					COL_RVS = 8
=2					CTH_LineNo = COL_Green
=6					CTH_Keyword = COL_Cyan
=11					CTH_Comment = COL_Yellow+COL_Rvs
=7					CTH_Definition = COL_White
=5					CTH_String = COL_Magenta
=3					CTH_Call = COL_Yellow
=7					CTH_Variable = COL_White

;******  Return to file: kernel.asm

.1000	a2 ff		ldx #$ff			ldx 	#$FF 						; reset the stack
.1002	9a		txs				txs
.1003	20 35 11	jsr $1135			jsr 	ExternInitialise
.1006	a9 46		lda #$46			lda 	#BootMsg & $FF
.1008	a0 10		ldy #$10			ldy 	#BootMsg >> 8
.100a	20 27 12	jsr $1227			jsr 	EXPrintString
.100d					WarmStartBlankStack:
.100d	86 10		stx $10				stx 	temp1
.100f	a2 80		ldx #$80			ldx 	#NumberStackBase
.1011	9a		txs				txs
.1012	a6 10		ldx $10				ldx 	temp1
.1014	4c b6 27	jmp $27b6			jmp 	EncodeTest
.1017					WarmStart:
.1017	a9 03		lda #$03			lda 	#COL_Yellow
.1019	20 6c 11	jsr $116c			jsr 	ExternColour
.101c	20 8f 11	jsr $118f			jsr 	ExternInput
.101f	a9 06		lda #$06			lda 	#COL_Cyan
.1021	20 6c 11	jsr $116c			jsr 	ExternColour
.1024	a2 10		ldx #$10			ldx 	#encodeBuffer & $FF 		; run what is in the encode buffer.
.1026	a0 09		ldy #$09			ldy 	#encodeBuffer >> 8
.1028	20 98 10	jsr $1098			jsr 	InitialiseCoreCode 			; initialise the NEXT routine at $00 so error line# works
.102b	a9 10		lda #$10			lda 	#textBuffer & $FF
.102d	a0 08		ldy #$08			ldy 	#textBuffer >> 8
.102f	20 93 16	jsr $1693			jsr 	EncodeProgram
.1032	ad 11 09	lda $0911			lda 	encodeBuffer+1 				; has a line number been entered ?
.1035	0d 12 09	ora $0912			ora 	encodeBuffer+2
.1038	d0 07		bne $1041			bne 	LineEditor 					; if so, do the line editing code.
.103a	a9 ff		lda #$ff			lda 	#$FF
.103c	85 05		sta $05				sta 	rsp
.103e	4c 00 00	jmp $0000			jmp 	NextCode
.1041					LineEditor:
.1041	20 a2 1e	jsr $1ea2			jsr 	EditProgram
.1044	80 c7		bra $100d			bra 	WarmStartBlankStack
.1046					BootMsg:
>1046	2a 2a 2a 20 52 50 4c 2f				.text 	"*** RPL/C INTERPRETER ***",13,13
>104e	43 20 49 4e 54 45 52 50 52 45 54 45 52 20 2a 2a
>105e	2a 0d 0d
>1061	57 52 49 54 54 45 4e 20				.text	"WRITTEN BY PAUL ROBSON 2020",13,13
>1069	42 59 20 50 41 55 4c 20 52 4f 42 53 4f 4e 20 32
>1079	30 32 30 0d 0d
>107e	42 55 49 4c 44 3a 20				.text 	"BUILD: "

;******  Processing file: generated/timestamp.inc

>1085	5b 32 30 2d 30 31 2d 31			.text	"[20-01-15 14:41]"
>108d	35 20 31 34 3a 34 31 5d

;******  Return to file: kernel.asm

>1095	0d 0d 00					.byte 	13,13,0

;******  Processing file: code/core.src

.1098					InitialiseCoreCode:
.1098	a9 e8		lda #$e8			lda 	#$E8 					; Copy INX INX 			4 cycles when run
.109a	85 00		sta $00				sta 	NextCode
.109c	85 01		sta $01				sta 	NextCode+1
.109e	a9 7c		lda #$7c			lda 	#$7C 					; Copy JMP ($aaaa,x) 	6 cycles when run
.10a0	85 02		sta $02				sta 	NextCode+2
.10a2	86 03		stx $03				stx 	NextCode+3 				; set the indirect address (IP)
.10a4	84 04		sty $04				sty 	NextCode+4
.10a6	a2 01		ldx #$01			ldx 	#1 						; set up to run from provided word.
.10a8	60		rts				rts								; (2 INX skip offset and line#)
.10a9					Literal2Byte:
.10a9	a5 06		lda $06				lda 	TOS
.10ab	48		pha				pha
.10ac	a5 07		lda $07				lda 	TOS+1
.10ae	48		pha				pha
.10af	e8		inx				inx  							; point X to the word
.10b0	e8		inx				inx
.10b1	8a		txa				txa 							; copy into Y
.10b2	a8		tay				tay
.10b3	b1 03		lda ($03),y			lda 	(IP),y 					; read it. the LSB
.10b5	85 06		sta $06				sta 	TOS
.10b7	c8		iny				iny 							; read and push the MSB
.10b8	b1 03		lda ($03),y			lda 	(IP),y
.10ba	85 07		sta $07				sta 	TOS+1
.10bc	4c 00 00	jmp $0000			jmp 	NextCode
.10bf					Literal2ByteDecode:
.10bf	a9 06		lda #$06			lda 	#CTH_Keyword
.10c1	20 63 1e	jsr $1e63			jsr 	DecodeWriteBuffer
.10c4	b1 08		lda ($08),y			lda 	(srcPtr),y
.10c6	aa		tax				tax
.10c7	c8		iny				iny
.10c8	b1 08		lda ($08),y			lda 	(srcPtr),y
.10ca	a8		tay				tay
.10cb	8a		txa				txa
.10cc	38		sec				sec 							; output signed
.10cd	20 85 1e	jsr $1e85			jsr 	DecodeYAToBuffer
.10d0	60		rts				rts
.10d1					LiteralString:
.10d1	a5 06		lda $06				lda 	TOS
.10d3	48		pha				pha
.10d4	a5 07		lda $07				lda 	TOS+1
.10d6	48		pha				pha
.10d7	e8		inx				inx
.10d8	e8		inx				inx 							; skip over current word
.10d9	8a		txa				txa 							; add to IP + 1 to give string address
.10da	a8		tay				tay 							; put in Y
.10db	38		sec				sec 							; make that TOS
.10dc	65 03		adc $03				adc 	IP
.10de	85 06		sta $06				sta 	TOS
.10e0	a5 04		lda $04				lda 	IP+1
.10e2	69 00		adc #$00			adc 	#0
.10e4	85 07		sta $07				sta 	TOS+1
.10e6	8a		txa				txa 							; add data length to X
.10e7	18		clc				clc
.10e8	71 03		adc ($03),y			adc 	(IP),y
.10ea	aa		tax				tax
.10eb	ca		dex				dex
.10ec	ca		dex				dex
.10ed	4c 00 00	jmp $0000			jmp 	NextCode
.10f0					LiteralStringDecoder:
.10f0	a9 05		lda #$05			lda 	#CTH_String
.10f2	20 63 1e	jsr $1e63			jsr 	DecodeWriteBuffer
.10f5	a9 22		lda #$22			lda 	#'"'
.10f7	20 63 1e	jsr $1e63			jsr 	DecodeWriteBuffer
.10fa	20 6c 1e	jsr $1e6c			jsr 	DecodeOutputData
.10fd	20 63 1e	jsr $1e63			jsr 	DecodeWriteBuffer
.1100	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: code/error.asm

.1101					ErrorHandler:
>1101	ff						.byte 	$FF
.1102	68		pla				pla 								; get message address
.1103	7a		ply				ply
.1104	1a		inc a				inc 	a
.1105	d0 01		bne $1108			bne 	_EHNoCarry
.1107	c8		iny				iny
.1108					_EHNoCarry:
.1108	20 27 12	jsr $1227			jsr 	EXPrintString
.110b	a0 01		ldy #$01			ldy 	#1 							; check if there is a line #
.110d	b1 03		lda ($03),y			lda 	(IP),y
.110f	c8		iny				iny
.1110	11 03		ora ($03),y			ora 	(IP),y
.1112	f0 14		beq $1128			beq 	_EHNoLine
.1114	a9 30		lda #$30			lda 	#_EHMsg2 & $FF 				; print " at "
.1116	a0 11		ldy #$11			ldy 	#_EHMsg2 >> 8
.1118	20 27 12	jsr $1227			jsr 	EXPrintString
.111b	a0 02		ldy #$02			ldy 	#2 							; print line number
.111d	b1 03		lda ($03),y			lda 	(IP),y
.111f	48		pha				pha
.1120	88		dey				dey
.1121	b1 03		lda ($03),y			lda 	(IP),y
.1123	7a		ply				ply
.1124	18		clc				clc
.1125	20 89 22	jsr $2289			jsr 	PrintYA
.1128					_EHNoLine:
.1128	a9 0d		lda #$0d			lda 	#13
.112a	20 62 11	jsr $1162			jsr 	ExternPrint
.112d	4c 0d 10	jmp $100d			jmp 	WarmStartBlankStack			; S is indeterminate
>1130	20 41 54 20 00			_EHMsg2:.text 	" AT ",0

;******  Return to file: kernel.asm


;******  Processing file: code/extern.asm

.1135					ExternInitialise:
.1135	a9 90		lda #$90			lda 	#144 						; set colour
.1137	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.113a	a9 01		lda #$01			lda 	#$01
.113c	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.113f	a9 0e		lda #$0e			lda 	#14							; lower case
.1141	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.1144	a9 93		lda #$93			lda 	#147 						; clear screen
.1146	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.1149	a9 07		lda #$07			lda 	#COL_WHITE 					; white text.
.114b	4c 6c 11	jmp $116c			jmp 	ExternColour
.114e					ExternCheckBreak:
.114e	da		phx				phx 								; make sure we keep XY
.114f	5a		phy				phy
.1150	20 e1 ff	jsr $ffe1			jsr 	$FFE1						; STOP check on CBM KERNAL
.1153	f0 03		beq $1158			beq		_ECBExit 					; stopped
.1155	7a		ply				ply 								; restore and exit.
.1156	fa		plx				plx
.1157	60		rts				rts
.1158					_ECBExit:
.1158	20 01 11	jsr $1101			jsr 	ErrorHandler
>115b	45 53 43 41 50 45 00				.text 	"ESCAPE",0
.1162					ExternPrint:
.1162	48		pha				pha
.1163	da		phx				phx
.1164	5a		phy				phy
.1165	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.1168	7a		ply				ply
.1169	fa		plx				plx
.116a	68		pla				pla
.116b	60		rts				rts
.116c					ExternColour:
.116c	48		pha				pha
.116d	da		phx				phx
.116e	48		pha				pha
.116f	29 08		and #$08			and 	#8
.1171	0a		asl a				asl 	a
.1172	0a		asl a				asl 	a
.1173	0a		asl a				asl 	a
.1174	0a		asl a				asl 	a
.1175	49 92		eor #$92			eor 	#$92
.1177	20 62 11	jsr $1162			jsr 	ExternPrint
.117a	68		pla				pla
.117b	29 07		and #$07			and 	#7
.117d	aa		tax				tax
.117e	bd 87 11	lda $1187,x			lda 	_ECTable,x
.1181	20 62 11	jsr $1162			jsr 	ExternPrint
.1184	fa		plx				plx
.1185	68		pla				pla
.1186	60		rts				rts
.1187					_ECTable:
>1187	90						.byte 	144
>1188	1c						.byte 	28
>1189	1e						.byte 	30
>118a	9e						.byte 	158
>118b	1f						.byte 	31
>118c	9c						.byte 	156
>118d	9f						.byte 	159
>118e	05						.byte 	5
.118f					ExternInput:
.118f	a9 10		lda #$10			lda 	#(textBuffer & $FF)
.1191	85 14		sta $14				sta 	temp3
.1193	a9 08		lda #$08			lda 	#(textBuffer >> 8)
.1195	85 15		sta $15				sta 	temp3+1
.1197	20 cf ff	jsr $ffcf	_EIRead:jsr 	$FFCF
.119a	29 7f		and #$7f			and 	#$7F
.119c	c9 0d		cmp #$0d			cmp 	#13
.119e	f0 0a		beq $11aa			beq 	_EIExit
.11a0	92 14		sta ($14)			sta 	(temp3)
.11a2	e6 14		inc $14				inc 	temp3
.11a4	d0 f1		bne $1197			bne 	_EIRead
.11a6	e6 15		inc $15				inc 	temp3+1
.11a8	80 ed		bra $1197			bra 	_EIRead
.11aa	a9 00		lda #$00	_EIExit:lda 	#0
.11ac	92 14		sta ($14)			sta 	(temp3)
.11ae	a9 0d		lda #$0d			lda 	#13
.11b0	20 62 11	jsr $1162			jsr 	ExternPrint
.11b3	60		rts				rts
.11b4					ExternSave:
.11b4	da		phx				phx
.11b5	5a		phy				phy
.11b6	85 12		sta $12				sta 	temp2 						; save start
.11b8	84 13		sty $13				sty 	temp2+1
.11ba	20 1c 12	jsr $121c			jsr 	EXGetLength 				; get length of file into A
.11bd	a6 14		ldx $14				ldx 	temp3
.11bf	a4 15		ldy $15				ldy 	temp3+1
.11c1	20 bd ff	jsr $ffbd			jsr 	$FFBD 						; set name
.11c4	a9 01		lda #$01			lda 	#1
.11c6	a2 08		ldx #$08			ldx 	#8	 						; device #8
.11c8	a0 00		ldy #$00			ldy 	#0
.11ca	20 ba ff	jsr $ffba			jsr 	$FFBA 						; set LFS
.11cd	a6 10		ldx $10				ldx 	temp1 						; end address
.11cf	a4 11		ldy $11				ldy 	temp1+1
.11d1	a9 12		lda #$12			lda 	#temp2
.11d3	20 d8 ff	jsr $ffd8			jsr 	$FFD8 						; save
.11d6	b0 03		bcs $11db			bcs 	_ESSave
.11d8	7a		ply				ply
.11d9	fa		plx				plx
.11da	60		rts				rts
.11db					_ESSave:
.11db	20 01 11	jsr $1101			jsr 	ErrorHandler
>11de	53 41 56 45 20 46 41 49				.text 	"SAVE FAILED",0
>11e6	4c 45 44 00
.11ea					ExternLoad:
.11ea	da		phx				phx 								; save XY
.11eb	5a		phy				phy
.11ec	48		pha				pha 								; save target
.11ed	5a		phy				phy
.11ee	20 1c 12	jsr $121c			jsr 	EXGetLength 				; get length of file into A
.11f1	a6 14		ldx $14				ldx 	temp3
.11f3	a4 15		ldy $15				ldy 	temp3+1
.11f5	20 bd ff	jsr $ffbd			jsr 	$FFBD 						; set name
.11f8	a9 01		lda #$01			lda 	#1
.11fa	a2 08		ldx #$08			ldx 	#8	 						; device #8
.11fc	a0 00		ldy #$00			ldy 	#0
.11fe	20 ba ff	jsr $ffba			jsr 	$FFBA 						; set LFS
.1201	7a		ply				ply 								; restore target to YX and call load
.1202	fa		plx				plx
.1203	a9 00		lda #$00			lda 	#0 							; load command
.1205	20 d5 ff	jsr $ffd5			jsr 	$FFD5
.1208	b0 03		bcs $120d			bcs 	_ESLoad
.120a	7a		ply				ply
.120b	fa		plx				plx
.120c	60		rts				rts
.120d					_ESLoad:
.120d	20 01 11	jsr $1101			jsr 	ErrorHandler
>1210	4c 4f 41 44 20 46 41 49				.text 	"LOAD FAILED",0
>1218	4c 45 44 00
.121c					EXGetLength:
.121c	5a		phy				phy
.121d	a0 ff		ldy #$ff			ldy 	#255
.121f	c8		iny		_EXGL0:	iny
.1220	b1 14		lda ($14),y			lda 	(temp3),y
.1222	d0 fb		bne $121f			bne 	_EXGL0
.1224	98		tya				tya
.1225	7a		ply				ply
.1226	60		rts				rts
.1227					EXPrintString:
.1227	48		pha				pha
.1228	5a		phy				phy
.1229	84 11		sty $11				sty 	temp1+1
.122b	85 10		sta $10				sta 	temp1
.122d	a0 00		ldy #$00			ldy 	#0
.122f					_EXPSLoop:
.122f	b1 10		lda ($10),y			lda 	(temp1),y
.1231	f0 08		beq $123b			beq 	_EXPSExit
.1233	29 7f		and #$7f			and 	#$7F
.1235	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.1238	c8		iny				iny
.1239	80 f4		bra $122f			bra 	_EXPSLoop
.123b					_EXPSExit:
.123b	7a		ply				ply
.123c	68		pla				pla
.123d	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/binary.src

.123e					Add:
.123e	7a		ply				ply
.123f	68		pla				pla
.1240	18		clc				clc
.1241	65 06		adc $06				adc 	TOS
.1243	85 06		sta $06				sta 	TOS
.1245	98		tya				tya
.1246	65 07		adc $07				adc 	TOS+1
.1248	85 07		sta $07				sta 	TOS+1
.124a	4c 00 00	jmp $0000			jmp 	NextCode
.124d					Subtract:
.124d	7a		ply				ply
.124e	68		pla				pla
.124f	38		sec				sec
.1250	49 ff		eor #$ff			eor 	#$FF
.1252	65 06		adc $06				adc 	TOS
.1254	85 06		sta $06				sta 	TOS
.1256	98		tya				tya
.1257	49 ff		eor #$ff			eor 	#$FF
.1259	65 07		adc $07				adc 	TOS+1
.125b	85 07		sta $07				sta 	TOS+1
.125d	4c 00 00	jmp $0000			jmp 	NextCode
.1260					And:
.1260	68		pla				pla
.1261	25 07		and $07				and 	TOS+1
.1263	85 07		sta $07				sta 	TOS+1
.1265	68		pla				pla
.1266	25 06		and $06				and 	TOS
.1268	85 06		sta $06				sta 	TOS
.126a	4c 00 00	jmp $0000			jmp 	NextCode
.126d					Xor:
.126d	68		pla				pla
.126e	45 07		eor $07				eor 	TOS+1
.1270	85 07		sta $07				sta 	TOS+1
.1272	68		pla				pla
.1273	45 06		eor $06				eor 	TOS
.1275	85 06		sta $06				sta 	TOS
.1277	4c 00 00	jmp $0000			jmp 	NextCode
.127a					LogOr:
.127a	68		pla				pla
.127b	05 07		ora $07				ora 	TOS+1
.127d	85 07		sta $07				sta 	TOS+1
.127f	68		pla				pla
.1280	05 06		ora $06				ora 	TOS
.1282	85 06		sta $06				sta 	TOS
.1284	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/compare.src

.1287					CheckNotEqual:
.1287	38		sec				sec
.1288	80 01		bra $128b			bra 	CECode
.128a					CheckEqual:
.128a	18		clc				clc
.128b					CECode:
.128b	86 10		stx $10				stx 	temp1
.128d	ba		tsx				tsx
.128e	08		php				php
.128f	a5 06		lda $06				lda 	TOS
.1291	5d 02 01	eor $0102,x			eor 	Stack2Low,x
.1294	d0 17		bne $12ad			bne	 	CompareFalse
.1296	a5 07		lda $07				lda 	TOS+1
.1298	5d 01 01	eor $0101,x			eor 	Stack2High,x
.129b	d0 10		bne $12ad			bne 	CompareFalse
.129d					CompareTrue:
.129d	a6 10		ldx $10				ldx 	temp1
.129f	28		plp				plp
.12a0	b0 10		bcs $12b2			bcs		CompareFalse2
.12a2					CompareTrue2:
.12a2	68		pla				pla
.12a3	68		pla				pla
.12a4	a9 ff		lda #$ff			lda 	#$FF
.12a6	85 06		sta $06				sta 	TOS
.12a8	85 07		sta $07				sta 	TOS+1
.12aa	4c 00 00	jmp $0000			jmp 	NextCode
.12ad					CompareFalse:
.12ad	a6 10		ldx $10				ldx 	temp1
.12af	28		plp				plp
.12b0	b0 f0		bcs $12a2			bcs		CompareTrue2
.12b2					CompareFalse2:
.12b2	68		pla				pla
.12b3	68		pla				pla
.12b4	64 06		stz $06				stz 	TOS
.12b6	64 07		stz $07				stz 	TOS+1
.12b8	4c 00 00	jmp $0000			jmp 	NextCode
.12bb					CheckGreaterEq:
.12bb	38		sec				sec
.12bc	80 01		bra $12bf			bra		CLCode
.12be					CheckLess:
.12be	18		clc				clc
.12bf	86 10		stx $10		CLCode:	stx 	temp1
.12c1	ba		tsx				tsx
.12c2	08		php				php
.12c3	18		clc				clc
.12c4	a5 06		lda $06				lda 	TOS
.12c6	fd 02 01	sbc $0102,x			sbc 	Stack2Low,x
.12c9	a5 07		lda $07				lda 	TOS+1
.12cb	fd 01 01	sbc $0101,x			sbc 	Stack2High,x
.12ce	50 02		bvc $12d2			bvc 	_CLNoFlip
.12d0	49 80		eor #$80			eor 	#$80
.12d2					_CLNoFlip:
.12d2	0a		asl a				asl 	a
.12d3	b0 d8		bcs $12ad			bcs 	CompareFalse
.12d5	80 c6		bra $129d			bra 	CompareTrue
.12d7					CheckLessEq:
.12d7	38		sec				sec
.12d8	80 01		bra $12db			bra		CGCode
.12da					CheckGreater:
.12da	18		clc				clc
.12db					CGCode:
.12db	86 10		stx $10				stx 	temp1
.12dd	ba		tsx				tsx
.12de	08		php				php
.12df	18		clc				clc
.12e0	bd 02 01	lda $0102,x			lda 	Stack2Low,x
.12e3	e5 06		sbc $06				sbc 	TOS
.12e5	bd 01 01	lda $0101,x			lda 	Stack2High,x
.12e8	e5 07		sbc $07				sbc 	TOS+1
.12ea	50 02		bvc $12ee			bvc 	_CGNoFlip
.12ec	49 80		eor #$80			eor 	#$80
.12ee					_CGNoFlip:
.12ee	0a		asl a				asl 	a
.12ef	b0 bc		bcs $12ad			bcs 	CompareFalse
.12f1	80 aa		bra $129d			bra 	CompareTrue
.12f3					Minimum:
.12f3	a9 00		lda #$00			lda 	#0
.12f5	80 02		bra $12f9			bra 	MinMaxCode
.12f7					Maximum:
.12f7	a9 80		lda #$80			lda 	#$80
.12f9					MinMaxCode:
.12f9	85 11		sta $11				sta 	temp1+1
.12fb	86 10		stx $10				stx 	temp1
.12fd	ba		tsx				tsx
.12fe	38		sec				sec
.12ff	a5 06		lda $06				lda 	TOS
.1301	fd 02 01	sbc $0102,x			sbc 	Stack2Low,x
.1304	a5 07		lda $07				lda 	TOS+1
.1306	fd 01 01	sbc $0101,x			sbc 	Stack2High,x
.1309	50 02		bvc $130d			bvc 	_MMNoFlip
.130b	49 80		eor #$80			eor 	#$80
.130d					_MMNoFlip:
.130d	45 11		eor $11				eor 	temp1+1
.130f	30 0a		bmi $131b			bmi 	_MMNoCopy
.1311	bd 02 01	lda $0102,x			lda 	Stack2Low,x
.1314	85 06		sta $06				sta 	TOS
.1316	bd 01 01	lda $0101,x			lda 	Stack2High,x
.1319	85 07		sta $07				sta 	TOS+1
.131b					_MMNoCopy:
.131b	a6 10		ldx $10				ldx 	temp1
.131d	68		pla				pla
.131e	68		pla				pla
.131f	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/divide.src

.1322					Divide16x16:
.1322	86 12		stx $12				stx 	temp2
.1324	ba		tsx				tsx
.1325	20 48 13	jsr $1348			jsr 	IntegerDivide
.1328	68		pla				pla
.1329	85 07		sta $07				sta 	TOS+1
.132b	68		pla				pla
.132c	85 06		sta $06				sta 	TOS
.132e	a6 12		ldx $12				ldx 	temp2
.1330	4c 00 00	jmp $0000			jmp 	NextCode
.1333					Modulus16x16:
.1333	86 12		stx $12				stx 	temp2
.1335	ba		tsx				tsx
.1336	20 48 13	jsr $1348			jsr 	IntegerDivide
.1339	a6 12		ldx $12				ldx 	temp2
.133b	68		pla				pla
.133c	68		pla				pla
.133d	a5 10		lda $10				lda 	temp1
.133f	85 06		sta $06				sta 	TOS
.1341	a5 11		lda $11				lda 	temp1+1
.1343	85 07		sta $07				sta 	TOS+1
.1345	4c 00 00	jmp $0000			jmp 	NextCode
.1348					IntegerDivide:
.1348	a5 06		lda $06				lda 	TOS 				; check for division by zero.
.134a	05 07		ora $07				ora 	TOS+1
.134c	d0 14		bne $1362			bne 	_BFDOkay
.134e	20 01 11	jsr $1101			jsr 	ErrorHandler
>1351	44 49 56 49 53 49 4f 4e				.text 	"DIVISION BY ZERO",0
>1359	20 42 59 20 5a 45 52 4f 00
.1362					_BFDOkay:
.1362	64 10		stz $10				stz 	temp1 						; Q/Dividend/Left in +0
.1364	64 11		stz $11				stz 	temp1+1 					; M/Divisor/Right in +2
.1366	64 1a		stz $1a				stz 	SignCount 					; Count of signs.
.1368	20 a3 13	jsr $13a3			jsr 	CheckIntegerNegate 			; negate 2nd (and bump sign count)
.136b	20 bd 13	jsr $13bd			jsr 	CheckTOSNegate 				; negate TOS (and bump sign count)
.136e	5a		phy				phy 								; Y is the counter
.136f	a0 10		ldy #$10			ldy 	#16 						; 16 iterations of the loop.
.1371					_BFDLoop:
.1371	1e 02 01	asl $0102,x			asl 	Stack2Low,x 				; shift AQ left.
.1374	3e 01 01	rol $0101,x			rol 	Stack2High,x
.1377	26 10		rol $10				rol 	temp1
.1379	26 11		rol $11				rol 	temp1+1
.137b	38		sec				sec
.137c	a5 10		lda $10				lda 	temp1+0 					; Calculate A-M on stack.
.137e	e5 06		sbc $06				sbc 	TOS
.1380	48		pha				pha
.1381	a5 11		lda $11				lda 	temp1+1
.1383	e5 07		sbc $07				sbc 	TOS+1
.1385	90 0f		bcc $1396			bcc 	_BFDNoAdd
.1387	85 11		sta $11				sta 	temp1+1
.1389	68		pla				pla
.138a	85 10		sta $10				sta 	temp1+0
.138c	bd 02 01	lda $0102,x			lda 	Stack2Low,x 				; set Q bit 1.
.138f	09 01		ora #$01			ora 	#1
.1391	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.1394	80 01		bra $1397			bra 	_BFDNext
.1396					_BFDNoAdd:
.1396	68		pla				pla 								; Throw away the intermediate calculations
.1397					_BFDNext:
.1397	88		dey				dey
.1398	d0 d7		bne $1371			bne 	_BFDLoop
.139a	7a		ply				ply 								; restore Y
.139b	46 1a		lsr $1a				lsr 	SignCount 					; if sign count odd,
.139d	90 03		bcc $13a2			bcc 	_BFDUnsigned 				; then the result is signed
.139f	20 a9 13	jsr $13a9			jsr		IntegerNegateAlways 		; negate the result
.13a2					_BFDUnsigned:
.13a2	60		rts				rts
.13a3					CheckIntegerNegate:
.13a3	bd 01 01	lda $0101,x			lda 	Stack2High,x 				; is it -ve = MSB set ?
.13a6	30 01		bmi $13a9			bmi 	IntegerNegateAlways 		; if so negate it
.13a8	60		rts				rts
.13a9					IntegerNegateAlways:
.13a9	e6 1a		inc $1a				inc 	SignCount 					; bump the count of signs
.13ab	38		sec				sec 								; negate
.13ac	a9 00		lda #$00			lda 	#0
.13ae	fd 02 01	sbc $0102,x			sbc 	Stack2Low,x
.13b1	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.13b4	a9 00		lda #$00			lda 	#0
.13b6	fd 01 01	sbc $0101,x			sbc 	Stack2High,x
.13b9	9d 01 01	sta $0101,x			sta 	Stack2High,x
.13bc	60		rts				rts
.13bd					CheckTOSNegate:
.13bd	a5 07		lda $07				lda 	TOS+1
.13bf	10 0f		bpl $13d0			bpl		CTNNoChange
.13c1	e6 1a		inc $1a				inc 	SignCount
.13c3					TOSNegateAlways:
.13c3	38		sec				sec
.13c4	a9 00		lda #$00			lda 	#0
.13c6	e5 06		sbc $06				sbc 	TOS
.13c8	85 06		sta $06				sta 	TOS
.13ca	a9 00		lda #$00			lda 	#0
.13cc	e5 07		sbc $07				sbc 	TOS+1
.13ce	85 07		sta $07				sta 	TOS+1
.13d0					CTNNoChange:
.13d0	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/multiply.src

.13d1					Multiply16x16:
.13d1	86 10		stx $10				stx 	temp1
.13d3	ba		tsx				tsx
.13d4	bd 02 01	lda $0102,x			lda 	Stack2Low,x 				; 2nd value on stack to temp1
.13d7	85 12		sta $12				sta 	temp2
.13d9	bd 01 01	lda $0101,x			lda		Stack2High,x
.13dc	85 13		sta $13				sta 	temp2+1
.13de	9e 02 01	stz $0102,x			stz 	Stack2Low,x 				; zero 2nd value on stack
.13e1	9e 01 01	stz $0101,x			stz 	Stack2High,x
.13e4					_MultLoop:
.13e4	46 13		lsr $13				lsr 	temp2+1 					; ror temp2 into C
.13e6	66 12		ror $12				ror 	temp2
.13e8	90 11		bcc $13fb			bcc 	_MultNoAdd
.13ea	18		clc				clc 								; add 1st to 2nd
.13eb	a5 06		lda $06				lda 	TOS
.13ed	7d 02 01	adc $0102,x			adc 	Stack2Low,x
.13f0	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.13f3	a5 07		lda $07				lda 	TOS+1
.13f5	7d 01 01	adc $0101,x			adc 	Stack2High,x
.13f8	9d 01 01	sta $0101,x			sta 	Stack2High,x
.13fb					_MultNoAdd:
.13fb	06 06		asl $06				asl 	TOS 						; shift 1st left
.13fd	26 07		rol $07				rol 	TOS+1
.13ff	a5 12		lda $12				lda 	temp2	 					; until zero
.1401	05 13		ora $13				ora 	temp2+1
.1403	d0 df		bne $13e4			bne 	_MultLoop
.1405	a6 10		ldx $10				ldx 	temp1 						; restore X load result
.1407	68		pla				pla
.1408	85 07		sta $07				sta 	TOS+1
.140a	68		pla				pla
.140b	85 06		sta $06				sta 	TOS
.140d	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/arithmetic/unary.src

.1410					Unary1Plus:
.1410	e6 06		inc $06				inc 	TOS
.1412	d0 02		bne $1416			bne 	_U1PSkip
.1414	e6 07		inc $07				inc 	TOS+1
.1416					_U1PSkip:
.1416	4c 00 00	jmp $0000			jmp 	NextCode
.1419					Unary2Plus:
.1419	18		clc				clc
.141a	a5 06		lda $06				lda 	TOS
.141c	69 02		adc #$02			adc 	#2
.141e	85 06		sta $06				sta 	TOS
.1420	90 02		bcc $1424			bcc 	_U1PSkip
.1422	e6 07		inc $07				inc 	TOS+1
.1424					_U1PSkip:
.1424	4c 00 00	jmp $0000			jmp 	NextCode
.1427					Unary1Minus:
.1427	a5 06		lda $06				lda 	TOS
.1429	d0 02		bne $142d			bne 	_U1MSkip
.142b	c6 07		dec $07				dec 	TOS+1
.142d					_U1MSkip:
.142d	c6 06		dec $06				dec 	TOS
.142f	4c 00 00	jmp $0000			jmp 	NextCode
.1432					Unary2Minus:
.1432	38		sec				sec
.1433	a5 06		lda $06				lda 	TOS
.1435	e9 02		sbc #$02			sbc 	#2
.1437	85 06		sta $06				sta 	TOS
.1439	b0 02		bcs $143d			bcs 	_U1PSkip
.143b	c6 07		dec $07				dec 	TOS+1
.143d					_U1PSkip:
.143d	4c 00 00	jmp $0000			jmp 	NextCode
.1440					Absolute:
.1440	a5 07		lda $07				lda 	TOS+1
.1442	30 03		bmi $1447			bmi 	Negate
.1444	4c 00 00	jmp $0000			jmp 	NextCode
.1447					Negate:
.1447	38		sec				sec
.1448	a9 00		lda #$00			lda 	#0
.144a	e5 06		sbc $06				sbc 	TOS
.144c	85 06		sta $06				sta 	TOS
.144e	a9 00		lda #$00			lda 	#0
.1450	e5 07		sbc $07				sbc 	TOS+1
.1452	85 07		sta $07				sta 	TOS+1
.1454	4c 00 00	jmp $0000			jmp 	NextCode
.1457					OneComplement:
.1457	a5 06		lda $06				lda 	TOS
.1459	49 ff		eor #$ff			eor 	#$FF
.145b	85 06		sta $06				sta 	TOS
.145d	a5 07		lda $07				lda 	TOS+1
.145f	49 ff		eor #$ff			eor 	#$FF
.1461	85 07		sta $07				sta 	TOS+1
.1463	4c 00 00	jmp $0000			jmp 	NextCode
.1466					CheckMinus:
.1466	a5 07		lda $07				lda 	TOS+1
.1468	30 07		bmi $1471			bmi 	UnaryTrue
.146a					UnaryFalse:
.146a	64 06		stz $06				stz 	TOS
.146c	64 07		stz $07				stz 	TOS+1
.146e	4c 00 00	jmp $0000			jmp 	NextCode
.1471					UnaryTrue:
.1471	a9 ff		lda #$ff			lda 	#$FF
.1473	85 06		sta $06				sta 	TOS
.1475	85 07		sta $07				sta 	TOS+1
.1477	4c 00 00	jmp $0000			jmp 	NextCode
.147a					CheckZero:
.147a	a5 06		lda $06				lda 	TOS
.147c	05 07		ora $07				ora 	TOS+1
.147e	d0 ea		bne $146a			bne 	UnaryFalse
.1480	80 ef		bra $1471			bra 	UnaryTrue
.1482					SignTOS:
.1482	a5 07		lda $07				lda 	TOS+1
.1484	30 eb		bmi $1471			bmi		UnaryTrue
.1486	05 06		ora $06				ora 	TOS
.1488	f0 e0		beq $146a			beq 	UnaryFalse
.148a	a9 01		lda #$01			lda 	#1
.148c	85 06		sta $06				sta 	TOS
.148e	64 07		stz $07				stz		TOS+1
.1490	4c 00 00	jmp $0000			jmp 	NextCode
.1493					ByteSwap:
.1493	a5 06		lda $06				lda 	TOS
.1495	a4 07		ldy $07				ldy 	TOS+1
.1497	85 07		sta $07				sta 	TOS+1
.1499	84 06		sty $06				sty 	TOS
.149b	4c 00 00	jmp $0000			jmp 	NextCode
.149e					Times16:
.149e	06 06		asl $06				asl 	TOS
.14a0	26 07		rol $07				rol 	TOS+1
.14a2					Times8:
.14a2	06 06		asl $06				asl 	TOS
.14a4	26 07		rol $07				rol 	TOS+1
.14a6					Times4:
.14a6	06 06		asl $06				asl 	TOS
.14a8	26 07		rol $07				rol 	TOS+1
.14aa					Times2:
.14aa	06 06		asl $06				asl 	TOS
.14ac	26 07		rol $07				rol 	TOS+1
.14ae	4c 00 00	jmp $0000			jmp 	NextCode
.14b1					Divide16:
.14b1	46 07		lsr $07				lsr 	TOS+1
.14b3	66 06		ror $06				ror 	TOS
.14b5					Divide8:
.14b5	46 07		lsr $07				lsr 	TOS+1
.14b7	66 06		ror $06				ror 	TOS
.14b9					Divide4:
.14b9	46 07		lsr $07				lsr 	TOS+1
.14bb	66 06		ror $06				ror 	TOS
.14bd					Divide2:
.14bd	46 07		lsr $07				lsr 	TOS+1
.14bf	66 06		ror $06				ror 	TOS
.14c1	4c 00 00	jmp $0000			jmp 	NextCode
.14c4					Times256:
.14c4	a5 06		lda $06				lda 	TOS
.14c6	85 07		sta $07				sta 	TOS+1
.14c8	64 06		stz $06				stz 	TOS
.14ca	4c 00 00	jmp $0000			jmp 	NextCode
.14cd					Divide256:
.14cd	a5 07		lda $07				lda 	TOS+1
.14cf	85 06		sta $06				sta 	TOS
.14d1	64 07		stz $07				stz 	TOS+1
.14d3	4c 00 00	jmp $0000			jmp 	NextCode
.14d6					RandomNumber:
.14d6	a5 06		lda $06				lda 	TOS
.14d8	48		pha				pha
.14d9	a5 07		lda $07				lda 	TOS+1
.14db	48		pha				pha
.14dc	a5 1b		lda $1b				lda 	randomSeed
.14de	05 1c		ora $1c				ora 	randomSeed+1
.14e0	d0 08		bne $14ea			bne 	_RH_NoInit
.14e2	a9 7c		lda #$7c			lda 	#$7C
.14e4	85 1b		sta $1b				sta 	randomSeed
.14e6	a9 a1		lda #$a1			lda 	#$A1
.14e8	85 1c		sta $1c				sta 	randomSeed+1
.14ea					_RH_NoInit:
.14ea	a5 1b		lda $1b				lda 	randomSeed
.14ec	4a		lsr a		        lsr		a
.14ed	26 1c		rol $1c		        rol 	randomSeed+1
.14ef	90 02		bcc $14f3	        bcc 	_RH_NoEor
.14f1	49 b4		eor #$b4	        eor 	#$B4
.14f3					_RH_NoEor:
.14f3	85 1b		sta $1b		        sta 	randomSeed
.14f5	45 1c		eor $1c		        eor 	randomSeed+1
.14f7	85 07		sta $07		        sta 	TOS+1
.14f9	a5 1b		lda $1b		        lda 	randomSeed
.14fb	85 06		sta $06		        sta 	TOS
.14fd	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/data/literals.src

.1500					Constant0:
.1500	a5 06		lda $06				lda 	TOS
.1502	48		pha				pha
.1503	a5 07		lda $07				lda 	TOS+1
.1505	48		pha				pha
.1506	64 06		stz $06				stz 	TOS
.1508	64 07		stz $07				stz 	TOS+1
.150a	4c 00 00	jmp $0000			jmp 	NextCode
.150d					ConstantMinus1:
.150d	a5 06		lda $06				lda 	TOS
.150f	48		pha				pha
.1510	a5 07		lda $07				lda 	TOS+1
.1512	48		pha				pha
.1513	a9 ff		lda #$ff			lda 	#$FF
.1515	85 06		sta $06				sta 	TOS
.1517	85 07		sta $07				sta 	TOS+1
.1519	4c 00 00	jmp $0000			jmp 	NextCode
.151c					C1:
.151c	a0 01		ldy #$01			ldy 	#1
.151e	80 24		bra $1544			bra 	Const1Byte
.1520					C2:
.1520	a0 02		ldy #$02			ldy 	#2
.1522	80 20		bra $1544			bra 	Const1Byte
.1524					C3:
.1524	a0 03		ldy #$03			ldy 	#3
.1526	80 1c		bra $1544			bra 	Const1Byte
.1528					C4:
.1528	a0 04		ldy #$04			ldy 	#4
.152a	80 18		bra $1544			bra 	Const1Byte
.152c					C5:
.152c	a0 05		ldy #$05			ldy 	#5
.152e	80 14		bra $1544			bra 	Const1Byte
.1530					C8:
.1530	a0 08		ldy #$08			ldy 	#8
.1532	80 10		bra $1544			bra 	Const1Byte
.1534					C10:
.1534	a0 0a		ldy #$0a			ldy 	#10
.1536	80 0c		bra $1544			bra 	Const1Byte
.1538					C15:
.1538	a0 0f		ldy #$0f			ldy 	#15
.153a	80 08		bra $1544			bra 	Const1Byte
.153c					C16:
.153c	a0 10		ldy #$10			ldy 	#16
.153e	80 04		bra $1544			bra 	Const1Byte
.1540					C24:
.1540	a0 18		ldy #$18			ldy 	#24
.1542	80 00		bra $1544			bra 	Const1Byte
.1544					Const1Byte:
.1544	a5 06		lda $06				lda 	TOS
.1546	48		pha				pha
.1547	a5 07		lda $07				lda 	TOS+1
.1549	48		pha				pha
.154a	84 06		sty $06				sty 	TOS
.154c	64 07		stz $07				stz 	TOS+1
.154e	4c 00 00	jmp $0000			jmp 	NextCode
.1551					C32:
.1551	a0 20		ldy #$20			ldy 	#32
.1553	80 ef		bra $1544			bra 	Const1Byte
.1555					C63:
.1555	a0 3f		ldy #$3f			ldy 	#63
.1557	80 eb		bra $1544			bra 	Const1Byte
.1559					C64:
.1559	a0 40		ldy #$40			ldy 	#64
.155b	80 e7		bra $1544			bra 	Const1Byte
.155d					C100:
.155d	a0 64		ldy #$64			ldy 	#100
.155f	80 e3		bra $1544			bra 	Const1Byte
.1561					C127:
.1561	a0 7f		ldy #$7f			ldy 	#127
.1563	80 df		bra $1544			bra 	Const1Byte
.1565					C128:
.1565	a0 80		ldy #$80			ldy 	#128
.1567	80 db		bra $1544			bra 	Const1Byte
.1569					C255:
.1569	a0 ff		ldy #$ff			ldy 	#255
.156b	80 d7		bra $1544			bra 	Const1Byte
.156d					Const2Byte:
.156d	85 06		sta $06				sta 	TOS
.156f	84 07		sty $07				sty 	TOS+1
.1571	4c 00 00	jmp $0000			jmp 	NextCode
.1574					C256:
.1574	a5 06		lda $06				lda 	TOS
.1576	48		pha				pha
.1577	a5 07		lda $07				lda 	TOS+1
.1579	48		pha				pha
.157a	a9 00		lda #$00			lda 	#(256) & $FF
.157c	a0 01		ldy #$01			ldy 	#(256) >> 8
.157e	80 ed		bra $156d			bra 	Const2Byte
.1580					C512:
.1580	a5 06		lda $06				lda 	TOS
.1582	48		pha				pha
.1583	a5 07		lda $07				lda 	TOS+1
.1585	48		pha				pha
.1586	a9 00		lda #$00			lda 	#(512) & $FF
.1588	a0 02		ldy #$02			ldy 	#(512) >> 8
.158a	80 e1		bra $156d			bra 	Const2Byte
.158c					C1024:
.158c	a5 06		lda $06				lda 	TOS
.158e	48		pha				pha
.158f	a5 07		lda $07				lda 	TOS+1
.1591	48		pha				pha
.1592	a9 00		lda #$00			lda 	#(1024) & $FF
.1594	a0 04		ldy #$04			ldy 	#(1024) >> 8
.1596	80 d5		bra $156d			bra 	Const2Byte
.1598					C4096:
.1598	a5 06		lda $06				lda 	TOS
.159a	48		pha				pha
.159b	a5 07		lda $07				lda 	TOS+1
.159d	48		pha				pha
.159e	a9 00		lda #$00			lda 	#(4096) & $FF
.15a0	a0 10		ldy #$10			ldy 	#(4096) >> 8
.15a2	80 c9		bra $156d			bra 	Const2Byte
.15a4					C32767:
.15a4	a5 06		lda $06				lda 	TOS
.15a6	48		pha				pha
.15a7	a5 07		lda $07				lda 	TOS+1
.15a9	48		pha				pha
.15aa	a9 ff		lda #$ff			lda 	#(32767) & $FF
.15ac	a0 7f		ldy #$7f			ldy 	#(32767) >> 8
.15ae	80 bd		bra $156d			bra 	Const2Byte
.15b0					C32768:
.15b0	a5 06		lda $06				lda 	TOS
.15b2	48		pha				pha
.15b3	a5 07		lda $07				lda 	TOS+1
.15b5	48		pha				pha
.15b6	a9 00		lda #$00			lda 	#(32768) & $FF
.15b8	a0 80		ldy #$80			ldy 	#(32768) >> 8
.15ba	80 b1		bra $156d			bra 	Const2Byte

;******  Return to file: kernel.asm


;******  Processing file: words/data/stack.src

.15bc					Drop:
.15bc	68		pla				pla
.15bd	85 07		sta $07				sta 	TOS+1
.15bf	68		pla				pla
.15c0	85 06		sta $06				sta 	TOS
.15c2	4c 00 00	jmp $0000			jmp 	NextCode
.15c5					TestDup:
.15c5	a5 06		lda $06				lda 	TOS
.15c7	05 07		ora $07				ora 	TOS+1
.15c9	d0 03		bne $15ce			bne 	Dup
.15cb	4c 00 00	jmp $0000			jmp 	NextCode
.15ce					Dup:
.15ce	a5 06		lda $06				lda 	TOS
.15d0	48		pha				pha
.15d1	a5 07		lda $07				lda 	TOS+1
.15d3	48		pha				pha
.15d4	4c 00 00	jmp $0000			jmp 	NextCode
.15d7					Swap:
.15d7	86 10		stx $10				stx 	temp1
.15d9	7a		ply				ply
.15da	fa		plx				plx
.15db	a5 06		lda $06				lda 	TOS
.15dd	48		pha				pha
.15de	a5 07		lda $07				lda 	TOS+1
.15e0	48		pha				pha
.15e1	86 06		stx $06				stx 	TOS
.15e3	84 07		sty $07				sty 	TOS+1
.15e5	a6 10		ldx $10				ldx 	temp1
.15e7	4c 00 00	jmp $0000			jmp 	NextCode
.15ea					Over:
.15ea	a5 06		lda $06				lda 	TOS
.15ec	48		pha				pha
.15ed	a5 07		lda $07				lda 	TOS+1
.15ef	48		pha				pha
.15f0	86 10		stx $10				stx 	temp1
.15f2	ba		tsx				tsx
.15f3	bd 04 01	lda $0104,x			lda 	stack3low,x
.15f6	85 06		sta $06				sta 	TOS
.15f8	bd 03 01	lda $0103,x			lda 	stack3High,x
.15fb	85 07		sta $07				sta 	TOS+1
.15fd	a6 10		ldx $10				ldx 	temp1
.15ff	4c 00 00	jmp $0000			jmp 	NextCode
.1602					Nip:
.1602	68		pla				pla
.1603	68		pla				pla
.1604	4c 00 00	jmp $0000			jmp 	NextCode
.1607					Rot:
.1607	86 10		stx $10				stx 	temp1
.1609	ba		tsx				tsx
.160a	bd 04 01	lda $0104,x			lda 	Stack3Low,x
.160d	a8		tay				tay
.160e	bd 02 01	lda $0102,x			lda 	Stack2Low,x
.1611	9d 04 01	sta $0104,x			sta 	Stack3Low,x
.1614	a5 06		lda $06				lda 	TOS
.1616	9d 02 01	sta $0102,x			sta 	Stack2Low,x
.1619	84 06		sty $06				sty 	TOS
.161b	bd 03 01	lda $0103,x			lda 	Stack3High,x
.161e	a8		tay				tay
.161f	bd 01 01	lda $0101,x			lda 	Stack2High,x
.1622	9d 03 01	sta $0103,x			sta 	Stack3High,x
.1625	a5 07		lda $07				lda 	TOS+1
.1627	9d 01 01	sta $0101,x			sta 	Stack2High,x
.162a	84 07		sty $07				sty 	TOS+1
.162c	a6 10		ldx $10				ldx 	temp1
.162e	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/data/memory.src

.1631					ByteRead:
.1631	b2 06		lda ($06)			lda 	(TOS)
.1633	85 06		sta $06				sta 	TOS
.1635	64 07		stz $07				stz 	TOS+1
.1637	4c 00 00	jmp $0000			jmp 	NextCode
.163a					WordRead:
.163a	a0 01		ldy #$01			ldy 	#1
.163c	b1 06		lda ($06),y			lda 	(TOS),y
.163e	a8		tay				tay
.163f	b2 06		lda ($06)			lda 	(TOS)
.1641	85 06		sta $06				sta 	TOS
.1643	84 07		sty $07				sty 	TOS+1
.1645	4c 00 00	jmp $0000			jmp 	NextCode
.1648					ByteWrite:
.1648	68		pla				pla
.1649	68		pla				pla
.164a	92 06		sta ($06)			sta 	(TOS)
.164c	68		pla				pla
.164d	85 07		sta $07				sta 	TOS+1
.164f	68		pla				pla
.1650	85 06		sta $06				sta 	TOS
.1652	4c 00 00	jmp $0000			jmp 	NextCode
.1655					WordWrite:
.1655	68		pla				pla
.1656	a0 01		ldy #$01			ldy 	#1
.1658	91 06		sta ($06),y			sta 	(TOS),y
.165a	68		pla				pla
.165b	92 06		sta ($06)			sta 	(TOS)
.165d	68		pla				pla
.165e	85 07		sta $07				sta 	TOS+1
.1660	68		pla				pla
.1661	85 06		sta $06				sta 	TOS
.1663	4c 00 00	jmp $0000			jmp 	NextCode
.1666					WordAdd:
.1666	7a		ply				ply
.1667	68		pla				pla
.1668	18		clc				clc
.1669	72 06		adc ($06)			adc 	(TOS)
.166b	92 06		sta ($06)			sta 	(TOS)
.166d	98		tya				tya
.166e	a0 01		ldy #$01			ldy 	#1
.1670	71 06		adc ($06),y			adc 	(TOS),y
.1672	91 06		sta ($06),y			sta 	(TOS),y
.1674	68		pla				pla
.1675	85 07		sta $07				sta 	TOS+1
.1677	68		pla				pla
.1678	85 06		sta $06				sta 	TOS
.167a	4c 00 00	jmp $0000			jmp 	NextCode
.167d					AllocateMemory:
.167d	a5 06		lda $06				lda 	TOS 						; save memory required on stack.
.167f	48		pha				pha
.1680	a5 07		lda $07				lda 	TOS+1
.1682	48		pha				pha
.1683	a5 0e		lda $0e				lda 	nextFreeMem 				; copy free mem address to TOS
.1685	85 06		sta $06				sta 	TOS
.1687	a5 0f		lda $0f				lda 	nextFreeMem+1
.1689	85 07		sta $07				sta 	TOS+1
.168b	7a		ply				ply 								; advance the free ram pointer
.168c	68		pla				pla
.168d	20 5d 1d	jsr $1d5d			jsr 	AdvanceFreeMem
.1690	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/encode/encode.src

.1693					EncodeProgram:
.1693	48		pha				pha 								; save registers.
.1694	da		phx				phx
.1695	5a		phy				phy
.1696	84 09		sty $09				sty 	srcPtr+1					; save source pointer.
.1698	85 08		sta $08				sta		srcPtr
.169a	a9 ff		lda #$ff			lda 	#$FF
.169c	85 05		sta $05				sta 	rsp
.169e	a6 05		ldx $05				ldx 	rsp 						; this is the current stack entry type, so $00 means
.16a0	9e 40 07	stz $0740,x			stz 	returnStackHigh,x 			; an initial "until" will fail as it's looking for "R" here (repeat)
.16a3	20 17 19	jsr $1917			jsr 	EncodeTrimTrailingSpaces 	; remove trailing spaces.
.16a6	a9 03		lda #$03			lda 	#3 							; reset the encode Buffer
.16a8	8d 10 09	sta $0910			sta 	encodeBuffer 				; this is also the write ptr/offset
.16ab	9c 11 09	stz $0911			stz 	encodeBuffer+1 				; the line number
.16ae	9c 12 09	stz $0912			stz 	encodeBuffer+2 				; which is initially zero.
.16b1	b2 08		lda ($08)			lda 	(srcPtr) 					; check if first character is digit
.16b3	20 c2 18	jsr $18c2			jsr 	CheckIsDigit
.16b6	90 09		bcc $16c1			bcc 	_EPNoLineNumber 			; if so there is a line number
.16b8	20 e4 18	jsr $18e4			jsr 	EncodeGetConstant 			; extract that constant from the source
.16bb	8d 11 09	sta $0911			sta 	encodeBuffer+1 				; that is the line number
.16be	8c 12 09	sty $0912			sty 	encodeBuffer+2
.16c1					_EPNoLineNumber:
.16c1					EncodeLoop:
.16c1	20 09 19	jsr $1909			jsr 	EncSkipSpaces 				; skip over spaces
.16c4	b2 08		lda ($08)			lda 	(srcPtr) 					; reached end ?
.16c6	d0 23		bne $16eb			bne 	_EPNotEnd
.16c8					_EPEndEncode:
.16c8	a9 76		lda #$76			lda 	#NextLine & $FF 			; compile $$nextline to mark eol
.16ca	a0 21		ldy #$21			ldy 	#NextLine >> 8
.16cc	20 9a 18	jsr $189a			jsr 	EncodeWriteWord
.16cf	a5 05		lda $05				lda 	rsp 						; is the return stack empty ?
.16d1	c9 ff		cmp #$ff			cmp 	#$FF
.16d3	d0 04		bne $16d9			bne 	_EPIncomplete
.16d5	7a		ply				ply									; restore and exit.
.16d6	fa		plx				plx
.16d7	68		pla				pla
.16d8	60		rts				rts
.16d9					_EPIncomplete:
.16d9	20 01 11	jsr $1101			jsr 	ErrorHandler
>16dc	53 54 52 55 43 54 55 52				.text 	"STRUCTURE OPEN",0
>16e4	45 20 4f 50 45 4e 00
.16eb					_EPNotEnd:
.16eb	b2 08		lda ($08)			lda 	(srcPtr)
.16ed	c9 22		cmp #$22			cmp 	#'"'						; is it a quoted string or comment ?
.16ef	f0 04		beq $16f5			beq 	_EPIsComStr
.16f1	c9 27		cmp #$27			cmp 	#"'"
.16f3	d0 05		bne $16fa			bne 	_EPNotComStr
.16f5					_EPIsComStr:
.16f5	20 e7 17	jsr $17e7			jsr 	EncodeCommentString
.16f8	80 c7		bra $16c1			bra 	EncodeLoop
.16fa					_EPNotComStr:
.16fa	38		sec				sec
.16fb	20 f6 18	jsr $18f6			jsr 	EncSetBit7Word
.16fe	20 3e 19	jsr $193e			jsr 	EncodeSearchDictionary		; look it up
.1701	90 45		bcc $1748			bcc 	_EPNotInDictionary
.1703	85 10		sta $10				sta 	temp1 						; save dictionary record address
.1705	84 11		sty $11				sty 	temp1+1
.1707	a0 01		ldy #$01			ldy 	#1
.1709	b1 10		lda ($10),y			lda 	(temp1),y 					; check if has an encode bit
.170b	29 20		and #$20			and 	#$20
.170d	d0 12		bne $1721			bne 	_EPEncodeRoutine 			; if so, do special routine.
.170f	a0 02		ldy #$02			ldy 	#2 							; write out the routine address
.1711	b1 10		lda ($10),y			lda 	(temp1),y
.1713	20 a4 18	jsr $18a4			jsr 	EncodeWriteByte
.1716	c8		iny				iny
.1717	b1 10		lda ($10),y			lda 	(temp1),y
.1719	20 a4 18	jsr $18a4			jsr 	EncodeWriteByte
.171c	20 ce 18	jsr $18ce			jsr 	EncodeMoveNextWord 			; advance to the next and loop
.171f	80 a0		bra $16c1			bra 	EncodeLoop
.1721					_EPEncodeRoutine:
.1721	a0 01		ldy #$01			ldy 	#1							; get type bit
.1723	b1 10		lda ($10),y			lda 	(temp1),y
.1725	a0 04		ldy #$04			ldy 	#4							; encoder here if no decoder
.1727	29 10		and #$10			and 	#$10 						; but decoder comes first
.1729	f0 02		beq $172d			beq 	_EPENoDecoder
.172b	c8		iny				iny 								; so if it exists, adjust for it.
.172c	c8		iny				iny
.172d					_EPENoDecoder:
.172d	b1 10		lda ($10),y			lda 	(temp1),y 					; copy exec addr to temp2
.172f	85 12		sta $12				sta 	temp2
.1731	c8		iny				iny
.1732	b1 10		lda ($10),y			lda 	(temp1),y
.1734	85 13		sta $13				sta 	temp2+1
.1736	48		pha				pha 								; call routine preserving state
.1737	da		phx				phx
.1738	5a		phy				phy
.1739	20 45 17	jsr $1745			jsr 	_EPECallTemp2
.173c	7a		ply				ply
.173d	fa		plx				plx
.173e	68		pla				pla
.173f	20 ce 18	jsr $18ce			jsr 	EncodeMoveNextWord 			; advance to the next and loop
.1742	4c c1 16	jmp $16c1			jmp 	EncodeLoop
.1745					_EPECallTemp2:
.1745	6c 12 00	jmp ($0012)			jmp 	(temp2)
.1748					_EPNotInDictionary:
.1748	20 4c 18	jsr $184c			jsr 	EncodeSearchUserDefined 	; are there any user defined routines
.174b	90 19		bcc $1766			bcc 	_EPNotDefined
.174d	48		pha				pha
.174e	a9 c0		lda #$c0			lda	 	#CallHandler & $FF 			; write code call handler
.1750	20 a4 18	jsr $18a4			jsr 	EncodeWriteByte
.1753	a9 1b		lda #$1b			lda	 	#CallHandler >> 8
.1755	20 a4 18	jsr $18a4			jsr 	EncodeWriteByte
.1758	68		pla				pla 								; write line number
.1759	20 a4 18	jsr $18a4			jsr 	EncodeWriteByte
.175c	98		tya				tya
.175d	20 a4 18	jsr $18a4			jsr 	EncodeWriteByte
.1760	20 ce 18	jsr $18ce			jsr 	EncodeMoveNextWord 			; advance to the next and loop
.1763	4c c1 16	jmp $16c1			jmp 	EncodeLoop
.1766					_EPNotDefined:
.1766	b2 08		lda ($08)			lda 	(srcPtr) 					; first character
.1768	c9 3a		cmp #$3a			cmp 	#":"						; is it :<routine> ?
.176a	f0 58		beq $17c4			beq 	_EPDefinition
.176c	c9 3c		cmp #$3c			cmp 	#"<"						; is it <line> which is call syntax
.176e	f0 2e		beq $179e			beq 	_EPCallDirect
.1770	c9 21		cmp #$21			cmp 	#"!"						; check for variable operators
.1772	f0 47		beq $17bb			beq 	_EPVariable
.1774	c9 40		cmp #$40			cmp 	#"@"
.1776	f0 43		beq $17bb			beq 	_EPVariable
.1778	c9 26		cmp #$26			cmp 	#"&"
.177a	f0 3f		beq $17bb			beq 	_EPVariable
.177c	a9 a9		lda #$a9			lda 	#Literal2Byte & $FF 		; write out 2 byte literal
.177e	a0 10		ldy #$10			ldy 	#Literal2Byte >> 8
.1780	20 9a 18	jsr $189a			jsr 	EncodeWriteWord
.1783					_EPOutputConstant:
.1783	20 e4 18	jsr $18e4			jsr 	EncodeGetConstant 			; extract that constant from the source
.1786	90 06		bcc $178e			bcc 	_EPFail 					; if can't find one, that's us done.
.1788	20 9a 18	jsr $189a			jsr 	EncodeWriteWord 			; write out the encoded value.
.178b	4c c1 16	jmp $16c1			jmp 	EncodeLoop 					; and go round again.
.178e					_EPFail:
.178e	20 01 11	jsr $1101			jsr 	ErrorHandler
>1791	53 59 4e 54 41 58 20 45				.text 	"SYNTAX ERROR",0
>1799	52 52 4f 52 00
.179e					_EPCallDirect:
.179e	a9 c0		lda #$c0			lda	 	#CallHandler & $FF 			; write code call handler
.17a0	a0 1b		ldy #$1b			ldy	 	#CallHandler >> 8
.17a2	20 9a 18	jsr $189a			jsr 	EncodeWriteWord
.17a5	a9 01		lda #$01			lda 	#1
.17a7	20 da 18	jsr $18da			jsr 	EncodeAddSrcPtr 			; skip over the <
.17aa	a0 ff		ldy #$ff			ldy 	#255 						; scan forward for last character.
.17ac					_EPToLast:
.17ac	c8		iny				iny
.17ad	b1 08		lda ($08),y			lda 	(srcPtr),y
.17af	10 fb		bpl $17ac			bpl	 	_EPToLast
.17b1	c9 be		cmp #$be			cmp 	#">"+$80 					; must be >
.17b3	d0 d9		bne $178e			bne 	_EPFail
.17b5	a9 20		lda #$20			lda 	#" " 						; strip back to a number, erases last char
.17b7	91 08		sta ($08),y			sta 	(srcPtr),y
.17b9	80 c8		bra $1783			bra 	_EPOutputConstant 			; borrow the number routines extract/compile constant
.17bb					_EPVariable:
.17bb	20 92 19	jsr $1992			jsr 	EncodeVariableReference
.17be	20 ce 18	jsr $18ce			jsr 	EncodeMoveNextWord 			; advance to the next and loop
.17c1	4c c1 16	jmp $16c1			jmp 	EncodeLoop
.17c4					_EPDefinition:
.17c4	a9 b8		lda #$b8			lda	 	#DefineCode & $FF 			; write code call handler
.17c6	a0 21		ldy #$21			ldy	 	#DefineCode >> 8
.17c8	20 9a 18	jsr $189a			jsr 	EncodeWriteWord
.17cb	ae 10 09	ldx $0910			ldx 	encodeBuffer 				; position
.17ce	a9 01		lda #$01			lda 	#1 							; write default size
.17d0	20 a4 18	jsr $18a4			jsr 	EncodeWriteByte
.17d3	a0 00		ldy #$00			ldy 	#0 							; copy definition over.
.17d5	c8		iny		_EPCopy:iny
.17d6	b1 08		lda ($08),y			lda 	(srcPtr),y
.17d8	20 a4 18	jsr $18a4			jsr 	EncodeWriteByte
.17db	fe 10 09	inc $0910,x			inc 	encodeBuffer,x 				; update length.
.17de	0a		asl a				asl 	a
.17df	90 f4		bcc $17d5			bcc 	_EPCopy
.17e1	20 ce 18	jsr $18ce			jsr 	EncodeMoveNextWord 			; advance to the next and loop
.17e4	4c c1 16	jmp $16c1			jmp 	EncodeLoop

;******  Return to file: kernel.asm


;******  Processing file: words/encode/comstr.src

.17e7					EncodeCommentString:
.17e7	b2 08		lda ($08)			lda 	(srcPtr) 					; get first character
.17e9	64 10		stz $10				stz 	temp1 						; other terminator = EOL
.17eb	aa		tax				tax 								; save in X
.17ec	a9 8d		lda #$8d			lda 	#(SkipComment & $FF)		; get the routine to use
.17ee	a0 21		ldy #$21			ldy 	#(SkipComment >> 8)
.17f0	e0 27		cpx #$27			cpx 	#"'"
.17f2	f0 06		beq $17fa			beq 	_ECSGotCmd
.17f4	86 10		stx $10				stx		temp1 						; other terminator = "
.17f6	a9 d1		lda #$d1			lda 	#(LiteralString & $FF)
.17f8	a0 10		ldy #$10			ldy 	#(LiteralString >> 8)
.17fa					_ECSGotCmd:
.17fa	20 9a 18	jsr $189a			jsr 	EncodeWriteWord 			; write word out.
.17fd	a9 01		lda #$01			lda 	#1 							; skip over ' or "
.17ff	20 da 18	jsr $18da			jsr 	EncodeAddSrcPtr
.1802	e0 27		cpx #$27			cpx 	#"'"						; if ' then skip spaces
.1804	d0 03		bne $1809			bne 	_ECNoSkipSpaces
.1806	20 09 19	jsr $1909			jsr 	EncSkipSpaces
.1809					_ECNoSkipSpaces:
.1809	ae 10 09	ldx $0910			ldx 	encodeBuffer 				; keep offset to buffer in X.
.180c	a9 01		lda #$01			lda 	#1
.180e	20 a4 18	jsr $18a4			jsr 	EncodeWriteByte 			; write total length, so far 1.
.1811	a0 00		ldy #$00			ldy 	#0 							; for reading the actual text
.1813					_ECSCopyText:
.1813	b1 08		lda ($08),y			lda 	(srcPtr),y 					; get next
.1815	f0 18		beq $182f			beq 	_ECSEndOfLine 				; end of line ?
.1817	c5 10		cmp $10				cmp 	temp1						; is it the other terminator
.1819	f0 09		beq $1824			beq 	_ECSEndOfString 			; if so must be closing quote.
.181b	20 a4 18	jsr $18a4			jsr 	EncodeWriteByte 			; write the byte out
.181e	fe 10 09	inc $0910,x			inc 	encodeBuffer,x				; increase length
.1821	c8		iny				iny 								; next character
.1822	80 ef		bra $1813			bra 	_ECSCopyText
.1824					_ECSEndOfString:
.1824	c8		iny				iny 								; skip closing quote.
.1825	a9 00		lda #$00			lda 	#0 							; write out ASCIIZ
.1827	20 a4 18	jsr $18a4			jsr 	EncodeWriteByte
.182a	fe 10 09	inc $0910,x			inc 	encodeBuffer,x 				; fix the length up.
.182d	80 18		bra $1847			bra 	_ECSComplete 				; and just patching up srcPtr to do.
.182f					_ECSEndOfLine:
.182f	a5 10		lda $10				lda 	temp1 						; missing closing quote
.1831	f0 14		beq $1847			beq 	_ECSComplete 				; if we were doing a string.
.1833	20 01 11	jsr $1101			jsr 	ErrorHandler
>1836	4e 4f 20 43 4c 4f 53 49				.text 	"NO CLOSING QUOTE",0
>183e	4e 47 20 51 55 4f 54 45 00
.1847					_ECSComplete:
.1847	98		tya				tya									; skip over.
.1848	20 da 18	jsr $18da			jsr 	EncodeAddSrcPtr
.184b	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/encode/encdef.src

.184c					EncodeSearchUserDefined:
.184c	38		sec				sec 								; temp1 = srcPtr-6 because the
.184d	a5 08		lda $08				lda 	srcPtr				 		; name is 6 in (offset line# $$call len)
.184f	e9 06		sbc #$06			sbc		#6
.1851	85 10		sta $10				sta 	temp1
.1853	a5 09		lda $09				lda 	srcPtr+1
.1855	e9 00		sbc #$00			sbc 	#0
.1857	85 11		sta $11				sta 	temp1+1
.1859	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.185b	85 12		sta $12				sta 	0+(temp2)
.185d	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.185f	85 13		sta $13				sta 	1+(temp2)
.1861					_ESULoop:
.1861	b2 12		lda ($12)			lda 	(temp2) 					; reached the end (offset 0)
.1863	f0 33		beq $1898			beq 	_ESUFail
.1865	a0 03		ldy #$03			ldy 	#3 							; check it is $$define
.1867	b1 12		lda ($12),y			lda 	(temp2),y
.1869	c9 b8		cmp #$b8			cmp 	#DefineCode & $FF
.186b	d0 1e		bne $188b			bne 	_ESUNext
.186d	c8		iny				iny
.186e	b1 12		lda ($12),y			lda 	(temp2),y
.1870	c9 21		cmp #$21			cmp 	#DefineCode >> 8
.1872	d0 17		bne $188b			bne 	_ESUNext
.1874	c8		iny				iny 								; skip length byte.
.1875					_ESUCompare:
.1875	c8		iny				iny
.1876	b1 12		lda ($12),y			lda 	(temp2),y
.1878	d1 10		cmp ($10),y			cmp 	(temp1),y
.187a	d0 0f		bne $188b			bne 	_ESUNext
.187c	0a		asl a				asl 	a 							; bit 7 set => found it.
.187d	90 f6		bcc $1875			bcc 	_ESUCompare
.187f	a0 01		ldy #$01			ldy 	#1
.1881	b1 12		lda ($12),y			lda 	(temp2),y 					; read in the line number to YA
.1883	aa		tax				tax
.1884	c8		iny				iny
.1885	b1 12		lda ($12),y			lda 	(temp2),y
.1887	a8		tay				tay
.1888	8a		txa				txa
.1889	38		sec				sec 								; return with carry set as found
.188a	60		rts				rts
.188b					_ESUNext:
.188b	18		clc				clc
.188c	a5 12		lda $12				lda 	temp2
.188e	72 12		adc ($12)			adc 	(temp2)
.1890	85 12		sta $12				sta 	temp2
.1892	90 02		bcc $1896			bcc 	_NoCarryAdv
.1894	e6 13		inc $13				inc 	temp2+1
.1896					_NoCarryAdv:
.1896	80 c9		bra $1861			bra 	_ESULoop 					; and loop round
.1898					_ESUFail:
.1898	18		clc				clc
.1899	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/encode/encutils.src

.189a					EncodeWriteWord:
.189a	48		pha				pha
.189b	20 a4 18	jsr $18a4			jsr 	EncodeWriteByte
.189e	98		tya				tya
.189f	20 a4 18	jsr $18a4			jsr 	EncodeWriteByte
.18a2	68		pla				pla
.18a3	60		rts				rts
.18a4					EncodeWriteByte:
.18a4	da		phx				phx
.18a5	ae 10 09	ldx $0910			ldx 	encodeBuffer
.18a8	9d 10 09	sta $0910,x			sta 	encodeBuffer,x
.18ab	9e 11 09	stz $0911,x			stz 	encodeBuffer+1,x
.18ae	9e 12 09	stz $0912,x			stz 	encodeBuffer+2,x
.18b1	ee 10 09	inc $0910			inc 	encodeBuffer
.18b4	fa		plx				plx
.18b5	60		rts				rts
.18b6					CheckIsLetter:
.18b6	c9 41		cmp #$41			cmp 	#"A"						; return CS if A..Z
.18b8	90 06		bcc $18c0			bcc 	_CILFail
.18ba	c9 5b		cmp #$5b			cmp 	#"Z"+1
.18bc	b0 02		bcs $18c0			bcs 	_CILFail
.18be	38		sec				sec
.18bf	60		rts				rts
.18c0					_CILFail:
.18c0	18		clc				clc
.18c1	60		rts				rts
.18c2					CheckIsDigit:
.18c2	c9 30		cmp #$30			cmp 	#"0"						; return CS if 0..9
.18c4	90 06		bcc $18cc			bcc 	_CIDFail
.18c6	c9 3a		cmp #$3a			cmp 	#"9"+1
.18c8	b0 02		bcs $18cc			bcs 	_CIDFail
.18ca	38		sec				sec
.18cb	60		rts				rts
.18cc					_CIDFail:
.18cc	18		clc				clc
.18cd	60		rts				rts
.18ce					EncodeMoveNextWord:
.18ce	a0 ff		ldy #$ff			ldy 	#255 						; search forward
.18d0					_EPNWLoop:
.18d0	c8		iny				iny
.18d1	b1 08		lda ($08),y			lda 	(srcPtr),y
.18d3	c9 21		cmp #$21			cmp 	#" "+1						; looking for <= space
.18d5	b0 f9		bcs $18d0			bcs 	_EPNWLoop
.18d7	98		tya				tya
.18d8	80 00		bra $18da			bra 	EncodeAddSrcPtr
.18da					EncodeAddSrcPtr:
.18da	18		clc				clc 								; add offset
.18db	65 08		adc $08				adc 	srcPtr
.18dd	85 08		sta $08				sta 	srcPtr
.18df	90 02		bcc $18e3			bcc 	_EASPNoCarry
.18e1	e6 09		inc $09				inc 	srcPtr+1					; carry through
.18e3					_EASPNoCarry:
.18e3	60		rts				rts
.18e4					EncodeGetConstant:
.18e4	a5 08		lda $08				lda 	srcPtr 						; get source
.18e6	a4 09		ldy $09				ldy 	srcPtr+1
.18e8	20 e1 21	jsr $21e1			jsr 	ConvertToInteger 			; call converter
.18eb	90 08		bcc $18f5			bcc 	_EGCExit
.18ed	20 da 18	jsr $18da			jsr 	EncodeAddSrcPtr 			; if passed add chars to src ptr
.18f0	a5 14		lda $14				lda 	temp3 						; get result into YA
.18f2	a4 15		ldy $15				ldy 	temp3+1
.18f4	38		sec				sec 								; return CS
.18f5					_EGCExit:
.18f5	60		rts				rts
.18f6					EncSetBit7Word:
.18f6	08		php				php 								; save carry
.18f7	a0 ff		ldy #$ff			ldy 	#255 						; scan forward for space/NULL
.18f9					_ESB7Loop:
.18f9	c8		iny				iny
.18fa	b1 08		lda ($08),y			lda 	(srcPtr),y
.18fc	c9 21		cmp #$21			cmp 	#" "+1 						; while > ' '
.18fe	b0 f9		bcs $18f9			bcs 	_ESB7Loop
.1900	88		dey				dey									; previous character
.1901	b1 08		lda ($08),y			lda 	(srcPtr),y 					; read it
.1903	0a		asl a				asl 	a 							; shift bit 7 out
.1904	28		plp				plp 								; restore carry
.1905	6a		ror a				ror 	a 							; shift it in
.1906	91 08		sta ($08),y			sta 	(srcPtr),y 					; write back and exit
.1908	60		rts				rts
.1909					EncSkipSpaces:
.1909	b2 08		lda ($08)			lda 	(srcPtr) 					; skip over spaces/ reached end
.190b	c9 20		cmp #$20			cmp 	#32
.190d	d0 07		bne $1916			bne 	_ESNotSpace
.190f	a9 01		lda #$01			lda 	#1
.1911	20 da 18	jsr $18da			jsr 	EncodeAddSrcPtr
.1914	80 f3		bra $1909			bra	 	EncSkipSpaces
.1916					_ESNotSpace:
.1916	60		rts				rts
.1917					EncodeTrimTrailingSpaces:
.1917	a0 ff		ldy #$ff			ldy 	#255 						; find EOS
.1919					_ETTFindEnd:
.1919	c8		iny				iny
.191a	b1 08		lda ($08),y			lda 	(srcPtr),y
.191c	d0 fb		bne $1919			bne 	_ETTFindEnd
.191e					_ETTRemoveSpace:
.191e	c0 00		cpy #$00			cpy 	#0 							; start of string
.1920	f0 0d		beq $192f			beq 	_ETTExit
.1922	88		dey				dey 								; previous character 1..32
.1923	b1 08		lda ($08),y			lda 	(srcPtr),y
.1925	c9 21		cmp #$21			cmp 	#32+1
.1927	b0 06		bcs $192f			bcs 	_ETTExit
.1929	a9 00		lda #$00			lda 	#0 							; erase it and go round again
.192b	91 08		sta ($08),y			sta 	(srcPtr),y
.192d	80 ef		bra $191e			bra 	_ETTRemoveSpace
.192f					_ETTExit:
.192f	60		rts				rts
.1930					EncodePushPosMarkerOnStack:
.1930	e6 05		inc $05				inc 	rsp 						; make space on rstack
.1932	a6 05		ldx $05				ldx 	rsp							; access it
.1934	9d 40 07	sta $0740,x			sta 	returnStackHigh,x			; save marker
.1937	ad 10 09	lda $0910			lda 	encodeBuffer 				; save position in encode buffer
.193a	9d 80 07	sta $0780,x			sta 	returnStackX,x
.193d	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/encode/encsearch.src

.193e					EncodeSearchDictionary:
.193e	a9 74		lda #$74			lda 	#(Dictionary) & $FF
.1940	85 10		sta $10				sta 	0+(temp1)
.1942	a9 24		lda #$24			lda 	#(Dictionary) >> 8
.1944	85 11		sta $11				sta 	1+(temp1)
.1946					_ESDLoop:
.1946	b2 10		lda ($10)			lda 	(temp1) 					; end of dictionary return with CC.
.1948	18		clc				clc
.1949	f0 46		beq $1991			beq 	_ESDExit
.194b	a0 01		ldy #$01			ldy 	#1 							; get control bits, get offset to name.
.194d	b1 10		lda ($10),y			lda 	(temp1),y
.194f	4a		lsr a				lsr 	a 							; encode/decode bits move to 0,1
.1950	4a		lsr a				lsr 	a
.1951	4a		lsr a				lsr 	a
.1952	4a		lsr a				lsr 	a
.1953	c8		iny				iny 								; Y = 2
.1954	4a		lsr a				lsr 	a
.1955	90 01		bcc $1958			bcc 	_ESDNotDec
.1957	c8		iny				iny
.1958					_ESDNotDec:
.1958	4a		lsr a				lsr 	a
.1959	90 01		bcc $195c			bcc 	_ESDNotInc
.195b	c8		iny				iny
.195c					_ESDNotInc:
.195c	98		tya				tya
.195d	0a		asl a				asl 	a 							; A is now 4,6,8 offset to name.
.195e	a8		tay				tay
.195f	b1 10		lda ($10),y			lda 	(temp1),y 					; quick check of first character
.1961	d2 08		cmp ($08)			cmp 	(srcPtr)
.1963	d0 1f		bne $1984			bne 	_ESDNext 					; do not match, go to next
.1965	98		tya				tya 								; make temp2 point to the name in
.1966	18		clc				clc 								; the dictionary.
.1967	65 10		adc $10				adc 	temp1
.1969	85 12		sta $12				sta 	temp2
.196b	a5 11		lda $11				lda 	temp1+1
.196d	69 00		adc #$00			adc 	#0
.196f	85 13		sta $13				sta 	temp2+1
.1971	a0 ff		ldy #$ff			ldy 	#255 						; now start matching up.
.1973					_ESDCompare:
.1973	c8		iny				iny
.1974	b1 08		lda ($08),y			lda 	(srcPtr),y
.1976	d1 12		cmp ($12),y			cmp 	(temp2),y
.1978	d0 0a		bne $1984			bne 	_ESDNext
.197a	0a		asl a				asl 	a
.197b	90 f6		bcc $1973			bcc 	_ESDCompare
.197d	a5 10		lda $10				lda 	temp1 						; return address in YA and carry set.
.197f	a4 11		ldy $11				ldy 	temp1+1
.1981	38		sec				sec
.1982	80 0d		bra $1991			bra 	_ESDExit
.1984					_ESDNext:
.1984	18		clc				clc
.1985	a5 10		lda $10				lda 	temp1
.1987	72 10		adc ($10)			adc 	(temp1)
.1989	85 10		sta $10				sta 	temp1
.198b	90 b9		bcc $1946			bcc 	_ESDLoop
.198d	e6 11		inc $11				inc 	temp1+1
.198f	80 b5		bra $1946			bra 	_ESDLoop
.1991					_ESDExit:
.1991	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/encode/encvar.src

.1992					EncodeVariableReference:
.1992	b2 08		lda ($08)			lda 	(srcPtr)					; get the type, use it to identify the routine
.1994	a2 1a		ldx #$1a			ldx 	#VarAddressHandler & $FF
.1996	a0 23		ldy #$23			ldy 	#VarAddressHandler >> 8
.1998	c9 26		cmp #$26			cmp 	#"&"
.199a	f0 0c		beq $19a8			beq 	_EVFHaveAddress
.199c	a2 34		ldx #$34			ldx 	#VarReadHandler & $FF
.199e	a0 23		ldy #$23			ldy 	#VarReadHandler >> 8
.19a0	c9 40		cmp #$40			cmp 	#"@"
.19a2	f0 04		beq $19a8			beq 	_EVFHaveAddress
.19a4	a2 50		ldx #$50			ldx 	#VarWriteHandler & $FF
.19a6	a0 23		ldy #$23			ldy 	#VarWriteHandler >> 8
.19a8					_EVFHaveAddress:
.19a8	8a		txa				txa
.19a9	20 9a 18	jsr $189a			jsr 	EncodeWriteWord 			; write it out.
.19ac	a0 01		ldy #$01			ldy 	#1 							; get the first charactere
.19ae	b1 08		lda ($08),y			lda 	(srcPtr),y
.19b0	29 7f		and #$7f			and 	#$7F 						; might be the last.
.19b2	20 b6 18	jsr $18b6			jsr 	CheckIsLetter 				; is it A-Z
.19b5	90 1a		bcc $19d1			bcc 	EVFFail
.19b7	29 1f		and #$1f			and 	#31 						; make 1-26
.19b9	85 10		sta $10				sta 	temp1 						; start building the name in temp1
.19bb	64 11		stz $11				stz 	temp1+1
.19bd	38		sec				sec 								; possible char 2
.19be	20 e6 19	jsr $19e6			jsr 	EncVarAlNum
.19c1	18		clc				clc 								; possible char 3
.19c2	20 e6 19	jsr $19e6			jsr 	EncVarAlNum
.19c5	b1 08		lda ($08),y			lda 	(srcPtr),y 					; more text after ?
.19c7	10 08		bpl $19d1			bpl 	EVFFail
.19c9	a5 10		lda $10				lda 	temp1 						; write out variable identifier.
.19cb	a4 11		ldy $11				ldy 	temp1+1
.19cd	20 9a 18	jsr $189a			jsr 	EncodeWriteWord
.19d0	60		rts				rts
.19d1					EVFFail:
.19d1	20 01 11	jsr $1101			jsr 	ErrorHandler
>19d4	42 41 44 20 56 41 52 49				.text 	"BAD VARIABLE NAME",0
>19dc	41 42 4c 45 20 4e 41 4d 45 00
.19e6					EncVarAlNum:
.19e6	b1 08		lda ($08),y			lda 	(srcPtr),y 					; points to the  last char processed.
.19e8	10 01		bpl $19eb			bpl 	_EVAContinue
.19ea	60		rts				rts
.19eb					_EVAContinue:
.19eb	08		php				php 								; CS x 32 ; CC x 32 x 40
.19ec	c8		iny				iny 								; get the next character, strip bit 7
.19ed	b1 08		lda ($08),y			lda 	(srcPtr),y
.19ef	29 7f		and #$7f			and 	#$7F
.19f1	20 b6 18	jsr $18b6			jsr 	CheckIsLetter 				; letter ?
.19f4	b0 08		bcs $19fe			bcs 	_EVACharOkay
.19f6	20 c2 18	jsr $18c2			jsr 	CheckIsDigit				; fail if not digit.
.19f9	90 d6		bcc $19d1			bcc 	EVFFail
.19fb	18		clc				clc
.19fc	69 2b		adc #$2b			adc 	#"Z"+1-"0"					; shift 0 so after Z
.19fe					_EVACharOkay:
.19fe	38		sec				sec 								; range 1-36
.19ff	e9 40		sbc #$40			sbc 	#64
.1a01	28		plp				plp 								; which multiplier ?
.1a02	90 0f		bcc $1a13			bcc 	_EVATimes32x40
.1a04	85 12		sta $12				sta 	temp2 						; save in temp2 - A x 32
.1a06	64 13		stz $13				stz 	temp2+1
.1a08	a2 05		ldx #$05			ldx 	#5
.1a0a	06 12		asl $12		_EVA32:	asl 	temp2
.1a0c	26 13		rol $13				rol 	temp2+1
.1a0e	ca		dex				dex
.1a0f	d0 f9		bne $1a0a			bne 	_EVA32
.1a11	80 0b		bra $1a1e			bra 	_EVAAddVar
.1a13					_EVATimes32x40:
.1a13	85 13		sta $13				sta 	temp2+1						; 32 x 40 = 1280 or $500, so temp2 = A x 256 x 5
.1a15	64 12		stz $12				stz 	temp2
.1a17	0a		asl a				asl 	a
.1a18	0a		asl a				asl 	a
.1a19	18		clc				clc
.1a1a	65 13		adc $13				adc 	temp2+1
.1a1c	85 13		sta $13				sta 	temp2+1
.1a1e					_EVAAddVar:
.1a1e	18		clc				clc
.1a1f	a5 10		lda $10				lda 	temp1
.1a21	65 12		adc $12				adc 	temp2
.1a23	85 10		sta $10				sta 	temp1
.1a25	a5 11		lda $11				lda 	temp1+1
.1a27	65 13		adc $13				adc 	temp2+1
.1a29	85 11		sta $11				sta 	temp1+1
.1a2b	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/structures/fornext.src

.1a2c					ForHandler:
.1a2c	e6 05		inc $05				inc 	rsp 						; bump the RSP
.1a2e	a4 05		ldy $05				ldy 	rsp 						; get return stack and push TOS/$FF on it.
.1a30	c0 40		cpy #$40			cpy 	#$40 						; overflow
.1a32	f0 18		beq $1a4c			beq 	_FHOverflow
.1a34	a5 07		lda $07				lda 	TOS+1
.1a36	99 40 07	sta $0740,y			sta 	returnStackHigh,y
.1a39	a5 06		lda $06				lda 	TOS
.1a3b	99 00 07	sta $0700,y			sta 	returnStackLow,y
.1a3e	a9 ff		lda #$ff			lda 	#$FF
.1a40	99 80 07	sta $0780,y			sta 	returnStackX,y
.1a43	68		pla				pla
.1a44	85 07		sta $07				sta 	TOS+1
.1a46	68		pla				pla
.1a47	85 06		sta $06				sta 	TOS
.1a49	4c 00 00	jmp $0000			jmp 	NextCode
.1a4c					_FHOverflow:
.1a4c	20 01 11	jsr $1101			jsr 	ErrorHandler
>1a4f	53 54 52 55 43 54 55 52				.text 	"STRUCTURE OVERFLOW",0
>1a57	45 20 4f 56 45 52 46 4c 4f 57 00
.1a62					ForEncoder:
.1a62	a9 2c		lda #$2c			lda 	#ForHandler & $FF 			; for handler
.1a64	a0 1a		ldy #$1a			ldy 	#ForHandler >> 8
.1a66	20 9a 18	jsr $189a			jsr 	EncodeWriteWord
.1a69	a9 46		lda #$46			lda 	#"F" 						; for marker
.1a6b	20 30 19	jsr $1930			jsr 	EncodePushPosMarkerOnStack
.1a6e	60		rts				rts
.1a6f					NextHandler:
.1a6f	da		phx				phx
.1a70	a6 05		ldx $05				ldx 	rsp 						; get current stack ptr
.1a72	bd 80 07	lda $0780,x			lda 	returnStackX,x 				; check it's a FOR Loop
.1a75	c9 ff		cmp #$ff			cmp 	#$FF
.1a77	d0 21		bne $1a9a			bne 	NHNoFor
.1a79	bd 00 07	lda $0700,x			lda 	returnStackLow,x 			; decrement the count
.1a7c	d0 03		bne $1a81			bne 	_NHNoBorrow
.1a7e	de 40 07	dec $0740,x			dec 	returnStackHigh,x
.1a81					_NHNoBorrow:
.1a81	de 00 07	dec $0700,x			dec 	returnStackLow,x
.1a84	bd 00 07	lda $0700,x			lda 	returnStackLow,x 			; have we reached the end ?
.1a87	1d 40 07	ora $0740,x			ora 	returnStackHigh,x
.1a8a	fa		plx				plx 								; restore X and re-test
.1a8b	09 00		ora #$00			ora 	#0
.1a8d	f0 05		beq $1a94			beq 	_NHComplete 				; if so then complete, else loop.
.1a8f	e8		inx				inx 								; advance to branch
.1a90	e8		inx				inx
.1a91	4c b6 1b	jmp $1bb6			jmp 	BranchAlways
.1a94					_NHComplete:
.1a94	e8		inx				inx 								; skip over the branch quantity
.1a95	c6 05		dec $05				dec 	rsp 						; drop the indx
.1a97	4c 00 00	jmp $0000			jmp 	NextCode
.1a9a					NHNoFor:
.1a9a	20 01 11	jsr $1101			jsr 	ErrorHandler
>1a9d	4f 55 54 20 4f 46 20 46				.text 	"OUT OF FOR SCOPE",0
>1aa5	4f 52 20 53 43 4f 50 45 00
.1aae					NextEncoder:
.1aae	a9 6f		lda #$6f			lda 	#NextHandler & $FF 			; next code
.1ab0	a0 1a		ldy #$1a			ldy 	#NextHandler >> 8
.1ab2	20 9a 18	jsr $189a			jsr 	EncodeWriteWord
.1ab5	a6 05		ldx $05				ldx 	rsp 						; get stack offset and pop
.1ab7	c6 05		dec $05				dec 	rsp
.1ab9	bd 40 07	lda $0740,x			lda 	returnStackHigh,x 			; check it is a for
.1abc	c9 46		cmp #$46			cmp 	#"F"
.1abe	d0 07		bne $1ac7			bne 	_NENoFor
.1ac0	bd 80 07	lda $0780,x			lda 	returnStackX,x 				; write the branch
.1ac3	20 a4 18	jsr $18a4			jsr 	EncodeWriteByte
.1ac6	60		rts				rts
.1ac7					_NENoFor:
.1ac7	20 01 11	jsr $1101			jsr 	ErrorHandler
>1aca	4d 49 53 53 49 4e 47 20				.text 	"MISSING FOR",0
>1ad2	46 4f 52 00
.1ad6					GetIndex:
.1ad6	a4 05		ldy $05				ldy 	rsp 						; get current stack ptr
.1ad8	b9 80 07	lda $0780,y			lda 	returnStackX,y 				; check it's a FOR Loop
.1adb	c9 ff		cmp #$ff			cmp 	#$FF
.1add	d0 bb		bne $1a9a			bne 	NHNoFor
.1adf	a5 06		lda $06				lda 	TOS
.1ae1	48		pha				pha
.1ae2	a5 07		lda $07				lda 	TOS+1
.1ae4	48		pha				pha
.1ae5	b9 00 07	lda $0700,y			lda 	returnStackLow,y 			; put counter-1 out
.1ae8	38		sec				sec
.1ae9	e9 01		sbc #$01			sbc 	#1
.1aeb	85 06		sta $06				sta 	TOS
.1aed	b9 40 07	lda $0740,y			lda 	returnStackHigh,y
.1af0	e9 00		sbc #$00			sbc 	#0
.1af2	85 07		sta $07				sta 	TOS+1
.1af4	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/structures/ifelseendif.src

.1af7					IfHandler:
.1af7	4c 9e 1b	jmp $1b9e			jmp 	BranchIfZero
.1afa					IfEncoder:
.1afa	a9 f7		lda #$f7			lda 	#IfHandler & $FF 			; if handler
.1afc	a0 1a		ldy #$1a			ldy 	#IfHandler >> 8
.1afe	20 9a 18	jsr $189a			jsr 	EncodeWriteWord
.1b01	a9 49		lda #$49			lda 	#"I" 						; if marker
.1b03	20 30 19	jsr $1930			jsr 	EncodePushPosMarkerOnStack
.1b06	a9 00		lda #$00			lda 	#0
.1b08	20 a4 18	jsr $18a4			jsr 	EncodeWriteByte 			; dummy write.
.1b0b	60		rts				rts
.1b0c					ElseHandler:
.1b0c	4c b4 1b	jmp $1bb4			jmp 	BranchTestSucceedsNoPop
.1b0f					ElseEncoder:
.1b0f	a9 0c		lda #$0c			lda 	#ElseHandler & $FF 			; else handler
.1b11	a0 1b		ldy #$1b			ldy 	#ElseHandler >> 8
.1b13	20 9a 18	jsr $189a			jsr 	EncodeWriteWord
.1b16	ad 10 09	lda $0910			lda 	encodeBuffer 				; push current position
.1b19	48		pha				pha
.1b1a	a9 00		lda #$00			lda 	#0 							; zero branch
.1b1c	20 a4 18	jsr $18a4			jsr 	EncodeWriteByte
.1b1f	20 3c 1b	jsr $1b3c			jsr 	IfPatch 					; fix up the branch.
.1b22	a9 49		lda #$49			lda 	#"I" 						; recreate if marker
.1b24	20 30 19	jsr $1930			jsr 	EncodePushPosMarkerOnStack
.1b27	68		pla				pla 								; address to patch
.1b28	a6 05		ldx $05				ldx 	rsp
.1b2a	9d 80 07	sta $0780,x			sta 	returnStackX,x 				; and overwrite the target address
.1b2d	60		rts				rts
.1b2e					EndIfHandler:
.1b2e	4c 00 00	jmp $0000			jmp 	NextCode
.1b31					EndIfEncoder:
.1b31	a9 2e		lda #$2e			lda 	#EndIfHandler & $FF 		; endif handler
.1b33	a0 1b		ldy #$1b			ldy 	#EndIfHandler >> 8
.1b35	20 9a 18	jsr $189a			jsr 	EncodeWriteWord
.1b38	20 3c 1b	jsr $1b3c			jsr 	IfPatch
.1b3b	60		rts				rts
.1b3c					IfPatch:
.1b3c	a6 05		ldx $05				ldx 	rsp 						; get stack offset and pop
.1b3e	c6 05		dec $05				dec 	rsp
.1b40	bd 40 07	lda $0740,x			lda 	returnStackHigh,x 			; check it is an if.
.1b43	c9 49		cmp #$49			cmp 	#"I"
.1b45	d0 0b		bne $1b52			bne 	_NENoIf
.1b47	bd 80 07	lda $0780,x			lda 	returnStackX,x 				; this is what you patch.
.1b4a	aa		tax				tax
.1b4b	ad 10 09	lda $0910			lda 	encodeBuffer 				; with the current position.
.1b4e	9d 10 09	sta $0910,x			sta 	encodeBuffer,x
.1b51	60		rts				rts
.1b52					_NENoIf:
.1b52	20 01 11	jsr $1101			jsr 	ErrorHandler
>1b55	4d 49 53 53 49 4e 47 20				.text 	"MISSING IF",0
>1b5d	49 46 00

;******  Return to file: kernel.asm


;******  Processing file: words/structures/repeatuntil.src

.1b60					RepeatHandler:
.1b60	4c 00 00	jmp $0000			jmp 	NextCode
.1b63					RepeatEncoder:
.1b63	a9 60		lda #$60			lda 	#RepeatHandler & $FF 		; repeat marker
.1b65	a0 1b		ldy #$1b			ldy 	#RepeatHandler >> 8
.1b67	20 9a 18	jsr $189a			jsr 	EncodeWriteWord
.1b6a	a9 52		lda #$52			lda 	#"R" 						; repeat marker
.1b6c	20 30 19	jsr $1930			jsr 	EncodePushPosMarkerOnStack
.1b6f	60		rts				rts
.1b70					UntilHandler:
.1b70	4c 9e 1b	jmp $1b9e			jmp 	BranchIfZero
.1b73					UntilEncoder:
.1b73	a9 70		lda #$70			lda 	#UntilHandler & $FF 		; until code
.1b75	a0 1b		ldy #$1b			ldy 	#UntilHandler >> 8
.1b77	20 9a 18	jsr $189a			jsr 	EncodeWriteWord
.1b7a	a6 05		ldx $05				ldx 	rsp 						; get stack offset and pop
.1b7c	c6 05		dec $05				dec 	rsp
.1b7e	bd 40 07	lda $0740,x			lda 	returnStackHigh,x 			; check it is a repeat
.1b81	c9 52		cmp #$52			cmp 	#"R"
.1b83	d0 07		bne $1b8c			bne 	_UENoRepeat
.1b85	bd 80 07	lda $0780,x			lda 	returnStackX,x 				; write the branch
.1b88	20 a4 18	jsr $18a4			jsr 	EncodeWriteByte
.1b8b	60		rts				rts
.1b8c					_UENoRepeat:
.1b8c	20 01 11	jsr $1101			jsr 	ErrorHandler
>1b8f	4d 49 53 53 49 4e 47 20				.text 	"MISSING REPEAT",0
>1b97	52 45 50 45 41 54 00

;******  Return to file: kernel.asm


;******  Processing file: words/system/branch.src

.1b9e					BranchIfZero:
.1b9e	a5 06		lda $06				lda 	TOS 						; check TOS = 0
.1ba0	05 07		ora $07				ora 	TOS+1
.1ba2	f0 0a		beq $1bae			beq 	BranchTestSucceeds
.1ba4					BranchTestFails:
.1ba4	68		pla				pla
.1ba5	85 07		sta $07				sta 	TOS+1
.1ba7	68		pla				pla
.1ba8	85 06		sta $06				sta 	TOS
.1baa	e8		inx				inx 								; skip over the relative branch.
.1bab	4c 00 00	jmp $0000			jmp 	NextCode
.1bae					BranchTestSucceeds:
.1bae	68		pla				pla
.1baf	85 07		sta $07				sta 	TOS+1
.1bb1	68		pla				pla
.1bb2	85 06		sta $06				sta 	TOS
.1bb4					BranchTestSucceedsNoPop:
.1bb4	e8		inx				inx 								; advance by two, to the offset
.1bb5	e8		inx				inx
.1bb6					BranchAlways:
.1bb6	8a		txa				txa 								; A = Y = position
.1bb7	a8		tay				tay 								; (IP),Y now points to the branch target
.1bb8	b1 03		lda ($03),y			lda 	(IP),y 						; adjust the position
.1bba	aa		tax				tax 								; position back in this line.
.1bbb	ca		dex				dex
.1bbc	ca		dex				dex
.1bbd	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/system/callhandler.src

.1bc0					CallHandler:
.1bc0	e8		inx				inx									; bump X to the call address.
.1bc1	e8		inx				inx
.1bc2	e6 05		inc $05				inc 	rsp 						; bump the RSP (first time to zero)
.1bc4	a4 05		ldy $05				ldy 	rsp 						; get return stack and push IP/X on it.
.1bc6	c0 40		cpy #$40			cpy 	#$40 						; overflow
.1bc8	f0 54		beq $1c1e			beq 	_CHOverflow
.1bca	a5 04		lda $04				lda 	IP+1
.1bcc	99 40 07	sta $0740,y			sta 	returnStackHigh,y
.1bcf	a5 03		lda $03				lda 	IP
.1bd1	99 00 07	sta $0700,y			sta 	returnStackLow,y
.1bd4	8a		txa				txa
.1bd5	99 80 07	sta $0780,y			sta 	returnStackX,y
.1bd8	8a		txa				txa 								; get the line number into temp1.
.1bd9	a8		tay				tay
.1bda	b1 03		lda ($03),y			lda 	(IP),y
.1bdc	85 10		sta $10				sta 	temp1
.1bde	c8		iny				iny
.1bdf	b1 03		lda ($03),y			lda 	(IP),y
.1be1	85 11		sta $11				sta 	temp1+1
.1be3	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.1be5	85 03		sta $03				sta 	0+(IP)
.1be7	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.1be9	85 04		sta $04				sta 	1+(IP)
.1beb	b2 03		lda ($03)			lda 	(IP)						; no program code ?
.1bed	f0 17		beq $1c06			beq 	_CHFail
.1bef	a0 01		ldy #$01			ldy 	#1 							; Y = 1 throughout.
.1bf1					_CHSearch:
.1bf1	b1 03		lda ($03),y			lda 	(IP),y 						; check LSB of line number
.1bf3	c5 10		cmp $10				cmp 	temp1
.1bf5	f0 3e		beq $1c35			beq 	_CHFoundLSB
.1bf7					_CHSearchNext:
.1bf7	18		clc				clc
.1bf8	a5 03		lda $03				lda 	IP
.1bfa	72 03		adc ($03)			adc 	(IP)
.1bfc	85 03		sta $03				sta 	IP
.1bfe	90 02		bcc $1c02			bcc 	_NoCarryAdv
.1c00	e6 04		inc $04				inc 	IP+1
.1c02					_NoCarryAdv:
.1c02	b2 03		lda ($03)			lda 	(IP)						; check reached the end.
.1c04	d0 eb		bne $1bf1			bne 	_CHSearch
.1c06					_CHFail:
.1c06	20 01 11	jsr $1101			jsr 	ErrorHandler
>1c09	43 41 4e 54 20 46 49 4e				.text 	"CANT FIND DEFINITION",0
>1c11	44 20 44 45 46 49 4e 49 54 49 4f 4e 00
.1c1e					_CHOverflow:
.1c1e	20 01 11	jsr $1101			jsr 	ErrorHandler
>1c21	43 41 4c 4c 20 53 54 41				.text 	"CALL STACK OVERFLOW",0
>1c29	43 4b 20 4f 56 45 52 46 4c 4f 57 00
.1c35					_CHFoundLSB:
.1c35	c8		iny				iny 								; get MSB
.1c36	b1 03		lda ($03),y			lda 	(IP),y
.1c38	88		dey				dey
.1c39	c5 11		cmp $11				cmp 	temp1+1 					; matches, if not contineu
.1c3b	d0 ba		bne $1bf7			bne 	_CHSearchNext
.1c3d	a0 03		ldy #$03			ldy 	#3	 						; check it begins with $$define
.1c3f	b1 03		lda ($03),y			lda 	(IP),y
.1c41	c9 b8		cmp #$b8			cmp 	#DefineCode & $FF
.1c43	d0 c1		bne $1c06			bne 	_CHFail
.1c45	c8		iny				iny
.1c46	b1 03		lda ($03),y			lda 	(IP),y
.1c48	c9 21		cmp #$21			cmp 	#DefineCode >> 8
.1c4a	d0 ba		bne $1c06			bne 	_CHFail
.1c4c	c8		iny				iny
.1c4d	b1 03		lda ($03),y			lda 	(IP),y 						; this is the length of the define name
.1c4f	18		clc				clc
.1c50	69 03		adc #$03			adc 	#5-2 						; $$define token, line number, offset - 2 for Next
.1c52	aa		tax				tax
.1c53	4c 00 00	jmp $0000			jmp 	NextCode
.1c56					ReturnHandler:
.1c56	a4 05		ldy $05				ldy 	rsp 						; get rsp
.1c58	30 15		bmi $1c6f			bmi 	_RHUnderflow 				; if -ve underflowed
.1c5a	c6 05		dec $05				dec 	rsp 						; decrement rsp
.1c5c	b9 40 07	lda $0740,y			lda 	returnStackHigh,y 			; restore IP/X
.1c5f	85 04		sta $04				sta 	IP+1
.1c61	b9 00 07	lda $0700,y			lda 	returnStackLow,y
.1c64	85 03		sta $03				sta 	IP
.1c66	b9 80 07	lda $0780,y			lda 	returnStackX,y
.1c69	aa		tax				tax
.1c6a	f0 15		beq $1c81			beq 	_RHInLoop 					; this means you have done :something for ; next
.1c6c	4c 00 00	jmp $0000			jmp 	NextCode
.1c6f					_RHUnderflow:
.1c6f	20 01 11	jsr $1101			jsr 	ErrorHandler
>1c72	4d 49 53 53 49 4e 47 20				.text 	"MISSING RETURN",0
>1c7a	52 45 54 55 52 4e 00
.1c81					_RHInLoop:
.1c81	20 01 11	jsr $1101			jsr 	ErrorHandler
>1c84	52 45 54 55 52 4e 20 49				.text 	"RETURN IN LOOP ERROR",0
>1c8c	4e 20 4c 4f 4f 50 20 45 52 52 4f 52 00
.1c99					CallHandlerDecode:
.1c99	a9 03		lda #$03			lda 	#CTH_Call					; space
.1c9b	20 63 1e	jsr $1e63			jsr 	DecodeWriteBuffer
.1c9e	b1 08		lda ($08),y			lda 	(srcPtr),y 					; get line number into YA
.1ca0	aa		tax				tax
.1ca1	c8		iny				iny
.1ca2	b1 08		lda ($08),y			lda 	(srcPtr),y
.1ca4	a8		tay				tay
.1ca5	8a		txa				txa
.1ca6	20 e3 1c	jsr $1ce3			jsr 	FindLine 					; try to locate that line.
.1ca9	b0 11		bcs $1cbc			bcs 	_CHDFound 					; if found .....
.1cab					_CHDLineOnly:
.1cab	48		pha				pha
.1cac	a9 3c		lda #$3c			lda 	#"<"
.1cae	20 63 1e	jsr $1e63			jsr 	DecodeWriteBuffer
.1cb1	68		pla				pla
.1cb2	18		clc				clc 								; output unsigned
.1cb3	20 85 1e	jsr $1e85			jsr 	DecodeYAToBuffer
.1cb6	a9 3e		lda #$3e			lda 	#">"
.1cb8	20 63 1e	jsr $1e63			jsr 	DecodeWriteBuffer
.1cbb	60		rts				rts
.1cbc					_CHDFound:
.1cbc	48		pha				pha 								; save YA
.1cbd	5a		phy				phy
.1cbe	a0 03		ldy #$03			ldy 	#3 							; check first is $$define
.1cc0	b1 10		lda ($10),y			lda 	(temp1),y
.1cc2	c9 b8		cmp #$b8			cmp 	#DefineCode & 255
.1cc4	d0 07		bne $1ccd			bne 	_CHDNoDefine
.1cc6	c8		iny				iny
.1cc7	b1 10		lda ($10),y			lda 	(temp1),y
.1cc9	c9 21		cmp #$21			cmp 	#DefineCode >> 8
.1ccb	f0 04		beq $1cd1			beq 	_CHDFoundDefine
.1ccd					_CHDNoDefine:
.1ccd	7a		ply				ply									; restore the line number and print it in <>
.1cce	68		pla				pla
.1ccf	80 da		bra $1cab			bra 	_CHDLineOnly
.1cd1					_CHDFoundDefine:
.1cd1	68		pla				pla 								; throw saved line number.
.1cd2	68		pla				pla
.1cd3	a0 05		ldy #$05			ldy 	#5 							; 3,4 $$define 5 length, name has bit 7 set at end
.1cd5					_CHDOutName:
.1cd5	c8		iny				iny 								; next
.1cd6	b1 10		lda ($10),y			lda 	(temp1),y 					; print char no bit 7
.1cd8	48		pha				pha
.1cd9	29 7f		and #$7f			and 	#$7F
.1cdb	20 63 1e	jsr $1e63			jsr 	DecodeWriteBuffer
.1cde	68		pla				pla
.1cdf	0a		asl a				asl 	a 							; bit 7 to carry
.1ce0	90 f3		bcc $1cd5			bcc 	_CHDOutName
.1ce2	60		rts				rts
.1ce3					FindLine:
.1ce3	48		pha				pha 								; save registers
.1ce4	da		phx				phx
.1ce5	5a		phy				phy
.1ce6	85 12		sta $12				sta 	temp2 						; temp2 = target line#
.1ce8	84 13		sty $13				sty 	temp2+1
.1cea	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.1cec	85 10		sta $10				sta 	0+(temp1)
.1cee	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.1cf0	85 11		sta $11				sta 	1+(temp1)
.1cf2					_FLLoop:
.1cf2	b2 10		lda ($10)			lda 	(temp1) 					; found end ?
.1cf4	18		clc				clc									; if so exit with CC.
.1cf5	f0 1d		beq $1d14			beq 	_FLExit
.1cf7	a0 01		ldy #$01			ldy 	#1 							; check line # match
.1cf9	b1 10		lda ($10),y			lda 	(temp1),y
.1cfb	c5 12		cmp $12				cmp 	temp2
.1cfd	d0 08		bne $1d07			bne 	_FLNext
.1cff	c8		iny				iny
.1d00	b1 10		lda ($10),y			lda 	(temp1),y
.1d02	c5 13		cmp $13				cmp 	temp2+1
.1d04	38		sec				sec 								; if so exit with CS
.1d05	f0 0d		beq $1d14			beq 	_FLExit
.1d07					_FLNext:
.1d07	18		clc				clc
.1d08	a5 10		lda $10				lda 	temp1
.1d0a	72 10		adc ($10)			adc 	(temp1)
.1d0c	85 10		sta $10				sta 	temp1
.1d0e	90 02		bcc $1d12			bcc 	_NoCarryAdv
.1d10	e6 11		inc $11				inc 	temp1+1
.1d12					_NoCarryAdv:
.1d12	80 de		bra $1cf2			bra 	_FLLoop 					; keep looking.
.1d14					_FLExit:
.1d14	7a		ply				ply
.1d15	fa		plx				plx
.1d16	68		pla				pla
.1d17	60		rts				rts
.1d18	18		clc				clc
.1d19	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/clrnew.src

.1d1a					NewHandler:
.1d1a	9c 00 40	stz $4000			stz 	ProgramMemory 				; Make the first offset zero.
.1d1d	20 30 1d	jsr $1d30			jsr 	ClearVariableSpace 			; clear variables, reset pointers
.1d20	4c 00 00	jmp $0000			jmp 	NextCode
.1d23					ClrHandler:
.1d23	86 10		stx $10				stx 	temp1
.1d25	a2 80		ldx #$80			ldx 	#NumberStackBase
.1d27	9a		txs				txs
.1d28	a6 10		ldx $10				ldx 	temp1
.1d2a	20 30 1d	jsr $1d30			jsr 	ClearVariableSpace 			; clear variables, reset pointers
.1d2d	4c 00 00	jmp $0000			jmp 	NextCode
.1d30					ClearVariableSpace:
.1d30	a9 ff		lda #$ff			lda 	#$FF
.1d32	85 05		sta $05				sta 	rsp
.1d34	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.1d36	85 0e		sta $0e				sta 	0+(nextFreeMem)
.1d38	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.1d3a	85 0f		sta $0f				sta 	1+(nextFreeMem)
.1d3c	a0 1f		ldy #$1f			ldy 	#hashTableSize*2-1 			; erase the hash table (used for variables)
.1d3e					_CVSHashClear:
.1d3e	a9 00		lda #$00			lda 	#0 							; all the first record pointers are $00
.1d40	99 40 06	sta $0640,y			sta 	hashTable,y
.1d43	88		dey				dey
.1d44	10 f8		bpl $1d3e			bpl 	_CVSHashClear
.1d46					_CVSFindEnd:
.1d46	18		clc				clc
.1d47	a5 0e		lda $0e				lda 	nextFreeMem
.1d49	72 0e		adc ($0e)			adc 	(nextFreeMem)
.1d4b	85 0e		sta $0e				sta 	nextFreeMem
.1d4d	90 02		bcc $1d51			bcc 	_NoCarryAdv
.1d4f	e6 0f		inc $0f				inc 	nextFreeMem+1
.1d51					_NoCarryAdv:
.1d51	b2 0e		lda ($0e)			lda 	(nextFreeMem)
.1d53	d0 f1		bne $1d46			bne 	_CVSFindEnd
.1d55	a9 08		lda #$08			lda 	#8 							; this puts a gap in, more for clarity than anything.
.1d57	a0 00		ldy #$00			ldy 	#0
.1d59	20 5d 1d	jsr $1d5d			jsr 	AdvanceFreeMem				; we need +1 because the previous code leaves the
.1d5c	60		rts				rts 								; free mem pointer pointing to the last zero offset
.1d5d					AdvanceFreeMem:
.1d5d	18		clc				clc
.1d5e	65 0e		adc $0e				adc 	nextFreeMem
.1d60	85 0e		sta $0e				sta 	nextFreeMem
.1d62	98		tya				tya
.1d63	65 0f		adc $0f				adc 	nextFreeMem+1
.1d65	85 0f		sta $0f				sta 	nextFreeMem+1
.1d67	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/debug.src

.1d68					ExitDump:
.1d68	ba		tsx				tsx 								; save Data Stack in temp1
.1d69	86 10		stx $10				stx 	temp1
.1d6b	4c ff ff	jmp $ffff			jmp 	$FFFF 						; makes the X16-Emulator dump-exit.
.1d6e					BreakCmd:
>1d6e	ff						.byte 	$FF
.1d6f	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/system/decode.src

.1d72					DecodeLineIntoBufPtr:
.1d72	48		pha				pha
.1d73	da		phx				phx
.1d74	5a		phy				phy
.1d75	85 08		sta $08				sta 	srcPtr 						; save the source line.
.1d77	84 09		sty $09				sty 	srcPtr+1
.1d79	90 1b		bcc $1d96			bcc 	_DecodeNoLineNumber
.1d7b	a0 01		ldy #$01			ldy 	#1 							; get line # to YA
.1d7d	b1 08		lda ($08),y			lda 	(srcPtr),y
.1d7f	aa		tax				tax
.1d80	c8		iny				iny
.1d81	b1 08		lda ($08),y			lda 	(srcPtr),y
.1d83	a8		tay				tay
.1d84	8a		txa				txa
.1d85	18		clc				clc
.1d86	20 85 1e	jsr $1e85			jsr 	DecodeYAToBuffer 			; convert to string in buffer
.1d89	aa		tax				tax 								; count in X
.1d8a					_DecodeLineSpace:
.1d8a	e0 05		cpx #$05			cpx 	#5
.1d8c	f0 08		beq $1d96			beq 	_DecodeNoLineNumber
.1d8e	a9 20		lda #$20			lda 	#" " 						; pad to 5 spaces
.1d90	20 63 1e	jsr $1e63			jsr 	DecodeWriteBuffer
.1d93	e8		inx				inx
.1d94	80 f4		bra $1d8a			bra 	_DecodeLineSpace
.1d96					_DecodeNoLineNumber:
.1d96	a0 03		ldy #$03			ldy 	#3 							; initial position.
.1d98					_DecodeLoop:
.1d98	b1 08		lda ($08),y			lda 	(srcPtr),y 					; copy the current character to temp1
.1d9a	85 10		sta $10				sta 	temp1 						; must be an execution address.
.1d9c	c8		iny				iny
.1d9d	b1 08		lda ($08),y			lda 	(srcPtr),y
.1d9f	85 11		sta $11				sta 	temp1+1
.1da1	c8		iny				iny 								; y points to the byte after it.
.1da2	a5 10		lda $10				lda 	temp1
.1da4	c9 76		cmp #$76			cmp 	#NextLine & $FF
.1da6	d0 06		bne $1dae			bne 	_DecodeNotEOL
.1da8	a5 11		lda $11				lda 	temp1+1
.1daa	c9 21		cmp #$21			cmp 	#NextLine >> 8
.1dac	f0 0b		beq $1db9			beq 	_DecodeEOL
.1dae					_DecodeNotEOL:
.1dae	20 c1 1d	jsr $1dc1			jsr 	IdentifyCodeWord
.1db1	20 0e 1e	jsr $1e0e			jsr 	DecodeFoundWord
.1db4	20 f8 1d	jsr $1df8			jsr 	AdvanceToNext 				; advance to next entry in the line.
.1db7	80 df		bra $1d98			bra 	_DecodeLoop 				; and go round again
.1db9					_DecodeEOL:
.1db9	a9 00		lda #$00			lda 	#0
.1dbb	92 0a		sta ($0a)			sta 	(bufPtr)
.1dbd	7a		ply				ply 								; restore registers and exit
.1dbe	fa		plx				plx
.1dbf	68		pla				pla
.1dc0	60		rts				rts
.1dc1					IdentifyCodeWord:
.1dc1	5a		phy				phy 								; save current position on the stack.
.1dc2	a9 74		lda #$74			lda 	#(Dictionary) & $FF
.1dc4	85 0c		sta $0c				sta 	0+(matchPtr)
.1dc6	a9 24		lda #$24			lda 	#(Dictionary) >> 8
.1dc8	85 0d		sta $0d				sta 	1+(matchPtr)
.1dca					_DecodeIdentify:
.1dca	a0 02		ldy #$02			ldy 	#2 							; have we found a match ?
.1dcc	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.1dce	c5 10		cmp $10				cmp 	temp1
.1dd0	d0 07		bne $1dd9			bne 	_DecodeIdNext
.1dd2	c8		iny				iny
.1dd3	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.1dd5	c5 11		cmp $11				cmp 	temp1+1
.1dd7	f0 1d		beq $1df6			beq 	_DecodeIdFound
.1dd9					_DecodeIdNext:
.1dd9	18		clc				clc
.1dda	b2 0c		lda ($0c)			lda 	(matchPtr)
.1ddc	f0 0a		beq $1de8			beq 	_DecodeIdIssue
.1dde	65 0c		adc $0c				adc 	matchPtr
.1de0	85 0c		sta $0c				sta 	matchPtr
.1de2	90 e6		bcc $1dca			bcc 	_DecodeIdentify
.1de4	e6 0d		inc $0d				inc 	matchPtr+1
.1de6	80 e2		bra $1dca			bra 	_DecodeIdentify
.1de8					_DecodeIdIssue:
.1de8	20 01 11	jsr $1101			jsr 	ErrorHandler
>1deb	44 45 43 4f 44 45 2f 42				.text 	"DECODE/BUG",0
>1df3	55 47 00
.1df6					_DecodeIdFound:
.1df6	7a		ply				ply 								; restore position.
.1df7	60		rts				rts
.1df8					AdvanceToNext:
.1df8	5a		phy				phy 								; get the parameter count from bits 0-1 of the type byte
.1df9	a0 01		ldy #$01			ldy 	#1
.1dfb	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.1dfd	29 03		and #$03			and 	#3 							; bits 0-1.
.1dff	7a		ply				ply
.1e00	c9 03		cmp #$03			cmp 	#3 							; is it n-bytes e.g. specified by the next byte
.1e02	d0 02		bne $1e06			bne 	_ATN012
.1e04	b1 08		lda ($08),y			lda 	(srcPtr),y 					; if so, use that byte as the overall length.
.1e06					_ATN012:
.1e06	85 12		sta $12				sta 	temp2 						; now add that to Y
.1e08	98		tya				tya
.1e09	18		clc				clc
.1e0a	65 12		adc $12				adc 	temp2
.1e0c	a8		tay				tay
.1e0d	60		rts				rts
.1e0e					DecodeFoundWord:
.1e0e	5a		phy				phy 								; save current position
.1e0f	84 12		sty $12				sty		temp2 						; put it in temp2 as well.
.1e11	a0 01		ldy #$01			ldy 	#1 							; get the type byte
.1e13	b1 0c		lda ($0c),y			lda 	(matchPtr),y 				; is there a special decoder check (bit 4 set) ?
.1e15	29 10		and #$10			and 	#$10
.1e17	d0 0e		bne $1e27			bne 	_DFWSpecialDecoder
.1e19	b1 0c		lda ($0c),y			lda 	(matchPtr),y 				; reget it.
.1e1b	30 08		bmi $1e25			bmi 	_DFWExit 					; if hidden word (bit 7 set)
.1e1d	a9 06		lda #$06			lda 	#CTH_Keyword				; output a space to the buffer
.1e1f	20 63 1e	jsr $1e63			jsr 	DecodeWriteBuffer
.1e22	20 40 1e	jsr $1e40			jsr 	DecodeCurrentWord 			; expand that.
.1e25					_DFWExit:
.1e25	7a		ply				ply 								; restore current position
.1e26	60		rts				rts
.1e27					_DFWSpecialDecoder:
.1e27	a0 04		ldy #$04			ldy 	#4 							; the decode word address is at offset 4,5
.1e29	b1 0c		lda ($0c),y			lda 	(matchPtr),y 				; copy this into temp2
.1e2b	85 12		sta $12				sta 	temp2
.1e2d	c8		iny				iny
.1e2e	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.1e30	85 13		sta $13				sta 	temp2+1
.1e32	7a		ply				ply 	 							; restore current position into Y
.1e33	48		pha				pha 								; save registers
.1e34	da		phx				phx
.1e35	5a		phy				phy
.1e36	20 3d 1e	jsr $1e3d			jsr 	_DFWCallDecoder				; call the decoder routine
.1e39	7a		ply				ply 								; restore registers and exit
.1e3a	fa		plx				plx
.1e3b	68		pla				pla
.1e3c	60		rts				rts
.1e3d					_DFWCallDecoder:
.1e3d	6c 12 00	jmp ($0012)			jmp 	(temp2)
.1e40					DecodeCurrentWord:
.1e40	5a		phy				phy
.1e41	a0 01		ldy #$01			ldy 	#1 							; read type byte
.1e43	b1 0c		lda ($0c),y			lda 	(matchPtr),y
.1e45	a0 04		ldy #$04			ldy 	#4 							; original offset
.1e47	4a		lsr a				lsr 	a 							; encoder/decoder bits in 0-1
.1e48	4a		lsr a				lsr 	a 							; add 2 to Y for each encoder/decoder
.1e49	4a		lsr a				lsr 	a 							; bit set.
.1e4a	4a		lsr a				lsr 	a
.1e4b	4a		lsr a				lsr 	a 							; decoder bit
.1e4c	90 02		bcc $1e50			bcc 	_DWBNoDec
.1e4e	c8		iny				iny
.1e4f	c8		iny				iny
.1e50					_DWBNoDec:
.1e50	4a		lsr a				lsr 	a
.1e51	90 02		bcc $1e55			bcc 	_DWBNoEnc
.1e53	c8		iny				iny
.1e54	c8		iny				iny
.1e55					_DWBNoEnc:
.1e55					_DWBWordOut:
.1e55	b1 0c		lda ($0c),y			lda 	(matchPtr),y 				; output until bit 7 set.
.1e57	48		pha				pha
.1e58	29 7f		and #$7f			and 	#$7F
.1e5a	20 63 1e	jsr $1e63			jsr		DecodeWriteBuffer
.1e5d	c8		iny				iny
.1e5e	68		pla				pla
.1e5f	10 f4		bpl $1e55			bpl 	_DWBWordOut
.1e61	7a		ply				ply 								; restore Y and exit
.1e62	60		rts				rts
.1e63					DecodeWriteBuffer:
.1e63	92 0a		sta ($0a)			sta 	(bufPtr)
.1e65	e6 0a		inc $0a				inc 	bufPtr
.1e67	d0 02		bne $1e6b			bne 	_DWBNoCarry
.1e69	e6 0b		inc $0b				inc 	bufPtr+1
.1e6b					_DWBNoCarry:
.1e6b	60		rts				rts
.1e6c					DecodeOutputData:
.1e6c	48		pha				pha
.1e6d	da		phx				phx
.1e6e	5a		phy				phy
.1e6f	b1 08		lda ($08),y			lda 	(srcPtr),y 					; length + 1
.1e71	aa		tax				tax
.1e72					_DODLoop:
.1e72	ca		dex				dex 								; done it all ?
.1e73	f0 0c		beq $1e81			beq		_DODExit
.1e75	c8		iny				iny 								; output next character
.1e76	b1 08		lda ($08),y			lda 	(srcPtr),y
.1e78	29 7f		and #$7f			and 	#$7F
.1e7a	f0 f6		beq $1e72			beq 	_DODLoop 					; don't print NULL
.1e7c	20 63 1e	jsr $1e63			jsr 	DecodeWriteBuffer
.1e7f	80 f1		bra $1e72			bra 	_DODLoop
.1e81					_DODExit:
.1e81	7a		ply				ply
.1e82	fa		plx				plx
.1e83	68		pla				pla
.1e84	60		rts				rts
.1e85					DecodeYAToBuffer:
.1e85	da		phx				phx
.1e86	5a		phy				phy
.1e87	48		pha				pha
.1e88	a5 0a		lda $0a				lda 	bufPtr 						; copy bufPtr to temp2
.1e8a	85 12		sta $12				sta 	temp2
.1e8c	a5 0b		lda $0b				lda 	bufPtr+1
.1e8e	85 13		sta $13				sta 	temp2+1
.1e90	68		pla				pla
.1e91	20 af 22	jsr $22af			jsr 	ConvertToStringMain 		; convert YA to string there
.1e94	aa		tax				tax 								; chars output to X
.1e95	18		clc				clc
.1e96	65 0a		adc $0a				adc 	bufPtr 						; add to buffer pointer
.1e98	85 0a		sta $0a				sta 	bufPtr
.1e9a	90 02		bcc $1e9e			bcc 	_DYABNoCarry
.1e9c	e6 0b		inc $0b				inc 	bufPtr+1
.1e9e					_DYABNoCarry:
.1e9e	8a		txa				txa 								; count in A
.1e9f	7a		ply				ply									; restore and exit.
.1ea0	fa		plx				plx
.1ea1	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/edit.src

.1ea2					EditProgram:
.1ea2	20 1f 1f	jsr $1f1f			jsr 	EDFindLine					; find line address -> temp1
.1ea5	90 0f		bcc $1eb6			bcc 	_EPNotFound 				; if missing don't delete it.
.1ea7	a5 10		lda $10				lda 	temp1 						; save line address
.1ea9	48		pha				pha
.1eaa	a5 11		lda $11				lda 	temp1+1
.1eac	48		pha				pha
.1ead	20 c4 1e	jsr $1ec4			jsr 	EDDeleteLine 				; delete the line
.1eb0	68		pla				pla 								; restore line address
.1eb1	85 11		sta $11				sta 	temp1+1
.1eb3	68		pla				pla
.1eb4	85 10		sta $10				sta 	temp1
.1eb6					_EPNotFound:
.1eb6	ad 10 09	lda $0910			lda 	encodeBuffer 				; is there anything in the line.
.1eb9	c9 05		cmp #$05			cmp 	#5 							; <offset> <line#> <next line>
.1ebb	f0 03		beq $1ec0			beq 	_EPNoInsert
.1ebd	20 e7 1e	jsr $1ee7			jsr 	EDInsertLine 				; insert line back in.
.1ec0					_EPNoInsert:
.1ec0	20 30 1d	jsr $1d30			jsr 	ClearVariableSpace
.1ec3	60		rts				rts
.1ec4					EDDeleteLine:
.1ec4	20 30 1d	jsr $1d30			jsr 	ClearVariableSpace
.1ec7	a0 00		ldy #$00			ldy 	#0 							; this is the offset to copy down.
.1ec9	a2 00		ldx #$00			ldx 	#0
.1ecb	b1 10		lda ($10),y			lda 	(temp1),y
.1ecd	a8		tay				tay 								; put in Y
.1ece					_EDDelLoop:
.1ece	b1 10		lda ($10),y			lda 	(temp1),y 					; get it
.1ed0	81 10		sta ($10,x)			sta 	(temp1,x) 					; write it.
.1ed2	a5 10		lda $10				lda 	temp1 						; check if pointer has reached the end of
.1ed4	c5 0e		cmp $0e				cmp		nextFreeMem 				; low memory. We will have copied down an
.1ed6	d0 06		bne $1ede			bne 	_EDDelNext 					; extra pile of stuff - technically should
.1ed8	a5 11		lda $11				lda 	temp1+1 					; check the upper value (e.g. temp1+y)
.1eda	c5 0f		cmp $0f				cmp 	nextFreeMem+1				; doesn't really matter.
.1edc	f0 08		beq $1ee6			beq		_EDDelExit
.1ede					_EDDelNext:
.1ede	e6 10		inc $10				inc 	temp1 						; go to next byte.
.1ee0	d0 ec		bne $1ece			bne 	_EDDelLoop
.1ee2	e6 11		inc $11				inc 	temp1+1
.1ee4	80 e8		bra $1ece			bra 	_EDDelLoop
.1ee6					_EDDelExit:
.1ee6	60		rts				rts
.1ee7					EDInsertLine:
.1ee7	20 30 1d	jsr $1d30			jsr 	ClearVariableSpace
.1eea	a5 0e		lda $0e				lda 	nextFreeMem 				; copy high memory to temp3
.1eec	85 14		sta $14				sta 	temp3
.1eee	a5 0f		lda $0f				lda 	nextFreeMem+1
.1ef0	85 15		sta $15				sta 	temp3+1
.1ef2	ac 10 09	ldy $0910			ldy 	encodeBuffer 				; space to move it to in Y
.1ef5	a2 00		ldx #$00			ldx 	#0
.1ef7					_EDInsLoop:
.1ef7	a1 14		lda ($14,x)			lda 	(temp3,x)					; copy it up
.1ef9	91 14		sta ($14),y			sta 	(temp3),y
.1efb	a5 14		lda $14				lda 	temp3 						; reached the insert point (temp1)
.1efd	c5 10		cmp $10				cmp 	temp1
.1eff	d0 06		bne $1f07			bne 	_EDINextShift
.1f01	a5 15		lda $15				lda 	temp3+1
.1f03	c5 11		cmp $11				cmp 	temp1+1
.1f05	f0 0a		beq $1f11			beq 	_EDIShiftOver
.1f07					_EDINextShift:
.1f07	a5 14		lda $14				lda 	temp3 						; decrement the copy pointer.
.1f09	d0 02		bne $1f0d			bne 	_EDINoBorrow
.1f0b	c6 15		dec $15				dec 	temp3+1
.1f0d					_EDINoBorrow:
.1f0d	c6 14		dec $14				dec 	temp3
.1f0f	80 e6		bra $1ef7			bra 	_EDInsLoop
.1f11					_EDIShiftOver:
.1f11	a0 00		ldy #$00			ldy 	#0
.1f13					_EDICopyCode:
.1f13	b9 10 09	lda $0910,y			lda 	encodeBuffer,y				; read from the current line
.1f16	91 10		sta ($10),y			sta 	(temp1),y 					; write out
.1f18	c8		iny				iny 								; bump pointers
.1f19	cc 10 09	cpy $0910			cpy 	encodeBuffer 				; done the whole lot ?
.1f1c	d0 f5		bne $1f13			bne 	_EDICopyCode
.1f1e	60		rts				rts
.1f1f					EDFindLine:
.1f1f	a9 00		lda #$00			lda 	#(programMemory) & $FF
.1f21	85 10		sta $10				sta 	0+(temp1)
.1f23	a9 40		lda #$40			lda 	#(programMemory) >> 8
.1f25	85 11		sta $11				sta 	1+(temp1)
.1f27					_EDFLLoop:
.1f27	b2 10		lda ($10)			lda 	(temp1) 					; check offset
.1f29	f0 24		beq $1f4f			beq 	_EDFLFail 					; then obviously that's the end ;-) (great comment !)
.1f2b	a0 01		ldy #$01			ldy 	#1							; look at line #
.1f2d	38		sec				sec
.1f2e	ad 11 09	lda $0911			lda 	encodeBuffer+1				; subtract the current from the target
.1f31	f1 10		sbc ($10),y			sbc 	(temp1),y 					; so if searching for 100 and this one is 90,
.1f33	aa		tax				tax	 								; this will return 10.
.1f34	ad 12 09	lda $0912			lda 	encodeBuffer+2
.1f37	c8		iny				iny
.1f38	f1 10		sbc ($10),y			sbc 	(temp1),y
.1f3a	90 13		bcc $1f4f			bcc 	_EDFLFail					; if target < current then failed.
.1f3c	d0 04		bne $1f42			bne 	_EDFLNext 					; if non-zero then goto next
.1f3e	e0 00		cpx #$00			cpx 	#0 							; same for the LSB - zero if match found.
.1f40	f0 0f		beq $1f51			beq 	_EDFLFound
.1f42					_EDFLNext:
.1f42	18		clc				clc
.1f43	a5 10		lda $10				lda 	temp1
.1f45	72 10		adc ($10)			adc 	(temp1)
.1f47	85 10		sta $10				sta 	temp1
.1f49	90 02		bcc $1f4d			bcc 	_NoCarryAdv
.1f4b	e6 11		inc $11				inc 	temp1+1
.1f4d					_NoCarryAdv:
.1f4d	80 d8		bra $1f27			bra 	_EDFLLoop
.1f4f					_EDFLFail:
.1f4f	18		clc				clc
.1f50	60		rts				rts
.1f51					_EDFLFound:
.1f51	38		sec				sec
.1f52	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/list.src

.1f53					ListCode:
.1f53	64 1e		stz $1e				stz 	ListLowest 					; zero lowest line#
.1f55	64 1f		stz $1f				stz 	ListLowest+1
.1f57	a9 18		lda #$18			lda 	#24 						; show max 24 after lowest line
.1f59	85 1d		sta $1d				sta 	ListCount
.1f5b	a9 00		lda #$00			lda 	#(ProgramMemory) & $FF
.1f5d	85 18		sta $18				sta 	0+(listPtr)
.1f5f	a9 40		lda #$40			lda 	#(ProgramMemory) >> 8
.1f61	85 19		sta $19				sta 	1+(listPtr)
.1f63	86 10		stx $10				stx 	temp1						; S->A
.1f65	ba		tsx				tsx
.1f66	8a		txa				txa
.1f67	a6 10		ldx $10				ldx 	temp1
.1f69	c9 80		cmp #$80			cmp 	#NumberStackBase
.1f6b	f0 0e		beq $1f7b			beq 	_LCLoop
.1f6d	a5 06		lda $06				lda 	TOS 						; copy TOS to lowest
.1f6f	85 1e		sta $1e				sta 	ListLowest
.1f71	a5 07		lda $07				lda 	TOS+1
.1f73	85 1f		sta $1f				sta 	ListLowest+1
.1f75	68		pla				pla
.1f76	85 07		sta $07				sta 	TOS+1
.1f78	68		pla				pla
.1f79	85 06		sta $06				sta 	TOS
.1f7b					_LCLoop:
.1f7b	b2 18		lda ($18)			lda 	(listPtr)					; reached end ?
.1f7d	f0 4c		beq $1fcb			beq 	_LCExit
.1f7f	a0 01		ldy #$01			ldy 	#1							; >= list lowest
.1f81	b1 18		lda ($18),y			lda 	(listPtr),y
.1f83	c5 1e		cmp $1e				cmp 	ListLowest
.1f85	c8		iny				iny
.1f86	b1 18		lda ($18),y			lda 	(listPtr),y
.1f88	e5 1f		sbc $1f				sbc 	ListLowest+1
.1f8a	90 32		bcc $1fbe			bcc 	_LCNext
.1f8c	a9 10		lda #$10			lda 	#(textBuffer) & $FF
.1f8e	85 0a		sta $0a				sta 	0+(bufPtr)
.1f90	a9 08		lda #$08			lda 	#(textBuffer) >> 8
.1f92	85 0b		sta $0b				sta 	1+(bufPtr)
.1f94	a5 18		lda $18				lda 	listPtr 					; output the line.
.1f96	a4 19		ldy $19				ldy 	listPtr+1
.1f98	38		sec				sec
.1f99	20 72 1d	jsr $1d72			jsr 	DecodeLineIntoBufPtr
.1f9c	a9 02		lda #$02			lda 	#CTH_LineNo
.1f9e	20 6c 11	jsr $116c			jsr 	ExternColour
.1fa1	a0 ff		ldy #$ff			ldy 	#255
.1fa3					_LCLoop2:
.1fa3	c8		iny				iny
.1fa4	b9 10 08	lda $0810,y			lda 	textBuffer,y
.1fa7	f0 0e		beq $1fb7			beq 	_LCEnd
.1fa9	c9 20		cmp #$20			cmp 	#32
.1fab	b0 05		bcs $1fb2			bcs 	_LCPrint
.1fad	20 6c 11	jsr $116c			jsr 	ExternColour
.1fb0	a9 20		lda #$20			lda 	#32
.1fb2					_LCPrint:
.1fb2	20 62 11	jsr $1162			jsr 	ExternPrint
.1fb5	80 ec		bra $1fa3			bra 	_LCLoop2
.1fb7	a9 0d		lda #$0d	_LCEnd:	lda 	#13 						; new line
.1fb9	20 62 11	jsr $1162			jsr 	ExternPrint
.1fbc	c6 1d		dec $1d				dec 	ListCount					; done all the lines allowed
.1fbe					_LCNext:
.1fbe	18		clc				clc
.1fbf	a5 18		lda $18				lda 	listPtr
.1fc1	72 18		adc ($18)			adc 	(listPtr)
.1fc3	85 18		sta $18				sta 	listPtr
.1fc5	90 02		bcc $1fc9			bcc 	_NoCarryAdv
.1fc7	e6 19		inc $19				inc 	listPtr+1
.1fc9					_NoCarryAdv:
.1fc9	80 b0		bra $1f7b			bra 	_LCLoop 					; go round again.
.1fcb					_LCExit:
.1fcb	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/system/miscellany.src

.1fce					RunProgram:
.1fce	86 10		stx $10				stx 	temp1
.1fd0	a2 80		ldx #$80			ldx 	#NumberStackBase
.1fd2	9a		txs				txs
.1fd3	a6 10		ldx $10				ldx 	temp1
.1fd5	20 30 1d	jsr $1d30			jsr 	ClearVariableSpace 			; clear variables etc.
.1fd8	a2 00		ldx #$00			ldx		#ProgramMemory & $FF		; boot address
.1fda	a0 40		ldy #$40			ldy 	#ProgramMemory >>8
.1fdc	20 98 10	jsr $1098			jsr 	InitialiseCoreCode 			; initialise the NEXT routine at $00
.1fdf	4c 00 00	jmp $0000			jmp 	NextCode
.1fe2					Call6502:
.1fe2	a5 06		lda $06				lda 	TOS 						; copy call address
.1fe4	85 10		sta $10				sta 	temp1
.1fe6	a5 07		lda $07				lda 	TOS+1
.1fe8	85 11		sta $11				sta 	temp1+1
.1fea	68		pla				pla
.1feb	85 07		sta $07				sta 	TOS+1
.1fed	68		pla				pla
.1fee	85 06		sta $06				sta 	TOS
.1ff0	20 f6 1f	jsr $1ff6			jsr 	_CallTemp1 					; call it
.1ff3	4c 00 00	jmp $0000			jmp 	NextCode
.1ff6					_CallTemp1:
.1ff6	6c 10 00	jmp ($0010)			jmp 	(temp1)
.1ff9					AssertCode:
.1ff9	a5 06		lda $06				lda 	TOS 						; TOS = 0
.1ffb	05 07		ora $07				ora 	TOS+1
.1ffd	f0 09		beq $2008			beq 	_ASFail 					; if zero fail
.1fff	68		pla				pla
.2000	85 07		sta $07				sta 	TOS+1
.2002	68		pla				pla
.2003	85 06		sta $06				sta 	TOS
.2005	4c 00 00	jmp $0000			jmp 	NextCode
.2008					_ASFail:
.2008	20 01 11	jsr $1101			jsr 	ErrorHandler
>200b	41 53 53 45 52 54 00				.text 	"ASSERT",0
.2012					StopCode:
.2012	20 01 11	jsr $1101			jsr 	ErrorHandler
>2015	53 54 4f 50 00					.text 	"STOP",0
.201a					EndProgram:
.201a	4c 17 10	jmp $1017			jmp 	WarmStart
.201d					VlistCode:
.201d	a9 74		lda #$74			lda 	#(Dictionary) & $FF
.201f	85 10		sta $10				sta 	0+(temp1)
.2021	a9 24		lda #$24			lda 	#(Dictionary) >> 8
.2023	85 11		sta $11				sta 	1+(temp1)
.2025	a0 01		ldy #$01	_VLLoop:ldy 	#1							; type byte
.2027	b1 10		lda ($10),y			lda 	(temp1),y
.2029	a0 04		ldy #$04			ldy 	#4 							; Y = 4
.202b	4a		lsr a				lsr 	a 							; shift bits 4 and 5 to 0,1
.202c	4a		lsr a				lsr 	a
.202d	4a		lsr a				lsr		a
.202e	4a		lsr a				lsr 	a
.202f	4a		lsr a				lsr 	a 							; add those bits in
.2030	90 02		bcc $2034			bcc 	_VLNoDec
.2032	c8		iny				iny
.2033	c8		iny				iny
.2034					_VLNoDec:
.2034	4a		lsr a				lsr 	a
.2035	90 02		bcc $2039			bcc 	_VLNoEnc
.2037	c8		iny				iny
.2038	c8		iny				iny
.2039					_VLNoEnc:
.2039	b1 10		lda ($10),y			lda 	(temp1),y 					; remove $$ words
.203b	c9 24		cmp #$24			cmp 	#"$"
.203d	d0 06		bne $2045			bne 	_VLPrint
.203f	c8		iny				iny
.2040	51 10		eor ($10),y			eor 	(temp1),y
.2042	f0 13		beq $2057			beq 	_VLNext
.2044	88		dey				dey
.2045					_VLPrint:
.2045	b1 10		lda ($10),y			lda 	(temp1),y
.2047	48		pha				pha
.2048	c8		iny				iny
.2049	29 7f		and #$7f			and 	#$7F
.204b	20 62 11	jsr $1162			jsr 	ExternPrint
.204e	68		pla				pla
.204f	0a		asl a				asl 	a
.2050	90 f3		bcc $2045			bcc 	_VLPrint
.2052	a9 20		lda #$20			lda 	#32
.2054	20 62 11	jsr $1162			jsr 	ExternPrint
.2057					_VLNext:
.2057	18		clc				clc 								; go to next
.2058	b2 10		lda ($10)			lda 	(temp1)
.205a	65 10		adc $10				adc 	temp1
.205c	85 10		sta $10				sta 	temp1
.205e	90 02		bcc $2062			bcc 	_VLNoCarry
.2060	e6 11		inc $11				inc 	temp1+1
.2062					_VLNoCarry:
.2062	b2 10		lda ($10)			lda 	(temp1)
.2064	d0 bf		bne $2025			bne 	_VLLoop
.2066	a9 0d		lda #$0d			lda 	#13
.2068	20 62 11	jsr $1162			jsr 	ExternPrint
.206b	4c 00 00	jmp $0000			jmp 	NextCode
.206e					DumpStack:
.206e	a9 5b		lda #$5b			lda		#"["
.2070	20 62 11	jsr $1162			jsr 	ExternPrint
.2073	86 10		stx $10				stx 	temp1 						; X -> A
.2075	ba		tsx				tsx
.2076	8a		txa				txa
.2077	a6 10		ldx $10				ldx 	temp1
.2079	c9 80		cmp #$80			cmp 	#NumberStackBase 			; out of range, exit
.207b	f0 2f		beq $20ac			beq 	_DSExit
.207d	48		pha				pha 								; save it
.207e	a9 07		lda #$07			lda 	#COL_WHITE
.2080	20 6c 11	jsr $116c			jsr 	ExternColour
.2083	a5 06		lda $06				lda 	TOS 						; print TOS then stack values backwards
.2085	a4 07		ldy $07				ldy 	TOS+1
.2087	38		sec				sec 								; print unsigned.
.2088	20 89 22	jsr $2289			jsr 	PrintYA
.208b	a9 06		lda #$06			lda 	#COL_CYAN
.208d	20 6c 11	jsr $116c			jsr 	ExternColour
.2090	7a		ply				ply 								; restore offset
.2091					_DSLoop:
.2091	c0 7e		cpy #$7e			cpy 	#NumberStackBase-2 			; till done whole stack.
.2093	f0 17		beq $20ac			beq 	_DSExit
.2095	a9 20		lda #$20			lda 	#" " 						; space
.2097	20 62 11	jsr $1162			jsr 	ExternPrint
.209a	5a		phy				phy 								; save pos
.209b	b9 01 01	lda $0101,y			lda 	$0101,y 					; read stack item
.209e	48		pha				pha
.209f	b9 02 01	lda $0102,y			lda 	$0102,y
.20a2	7a		ply				ply
.20a3	38		sec				sec
.20a4	20 89 22	jsr $2289			jsr 	PrintYA 					; print it
.20a7	7a		ply				ply 								; restore and advance pos
.20a8	c8		iny				iny
.20a9	c8		iny				iny
.20aa	80 e5		bra $2091			bra 	_DSLoop
.20ac					_DSExit:
.20ac	a9 5d		lda #$5d			lda		#"]"
.20ae	20 62 11	jsr $1162			jsr 	ExternPrint
.20b1	a9 0d		lda #$0d			lda 	#13
.20b3	20 62 11	jsr $1162			jsr 	ExternPrint
.20b6	4c 00 00	jmp $0000			jmp 	NextCode

;******  Return to file: kernel.asm


;******  Processing file: words/system/saveload.src

.20b9					System_Save:
.20b9	20 30 1d	jsr $1d30			jsr 	ClearVariableSpace  		; make sure start/end are right
.20bc	20 3b 21	jsr $213b			jsr 	ExtendWithDictionary 		; attach the dictionary addresses.
.20bf	20 e7 20	jsr $20e7			jsr 	SLGetFileName 				; get filename -> temp3
.20c2	a5 0e		lda $0e				lda 	nextFreeMem 				; end address
.20c4	85 10		sta $10				sta 	temp1
.20c6	a5 0f		lda $0f				lda 	nextFreeMem+1
.20c8	85 11		sta $11				sta 	temp1+1
.20ca	a9 00		lda #$00			lda 	#ProgramMemory & $FF 		; program start to YA
.20cc	a0 40		ldy #$40			ldy 	#ProgramMemory >> 8
.20ce	20 b4 11	jsr $11b4			jsr 	ExternSave
.20d1	20 30 1d	jsr $1d30			jsr 	ClearVariableSpace  		; make sure start/end are right
.20d4	4c 0d 10	jmp $100d			jmp 	WarmStartBlankStack
.20d7					System_Load:
.20d7	20 e7 20	jsr $20e7			jsr 	SLGetFileName 				; get filename -> temp3
.20da	a9 00		lda #$00			lda 	#ProgramMemory & $FF 		; program start to YA
.20dc	a0 40		ldy #$40			ldy 	#ProgramMemory >> 8
.20de	20 ea 11	jsr $11ea			jsr 	ExternLoad
.20e1	20 30 1d	jsr $1d30			jsr 	ClearVariableSpace 			; reset everything.
.20e4	4c 0d 10	jmp $100d			jmp 	WarmStartBlankStack
.20e7					SLGetFileName:
.20e7	ba		tsx				tsx
.20e8	e0 80		cpx #$80			cpx 	#NumberStackBase
.20ea	f0 3a		beq $2126			beq 	_SLFNFail
.20ec	a9 10		lda #$10			lda 	#textBuffer & $FF 			; f/n in input buffer.
.20ee	85 14		sta $14				sta 	temp3
.20f0	a9 08		lda #$08			lda 	#textBuffer >> 8
.20f2	85 15		sta $15				sta 	temp3+1
.20f4	a0 00		ldy #$00			ldy 	#0
.20f6	b1 06		lda ($06),y	_SLCopy:lda 	(TOS),y
.20f8	91 14		sta ($14),y			sta 	(temp3),y
.20fa	c8		iny				iny
.20fb	c9 00		cmp #$00			cmp		#0
.20fd	d0 f7		bne $20f6			bne 	_SLCopy
.20ff	88		dey				dey
.2100	a2 03		ldx #$03			ldx 	#3 							; check if it ends in .RPL
.2102					_SLCheckEnd:
.2102	88		dey				dey
.2103	bd 36 21	lda $2136,x			lda 	_SLFNExtension,x
.2106	d1 14		cmp ($14),y			cmp 	(temp3),y
.2108	d0 05		bne $210f			bne 	_SLNoExtension
.210a	ca		dex				dex
.210b	10 f5		bpl $2102			bpl 	_SLCheckEnd
.210d	80 16		bra $2125			bra 	_SLExit
.210f					_SLNoExtension:
.210f	a0 ff		ldy #$ff			ldy 	#255						; add the extension.
.2111					_SLFindend:
.2111	c8		iny				iny
.2112	b9 10 08	lda $0810,y			lda 	textBuffer,y
.2115	d0 fa		bne $2111			bne 	_SLFindend
.2117	a2 00		ldx #$00			ldx 	#0
.2119					_SLAppend:
.2119	bd 36 21	lda $2136,x			lda 	_SLFNExtension,x
.211c	99 10 08	sta $0810,y			sta 	textBuffer,y
.211f	e8		inx				inx
.2120	c8		iny				iny
.2121	c9 00		cmp #$00			cmp 	#0
.2123	d0 f4		bne $2119			bne 	_SLAppend
.2125					_SLExit:
.2125	60		rts				rts
.2126					_SLFNFail:
.2126	20 01 11	jsr $1101			jsr 	ErrorHandler
>2129	42 41 44 20 46 49 4c 45				.text 	"BAD FILENAME",0
>2131	4e 41 4d 45 00
.2136					_SLFNExtension:
>2136	2e 52 50 4c 00					.text 	".RPL",0
.213b					ExtendWithDictionary:
.213b	20 64 21	jsr $2164			jsr 	_EWDMarker 					; 8 bytes after the final offset write a marker
.213e	a9 74		lda #$74			lda 	#(Dictionary) & $FF
.2140	85 10		sta $10				sta 	0+(temp1)
.2142	a9 24		lda #$24			lda 	#(Dictionary) >> 8
.2144	85 11		sta $11				sta 	1+(temp1)
.2146					_EWDLoop:
.2146	b2 10		lda ($10)			lda 	(temp1)						; end
.2148	f0 1a		beq $2164			beq 	_EWDMarker
.214a	a0 02		ldy #$02			ldy 	#2 							; output the address
.214c	b1 10		lda ($10),y			lda 	(temp1),y
.214e	20 6d 21	jsr $216d			jsr 	_EWDWrite
.2151	c8		iny				iny
.2152	b1 10		lda ($10),y			lda 	(temp1),y
.2154	20 6d 21	jsr $216d			jsr 	_EWDWrite
.2157	18		clc				clc 								; next entry.
.2158	a5 10		lda $10				lda 	temp1
.215a	72 10		adc ($10)			adc 	(temp1)
.215c	85 10		sta $10				sta 	temp1
.215e	90 e6		bcc $2146			bcc 	_EWDLoop
.2160	e6 11		inc $11				inc 	temp1+1
.2162	80 e2		bra $2146			bra 	_EWDLoop
.2164					_EWDMarker:
.2164	a9 ff		lda #$ff			lda 	#$FF
.2166	20 6d 21	jsr $216d			jsr 	_EWDWrite
.2169	20 6d 21	jsr $216d			jsr 	_EWDWrite
.216c	60		rts				rts
.216d					_EWDWrite:
.216d	92 0e		sta ($0e)			sta 	(nextFreeMem)
.216f	e6 0e		inc $0e				inc 	nextFreeMem
.2171	d0 02		bne $2175			bne 	_EWDExit
.2173	e6 0f		inc $0f				inc 	nextFreeMem+1
.2175					_EWDExit:
.2175	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/skipper.src

.2176					NextLine:
.2176	18		clc				clc
.2177	a5 03		lda $03				lda 	IP
.2179	72 03		adc ($03)			adc 	(IP)
.217b	85 03		sta $03				sta 	IP
.217d	90 02		bcc $2181			bcc 	_NoCarryAdv
.217f	e6 04		inc $04				inc 	IP+1
.2181					_NoCarryAdv:
.2181	b2 03		lda ($03)			lda 	(IP)						; is there any following program ?
.2183	f0 05		beq $218a			beq 	_NLGoEnd
.2185	a2 01		ldx #$01			ldx 	#1 							; start 3 in (-2 for Next)
.2187	4c 00 00	jmp $0000			jmp 	NextCode
.218a					_NLGoEnd:
.218a	4c 17 10	jmp $1017			jmp 	WarmStart
.218d					SkipComment:
.218d	e8		inx				inx									; (IP),X points to the length.
.218e	e8		inx				inx
.218f	8a		txa				txa
.2190	a8		tay				tay 								; put into Y
.2191	18		clc				clc
.2192	71 03		adc ($03),y			adc 	(IP),y 						; add the length to X
.2194	aa		tax				tax 								; put back in X
.2195	ca		dex				dex
.2196	ca		dex				dex
.2197	4c 00 00	jmp $0000			jmp 	NextCode
.219a					CommentDecoder:
.219a	a9 06		lda #$06			lda 	#CTH_Keyword
.219c	20 63 1e	jsr $1e63			jsr 	DecodeWriteBuffer
.219f	a9 27		lda #$27			lda 	#"'"
.21a1	20 63 1e	jsr $1e63			jsr 	DecodeWriteBuffer
.21a4	b1 08		lda ($08),y			lda 	(srcPtr),y 					; check if there is no data
.21a6	c9 01		cmp #$01			cmp 	#1
.21a8	f0 0d		beq $21b7			beq 	_CDEmpty 					; if so print nothing.
.21aa	a9 0b		lda #$0b			lda 	#CTH_Comment
.21ac	20 63 1e	jsr $1e63			jsr 	DecodeWriteBuffer
.21af	20 6c 1e	jsr $1e6c			jsr 	DecodeOutputData
.21b2	a9 20		lda #$20			lda 	#32
.21b4	20 63 1e	jsr $1e63			jsr 	DecodeWriteBuffer
.21b7					_CDEmpty
.21b7	60		rts				rts
.21b8					DefineCode:
.21b8	20 01 11	jsr $1101			jsr 	ErrorHandler
>21bb	52 45 41 43 48 45 44 20				.text 	"REACHED DEFINITION",0
>21c3	44 45 46 49 4e 49 54 49 4f 4e 00
.21ce					DefineDecoder:
.21ce	a9 07		lda #$07			lda 	#CTH_Definition
.21d0	20 63 1e	jsr $1e63			jsr 	DecodeWriteBuffer
.21d3	a9 3a		lda #$3a			lda 	#":"
.21d5	20 63 1e	jsr $1e63			jsr 	DecodeWriteBuffer
.21d8	20 6c 1e	jsr $1e6c			jsr 	DecodeOutputData
.21db	a9 20		lda #$20			lda 	#32
.21dd	20 63 1e	jsr $1e63			jsr 	DecodeWriteBuffer
.21e0	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/toint.src

.21e1					ConvertToInteger:
.21e1	84 17		sty $17				sty 	temp4+1
.21e3	85 16		sta $16				sta 	temp4
.21e5	64 14		stz $14				stz 	temp3 						; reset value
.21e7	64 15		stz $15				stz 	temp3+1
.21e9	64 10		stz $10				stz 	temp1 						; temp1 = 0 (decimal) 255 (hex)
.21eb	a0 00		ldy #$00			ldy 	#0 							; look at first character
.21ed	b1 16		lda ($16),y			lda 	(temp4),y
.21ef	49 2d		eor #$2d			eor 	#"-"						; zero if '-'
.21f1	85 11		sta $11				sta 	temp1+1 					; save this in temp1+1
.21f3	d0 01		bne $21f6			bne 	_CTINotMinus
.21f5	c8		iny				iny									; skip -
.21f6					_CTINotMinus:
.21f6	b1 16		lda ($16),y			lda 	(temp4),y
.21f8	c9 24		cmp #$24			cmp		#'$'						; if $ then skip it and set hex flag
.21fa	d0 03		bne $21ff			bne 	_CTILoop
.21fc	c6 10		dec $10				dec 	temp1
.21fe	c8		iny				iny
.21ff					_CTILoop:
.21ff	b1 16		lda ($16),y			lda 	(temp4),y 					; next digit
.2201	29 7f		and #$7f			and 	#$7F 						; drop end of word flag
.2203	38		sec				sec
.2204	e9 30		sbc #$30			sbc 	#'0' 						; put in range '0'+
.2206	90 65		bcc $226d			bcc 	_CTIFail 					; out of range.
.2208	c9 0a		cmp #$0a			cmp 	#10 						; in 0-9 ?
.220a	90 0b		bcc $2217			bcc 	_CTILegal
.220c	c9 11		cmp #$11			cmp 	#'A'-'0'					; between 9 and A ?
.220e	90 5d		bcc $226d			bcc 	_CTIFail
.2210	38		sec				sec
.2211	e9 07		sbc #$07			sbc 	#7 							; hex adjust
.2213	c9 10		cmp #$10			cmp 	#16 						; out of range ?
.2215	b0 56		bcs $226d			bcs 	_CTIFail
.2217					_CTILegal:
.2217	48		pha				pha 								; save digit value.
.2218	06 14		asl $14				asl 	temp3
.221a	26 15		rol $15				rol 	temp3+1
.221c	a5 14		lda $14				lda 	temp3 						; copy x2 into temp2
.221e	85 12		sta $12				sta 	temp2
.2220	a5 15		lda $15				lda 	temp3+1
.2222	85 13		sta $13				sta 	temp2+1
.2224	06 14		asl $14				asl 	temp3
.2226	26 15		rol $15				rol 	temp3+1
.2228	06 14		asl $14				asl 	temp3
.222a	26 15		rol $15				rol 	temp3+1
.222c	24 10		bit $10				bit 	temp1 						; hexadecimal
.222e	10 07		bpl $2237			bpl 	_CTIDecimal
.2230	06 14		asl $14				asl 	temp3
.2232	26 15		rol $15				rol 	temp3+1
.2234	68		pla				pla 								; get digit back
.2235	80 12		bra $2249			bra 	_CTIAddLoop
.2237					_CTIDecimal:
.2237	18		clc				clc 								; x 8 + x 2 = x 10
.2238	a5 14		lda $14				lda 	temp3
.223a	65 12		adc $12				adc 	temp2
.223c	85 14		sta $14				sta 	temp3
.223e	a5 15		lda $15				lda 	temp3+1
.2240	65 13		adc $13				adc 	temp2+1
.2242	85 15		sta $15				sta 	temp3+1
.2244	68		pla				pla 								; check digit 0-9
.2245	c9 0a		cmp #$0a			cmp 	#10
.2247	b0 24		bcs $226d			bcs 	_CTIFail
.2249					_CTIAddLoop:
.2249	18		clc				clc
.224a	65 14		adc $14				adc 	temp3
.224c	85 14		sta $14				sta 	temp3
.224e	90 02		bcc $2252			bcc 	_CTINoCarry
.2250	e6 15		inc $15				inc 	temp3+1
.2252					_CTINoCarry:
.2252	c8		iny				iny
.2253	b1 16		lda ($16),y			lda 	(temp4),y 					; was this the last character
.2255	c9 21		cmp #$21			cmp 	#32+1
.2257	b0 a6		bcs $21ff			bcs 	_CTILoop 					; no, go back.
.2259	a5 11		lda $11				lda 	temp1+1 					; was it - ?
.225b	d0 0d		bne $226a			bne 	_CTIOkay
.225d	38		sec				sec
.225e	a9 00		lda #$00			lda 	#0 							; negate temp3.
.2260	e5 14		sbc $14				sbc 	temp3
.2262	85 14		sta $14				sta 	temp3
.2264	a9 00		lda #$00			lda 	#0
.2266	e5 15		sbc $15				sbc 	temp3+1
.2268	85 15		sta $15				sta 	temp3+1
.226a					_CTIOkay:
.226a	98		tya				tya
.226b	38		sec				sec
.226c	60		rts				rts
.226d					_CTIFail:
.226d	18		clc				clc
.226e	60		rts				rts

;******  Return to file: kernel.asm


;******  Processing file: words/system/tostr.src

.226f					IntToString:
.226f	a9 10		lda #$10			lda 	#(textBuffer) & $FF
.2271	85 12		sta $12				sta 	0+(temp2)
.2273	a9 08		lda #$08			lda 	#(textBuffer) >> 8
.2275	85 13		sta $13				sta 	1+(temp2)
.2277	a5 06		lda $06				lda 	TOS 						; value in YA
.2279	a4 07		ldy $07				ldy 	TOS+1
.227b	20 ab 22	jsr $22ab			jsr 	ConvertToString
.227e	a9 10		lda #$10			lda 	#(textBuffer) & $FF
.2280	85 06		sta $06				sta 	0+(TOS)
.2282	a9 08		lda #$08			lda 	#(textBuffer) >> 8
.2284	85 07		sta $07				sta 	1+(TOS)
.2286	4c 00 00	jmp $0000			jmp 	NextCode
.2289					PrintYA:
.2289	48		pha				pha
.228a	da		phx				phx
.228b	5a		phy				phy
.228c	48		pha				pha
.228d	a9 10		lda #$10			lda 	#(textBuffer) & $FF
.228f	85 12		sta $12				sta 	0+(temp2)
.2291	a9 08		lda #$08			lda 	#(textBuffer) >> 8
.2293	85 13		sta $13				sta 	1+(temp2)
.2295	68		pla				pla
.2296	20 af 22	jsr $22af			jsr 	ConvertToStringMain
.2299	a2 00		ldx #$00			ldx 	#0
.229b					_PrintYALoop:
.229b	bd 10 08	lda $0810,x			lda 	textBuffer,x
.229e	20 62 11	jsr $1162			jsr 	ExternPrint
.22a1	e8		inx				inx
.22a2	bd 10 08	lda $0810,x			lda 	textBuffer,x
.22a5	d0 f4		bne $229b			bne 	_PrintYALoop
.22a7	7a		ply				ply
.22a8	fa		plx				plx
.22a9	68		pla				pla
.22aa	60		rts				rts
.22ab					ConvertToString:
.22ab	38		sec				sec
.22ac	80 01		bra $22af			bra 	ConvertToStringMain
.22ae					ConvertToStringUnsigned:
.22ae	18		clc				clc
.22af					ConvertToStringMain:
.22af	da		phx				phx									; save XY
.22b0	5a		phy				phy
.22b1	64 1a		stz $1a				stz 	SignCount 					; this is zero suppression
.22b3	85 10		sta $10				sta 	temp1 						; save YA in temp1
.22b5	84 11		sty $11				sty 	temp1+1
.22b7	a0 00		ldy #$00			ldy 	#0 							; index to result.
.22b9	90 16		bcc $22d1			bcc 	_CTSUnsigned 				; if carry clear do not adjust for -
.22bb	a5 11		lda $11				lda 	temp1+1 					; is it negative
.22bd	10 12		bpl $22d1			bpl 	_CTSUnsigned
.22bf	a9 2d		lda #$2d			lda 	#"-"						; output - sign
.22c1	91 12		sta ($12),y			sta 	(temp2),y
.22c3	c8		iny				iny
.22c4	38		sec				sec 								; negate temp1
.22c5	a9 00		lda #$00			lda 	#0
.22c7	e5 10		sbc $10				sbc 	temp1
.22c9	85 10		sta $10				sta 	temp1
.22cb	a9 00		lda #$00			lda 	#0
.22cd	e5 11		sbc $11				sbc 	temp1+1
.22cf	85 11		sta $11				sta 	temp1+1
.22d1					_CTSUnsigned:
.22d1	a2 00		ldx #$00			ldx 	#0 							; index into subtraction table
.22d3					_CTSLoop:
.22d3	a9 2f		lda #$2f			lda 	#"0"-1						; set the digit to '0' code.
.22d5	91 12		sta ($12),y			sta 	(temp2),y
.22d7					_CTSSubLoop:
.22d7	b1 12		lda ($12),y			lda 	(temp2),y 					; bump the count
.22d9	1a		inc a				inc 	a
.22da	91 12		sta ($12),y			sta 	(temp2),y
.22dc	38		sec				sec 								; do subtraction saving interim result
.22dd	a5 10		lda $10				lda 	temp1
.22df	fd 12 23	sbc $2312,x			sbc 	_CTSTable,x
.22e2	48		pha				pha
.22e3	a5 11		lda $11				lda 	temp1+1
.22e5	fd 13 23	sbc $2313,x			sbc 	_CTSTable+1,x
.22e8	90 07		bcc $22f1			bcc 	_CTSCantSubtract 			; end of subtraction.
.22ea	85 11		sta $11				sta 	temp1+1 					; save result back
.22ec	68		pla				pla
.22ed	85 10		sta $10				sta 	temp1
.22ef	80 e6		bra $22d7			bra 	_CTSSubLoop
.22f1					_CTSCantSubtract:
.22f1	68		pla				pla 								; throw away interim
.22f2	e8		inx				inx 								; next subtractor
.22f3	e8		inx				inx
.22f4	b1 12		lda ($12),y			lda 	(temp2),y 					; update leading zero
.22f6	49 30		eor #$30			eor 	#"0"
.22f8	05 1a		ora $1a				ora 	SignCount
.22fa	85 1a		sta $1a				sta 	SignCount
.22fc	f0 01		beq $22ff			beq		_CTSLZ 						; if all zeros so far suppress.
.22fe	c8		iny				iny 								; next character
.22ff					_CTSLZ:
.22ff	e0 08		cpx #$08			cpx 	#_CTSTableEnd-_CTSTable 	; done them all ?
.2301	d0 d0		bne $22d3			bne 	_CTSLoop
.2303					_CTSComplete:
.2303	a5 10		lda $10				lda		temp1 						; get remainder 0-9
.2305	09 30		ora #$30			ora 	#48 						; ASCII
.2307	91 12		sta ($12),y			sta 	(temp2),y					; write out
.2309	c8		iny				iny
.230a	a9 00		lda #$00			lda 	#0							; make ASCIIZ
.230c	91 12		sta ($12),y			sta 	(temp2),y
.230e	98		tya				tya 								; size in A
.230f	7a		ply				ply									; pull and exit.
.2310	fa		plx				plx
.2311	60		rts				rts
.2312					_CTSTable:
>2312	10 27 e8 03 64 00 0a 00				.word 	10000,1000,100,10 			; subtractors, this is a simple version.
.231a					_CTSTableEnd:

;******  Return to file: kernel.asm


;******  Processing file: words/system/varhandlers.src

.231a					VarAddressHandler:
.231a	18		clc				clc 								; find variable, error if it doesn't exist.
.231b	20 6c 23	jsr $236c			jsr 	VariableFind
.231e	a5 06		lda $06				lda 	TOS
.2320	48		pha				pha
.2321	a5 07		lda $07				lda 	TOS+1
.2323	48		pha				pha
.2324	a5 10		lda $10				lda 	temp1 						; the address is the new value
.2326	85 06		sta $06				sta 	TOS
.2328	a5 11		lda $11				lda		temp1+1
.232a	85 07		sta $07				sta 	TOS+1
.232c	4c 00 00	jmp $0000			jmp 	NextCode
.232f					VarAddrHandlerDecode:
.232f	a9 26		lda #$26			lda 	#"&"
.2331	4c 21 24	jmp $2421			jmp 	VarHandlerDecode
.2334					VarReadHandler:
.2334	18		clc				clc 								; find variable, error if it doesn't exist.
.2335	20 6c 23	jsr $236c			jsr 	VariableFind
.2338	a5 06		lda $06				lda 	TOS
.233a	48		pha				pha
.233b	a5 07		lda $07				lda 	TOS+1
.233d	48		pha				pha
.233e	b2 10		lda ($10)			lda 	(temp1)						; read variable address to TOS
.2340	85 06		sta $06				sta 	TOS
.2342	a0 01		ldy #$01			ldy 	#1
.2344	b1 10		lda ($10),y			lda 	(temp1),y
.2346	85 07		sta $07				sta 	TOS+1
.2348	4c 00 00	jmp $0000			jmp 	NextCode
.234b					VarReadHandlerDecode:
.234b	a9 40		lda #$40			lda 	#"@"
.234d	4c 21 24	jmp $2421			jmp 	VarHandlerDecode
.2350					VarWriteHandler:
.2350	38		sec				sec 								; find variable, create it if it doesn't exist.
.2351	20 6c 23	jsr $236c			jsr 	VariableFind
.2354	a5 06		lda $06				lda 	TOS 						; write TOS to that address.
.2356	92 10		sta ($10)			sta 	(temp1)
.2358	a5 07		lda $07				lda 	TOS+1
.235a	a0 01		ldy #$01			ldy 	#1
.235c	91 10		sta ($10),y			sta 	(temp1),y
.235e	68		pla				pla
.235f	85 07		sta $07				sta 	TOS+1
.2361	68		pla				pla
.2362	85 06		sta $06				sta 	TOS
.2364	4c 00 00	jmp $0000			jmp 	NextCode
.2367					VarWriteHandlerDecode:
.2367	a9 21		lda #$21			lda 	#"!"
.2369	4c 21 24	jmp $2421			jmp 	VarHandlerDecode
.236c					VariableFind:
.236c	08		php				php 								; save autocreate flag.
.236d	e8		inx				inx 								; advance to/over the variable name.
.236e	e8		inx				inx
.236f	8a		txa				txa 								; put in Y
.2370	a8		tay				tay
.2371	b1 03		lda ($03),y			lda 	(IP),y 						; copy name word into temp2
.2373	85 12		sta $12				sta 	temp2
.2375	c8		iny				iny
.2376	b1 03		lda ($03),y			lda 	(IP),y
.2378	85 13		sta $13				sta 	temp2+1
.237a	c9 1b		cmp #$1b			cmp 	#27 						; check for A-Z
.237c	b0 0f		bcs $238d			bcs 	_VFLong
.237e	a5 13		lda $13				lda 	temp2+1
.2380	d0 0b		bne $238d			bne 	_VFLong
.2382	a5 12		lda $12				lda 	temp2						; this is the index
.2384	0a		asl a				asl 	a 							; double it
.2385	85 10		sta $10				sta 	temp1
.2387	a9 06		lda #$06			lda 	#azVariables >> 8			; set the MSB
.2389	85 11		sta $11				sta 	temp1+1
.238b	28		plp				plp 								; throw creation flag, it always exists.
.238c	60		rts				rts
.238d					_VFLong:
.238d	a5 12		lda $12				lda 	temp2 						; built a hash table index into temp3/temp4
.238f	6a		ror a				ror 	a
.2390	6a		ror a				ror 	a
.2391	6a		ror a				ror 	a
.2392	6a		ror a				ror 	a
.2393	45 12		eor $12				eor 	temp2
.2395	45 13		eor $13				eor 	temp2+1
.2397	29 0f		and #$0f			and 	#(hashTableSize-1)			; force into range
.2399	0a		asl a				asl 	a
.239a	69 40		adc #$40			adc 	#hashTable & $FF 			; make an address of the head => temp1/3
.239c	85 10		sta $10				sta 	temp1
.239e	85 14		sta $14				sta 	temp3
.23a0	a9 06		lda #$06			lda 	#hashTable >> 8
.23a2	85 11		sta $11				sta 	temp1+1
.23a4	85 15		sta $15				sta 	temp3+1
.23a6					_VFSearch:
.23a6	a0 01		ldy #$01			ldy 	#1							; read MSB of first record
.23a8	b1 10		lda ($10),y			lda 	(temp1),y
.23aa	f0 23		beq $23cf			beq 	_VFNotFound 				; is MSB is zero, can't be a variable record
.23ac	a8		tay				tay 								; follow the link through.
.23ad	b2 10		lda ($10)			lda 	(temp1)
.23af	85 10		sta $10				sta 	temp1
.23b1	84 11		sty $11				sty 	temp1+1
.23b3	a0 04		ldy #$04			ldy 	#4							; check if the name matches
.23b5	b1 10		lda ($10),y			lda 	(temp1),y
.23b7	c5 12		cmp $12				cmp 	temp2
.23b9	d0 eb		bne $23a6			bne 	_VFSearch 					; if it doesn't, follow the next link.
.23bb	c8		iny				iny 								; same for 2nd byte of name
.23bc	b1 10		lda ($10),y			lda 	(temp1),y
.23be	c5 13		cmp $13				cmp 	temp2+1
.23c0	d0 e4		bne $23a6			bne 	_VFSearch
.23c2	18		clc				clc
.23c3	a5 10		lda $10				lda 	temp1 						; make temp1 point to the data at offset 2
.23c5	69 02		adc #$02			adc 	#2
.23c7	85 10		sta $10				sta 	temp1
.23c9	90 02		bcc $23cd			bcc 	_VFNoPage1
.23cb	e6 11		inc $11				inc 	temp1+1
.23cd					_VFNoPage1:
.23cd	28		plp				plp 								; don't need to worry about creation flag
.23ce	60		rts				rts
.23cf					_VFNotFound:
.23cf	28		plp				plp 								; was carry set, e.g. create a new record if not found ?
.23d0	b0 14		bcs $23e6			bcs 	_VFCreate
.23d2	20 01 11	jsr $1101			jsr 	ErrorHandler
>23d5	4e 4f 20 53 55 43 48 20				.text 	"NO SUCH VARIABLE",0
>23dd	56 41 52 49 41 42 4c 45 00
.23e6					_VFCreate:
.23e6	a0 01		ldy #$01			ldy 	#1
.23e8	b2 14		lda ($14)			lda 	(temp3) 					; copy the head link to the first 2 bytes
.23ea	92 0e		sta ($0e)			sta 	(nextFreeMem)
.23ec	b1 14		lda ($14),y			lda 	(temp3),y
.23ee	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.23f0	c8		iny				iny
.23f1	a9 00		lda #$00			lda 	#0	 						; write zero initialised data out.
.23f3	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.23f5	c8		iny				iny
.23f6	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.23f8	c8		iny				iny
.23f9	a5 12		lda $12				lda 	temp2 						; copy the name out
.23fb	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.23fd	c8		iny				iny
.23fe	a5 13		lda $13				lda 	temp2+1
.2400	91 0e		sta ($0e),y			sta 	(nextFreeMem),y
.2402	a0 01		ldy #$01			ldy 	#1
.2404	a5 0e		lda $0e				lda 	nextFreeMem 				; update the head link
.2406	92 14		sta ($14)			sta 	(temp3)
.2408	a5 0f		lda $0f				lda 	nextFreeMem+1
.240a	91 14		sta ($14),y			sta 	(temp3),y
.240c	18		clc				clc
.240d	a5 0e		lda $0e				lda 	nextFreeMem 				; put nextFreeMem+2 in temp1 (data pointer)
.240f	69 02		adc #$02			adc 	#2
.2411	85 10		sta $10				sta 	temp1
.2413	a5 0f		lda $0f				lda 	nextFreeMem+1
.2415	69 00		adc #$00			adc 	#0
.2417	85 11		sta $11				sta 	temp1+1
.2419	a9 06		lda #$06			lda 	#6							; shift freemem pointer up 6
.241b	a0 00		ldy #$00			ldy 	#0
.241d	20 5d 1d	jsr $1d5d			jsr 	AdvanceFreeMem
.2420	60		rts				rts
.2421					VarHandlerDecode:
.2421	48		pha				pha 								; save, leading space
.2422	a9 07		lda #$07			lda 	#CTH_Variable
.2424	20 63 1e	jsr $1e63			jsr 	DecodeWriteBuffer
.2427	68		pla				pla 								; restore and write type
.2428	20 63 1e	jsr $1e63			jsr 	DecodeWriteBuffer
.242b	b1 08		lda ($08),y			lda 	(srcPtr),y 					; copy to temp1
.242d	85 10		sta $10				sta 	temp1
.242f	c8		iny				iny
.2430	b1 08		lda ($08),y			lda 	(srcPtr),y
.2432	85 11		sta $11				sta 	temp1+1
.2434	a5 10		lda $10				lda 	temp1 						; output the first character
.2436	29 1f		and #$1f			and 	#31
.2438	20 63 24	jsr $2463			jsr 	VHOutVarChar
.243b	a2 05		ldx #$05			ldx 	#5 							; divide temp1 by 32
.243d					_VHDShift:
.243d	46 11		lsr $11				lsr 	temp1+1
.243f	66 10		ror $10				ror 	temp1
.2441	ca		dex				dex
.2442	d0 f9		bne $243d			bne 	_VHDShift
.2444	a2 ff		ldx #$ff			ldx 	#255 						; now divide that by 40 by repeated subtraction.
.2446					_VHDDiv40:
.2446	e8		inx				inx
.2447	38		sec				sec
.2448	a5 10		lda $10				lda 	temp1
.244a	e9 28		sbc #$28			sbc 	#40
.244c	a8		tay				tay
.244d	a5 11		lda $11				lda 	temp1+1
.244f	e9 00		sbc #$00			sbc 	#0
.2451	90 06		bcc $2459			bcc 	_VHDivDone
.2453	85 11		sta $11				sta 	temp1+1
.2455	84 10		sty $10				sty 	temp1
.2457	80 ed		bra $2446			bra 	_VHDDiv40
.2459					_VHDivDone:
.2459	a5 10		lda $10				lda 	temp1 						; remainder
.245b	20 63 24	jsr $2463			jsr 	VHOutVarChar
.245e	8a		txa				txa
.245f	20 63 24	jsr $2463			jsr 	VHOutVarChar 				; and result.
.2462	60		rts				rts
.2463					VHOutVarChar:
.2463	c9 00		cmp #$00			cmp 	#0
.2465	f0 0c		beq $2473			beq 	_VHOExit
.2467	18		clc				clc
.2468	69 40		adc #$40			adc 	#64 						; 65-90 A-Z 91-100 0-9
.246a	c9 5b		cmp #$5b			cmp 	#91 						; convert back ?
.246c	90 02		bcc $2470			bcc 	_VHOOut
.246e	e9 2b		sbc #$2b			sbc 	#91-48 						; adjust to digit
.2470					_VHOOut:
.2470	20 63 1e	jsr $1e63			jsr 	DecodeWriteBuffer
.2473					_VHOExit:
.2473	60		rts				rts

;******  Return to file: kernel.asm

.2474					Dictionary:

;******  Processing file: generated/dictionary.inc

>2474	05					.byte	_end0-*
>2475	00					.byte	$00
>2476	55 16					.word	WordWrite
>2478	a1					.byte	$a1
.2479					_end0:
>2479	10					.byte	_end1-*
>247a	52					.byte	$52
>247b	50 23					.word	VarWriteHandler
>247d	67 23					.word	VarWriteHandlerDecode
>247f	24 24 21 48 41 4e 44 4c			.byte	$24,$24,$21,$48,$41,$4e,$44,$4c,$45,$d2
>2487	45 d2
.2489					_end1:
>2489	10					.byte	_end2-*
>248a	52					.byte	$52
>248b	1a 23					.word	VarAddressHandler
>248d	2f 23					.word	VarAddrHandlerDecode
>248f	24 24 26 48 41 4e 44 4c			.byte	$24,$24,$26,$48,$41,$4e,$44,$4c,$45,$d2
>2497	45 d2
.2499					_end2:
>2499	10					.byte	_end3-*
>249a	52					.byte	$52
>249b	34 23					.word	VarReadHandler
>249d	4b 23					.word	VarReadHandlerDecode
>249f	24 24 40 48 41 4e 44 4c			.byte	$24,$24,$40,$48,$41,$4e,$44,$4c,$45,$d2
>24a7	45 d2
.24a9					_end3:
>24a9	0c					.byte	_end4-*
>24aa	52					.byte	$52
>24ab	c0 1b					.word	CallHandler
>24ad	99 1c					.word	CallHandlerDecode
>24af	24 24 43 41 4c cc			.byte	$24,$24,$43,$41,$4c,$cc
.24b5					_end4:
>24b5	0f					.byte	_end5-*
>24b6	53					.byte	$53
>24b7	8d 21					.word	SkipComment
>24b9	9a 21					.word	CommentDecoder
>24bb	24 24 43 4f 4d 4d 45 4e			.byte	$24,$24,$43,$4f,$4d,$4d,$45,$4e,$d4
>24c3	d4
.24c4					_end5:
>24c4	0e					.byte	_end6-*
>24c5	53					.byte	$53
>24c6	b8 21					.word	DefineCode
>24c8	ce 21					.word	DefineDecoder
>24ca	24 24 44 45 46 49 4e c5			.byte	$24,$24,$44,$45,$46,$49,$4e,$c5
.24d2					_end6:
>24d2	0f					.byte	_end7-*
>24d3	52					.byte	$52
>24d4	a9 10					.word	Literal2Byte
>24d6	bf 10					.word	Literal2ByteDecode
>24d8	24 24 4c 49 54 45 52 41			.byte	$24,$24,$4c,$49,$54,$45,$52,$41,$cc
>24e0	cc
.24e1					_end7:
>24e1	0e					.byte	_end8-*
>24e2	80					.byte	$80
>24e3	76 21					.word	NextLine
>24e5	24 24 4e 45 58 54 4c 49			.byte	$24,$24,$4e,$45,$58,$54,$4c,$49,$4e,$c5
>24ed	4e c5
.24ef					_end8:
>24ef	0e					.byte	_end9-*
>24f0	53					.byte	$53
>24f1	d1 10					.word	LiteralString
>24f3	f0 10					.word	LiteralStringDecoder
>24f5	24 24 53 54 52 49 4e c7			.byte	$24,$24,$53,$54,$52,$49,$4e,$c7
.24fd					_end9:
>24fd	05					.byte	_end10-*
>24fe	00					.byte	$00
>24ff	d1 13					.word	Multiply16x16
>2501	aa					.byte	$aa
.2502					_end10:
>2502	05					.byte	_end11-*
>2503	00					.byte	$00
>2504	3e 12					.word	Add
>2506	ab					.byte	$ab
.2507					_end11:
>2507	06					.byte	_end12-*
>2508	00					.byte	$00
>2509	66 16					.word	WordAdd
>250b	2b a1					.byte	$2b,$a1
.250d					_end12:
>250d	05					.byte	_end13-*
>250e	00					.byte	$00
>250f	4d 12					.word	Subtract
>2511	ad					.byte	$ad
.2512					_end13:
>2512	06					.byte	_end14-*
>2513	00					.byte	$00
>2514	0d 15					.word	ConstantMinus1
>2516	2d b1					.byte	$2d,$b1
.2518					_end14:
>2518	06					.byte	_end15-*
>2519	00					.byte	$00
>251a	6e 20					.word	DumpStack
>251c	2e ae					.byte	$2e,$ae
.251e					_end15:
>251e	05					.byte	_end16-*
>251f	00					.byte	$00
>2520	22 13					.word	Divide16x16
>2522	af					.byte	$af
.2523					_end16:
>2523	05					.byte	_end17-*
>2524	00					.byte	$00
>2525	00 15					.word	Constant0
>2527	b0					.byte	$b0
.2528					_end17:
>2528	06					.byte	_end18-*
>2529	00					.byte	$00
>252a	66 14					.word	CheckMinus
>252c	30 bc					.byte	$30,$bc
.252e					_end18:
>252e	06					.byte	_end19-*
>252f	00					.byte	$00
>2530	7a 14					.word	CheckZero
>2532	30 bd					.byte	$30,$bd
.2534					_end19:
>2534	05					.byte	_end20-*
>2535	00					.byte	$00
>2536	1c 15					.word	C1
>2538	b1					.byte	$b1
.2539					_end20:
>2539	06					.byte	_end21-*
>253a	00					.byte	$00
>253b	10 14					.word	Unary1Plus
>253d	31 ab					.byte	$31,$ab
.253f					_end21:
>253f	06					.byte	_end22-*
>2540	00					.byte	$00
>2541	27 14					.word	Unary1Minus
>2543	31 ad					.byte	$31,$ad
.2545					_end22:
>2545	06					.byte	_end23-*
>2546	00					.byte	$00
>2547	34 15					.word	C10
>2549	31 b0					.byte	$31,$b0
.254b					_end23:
>254b	07					.byte	_end24-*
>254c	00					.byte	$00
>254d	5d 15					.word	C100
>254f	31 30 b0				.byte	$31,$30,$b0
.2552					_end24:
>2552	08					.byte	_end25-*
>2553	00					.byte	$00
>2554	8c 15					.word	C1024
>2556	31 30 32 b4				.byte	$31,$30,$32,$b4
.255a					_end25:
>255a	07					.byte	_end26-*
>255b	00					.byte	$00
>255c	61 15					.word	C127
>255e	31 32 b7				.byte	$31,$32,$b7
.2561					_end26:
>2561	07					.byte	_end27-*
>2562	00					.byte	$00
>2563	65 15					.word	C128
>2565	31 32 b8				.byte	$31,$32,$b8
.2568					_end27:
>2568	06					.byte	_end28-*
>2569	00					.byte	$00
>256a	38 15					.word	C15
>256c	31 b5					.byte	$31,$b5
.256e					_end28:
>256e	06					.byte	_end29-*
>256f	00					.byte	$00
>2570	3c 15					.word	C16
>2572	31 b6					.byte	$31,$b6
.2574					_end29:
>2574	07					.byte	_end30-*
>2575	00					.byte	$00
>2576	9e 14					.word	Times16
>2578	31 36 aa				.byte	$31,$36,$aa
.257b					_end30:
>257b	07					.byte	_end31-*
>257c	00					.byte	$00
>257d	b1 14					.word	Divide16
>257f	31 36 af				.byte	$31,$36,$af
.2582					_end31:
>2582	05					.byte	_end32-*
>2583	00					.byte	$00
>2584	20 15					.word	C2
>2586	b2					.byte	$b2
.2587					_end32:
>2587	06					.byte	_end33-*
>2588	00					.byte	$00
>2589	aa 14					.word	Times2
>258b	32 aa					.byte	$32,$aa
.258d					_end33:
>258d	06					.byte	_end34-*
>258e	00					.byte	$00
>258f	19 14					.word	Unary2Plus
>2591	32 ab					.byte	$32,$ab
.2593					_end34:
>2593	06					.byte	_end35-*
>2594	00					.byte	$00
>2595	32 14					.word	Unary2Minus
>2597	32 ad					.byte	$32,$ad
.2599					_end35:
>2599	06					.byte	_end36-*
>259a	00					.byte	$00
>259b	bd 14					.word	Divide2
>259d	32 af					.byte	$32,$af
.259f					_end36:
>259f	06					.byte	_end37-*
>25a0	00					.byte	$00
>25a1	40 15					.word	C24
>25a3	32 b4					.byte	$32,$b4
.25a5					_end37:
>25a5	07					.byte	_end38-*
>25a6	00					.byte	$00
>25a7	69 15					.word	C255
>25a9	32 35 b5				.byte	$32,$35,$b5
.25ac					_end38:
>25ac	07					.byte	_end39-*
>25ad	00					.byte	$00
>25ae	74 15					.word	C256
>25b0	32 35 b6				.byte	$32,$35,$b6
.25b3					_end39:
>25b3	08					.byte	_end40-*
>25b4	00					.byte	$00
>25b5	c4 14					.word	Times256
>25b7	32 35 36 aa				.byte	$32,$35,$36,$aa
.25bb					_end40:
>25bb	08					.byte	_end41-*
>25bc	00					.byte	$00
>25bd	cd 14					.word	Divide256
>25bf	32 35 36 af				.byte	$32,$35,$36,$af
.25c3					_end41:
>25c3	05					.byte	_end42-*
>25c4	00					.byte	$00
>25c5	24 15					.word	C3
>25c7	b3					.byte	$b3
.25c8					_end42:
>25c8	06					.byte	_end43-*
>25c9	00					.byte	$00
>25ca	51 15					.word	C32
>25cc	33 b2					.byte	$33,$b2
.25ce					_end43:
>25ce	09					.byte	_end44-*
>25cf	00					.byte	$00
>25d0	a4 15					.word	C32767
>25d2	33 32 37 36 b7				.byte	$33,$32,$37,$36,$b7
.25d7					_end44:
>25d7	09					.byte	_end45-*
>25d8	00					.byte	$00
>25d9	b0 15					.word	C32768
>25db	33 32 37 36 b8				.byte	$33,$32,$37,$36,$b8
.25e0					_end45:
>25e0	05					.byte	_end46-*
>25e1	00					.byte	$00
>25e2	28 15					.word	C4
>25e4	b4					.byte	$b4
.25e5					_end46:
>25e5	06					.byte	_end47-*
>25e6	00					.byte	$00
>25e7	a6 14					.word	Times4
>25e9	34 aa					.byte	$34,$aa
.25eb					_end47:
>25eb	06					.byte	_end48-*
>25ec	00					.byte	$00
>25ed	b9 14					.word	Divide4
>25ef	34 af					.byte	$34,$af
.25f1					_end48:
>25f1	08					.byte	_end49-*
>25f2	00					.byte	$00
>25f3	98 15					.word	C4096
>25f5	34 30 39 b6				.byte	$34,$30,$39,$b6
.25f9					_end49:
>25f9	05					.byte	_end50-*
>25fa	00					.byte	$00
>25fb	2c 15					.word	C5
>25fd	b5					.byte	$b5
.25fe					_end50:
>25fe	07					.byte	_end51-*
>25ff	00					.byte	$00
>2600	80 15					.word	C512
>2602	35 31 b2				.byte	$35,$31,$b2
.2605					_end51:
>2605	06					.byte	_end52-*
>2606	00					.byte	$00
>2607	55 15					.word	C63
>2609	36 b3					.byte	$36,$b3
.260b					_end52:
>260b	06					.byte	_end53-*
>260c	00					.byte	$00
>260d	59 15					.word	C64
>260f	36 b4					.byte	$36,$b4
.2611					_end53:
>2611	05					.byte	_end54-*
>2612	00					.byte	$00
>2613	30 15					.word	C8
>2615	b8					.byte	$b8
.2616					_end54:
>2616	06					.byte	_end55-*
>2617	00					.byte	$00
>2618	a2 14					.word	Times8
>261a	38 aa					.byte	$38,$aa
.261c					_end55:
>261c	06					.byte	_end56-*
>261d	00					.byte	$00
>261e	b5 14					.word	Divide8
>2620	38 af					.byte	$38,$af
.2622					_end56:
>2622	05					.byte	_end57-*
>2623	40					.byte	$40
>2624	56 1c					.word	ReturnHandler
>2626	bb					.byte	$bb
.2627					_end57:
>2627	05					.byte	_end58-*
>2628	00					.byte	$00
>2629	be 12					.word	CheckLess
>262b	bc					.byte	$bc
.262c					_end58:
>262c	06					.byte	_end59-*
>262d	00					.byte	$00
>262e	d7 12					.word	CheckLessEq
>2630	3c bd					.byte	$3c,$bd
.2632					_end59:
>2632	06					.byte	_end60-*
>2633	00					.byte	$00
>2634	87 12					.word	CheckNotEqual
>2636	3c be					.byte	$3c,$be
.2638					_end60:
>2638	05					.byte	_end61-*
>2639	00					.byte	$00
>263a	8a 12					.word	CheckEqual
>263c	bd					.byte	$bd
.263d					_end61:
>263d	05					.byte	_end62-*
>263e	00					.byte	$00
>263f	da 12					.word	CheckGreater
>2641	be					.byte	$be
.2642					_end62:
>2642	06					.byte	_end63-*
>2643	00					.byte	$00
>2644	bb 12					.word	CheckGreaterEq
>2646	3e bd					.byte	$3e,$bd
.2648					_end63:
>2648	08					.byte	_end64-*
>2649	00					.byte	$00
>264a	c5 15					.word	TestDup
>264c	3f 44 55 d0				.byte	$3f,$44,$55,$d0
.2650					_end64:
>2650	05					.byte	_end65-*
>2651	00					.byte	$00
>2652	3a 16					.word	WordRead
>2654	c0					.byte	$c0
.2655					_end65:
>2655	07					.byte	_end66-*
>2656	00					.byte	$00
>2657	40 14					.word	Absolute
>2659	41 42 d3				.byte	$41,$42,$d3
.265c					_end66:
>265c	09					.byte	_end67-*
>265d	00					.byte	$00
>265e	7d 16					.word	AllocateMemory
>2660	41 4c 4c 4f c3				.byte	$41,$4c,$4c,$4f,$c3
.2665					_end67:
>2665	07					.byte	_end68-*
>2666	00					.byte	$00
>2667	60 12					.word	And
>2669	41 4e c4				.byte	$41,$4e,$c4
.266c					_end68:
>266c	0a					.byte	_end69-*
>266d	00					.byte	$00
>266e	f9 1f					.word	AssertCode
>2670	41 53 53 45 52 d4			.byte	$41,$53,$53,$45,$52,$d4
.2676					_end69:
>2676	09					.byte	_end70-*
>2677	00					.byte	$00
>2678	93 14					.word	ByteSwap
>267a	42 53 57 41 d0				.byte	$42,$53,$57,$41,$d0
.267f					_end70:
>267f	06					.byte	_end71-*
>2680	00					.byte	$00
>2681	48 16					.word	ByteWrite
>2683	43 a1					.byte	$43,$a1
.2685					_end71:
>2685	06					.byte	_end72-*
>2686	00					.byte	$00
>2687	31 16					.word	ByteRead
>2689	43 c0					.byte	$43,$c0
.268b					_end72:
>268b	07					.byte	_end73-*
>268c	00					.byte	$00
>268d	23 1d					.word	ClrHandler
>268f	43 4c d2				.byte	$43,$4c,$d2
.2692					_end73:
>2692	08					.byte	_end74-*
>2693	00					.byte	$00
>2694	bc 15					.word	Drop
>2696	44 52 4f d0				.byte	$44,$52,$4f,$d0
.269a					_end74:
>269a	07					.byte	_end75-*
>269b	00					.byte	$00
>269c	ce 15					.word	Dup
>269e	44 55 d0				.byte	$44,$55,$d0
.26a1					_end75:
>26a1	0a					.byte	_end76-*
>26a2	21					.byte	$21
>26a3	0c 1b					.word	ElseHandler
>26a5	0f 1b					.word	ElseEncoder
>26a7	45 4c 53 c5				.byte	$45,$4c,$53,$c5
.26ab					_end76:
>26ab	07					.byte	_end77-*
>26ac	00					.byte	$00
>26ad	1a 20					.word	EndProgram
>26af	45 4e c4				.byte	$45,$4e,$c4
.26b2					_end77:
>26b2	0b					.byte	_end78-*
>26b3	20					.byte	$20
>26b4	2e 1b					.word	EndIfHandler
>26b6	31 1b					.word	EndIfEncoder
>26b8	45 4e 44 49 c6				.byte	$45,$4e,$44,$49,$c6
.26bd					_end78:
>26bd	09					.byte	_end79-*
>26be	20					.byte	$20
>26bf	2c 1a					.word	ForHandler
>26c1	62 1a					.word	ForEncoder
>26c3	46 4f d2				.byte	$46,$4f,$d2
.26c6					_end79:
>26c6	08					.byte	_end80-*
>26c7	21					.byte	$21
>26c8	f7 1a					.word	IfHandler
>26ca	fa 1a					.word	IfEncoder
>26cc	49 c6					.byte	$49,$c6
.26ce					_end80:
>26ce	09					.byte	_end81-*
>26cf	00					.byte	$00
>26d0	d6 1a					.word	GetIndex
>26d2	49 4e 44 45 d8				.byte	$49,$4e,$44,$45,$d8
.26d7					_end81:
>26d7	08					.byte	_end82-*
>26d8	00					.byte	$00
>26d9	53 1f					.word	ListCode
>26db	4c 49 53 d4				.byte	$4c,$49,$53,$d4
.26df					_end82:
>26df	07					.byte	_end83-*
>26e0	00					.byte	$00
>26e1	f7 12					.word	Maximum
>26e3	4d 41 d8				.byte	$4d,$41,$d8
.26e6					_end83:
>26e6	07					.byte	_end84-*
>26e7	00					.byte	$00
>26e8	f3 12					.word	Minimum
>26ea	4d 49 ce				.byte	$4d,$49,$ce
.26ed					_end84:
>26ed	07					.byte	_end85-*
>26ee	00					.byte	$00
>26ef	33 13					.word	Modulus16x16
>26f1	4d 4f c4				.byte	$4d,$4f,$c4
.26f4					_end85:
>26f4	0a					.byte	_end86-*
>26f5	00					.byte	$00
>26f6	47 14					.word	Negate
>26f8	4e 45 47 41 54 c5			.byte	$4e,$45,$47,$41,$54,$c5
.26fe					_end86:
>26fe	07					.byte	_end87-*
>26ff	00					.byte	$00
>2700	1a 1d					.word	NewHandler
>2702	4e 45 d7				.byte	$4e,$45,$d7
.2705					_end87:
>2705	0a					.byte	_end88-*
>2706	21					.byte	$21
>2707	6f 1a					.word	NextHandler
>2709	ae 1a					.word	NextEncoder
>270b	4e 45 58 d4				.byte	$4e,$45,$58,$d4
.270f					_end88:
>270f	07					.byte	_end89-*
>2710	00					.byte	$00
>2711	02 16					.word	Nip
>2713	4e 49 d0				.byte	$4e,$49,$d0
.2716					_end89:
>2716	07					.byte	_end90-*
>2717	00					.byte	$00
>2718	57 14					.word	OneComplement
>271a	4e 4f d4				.byte	$4e,$4f,$d4
.271d					_end90:
>271d	06					.byte	_end91-*
>271e	00					.byte	$00
>271f	7a 12					.word	LogOr
>2721	4f d2					.byte	$4f,$d2
.2723					_end91:
>2723	08					.byte	_end92-*
>2724	00					.byte	$00
>2725	ea 15					.word	Over
>2727	4f 56 45 d2				.byte	$4f,$56,$45,$d2
.272b					_end92:
>272b	0c					.byte	_end93-*
>272c	20					.byte	$20
>272d	60 1b					.word	RepeatHandler
>272f	63 1b					.word	RepeatEncoder
>2731	52 45 50 45 41 d4			.byte	$52,$45,$50,$45,$41,$d4
.2737					_end93:
>2737	07					.byte	_end94-*
>2738	00					.byte	$00
>2739	d6 14					.word	RandomNumber
>273b	52 4e c4				.byte	$52,$4e,$c4
.273e					_end94:
>273e	07					.byte	_end95-*
>273f	00					.byte	$00
>2740	07 16					.word	Rot
>2742	52 4f d4				.byte	$52,$4f,$d4
.2745					_end95:
>2745	07					.byte	_end96-*
>2746	00					.byte	$00
>2747	ce 1f					.word	RunProgram
>2749	52 55 ce				.byte	$52,$55,$ce
.274c					_end96:
>274c	07					.byte	_end97-*
>274d	00					.byte	$00
>274e	82 14					.word	SignTOS
>2750	53 47 ce				.byte	$53,$47,$ce
.2753					_end97:
>2753	08					.byte	_end98-*
>2754	00					.byte	$00
>2755	12 20					.word	StopCode
>2757	53 54 4f d0				.byte	$53,$54,$4f,$d0
.275b					_end98:
>275b	08					.byte	_end99-*
>275c	00					.byte	$00
>275d	d7 15					.word	Swap
>275f	53 57 41 d0				.byte	$53,$57,$41,$d0
.2763					_end99:
>2763	07					.byte	_end100-*
>2764	00					.byte	$00
>2765	e2 1f					.word	Call6502
>2767	53 59 d3				.byte	$53,$59,$d3
.276a					_end100:
>276a	0d					.byte	_end101-*
>276b	00					.byte	$00
>276c	6f 22					.word	IntToString
>276e	54 4f 2e 53 54 52 49 4e			.byte	$54,$4f,$2e,$53,$54,$52,$49,$4e,$c7
>2776	c7
.2777					_end101:
>2777	0b					.byte	_end102-*
>2778	21					.byte	$21
>2779	70 1b					.word	UntilHandler
>277b	73 1b					.word	UntilEncoder
>277d	55 4e 54 49 cc				.byte	$55,$4e,$54,$49,$cc
.2782					_end102:
>2782	09					.byte	_end103-*
>2783	00					.byte	$00
>2784	1d 20					.word	VlistCode
>2786	56 4c 49 53 d4				.byte	$56,$4c,$49,$53,$d4
.278b					_end103:
>278b	0a					.byte	_end104-*
>278c	40					.byte	$40
>278d	6e 1d					.word	BreakCmd
>278f	58 42 52 45 41 cb			.byte	$58,$42,$52,$45,$41,$cb
.2795					_end104:
>2795	09					.byte	_end105-*
>2796	00					.byte	$00
>2797	68 1d					.word	ExitDump
>2799	58 44 55 4d d0				.byte	$58,$44,$55,$4d,$d0
.279e					_end105:
>279e	07					.byte	_end106-*
>279f	00					.byte	$00
>27a0	6d 12					.word	Xor
>27a2	58 4f d2				.byte	$58,$4f,$d2
.27a5					_end106:
>27a5	08					.byte	_end107-*
>27a6	00					.byte	$00
>27a7	b9 20					.word	System_Save
>27a9	53 41 56 c5				.byte	$53,$41,$56,$c5
.27ad					_end107:
>27ad	08					.byte	_end108-*
>27ae	00					.byte	$00
>27af	d7 20					.word	System_Load
>27b1	4c 4f 41 c4				.byte	$4c,$4f,$41,$c4
.27b5					_end108:
>27b5	00					.byte	0

;******  Return to file: kernel.asm


;******  Processing file: code/enctest.asm

.27b6					EncodeTest:
.27b6	a9 d0		lda #$d0			lda 	#(EncodeTestLine & $FF)
.27b8	a0 27		ldy #$27			ldy 	#(EncodeTestLine >> 8)
.27ba	20 93 16	jsr $1693			jsr 	EncodeProgram
.27bd	a9 10		lda #$10			lda 	#(textBuffer) & $FF
.27bf	85 0a		sta $0a				sta 	0+(bufPtr)
.27c1	a9 08		lda #$08			lda 	#(textBuffer) >> 8
.27c3	85 0b		sta $0b				sta 	1+(bufPtr)
.27c5	a0 09		ldy #$09			ldy 	#encodeBuffer>>8
.27c7	a9 10		lda #$10			lda 	#encodeBuffer & $FF
.27c9	38		sec				sec
.27ca	20 72 1d	jsr $1d72			jsr 	DecodeLineIntoBufPtr
.27cd	4c ff ff	jmp $ffff			jmp 	$FFFF
.27d0					EncodeTestLine:

;******  Processing file: code/../generated/edtext.inc

>27d0	31 37 32 38 30 20 22 44			.byte $31,$37,$32,$38,$30,$20,$22,$44,$32,$55,$46,$5a,$59,$49,$22,$20,$22,$44,$56,$33,$57,$57,$22,$20,$2d,$32,$36,$36,$31,$34,$20,$26,$45,$20,$22,$56,$35,$57,$50,$59,$33,$4e,$45,$34,$22,$20,$46,$58,$44,$38,$49,$49,$34,$20,$35,$20,$3c,$33,$32,$32,$36,$33,$3e,$20,$22,$4b,$54,$43,$32,$33,$51,$57,$41,$56,$22,$20,$52,$4f,$54,$20,$41,$34,$4f,$34,$4e,$4c,$32,$20,$3c,$33,$35,$39,$37,$38,$3e,$20,$3c,$33,$34,$37,$35,$31,$3e,$20,$3c,$33,$37,$38,$34,$38,$3e,$20,$2d,$32,$38,$36,$36,$20,$22,$46,$51,$43,$4e,$22,$20,$56,$51,$20,$55,$43,$44,$39,$20,$3c,$33,$37,$39,$36,$30,$3e,$20,$21,$51,$20,$21,$44,$57,$20,$3c,$33,$39,$35,$36,$33,$3e,$20,$3c,$33,$36,$33,$37,$36,$3e,$20,$56,$51,$20,$52,$55,$4e,$20,$3e,$20,$49,$4e,$44,$45,$58,$20,$3c,$33,$32,$39,$36,$30,$3e,$20,$40,$45,$39,$50,$20,$3c,$33,$32,$39,$33,$35,$3e,$20,$3c,$33,$31,$30,$33,$34,$3e,$20,$21,$50,$20,$2d,$32,$31,$31,$33,$31,$20,$22,$22,$20,$20,$20,$00
>27d8	32 55 46 5a 59 49 22 20 22 44 56 33 57 57 22 20
>27e8	2d 32 36 36 31 34 20 26 45 20 22 56 35 57 50 59
>27f8	33 4e 45 34 22 20 46 58 44 38 49 49 34 20 35 20
>2808	3c 33 32 32 36 33 3e 20 22 4b 54 43 32 33 51 57
>2818	41 56 22 20 52 4f 54 20 41 34 4f 34 4e 4c 32 20
>2828	3c 33 35 39 37 38 3e 20 3c 33 34 37 35 31 3e 20
>2838	3c 33 37 38 34 38 3e 20 2d 32 38 36 36 20 22 46
>2848	51 43 4e 22 20 56 51 20 55 43 44 39 20 3c 33 37
>2858	39 36 30 3e 20 21 51 20 21 44 57 20 3c 33 39 35
>2868	36 33 3e 20 3c 33 36 33 37 36 3e 20 56 51 20 52
>2878	55 4e 20 3e 20 49 4e 44 45 58 20 3c 33 32 39 36
>2888	30 3e 20 40 45 39 50 20 3c 33 32 39 33 35 3e 20
>2898	3c 33 31 30 33 34 3e 20 21 50 20 2d 32 31 31 33
>28a8	31 20 22 22 20 20 20 00

;******  Return to file: code/enctest.asm

.28b0					EncodeTestLineOriginal:

;******  Processing file: code/../generated/edtext.inc

>28b0	31 37 32 38 30 20 22 44			.byte $31,$37,$32,$38,$30,$20,$22,$44,$32,$55,$46,$5a,$59,$49,$22,$20,$22,$44,$56,$33,$57,$57,$22,$20,$2d,$32,$36,$36,$31,$34,$20,$26,$45,$20,$22,$56,$35,$57,$50,$59,$33,$4e,$45,$34,$22,$20,$46,$58,$44,$38,$49,$49,$34,$20,$35,$20,$3c,$33,$32,$32,$36,$33,$3e,$20,$22,$4b,$54,$43,$32,$33,$51,$57,$41,$56,$22,$20,$52,$4f,$54,$20,$41,$34,$4f,$34,$4e,$4c,$32,$20,$3c,$33,$35,$39,$37,$38,$3e,$20,$3c,$33,$34,$37,$35,$31,$3e,$20,$3c,$33,$37,$38,$34,$38,$3e,$20,$2d,$32,$38,$36,$36,$20,$22,$46,$51,$43,$4e,$22,$20,$56,$51,$20,$55,$43,$44,$39,$20,$3c,$33,$37,$39,$36,$30,$3e,$20,$21,$51,$20,$21,$44,$57,$20,$3c,$33,$39,$35,$36,$33,$3e,$20,$3c,$33,$36,$33,$37,$36,$3e,$20,$56,$51,$20,$52,$55,$4e,$20,$3e,$20,$49,$4e,$44,$45,$58,$20,$3c,$33,$32,$39,$36,$30,$3e,$20,$40,$45,$39,$50,$20,$3c,$33,$32,$39,$33,$35,$3e,$20,$3c,$33,$31,$30,$33,$34,$3e,$20,$21,$50,$20,$2d,$32,$31,$31,$33,$31,$20,$22,$22,$20,$20,$20,$00
>28b8	32 55 46 5a 59 49 22 20 22 44 56 33 57 57 22 20
>28c8	2d 32 36 36 31 34 20 26 45 20 22 56 35 57 50 59
>28d8	33 4e 45 34 22 20 46 58 44 38 49 49 34 20 35 20
>28e8	3c 33 32 32 36 33 3e 20 22 4b 54 43 32 33 51 57
>28f8	41 56 22 20 52 4f 54 20 41 34 4f 34 4e 4c 32 20
>2908	3c 33 35 39 37 38 3e 20 3c 33 34 37 35 31 3e 20
>2918	3c 33 37 38 34 38 3e 20 2d 32 38 36 36 20 22 46
>2928	51 43 4e 22 20 56 51 20 55 43 44 39 20 3c 33 37
>2938	39 36 30 3e 20 21 51 20 21 44 57 20 3c 33 39 35
>2948	36 33 3e 20 3c 33 36 33 37 36 3e 20 56 51 20 52
>2958	55 4e 20 3e 20 49 4e 44 45 58 20 3c 33 32 39 36
>2968	30 3e 20 40 45 39 50 20 3c 33 32 39 33 35 3e 20
>2978	3c 33 31 30 33 34 3e 20 21 50 20 2d 32 31 31 33
>2988	31 20 22 22 20 20 20 00

;******  Return to file: code/enctest.asm


;******  Return to file: kernel.asm

>3fff	ff						.byte 	$FF
.4000					ProgramMemory:

;******  End of listing
